- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Introducing Blazor Hybrid App Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Blazor混合应用程序开发
- en: In .NET MAUI, an alternative approach to constructing the **user interface**
    (**UI**) is by using Blazor. Blazor, a modern web framework developed by Microsoft,
    allows developers to create interactive web applications utilizing C# and Razor
    syntax instead of JavaScript. Additionally, Blazor can be employed in the development
    of .NET MAUI applications as part of a Blazor Hybrid app. The fundamental building
    blocks of Blazor are Razor components, which can be reused between native and
    web applications when utilizing Blazor and Blazor Hybrid. In comparison to XAML
    UIs, a Blazor UI offers increased reusability, encompassing both native and web
    applications. In this chapter, we will provide an introduction to Blazor and discuss
    its implementation in various scenarios. Additionally, we will introduce Razor
    components and explain how to develop a Blazor Hybrid app using these components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，构建**用户界面**（**UI**）的另一种方法是使用Blazor。Blazor是由微软开发的现代Web框架，允许开发人员使用C#和Razor语法而不是JavaScript来创建交互式Web应用程序。此外，Blazor还可以用于.NET
    MAUI应用程序的开发，作为Blazor混合应用程序的一部分。Blazor的基本构建块是Razor组件，当使用Blazor和Blazor混合时，这些组件可以在原生和Web应用程序之间重用。与XAML
    UI相比，Blazor UI提供了更高的可重用性，包括原生和Web应用程序。在本章中，我们将介绍Blazor及其在各种场景中的实现。此外，我们将介绍Razor组件，并解释如何使用这些组件开发Blazor混合应用程序。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What is Blazor?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor是什么？
- en: How to create a .NET MAUI Blazor project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个.NET MAUI Blazor项目
- en: How to create a new Razor component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个新的Razor组件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章中的源代码，您需要在您的PC或Mac上安装Visual Studio 2022。请参阅*第一章*，*使用.NET MAUI入门*中的*开发环境设置*部分以获取详细信息。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter08](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/41dfc374525657f3c09c3870733ddaccff3c3412).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter08](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/41dfc374525657f3c09c3870733ddaccff3c3412)。
- en: 'To check out the source code of this chapter, we can use the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书中源代码的信息，请参阅*第二章*，*构建我们的第一个.NET MAUI应用程序*中的*管理本书中的源代码*部分。
- en: What is Blazor?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor是什么？
- en: 'Blazor is a framework designed to build web applications utilizing HTML, CSS,
    and C#. When developing web applications with Blazor in ASP.NET Core, you have
    two options to consider: Blazor Server and Blazor **WebAssembly** (**Wasm**).
    Furthermore, .NET MAUI enables the use of Blazor to create native applications,
    introducing a third variant – the Blazor Hybrid app.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是一个用于使用HTML、CSS和C#构建Web应用程序的框架。当使用Blazor在ASP.NET Core中开发Web应用程序时，您有两个选项可以考虑：Blazor
    Server和Blazor **WebAssembly**（**Wasm**）。此外，.NET MAUI使Blazor能够创建原生应用程序，引入了第三种变体——Blazor混合应用程序。
- en: In web application development, tasks typically involve creating a frontend
    UI and a backend service. Backend services can be accessed through RESTful APIs
    or **remote procedure calls** (**RPCs**). UI components, comprised of HTML, CSS,
    and JavaScript, are loaded in a browser and displayed as web pages. In the ASP.NET
    Core architecture, components related to user interaction can be rendered on the
    server. This hosting model is known as Blazor Server. Alternatively, we can execute
    most of the UI components within the browser, which is referred to as the Blazor
    Wasm hosting model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序开发中，任务通常涉及创建前端UI和后端服务。后端服务可以通过RESTful API或**远程过程调用**（**RPCs**）访问。由HTML、CSS和JavaScript组成的UI组件在浏览器中加载并显示为网页。在ASP.NET
    Core架构中，与用户交互相关的组件可以在服务器上渲染。这种托管模型被称为Blazor Server。或者，我们可以在浏览器中执行大多数UI组件，这被称为Blazor
    Wasm托管模型。
- en: In some instances, applications may require access to device-specific features,
    such as sensors or cameras; to accommodate these requirements, developers usually
    create native applications. However, Blazor offers an additional solution – the
    Blazor Hybrid app. Now, let’s discuss Blazor hosting models in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序可能需要访问特定于设备的特性，例如传感器或摄像头；为了满足这些需求，开发者通常创建原生应用程序。然而，Blazor提供了一个额外的解决方案——Blazor混合应用程序。现在，让我们更详细地讨论Blazor托管模型。
- en: Hosting models
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管模型
- en: Blazor is a web framework designed for building web UI components, commonly
    referred to as Razor components, which can be hosted through various methods.
    These components can operate on the server side within ASP.NET Core (Blazor Server)
    or client side inside a web browser (Blazor Wasm).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是一个用于构建Web UI组件的Web框架，通常被称为Razor组件，可以通过各种方法进行托管。这些组件可以在ASP.NET Core（Blazor服务器）的服务器端或Web浏览器的客户端（Blazor
    Wasm）中运行。
- en: Furthermore, Razor components can be implemented in native mobile and desktop
    applications by rendering them within an embedded Web View control (Blazor Hybrid).
    Despite the differences in hosting models, the process of building Razor components
    remains consistent. Consequently, the same Razor components can be utilized across
    all hosting models without any modification.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Razor组件可以通过在嵌入的Web View控件中渲染来实现，用于原生移动和桌面应用程序（Blazor混合）。尽管托管模型有所不同，但构建Razor组件的过程保持一致。因此，相同的Razor组件可以在所有托管模型中无需修改地使用。
- en: Blazor Server
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor服务器
- en: In traditional web application development, the logic for user interactions
    is executed on the server side. Within the MVC design pattern, handling user interaction
    is an integral part of the application architecture. When a user interaction occurs
    in the browser, it is sent back to the server for processing. As a result, the
    entire page may be reloaded in response to the user’s request.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web应用程序开发中，用户交互的逻辑是在服务器端执行的。在MVC设计模式中，处理用户交互是应用程序架构的一个组成部分。当浏览器中发生用户交互时，它会被发送回服务器进行处理。因此，整个页面可能会根据用户的请求重新加载。
- en: To enhance performance, Blazor Server employs a design that resembles a **single-page
    application** (**SPA**) framework. When responding to a user request, Blazor Server
    processes it and only sends the **Document Object Model** (**DOM**) changes pertaining
    to the user action to the browser. As depicted in *Figure 8.1*, the processing
    logic in Blazor Server is similar to that of a SPA, with the key distinction being
    that Razor components are rendered on the server, rather than the browser. In
    order to facilitate real-time communication between the web client and the server,
    SignalR, an open source library, is utilized as the connection between the server
    and browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，Blazor服务器采用了一种类似于**单页应用程序**（SPA）框架的设计。当响应用户请求时，Blazor服务器处理它，并且只将涉及用户操作的**文档对象模型**（DOM）更改发送到浏览器。如图8.1所示，Blazor服务器的处理逻辑与SPA类似，关键区别在于Razor组件是在服务器上渲染，而不是在浏览器上。为了促进客户端和服务器之间的实时通信，使用了开源库SignalR作为服务器和浏览器之间的连接。
- en: '![Figure 7.1: Blazor Server](img/B21554_08_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：Blazor服务器](img/B21554_08_01.png)'
- en: 'Figure 8.1: Blazor Server'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：Blazor服务器
- en: '**Razor components versus Blazor components**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Razor组件与Blazor组件**'
- en: People may get confused between Blazor and Razor. Razor was introduced as a
    template engine of ASP.NET in 2010\. Razor syntax is a markup syntax in which
    developers can embed C# code into an HTML page. Blazor is a web framework that
    uses Razor syntax as the programming language. It was introduced around 2018\.
    Blazor is a component-based framework, and a Blazor app consists of Razor components.
    In other words, Blazor is a hosting model for Razor components. Blazor components
    and Razor components are widely used interchangeably, but the correct terminology
    is Razor component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会在Blazor和Razor之间感到困惑。Razor作为ASP.NET的模板引擎在2010年被引入。Razor语法是一种标记语法，开发者可以在其中将C#代码嵌入到HTML页面中。Blazor是一个使用Razor语法作为编程语言的Web框架，大约在2018年被引入。Blazor是一个基于组件的框架，一个Blazor应用程序由Razor组件组成。换句话说，Blazor是Razor组件的托管模型。Blazor组件和Razor组件被广泛互换使用，但正确的术语是Razor组件。
- en: A Razor component resides in a file with the `.razor` extension, and it is compiled
    as a .NET class at runtime. This `.razor` file can also be split into two files
    with `.razor` and `.razor.cs` extensions. The idea is quite similar to XAML and
    code-behind, which we learned about in *Part 1* of this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Razor 组件位于具有 `.razor` 扩展名的文件中，并在运行时编译为 .NET 类。这个 `.razor` 文件也可以拆分为两个文件，分别具有
    `.razor` 和 `.razor.cs` 扩展名。这个想法与我们在本书第一部分学到的 XAML 和代码后置非常相似。
- en: In Blazor Server, the app’s state is maintained on the server, and the client
    does not need a .NET runtime. This model can result in a faster initial load time
    as the browser only downloads a small initial payload. However, it requires a
    constant connection with the server, which may affect the scalability and introduce
    latency in UI updates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 服务器中，应用的状态在服务器上维护，客户端不需要 .NET 运行时。这种模型可以导致初始加载时间更快，因为浏览器只下载一个小型的初始负载。然而，它需要与服务器保持持续连接，这可能会影响可伸缩性并引入
    UI 更新的延迟。
- en: Blazor Wasm
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor Wasm
- en: 'Blazor Wasm is a hosting model that renders Razor components within a web browser.
    As illustrated in *Figure 8.2*, the Razor components are loaded into the browser
    and compiled into Wasm using the .NET runtime:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Wasm 是一种托管模型，它将 Razor 组件渲染到网页浏览器中。如图 8.2 所示，Razor 组件被加载到浏览器中，并使用 .NET
    运行时编译成 Wasm：
- en: '![Figure 7.2: Blazor Wasm](img/B21554_08_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：Blazor Wasm](img/B21554_08_02.png)'
- en: 'Figure 8.2: Blazor Wasm'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：Blazor Wasm
- en: In the browser, the startup page loads the .NET environment and Razor components.
    These Razor components are compiled to Wasm through a .NET **Intermediate Language**
    (**IL**) interpreter at runtime, which manages DOM changes. This process is commonly
    known as **just-in-time** (**JIT**) compilation. With JIT, the compilation takes
    place at runtime, which results in slower performance compared to **ahead-of-time**
    (**AOT**) compilation. Blazor Wasm apps can be compiled AOT to Wasm to improve
    runtime performance but at the expense of a much larger download size.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，启动页面加载 .NET 环境和 Razor 组件。这些 Razor 组件在运行时通过 .NET **中间语言**（**IL**）解释器编译成
    Wasm，该解释器管理 DOM 变化。这个过程通常被称为 **即时**（**JIT**）编译。使用 JIT，编译在运行时进行，与 **预编译**（**AOT**）编译相比，性能较慢。Blazor
    Wasm 应用可以编译成 AOT Wasm 以提高运行时性能，但代价是下载大小大大增加。
- en: With the introduction of .NET 8, a new runtime feature called jiterpreter was
    introduced in .NET 8 that enables partial JIT support in the .NET IL interpreter
    to achieve improved runtime performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 .NET 8 的引入，.NET 8 中引入了一个名为 jiterpreter 的新运行时功能，该功能使 .NET IL 解释器能够实现部分 JIT
    支持，从而提高运行时性能。
- en: Blazor Wasm apps can be deployed as static files and hosted on various web server
    platforms or static site hosting providers. Optionally, Blazor Wasm can also communicate
    with a server through API calls to retrieve data or offload complex operations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Wasm 应用可以作为静态文件部署，托管在各种网络服务器平台或静态站点托管提供商上。可选地，Blazor Wasm 还可以通过 API 调用来与服务器通信，以检索数据或卸载复杂操作。
- en: '**Wasm**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wasm**'
- en: Wasm is a binary instruction format for a stack-based virtual machine. Wasm
    is supported by most modern web browsers. With Wasm, we can use many programming
    languages to develop client-side components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm 是一种基于栈的虚拟机的二进制指令格式。Wasm 被大多数现代网页浏览器支持。使用 Wasm，我们可以使用许多编程语言来开发客户端组件。
- en: 'As a SPA framework, Blazor can be compared to other JavaScript-based SPA frameworks,
    such as React, Angular, and Vue. Numerous JavaScript SPA frameworks exist, and
    *Table 8.1* contains a comparison between Blazor and React. Although other JavaScript
    frameworks could also be used for comparison, the decision to choose React was
    based on the fact that React Native can be utilized to develop Hybrid apps. This
    shares some similarities with .NET MAUI Blazor, which will be discussed in the
    following section:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单页应用（SPA）框架，Blazor 可以与其他基于 JavaScript 的 SPA 框架进行比较，例如 React、Angular 和 Vue。存在许多
    JavaScript SPA 框架，*表 8.1* 包含了 Blazor 和 React 的比较。尽管也可以使用其他 JavaScript 框架进行比较，但选择
    React 的决定是基于 React Native 可以用于开发混合应用的事实。这与其他 .NET MAUI Blazor 的一些相似之处，将在下一节讨论：
- en: '| **Feature** | **React** | **Blazor Wasm** | **Blazor Server** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **React** | **Blazor Wasm** | **Blazor 服务器** |'
- en: '| Language | JavaScript/JSX/TypeScript | C# | C# |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | JavaScript/JSX/TypeScript | C# | C# |'
- en: '| Runtime | JavaScript engine | Wasm | ASP.NET Core |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 运行时 | JavaScript 引擎 | Wasm | ASP.NET Core |'
- en: '| Progressive Web App (PWA) Support | Yes | Yes | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 支持渐进式网络应用（PWA） | 是 | 是 | 否 |'
- en: '| Hosting | Flexible to choose | Flexible to choose | ASP.NET Core |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 托管 | 可灵活选择 | 可灵活选择 | ASP.NET Core |'
- en: '| Static Site Hosting | Yes | Yes | No |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 静态站点托管 | 是 | 是 | 否 |'
- en: '| Offloads Processing to Clients | Yes | Yes | No |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 将处理卸载到客户端 | 是 | 是 | 否 |'
- en: '| Performance | Lightweight with great performance | There is a heavier first-time
    load due to the extra download time of .NET runtimes | Similar performance to
    the JavaScript framework |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 轻量级且性能出色 | 由于.NET运行时的额外下载时间，首次加载较重 | 与JavaScript框架类似性能 |'
- en: 'Table 8.1: Comparison of Blazor and React'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：Blazor与React的比较
- en: Both JavaScript and Wasm are integral features of modern browsers. SPA frameworks
    that utilize either JavaScript or Wasm require no additional dependencies to run
    in a browser. Blazor Wasm supports JavaScript Interop, enabling the use of JavaScript
    components with Blazor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和Wasm都是现代浏览器的基本功能。使用JavaScript或Wasm的SPA框架在浏览器中运行无需额外的依赖。Blazor Wasm支持JavaScript
    Interop，允许使用JavaScript组件与Blazor一起使用。
- en: Both Blazor and React support PWA development, which allows SPAs to function
    in offline mode.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor和React都支持PWA开发，这使得单页应用（SPA）能够在离线模式下运行。
- en: Blazor Wasm and React both operate on the client side, utilizing **client-side
    rendering** (**CSR**). As a result, relying solely on these libraries for a web
    application could negatively affect **search engine optimization** (**SEO**) and
    the initial loading performance. This is because a considerable amount of time
    is necessary for the proper rendering of the content on the screen. In fact, in
    order to display the complete web app, the browser must download the entire application
    bundle, parse its content, execute it, and then render the result. This process
    could take several seconds for larger applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Wasm和React都在客户端运行，使用**客户端渲染**（**CSR**）。因此，仅依赖这些库构建Web应用可能会对**搜索引擎优化**（**SEO**）和初始加载性能产生负面影响。这是因为屏幕上内容的正确渲染需要相当长的时间。实际上，为了显示完整的Web应用，浏览器必须下载整个应用包，解析其内容，执行它，然后渲染结果。这个过程对于大型应用可能需要几秒钟。
- en: On the other hand, Blazor Server employs **server-side rendering** (**SSR**)
    to enhance the performance and user experience of web pages, particularly for
    users with slow internet connections or devices. SSR can decrease the initial
    loading time and bandwidth consumption of web pages by only sending the necessary
    HTML and CSS for the first render, while CSR necessitates downloading and executing
    a significant amount of JavaScript code before anything is rendered. Moreover,
    SSR facilitates faster interactions and transitions between pages, as the server
    can pre-render the upcoming page and transmit it to the browser as soon as the
    user clicks a link.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Blazor Server采用**服务器端渲染**（**SSR**）来提升网页的性能和用户体验，尤其是对于网络连接或设备较慢的用户。SSR通过仅发送首次渲染所需的HTML和CSS来减少网页的初始加载时间和带宽消耗，而CSR则需要下载并执行大量JavaScript代码才能开始渲染。此外，SSR还能加快页面间的交互和过渡，因为服务器可以在用户点击链接后立即预渲染即将显示的页面并将其传输到浏览器。
- en: Another advantage of SSR is that it can improve the SEO and social media sharing
    of web pages, as the server can provide the full HTML content and metadata of
    each page to crawlers and bots. CSR can make it harder for crawlers and bots to
    access and index the content of web pages, as they may not be able to execute
    JavaScript or wait for asynchronous data fetching.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SSR的另一个优点是它可以提高网页的SEO和社交媒体分享效果，因为服务器可以为每个页面提供完整的HTML内容和元数据给爬虫和机器人。CSR可能会使爬虫和机器人更难访问和索引网页内容，因为它们可能无法执行JavaScript或等待异步数据获取。
- en: SSR can also ensure that the content and layout of web pages are consistent
    across different browsers and devices, as the server can handle browser compatibility
    and responsiveness issues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SSR还可以确保网页的内容和布局在不同浏览器和设备上保持一致，因为服务器可以处理浏览器兼容性和响应性问题。
- en: In recent developments, both Blazor and JavaScript frameworks have transitioned
    to mixed rendering modes to harness the benefits of both CSR and SSR. With the
    introduction of .NET 8, Auto render mode is now available. This mode employs Wasm-based
    rendering when the .NET Wasm runtime can be loaded swiftly (within 100ms). This
    generally occurs when the runtime has already been downloaded and cached, or when
    a high-speed network connection is being used. If these conditions are not satisfied,
    the Auto render mode defaults to Server render mode while simultaneously downloading
    the .NET Wasm runtime in the background.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的发展中，Blazor和JavaScript框架都已转向混合渲染模式，以利用CSR和SSR的双重优势。随着.NET 8的引入，现在有了自动渲染模式。此模式在.NET
    Wasm运行时可以快速加载（在100毫秒内）时使用基于Wasm的渲染。这通常发生在运行时已经被下载并缓存，或者当使用高速网络连接时。如果这些条件不满足，自动渲染模式将默认切换到服务器渲染模式，同时后台下载.NET
    Wasm运行时。
- en: Blazor Hybrid
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor混合
- en: We can also utilize Blazor as the UI layer for desktop or mobile native frameworks,
    which are referred to as Blazor Hybrid applications. In such an app, Razor components
    are natively rendered on the device using an integrated WebView control. Wasm
    is not involved, so the application possesses the same capabilities as a native
    app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将Blazor用作桌面或移动原生框架的UI层，这些框架被称为Blazor混合应用。在这样的应用中，Razor组件通过集成的WebView控件在设备上以原生方式渲染。Wasm不参与其中，因此应用程序具有与原生应用相同的性能。
- en: In *Figure 8.3*, we observe that a Hybrid app allows us to utilize the **BlazorWebView**
    control for constructing and executing Razor components within an embedded WebView.
    The **BlazorWebView** control can be accessed in .NET MAUI and Windows desktop
    environments. By utilizing .NET MAUI and Blazor together, it is possible to use
    one set of web UI components across mobile, desktop, and web platforms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.3*中，我们可以观察到混合应用允许我们利用**BlazorWebView**控件在嵌入的WebView中构建和执行Razor组件。**BlazorWebView**控件可以在.NET
    MAUI和Windows桌面环境中访问。通过结合使用.NET MAUI和Blazor，我们可以在移动、桌面和Web平台之间使用一套Web UI组件。
- en: '![Figure 7.3: BlazorWebView](img/B21554_08_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：BlazorWebView](img/B21554_08_03.png)'
- en: 'Figure 8.3: BlazorWebView'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：BlazorWebView
- en: Blazor Hybrid applications can be developed using .NET MAUI, WPF, or Windows
    Forms. This means that it is possible to create a Blazor Hybrid application as
    a WPF, Windows Forms, or .NET MAUI application. In *Part 2*, we will focus solely
    on building a .NET MAUI Blazor Hybrid application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor混合应用可以使用.NET MAUI、WPF或Windows Forms进行开发。这意味着我们可以创建一个作为WPF、Windows Forms或.NET
    MAUI应用的Blazor混合应用。在*第2部分*中，我们将专注于构建.NET MAUI Blazor混合应用。
- en: We have presented three Blazor hosting models. Among these models, both Blazor
    Server and Blazor Hybrid applications offer full support for the .NET API. However,
    Blazor Wasm applications are limited to using a subset of the .NET APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了三种Blazor主机模型。在这些模型中，Blazor服务器和Blazor混合应用都提供了对.NET API的全面支持。然而，Blazor
    Wasm应用仅限于使用.NET API的子集。
- en: Blazor Bindings
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor绑定
- en: Other than the hosting models that we previously introduced. There is a special
    type of Blazor app called Blazor Bindings available. Blazor Bindings or Mobile
    Blazor Bindings is an experimental project from Microsoft aimed at expanding the
    capabilities of Blazor, making it a cross-platform technology not only for creating
    web applications but also, eventually, for mobile development.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前介绍的主机模型之外，还有一种特殊的Blazor应用类型，称为Blazor绑定。Blazor绑定或移动Blazor绑定是微软的一个实验性项目，旨在扩展Blazor的功能，使其不仅成为创建Web应用的跨平台技术，而且最终也成为移动开发的技术。
- en: Blazor is a framework that allows you to build interactive web interfaces using
    C# instead of JavaScript, for both client and server code. It relies on Wasm to
    run the C# code directly in the browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是一个框架，允许您使用C#而不是JavaScript构建交互式Web界面，适用于客户端和服务器代码。它依赖于Wasm在浏览器中直接运行C#代码。
- en: With Mobile Blazor Bindings, the developer can write Blazor syntax and components
    but have them rendered as native controls on iOS, macOS, Windows, and Android
    – similar to how .NET MAUI XAML applications operate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动Blazor绑定，开发者可以编写Blazor语法和组件，但它们将在iOS、macOS、Windows和Android上以原生控件的形式渲染——类似于.NET
    MAUI XAML应用的操作。
- en: 'The key components of Mobile Blazor Bindings are:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 移动Blazor绑定的关键组件包括：
- en: '**.NET Runtime**: Since .NET 5, we have a common BCL on all support platforms.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET运行时**：自.NET 5以来，我们在所有支持平台上都有一个共同的BCL。'
- en: '**Blazor**: Blazor allows running .NET Standard compatible code in the browser
    using Wasm. It also provides a way to define UI components using Razor files (`.razor`).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor**：Blazor 允许在浏览器中使用 Wasm 运行 .NET Standard 兼容的代码。它还提供了一种使用 Razor 文件（`.razor`）定义
    UI 组件的方法。'
- en: '**.NET MAUI**: .NET MAUI is a framework for building native UIs for iOS, macOS,
    Android, and Windows from a single, shared code base.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET MAUI**：.NET MAUI 是一个用于从单个共享代码库构建 iOS、macOS、Android 和 Windows 的原生 UI
    的框架。'
- en: '**BlazorBindings.Maui**: This is the NuGet package published by Oleksandr Liakhevych.
    This package provides the basic Blazor Bindings functionality.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlazorBindings.Maui**：这是 Oleksandr Liakhevych 发布的 NuGet 包。此包提供了基本的 Blazor
    Bindings 功能。'
- en: Mobile Blazor Bindings allow developers to use existing Blazor development skills
    for mobile application development, where developers can use Razor syntax with
    C# to build UI components for either Web UI or native UIs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Mobile Blazor Bindings 允许开发者在移动应用程序开发中使用现有的 Blazor 开发技能，其中开发者可以使用 Razor 语法与
    C# 构建用于 Web UI 或原生 UI 的 UI 组件。
- en: 'It’s important to note that, as of January 2024, Mobile Blazor Bindings are
    still in the experimental phase and are not recommended for production applications.
    Microsoft’s original source code repository can be found here: [https://github.com/dotnet/MobileBlazorBindings/](https://github.com/dotnet/MobileBlazorBindings/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，截至 2024 年 1 月，Mobile Blazor Bindings 仍然处于实验阶段，不建议用于生产应用程序。Microsoft
    的原始源代码仓库可以在这里找到：[https://github.com/dotnet/MobileBlazorBindings/](https://github.com/dotnet/MobileBlazorBindings/)。
- en: 'Currently, the project is in the preview stage and is not under active maintenance.
    However, some updates have been merged from the GitHub repository of Oleksandr
    Liakhevych. Oleksandr Liakhevych is actively developing and maintaining his own
    repository: [https://github.com/Dreamescaper/BlazorBindings.Maui](https://github.com/Dreamescaper/BlazorBindings.Maui).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该项目处于预览阶段，并且没有处于活跃维护状态。然而，一些更新已从 Oleksandr Liakhevych 的 GitHub 仓库合并。Oleksandr
    Liakhevych 正在积极开发和维护他自己的仓库：[https://github.com/Dreamescaper/BlazorBindings.Maui](https://github.com/Dreamescaper/BlazorBindings.Maui)。
- en: 'I have applied the Blazor Bindings from Oleksandr Liakhevych in implementing
    the source code for the first and second chapters of the book. The implemented
    code can be found in the designated branches: `BlazorBindings/chapter01` and `BlazorBindings/chapter02`:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在实现本书第一、二章节的源代码时应用了Oleksandr Liakhevych的Blazor Bindings。实现的代码可以在指定的分支中找到：`BlazorBindings/chapter01`
    和 `BlazorBindings/chapter02`：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition)。
- en: To gain an understanding of Blazor Bindings, let’s compare the code and screenshot
    from the `2nd/chapter01` and `BlazorBindings/chapter01` branches, as exemplified
    in the following code and *Figure 8.4*. The branch `2nd/chapter01` code was created
    from the .NET MAUI project template, whereas the code in the branch `BlazorBindings/chapter01`
    is the equivalent implementation using Blazor.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Blazor Bindings，让我们比较 `2nd/chapter01` 和 `BlazorBindings/chapter01` 分支中的代码和截图，如下面的代码和
    *图 8.4* 所示。`2nd/chapter01` 分支的代码是从 .NET MAUI 项目模板创建的，而 `BlazorBindings/chapter01`
    分支中的代码是使用 Blazor 的等效实现。
- en: '`MainPage.xaml` (`2nd/chapter01`) – [https://epa.ms/MainPage-CH01](https://epa.ms/MainPage-CH01)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.xaml` (`2nd/chapter01`) – [https://epa.ms/MainPage-CH01](https://epa.ms/MainPage-CH01)'
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Within `MainPage.xaml`, a `ScrollView` is included. This `ScrollView` contains
    an `Image`, two `Label` instances, and a `Button`, all of which are housed within
    the `VerticalStackLayout` control.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainPage.xaml` 中，包含了一个 `ScrollView` 控件。这个 `ScrollView` 包含了一个 `Image`、两个 `Label`
    实例和一个 `Button`，所有这些都被包含在 `VerticalStackLayout` 控件中。
- en: '`MainPage.Razor` (`BlazorBindings/chapter01`) – [https://epa.ms/MainPage-BlazorBindings](https://epa.ms/MainPage-BlazorBindings)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.Razor` (`BlazorBindings/chapter01`) – [https://epa.ms/MainPage-BlazorBindings](https://epa.ms/MainPage-BlazorBindings)'
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within `MainPage.razor`, we’ve replicated the same UI but used Razor syntax.
    We’ll delve deeper into the particulars of Razor syntax later in this chapter.
    Meanwhile, we can compare the UIs in *Figure 8.4*. They appear to be identical:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainPage.razor` 中，我们复制了相同的 UI，但使用了 Razor 语法。我们将在本章后面更深入地探讨 Razor 语法的细节。同时，我们可以比较
    *图 8.4* 中的 UI。它们看起来似乎是相同的：
- en: '![Screens screenshot of a computer  Description automatically generated](img/B21554_08_04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21554_08_04.png)'
- en: 'Figure 8.4: Recreating the main page UI using Razor syntax'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：使用Razor语法重新创建主页面UI
- en: What’s new in .NET 8 Blazor hosting models
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 8 Blazor托管模型的新特性
- en: 'In our previous discussion of Blazor hosting models, we touched upon the topic
    of Blazor render modes. Prior to .NET 8, ASP.NET Core supported two render modes:
    SSR and CSR. These render modes were tied to a project type at compile time.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前关于Blazor托管模型的讨论中，我们提到了Blazor渲染模式的话题。在.NET 8之前，ASP.NET Core支持两种渲染模式：SSR和CSR。这些渲染模式在编译时与项目类型相关联。
- en: However, .NET 8 introduced a new feature to harness the benefits of both SSR
    and CSR – the Interactive Auto rendering. This new rendering mode initially uses
    a server-side ASP.NET Core for content rendering and interactivity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，.NET 8引入了一个新功能，以利用SSR和CSR的双重优势——交互式自动渲染。这种新的渲染模式最初使用服务器端的ASP.NET Core进行内容渲染和交互。
- en: It then switches to the .NET Wasm runtime on the client side for subsequent
    rendering and interactivity, after the Blazor bundle is downloaded and the Wasm
    runtime activated. Interactive Auto rendering frequently offers the quickest app
    startup experience.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor捆绑包下载并激活Wasm运行时之后，它将切换到客户端的.NET Wasm运行时进行后续的渲染和交互。交互式自动渲染通常提供最快的应用程序启动体验。
- en: This constitutes a significant departure from previous ASP.NET Core versions.
    With .NET 8, developers can designate the render modes of individual components
    at both compile time and runtime. Moreover, these render modes can be defined
    at both the component and page levels.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的ASP.NET Core版本有显著的不同。使用.NET 8，开发者可以在编译时和运行时指定单个组件的渲染模式。此外，这些渲染模式可以在组件和页面级别进行定义。
- en: 'To illustrate this, in the following example, we apply SSR to the `Dialog`
    component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，在以下示例中，我们将SSR应用于`Dialog`组件：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To designate the render modes at the page level, consult the following code
    snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在页面级别指定渲染模式，请参考以下代码片段：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, the entire page will be rendered server side.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，整个页面将在服务器端进行渲染。
- en: With support for specifying render modes at runtime, the boundary between SSR
    and CSR has become blurry. Developers now have the flexibility to switch render
    modes within a single application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 支持在运行时指定渲染模式后，SSR和CSR之间的界限变得模糊。开发者现在可以在单个应用程序内灵活切换渲染模式。
- en: Before .NET 8, developers could create either a Blazor Server app or a Blazor
    Wasm app using Visual Studio templates. But .NET 8 introduced a new project template
    – the Blazor Web app. We’ll examine these project templates further in the next
    segment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 8之前，开发者可以使用Visual Studio模板创建Blazor服务器应用或Blazor Wasm应用。但.NET 8引入了一个新的项目模板——Blazor
    Web应用。我们将在下一部分进一步探讨这些项目模板。
- en: Project templates of .NET MAUI and Blazor apps
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI和Blazor应用的项目模板
- en: Blazor Server, Blazor Wasm, and Blazor Hybrid run in different hosting models
    at runtime, so they have different capabilities. Blazor Web app is the new project
    template introduced in .NET 8\. With this template, we can mix render modes at
    runtime. In this book, our focus is on Blazor Hybrid applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor服务器、Blazor Wasm和Blazor混合应用在运行时使用不同的托管模型，因此它们具有不同的功能。Blazor Web应用是.NET
    8中引入的新项目模板。使用此模板，我们可以在运行时混合渲染模式。在这本书中，我们的重点是Blazor混合应用。
- en: We can create different project types using either the command line or Visual
    Studio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令行或Visual Studio创建不同的项目类型。
- en: 'To conserve space, we will examine the project templates using the command
    line only. To list the installed project templates, we can run the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们将仅使用命令行来检查项目模板。要列出已安装的项目模板，我们可以运行以下命令：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding list, we filtered out irrelevant project types. To understand
    the different project types better, we can review the summary depicted in *Table
    8.2*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们过滤掉了不相关的项目类型。为了更好地理解不同的项目类型，我们可以回顾*表8.2*中描述的摘要：
- en: '| **Template Name/Short Name** | **SDK** | **Target Framework** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **模板名称/简称** | **SDK** | **目标框架** |'
- en: '| Blazor Wasm app (blazorwasm) | Microsoft.NET.Sdk.BlazorWebAssembly | net8.0
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Blazor Wasm应用（blazorwasm） | Microsoft.NET.Sdk.BlazorWebAssembly | net8.0
    |'
- en: '| Blazor Server app (blazorserver) | Microsoft.NET.Sdk.Web | net8.0 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Blazor服务器应用（blazorserver） | Microsoft.NET.Sdk.Web | net8.0 |'
- en: '| Blazor Web app(blazor) | Microsoft.NET.Sdk.WebMicrosoft.NET.Sdk.BlazorWebAssembly
    | net8.0 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Blazor Web应用（blazor） | Microsoft.NET.Sdk.WebMicrosoft.NET.Sdk.BlazorWebAssembly
    | net8.0 |'
- en: '| .NET MAUI app (maui) | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| .NET MAUI应用（maui） | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
- en: '| .NET MAUI Blazor app (maui-blazor) | Microsoft.NET.Sdk.Razor | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| .NET MAUI Blazor 应用程序 (maui-blazor) | Microsoft.NET.Sdk.Razor | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
- en: '| .NET MAUI Class Library (mauilib) | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| .NET MAUI 类库 (mauilib) | Microsoft.NET.Sdk | net8.0-androidnet8.0-iosnet8.0-maccatalystnet8.0-windows10.0.19041.0
    |'
- en: '| Razor Class Library (razorclasslib) | Microsoft.NET.Sdk.Razor | net8.0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Razor 类库 (razorclasslib) | Microsoft.NET.Sdk.Razor | net8.0 |'
- en: '| Class Library (classlib) | Microsoft.NET.Sdk | net8.0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 类库 (classlib) | Microsoft.NET.Sdk | net8.0 |'
- en: 'Table 8.2: .NET MAUI and Blazor-related project types'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2：.NET MAUI 和 Blazor 相关的项目类型
- en: The project types illustrated in *Table 8.2* can be categorized into two groups
    – Blazor apps and .NET MAUI apps. Let’s examine these groups in more detail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 8.2* 中所示的项目类型可以分为两组——Blazor 应用程序和 .NET MAUI 应用程序。让我们更详细地研究这些组。'
- en: Blazor apps
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blazor 应用程序
- en: In both Blazor Server and Blazor Wasm templates, the target framework is net8.0,
    but they utilize different SDKs. The Blazor Server application can fully leverage
    the server’s capabilities using `Microsoft.NET.Sdk.Web`, while Blazor Wasm has
    access to only a limited set of .NET APIs via `Microsoft.NET.Sdk.BlazorWebAssembly`.
    In the template of Blazor Web app, it mixes both Blazor Server and Blazor Wasm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor Server 和 Blazor Wasm 模板中，目标框架都是 net8.0，但它们使用不同的 SDK。Blazor Server 应用程序可以使用
    `Microsoft.NET.Sdk.Web` 完全利用服务器的功能，而 Blazor Wasm 通过 `Microsoft.NET.Sdk.BlazorWebAssembly`
    只能访问有限的 .NET API。在 Blazor Web 应用程序的模板中，它混合了 Blazor Server 和 Blazor Wasm。
- en: To share Razor components between Blazor Server and Blazor Wasm, a Razor Class
    Library may be employed. This library employs `Microsoft.NET.Sdk.Razor`. Additionally,
    the standard .NET class library, which can be shared across all .NET 8.0 applications,
    utilizes `Microsoft.NET.Sdk`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Blazor Server 和 Blazor Wasm 之间共享 Razor 组件，可以使用 Razor 类库。这个库使用 `Microsoft.NET.Sdk.Razor`。此外，可以跨所有
    .NET 8.0 应用程序共享的标准 .NET 类库使用 `Microsoft.NET.Sdk`。
- en: .NET MAUI apps
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET MAUI 应用程序
- en: In a .NET MAUI application, one can create XAML-based .NET MAUI apps utilizing
    the `Microsoft.NET.Sdk`, while for .NET MAUI Blazor apps, the `Microsoft.NET.Sdk.Razor`
    is employed. Both project types cater to the same collection of target frameworks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 应用程序中，可以使用 `Microsoft.NET.Sdk` 创建基于 XAML 的 .NET MAUI 应用程序，而对于 .NET
    MAUI Blazor 应用程序，则使用 `Microsoft.NET.Sdk.Razor`。这两种项目类型针对相同的目标框架集合。
- en: In order to share components, the standard .NET class library can be utilized.
    If it is necessary to incorporate .NET MAUI features within the shared components,
    the .NET MAUI class library may be employed. For instance, `PassXYZLib` is a .NET
    MAUI class library. Although both the .NET class library and the .NET MAUI class
    library utilize the same `Microsoft.NET.Sdk`, they target distinct frameworks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了共享组件，可以使用标准的 .NET 类库。如果需要在共享组件中集成 .NET MAUI 功能，可以使用 .NET MAUI 类库。例如，`PassXYZLib`
    是一个 .NET MAUI 类库。尽管 .NET 类库和 .NET MAUI 类库都使用相同的 `Microsoft.NET.Sdk`，但它们针对不同的框架。
- en: Creating a new .NET MAUI Blazor project
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的 .NET MAUI Blazor 项目
- en: To learn how to develop a Blazor Hybrid app, we need to upgrade our `PassXYZ.Vault`
    project to accommodate a Blazor-based UI. Fortunately, we don’t need to start
    from scratch – we can simply modify our existing project to support the Blazor
    UI. By doing this, we can efficiently build both an XAML-based app and a Hybrid
    app within the same project. Before incorporating the Blazor UI into our app,
    let’s first establish a new .NET MAUI Blazor project with an identical app name.
    This will allow us to reference the new project when converting our current project
    into a .NET MAUI Blazor project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何开发 Blazor 混合应用程序，我们需要将我们的 `PassXYZ.Vault` 项目升级以适应基于 Blazor 的用户界面。幸运的是，我们不需要从头开始——我们可以简单地修改我们的现有项目以支持
    Blazor UI。通过这样做，我们可以在同一个项目中高效地构建基于 XAML 的应用程序和混合应用程序。在我们将 Blazor UI 集成到我们的应用程序之前，让我们首先创建一个具有相同应用程序名称的新
    .NET MAUI Blazor 项目。这将允许我们在将我们的当前项目转换为 .NET MAUI Blazor 项目时引用新项目。
- en: We have the option to create this new .NET MAUI Blazor project either through
    the command line or via Visual Studio. We will demonstrate both methods in this
    section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择通过命令行或 Visual Studio 创建此新的 .NET MAUI Blazor 项目。在本节中，我们将演示这两种方法。
- en: Generating a .NET MAUI Blazor project with the dotnet command line
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dotnet 命令行生成 .NET MAUI Blazor 项目
- en: 'Let us begin by creating a new project using the .NET command line. This can
    be accomplished on both Windows and macOS platforms. To create a new project,
    we will utilize the short name `maui-blazor`, as mentioned in *Table 8.2*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用.NET命令行创建一个新项目。这可以在Windows和macOS平台上完成。要创建新项目，我们将使用*表8.2*中提到的简称`maui-blazor`：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the previous command, we selected the project template by specifying the
    short name, `maui-blazor`, and designated `PassXYZ.Vault` as the project name.
    After creating the project, it can be built and executed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们通过指定简称`maui-blazor`来选择项目模板，并将`PassXYZ.Vault`指定为项目名称。创建项目后，它可以构建和执行：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `build` command, we designate `net8.0-android` as the target framework
    for testing our new app. We can replace the target framework with other supported
    frameworks such as `net8.0-ios`, `net8.0-maccatalyst`, or `net8.0-windows10.0.19041.0`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build`命令中，我们将`net8.0-android`指定为目标框架来测试我们的新应用。我们可以将目标框架替换为其他支持的框架，如`net8.0-ios`、`net8.0-maccatalyst`或`net8.0-windows10.0.19041.0`。
- en: Refer to *Figure 8.6* to view a screenshot of this new app and its project structure.
    With this, we have successfully created a new project using the command line.
    Now, let’s explore how to accomplish the same task using Visual Studio on Windows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图8.6查看此新应用的屏幕截图及其项目结构。通过这种方式，我们已经使用命令行成功创建了一个新项目。现在，让我们探讨如何使用Windows上的Visual
    Studio完成相同的任务。
- en: Creating a .NET MAUI Blazor Hybrid App using Visual Studio on Windows
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上使用Visual Studio创建.NET MAUI Blazor混合应用
- en: 'To create a .NET MAUI Blazor Hybrid App project using Visual Studio, begin
    by launching Visual Studio and selecting `Create a new project`, and then in the
    search box, type `MAUI` to filter the available options. As shown in *Figure 8.5*,
    choose `.NET MAUI Blazor Hybrid App` from the list of project templates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Visual Studio在Windows上创建.NET MAUI Blazor混合应用项目，首先启动Visual Studio并选择“创建新项目”，然后在搜索框中输入“MAUI”以过滤可用选项。如图8.5所示，从项目模板列表中选择“.NET
    MAUI Blazor混合应用”：
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_08_05.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21554_08_05.png)'
- en: 'Figure 8.5: Creating a new .NET MAUI Blazor Hybrid App project'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：创建新的.NET MAUI Blazor混合应用项目
- en: After completing the project creation using the wizard, we can choose `net8.0-android`
    as the target framework for building and running the project. To conserve space,
    the Android platform will be used as our primary example in this section; however,
    you are welcome to explore and test other target frameworks if desired.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向导完成项目创建后，我们可以选择`net8.0-android`作为构建和运行项目的目标框架。为了节省空间，本节中将使用Android平台作为我们的主要示例；然而，如果您愿意，也可以探索和测试其他目标框架。
- en: Running the new project
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行新项目
- en: To execute the project, press *F5* or *Ctrl* + *F5* in Visual Studio, or use
    the `dotnet` command from the command line. Refer to *Figure 8.6* for screenshots
    illustrating this process and the project structure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行项目，请在Visual Studio中按*F5*或*Ctrl* + *F5*，或从命令行使用`dotnet`命令。请参考图8.6中的截图，说明此过程和项目结构。
- en: '![Figure 7.5: Screenshots and project structure](img/B21554_08_06.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：屏幕截图和项目结构](img/B21554_08_06.png)'
- en: 'Figure 8.6: Screenshots and project structure'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：屏幕截图和项目结构
- en: 'The UI of the app, created using the template, resembles a SPA with a navigation
    menu at the top for Android devices. When executed on Windows with a larger screen,
    the navigation menu displays on the left side of the screen in a side-by-side
    manner. The project structure closely mirrors that of a standard .NET MAUI app
    but with the following notable differences:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板创建的应用UI类似于SPA，顶部有导航菜单，适用于Android设备。在屏幕更大的Windows上执行时，导航菜单以并排方式显示在屏幕左侧。项目结构紧密模仿标准.NET
    MAUI应用，但有以下显著差异：
- en: '`wwwroot/`: This folder is the root of static files for web pages.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wwwroot/`：此文件夹是网页静态文件的根目录。'
- en: '`Pages/`: This folder contains Razor pages in the app.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages/`：此文件夹包含应用中的Razor页面。'
- en: '`Shared/`: This folder contains Razor components that can be shared.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shared/`：此文件夹包含可共享的Razor组件。'
- en: '`Main.razor`: This is the main page of the Blazor app.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main.razor`：这是Blazor应用的主页。'
- en: '`_Imports.razor`: This is a helper to import Razor components at the folder
    or project level.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_Imports.razor`：这是一个在文件夹或项目级别导入Razor组件的辅助工具。'
- en: To understand the difference between the .`NET MAUI` app and the `.NET MAUI
    Blazor` app, it is helpful to analyze their respective startup code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`.NET MAUI`应用和`.NET MAUI Blazor`应用之间的区别，分析它们各自的启动代码是有帮助的。
- en: The startup code of the .NET MAUI Blazor Hybrid App
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI Blazor混合应用的启动代码
- en: 'All .NET MAUI apps contain a file named `MauiProgram.cs`, which handles their
    startup and configuration. Let’s examine the startup code of the .NET MAUI Blazor
    Hybrid App:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有.NET MAUI应用都包含一个名为`MauiProgram.cs`的文件，该文件处理它们的启动和配置。让我们检查.NET MAUI Blazor混合应用的启动代码：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the .NET MAUI Blazor Hybrid App, we can see that the following Blazor configurations
    have been added:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI Blazor混合应用中，我们可以看到以下Blazor配置已被添加：
- en: '**(1)** `BlazorWebView` is added by calling `AddMauiBlazorWebView()`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1）** `BlazorWebView`是通过调用`AddMauiBlazorWebView()`添加的。'
- en: '**(2)** Developer tools are added by calling `AddBlazorWebViewDeveloperTools()`
    for debugging.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**（2）** 通过调用`AddBlazorWebViewDeveloperTools()`添加开发者工具以进行调试。'
- en: 'The rest of the startup process is the same as that for an XAML-based .NET
    MAUI app. In the `App.xaml.cs` file, the `MainPage` property, which is inherited
    from the `App` class, is assigned to an instance of `MainPage.xaml` as we can
    see in the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程的其余部分与基于XAML的.NET MAUI应用的启动过程相同。在`App.xaml.cs`文件中，从`App`类继承的`MainPage`属性被分配给`MainPage.xaml`的一个实例，如下所示：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The primary distinction between XAML-based applications and Blazor Hybrid applications
    lies in the UI controls used within `MainPage.xaml`. Let’s examine the code of
    `MainPage.xaml` closely to better understand this difference:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: XAML应用和Blazor混合应用之间的主要区别在于`MainPage.xaml`中使用的UI控件。让我们仔细检查`MainPage.xaml`的代码，以更好地理解这种差异：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `MainPage.xaml`, only one UI element named `BlazorWebView` is defined.
    With the `HostPage` property and the nested node `RootComponent`, it is possible
    to customize the `BlazorWebView` efficiently.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml`中，只定义了一个名为`BlazorWebView`的UI元素。通过`HostPage`属性和嵌套节点`RootComponent`，我们可以有效地自定义`BlazorWebView`。
- en: We can consider `BlazorWebView` to be similar to a browser. In a browser, the
    UI is typically loaded from an HTML file. The `HostPage` property **(1)** serves
    to indicate the static HTML page that should load within the web view control.
    In our specific case, this refers to `wwwroot/index.xhtml`, which we will examine
    in *Listing 8.1*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`BlazorWebView`视为类似于浏览器。在浏览器中，UI通常是从HTML文件加载的。`HostPage`属性**（1）**用于指示应在web视图控件中加载的静态HTML页面。在我们的特定情况下，这指的是`wwwroot/index.xhtml`，我们将在*列表8.1*中对其进行检查。
- en: In this static HTML file, we must designate the location for the Razor component
    and determine the root component. Both can be specified using the attributes of
    the nested node `RootComponent` **(2)**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个静态HTML文件中，我们必须指定Razor组件的位置并确定根组件。这两个都可以通过嵌套节点`RootComponent`的属性来指定**（2）**。
- en: In the previous chapter, we discovered that an XAML tag ultimately maps to a
    C# class. In this context, both `BlazorWebView` and `RootComponent` are also C#
    classes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现XAML标签最终映射到一个C#类。在这种情况下，`BlazorWebView`和`RootComponent`也都是C#类。
- en: In the `RootComponent`, we utilize the `Selector` attribute **(3)** to define
    a CSS selector that determines the placement of the root Razor component within
    our application. In our specific instance, we use the `#app` CSS selector defined
    in the `index.xhtml` file. The `ComponentType` attribute **(4)** establishes the
    type of the root component, which in our case is `Main`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RootComponent`中，我们利用`Selector`属性**（3）**定义一个CSS选择器，该选择器确定根Razor组件在我们应用程序中的位置。在我们的具体实例中，我们使用`index.xhtml`文件中定义的`#app`
    CSS选择器。`ComponentType`属性**（4）**建立了根组件的类型，在我们的例子中是`Main`。
- en: Finally, let’s revisit the HTML file (`index.xhtml`) that was mentioned earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们重新审视一下之前提到的HTML文件（`index.xhtml`）。
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8.1: `index.xhtml` ([https://epa.ms/index8-1](https://epa.ms/index8-1))'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1：`index.xhtml` ([https://epa.ms/index8-1](https://epa.ms/index8-1))
- en: 'We can see that `index.xhtml` is a simple HTML file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`index.xhtml`是一个简单的HTML文件：
- en: '**(1)** It uses the CSS stylesheet from the Bootstrap framework.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1）** 它使用了Bootstrap框架的CSS样式表。'
- en: '**(2)** The `id` selector is specified as `app`, which is then passed to the
    `Selector` attribute of the `RootComponent` within the `MainPage.xaml` file.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**（2）** `id`选择器指定为`app`，然后传递到`MainPage.xaml`文件中`RootComponent`的`Selector`属性。'
- en: '**(3)** A JavaScript file called `blazor.webview.js` is loaded at the end of
    `index.xhtml`. This is responsible for initializing the runtime environment for
    `BlazorWebView`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**（3）** 在`index.xhtml`的末尾加载了一个名为`blazor.webview.js`的JavaScript文件。这是负责初始化`BlazorWebView`运行时环境的部分。'
- en: With that, we have provided an overview of the .NET MAUI Blazor Hybrid app.
    In the following section, we will substitute the XAML-based UI with one that utilizes
    Blazor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经提供了 .NET MAUI Blazor 混合应用的概述。在下一节中，我们将用利用 Blazor 的 UI 替换基于 XAML 的 UI。
- en: Migrating to a .NET MAUI Blazor Hybrid App
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到 .NET MAUI Blazor 混合应用
- en: In the previous section, we created a new Hybrid app, which will serve as a
    reference for migrating our existing application. Instead of starting from scratch,
    we can take advantage of both the XAML and Blazor UIs within our current app by
    adjusting the project configuration. For now, we will implement a combination
    of XAML and Blazor UIs in a single application and, later on, transition entirely
    to Blazor in the following chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个新的混合应用，该应用将作为迁移现有应用程序的参考。我们不必从头开始，可以通过调整项目配置来利用我们当前应用程序中的 XAML
    和 Blazor UI。目前，我们将在单个应用程序中实现 XAML 和 Blazor UI 的组合，并在下一章中完全过渡到 Blazor。
- en: To convert our app into a .NET MAUI Blazor Hybrid app, it is necessary to implement
    the following modifications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的应用程序转换为 .NET MAUI Blazor 混合应用程序，必须实施以下修改。
- en: Change the SDK in the project file by replacing `Microsoft.NET.Sdk` with `Microsoft.NET.Sdk.Razor`,
    as the .NET MAUI Blazor Hybrid app relies on a different SDK.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目文件中将 `Microsoft.NET.Sdk` 替换为 `Microsoft.NET.Sdk.Razor` 来更改 SDK，因为 .NET
    MAUI Blazor 混合应用程序依赖于不同的 SDK。
- en: 'In the `PassXYZ.Vault.csproj` project file, the following line is present:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PassXYZ.Vault.csproj` 项目文件中，存在以下行：
- en: '[PRE12]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This line needs to be replaced with the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行需要替换为以下内容：
- en: '[PRE13]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Transfer the subsequent folders from the newly established project into our
    application:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新建立的项目中的后续文件夹转移到我们的应用程序中：
- en: '`wwwroot`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wwwroot`'
- en: '`Shared`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shared`'
- en: 'Transfer the subsequent files from the new project to our app:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目中的后续文件转移到我们的应用程序中：
- en: '`_Imports.razor`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_Imports.razor`'
- en: '`MainPage.xaml`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`'
- en: '`MainPage.xaml.cs`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml.cs`'
- en: '`Main.razor`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main.razor`'
- en: 'Revise `MauiProgram.cs` by adding the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码来修改 `MauiProgram.cs`：
- en: '[PRE14]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To review the commit history of these changes, go to [https://epa.ms/Blazor7-1](https://epa.ms/Blazor7-1).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些更改的提交历史，请访问 [https://epa.ms/Blazor7-1](https://epa.ms/Blazor7-1)。
- en: With these adjustments, we have implemented all the necessary modifications
    to the configuration and can now proceed to the subsequent step. Nonetheless,
    before we delve into working on these changes, let us first acquaint ourselves
    with the fundamental Razor syntax.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些调整，我们已经对配置进行了所有必要的修改，现在可以继续下一步。然而，在我们深入这些更改的工作之前，让我们首先熟悉基本的 Razor 语法。
- en: Understanding Razor syntax
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Razor 语法
- en: Blazor applications are composed of Razor components. As discussed in *Chapter
    3*, *User Interface Design with XAML*, XAML is a language that has its roots in
    XML. UI elements based on XAML consist of XAML pages and their corresponding C#
    code-behind files. Razor components closely resemble this pattern, with the primary
    difference being that Razor employs HTML as its markup language and C# code can
    be directly embedded within the HTML. Alternatively, we can opt to separate the
    C# code into a code-behind file, thus maintaining a clear distinction between
    the UI and its underlying logic.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 应用程序由 Razor 组件组成。如第 3 章*使用 XAML 进行用户界面设计*中讨论的，XAML 是一种起源于 XML 的语言。基于
    XAML 的 UI 元素由 XAML 页面及其相应的 C# 代码隐藏文件组成。Razor 组件与此模式相似，主要区别在于 Razor 使用 HTML 作为其标记语言，C#
    代码可以直接嵌入到 HTML 中。或者，我们可以选择将 C# 代码分离到代码隐藏文件中，从而在 UI 和其底层逻辑之间保持清晰的区分。
- en: Code blocks in Razor
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor 中的代码块
- en: 'To create the simplest Razor component, it would appear as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建最简单的 Razor 组件，它看起来如下所示：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous example, we can design our page similarly to an HTML page while
    incorporating programming logic within a code block. Razor pages or Razor components
    are generated as C# classes, with the filename serving as the class name. The
    newly created Razor components can be utilized as HTML tags in another Razor page.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们可以将页面设计得类似于 HTML 页面，同时在代码块中包含编程逻辑。Razor 页面或 Razor 组件作为 C# 类生成，文件名作为类名。新创建的
    Razor 组件可以用作另一个 Razor 页面中的 HTML 标签。
- en: Implicit Razor expressions
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式 Razor 表达式
- en: 'In Razor syntax, we can transition from HTML to C# using the `@` symbol. These
    are referred to as implicit Razor expressions. For instance, we can use the following
    implicit expression to set the text of the `label` tag with the C# variable `currentUser.Username`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Razor 语法中，我们可以使用 `@` 符号从 HTML 切换到 C#。这些被称为隐式 Razor 表达式。例如，我们可以使用以下隐式表达式设置
    `label` 标签的文本为 C# 变量 `currentUser.Username`：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There should be no spaces between implicit expressions. Using C# generics in
    implicit expressions is not possible, as the characters within the angle brackets
    (`<>`) are interpreted as an HTML tag.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式表达式之间不应有空格。在隐式表达式中使用 C# 泛型是不可能的，因为尖括号（`<>`）内的字符被解释为 HTML 标签。
- en: Explicit Razor expressions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式 Razor 表达式
- en: 'In order to address the challenges posed by implicit expressions (e.g., white
    space or utilizing generics), we can employ explicit Razor expressions. These
    explicit expressions are composed of an `@` symbol followed by parentheses. A
    generic method can be invoked as demonstrated in the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决隐式表达式（例如，空白或使用泛型）带来的挑战，我们可以使用显式 Razor 表达式。这些显式表达式由一个 `@` 符号后跟括号组成。可以像以下示例中那样调用泛型方法：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we intend to concatenate text with an expression, it is necessary to employ
    explicit expressions, as demonstrated in the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打算将文本与表达式连接时，必须使用显式表达式，如下所示：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In more complex scenarios, we can utilize explicit Razor expressions, like passing
    a lambda expression to an event handler. Let’s examine another instance of employing
    an explicit Razor expression when embedding HTML within C# code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，我们可以利用显式 Razor 表达式，例如将 lambda 表达式传递给事件处理器。让我们考察一个在 C# 代码中嵌入 HTML 时使用显式
    Razor 表达式的另一个实例。
- en: Expression encoding
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式编码
- en: Occasionally, we might need to incorporate HTML as a string within our C# code;
    however, the outcome could be different from what we anticipated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要在 C# 代码中嵌入 HTML 字符串；然而，结果可能与我们的预期不同。
- en: 'Let’s say we write the following C# expression:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编写以下 C# 表达式：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result will look like this after rendering:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后的结果将如下所示：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To preserve the HTML string, it is necessary to utilize the `MarkupString`
    keyword, as demonstrated in the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留 HTML 字符串，必须使用 `MarkupString` 关键字，如下所示：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result of the preceding C# expression is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 C# 表达式的结果是：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the desired output. We will delve deeper into explicit Razor expressions
    as we progress with the creation of Razor components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是期望的输出。随着我们创建 Razor 组件的进展，我们将更深入地探讨显式 Razor 表达式。
- en: Directives
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: 'In addition to HTML code and C# code blocks, there are reserved keywords designed
    for use as Razor directives. These Razor directives are denoted by implicit expressions
    that follow the `@` symbol and contain specific reserved keywords. In the previous
    section, we encountered the code block represented as `@code`. In this instance,
    `@code` serves as a directive, containing the reserved keyword `code`. Throughout
    this book, we will be using the following directives:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 HTML 代码和 C# 代码块之外，还有一些保留关键字专门用于作为 Razor 指令。这些 Razor 指令由跟随 `@` 符号的隐式表达式表示，并包含特定的保留关键字。在前一节中，我们遇到了表示为
    `@code` 的代码块。在这个例子中，`@code` 作为指令，包含保留关键字 `code`。在本书中，我们将使用以下指令：
- en: '`@attribute`: This is used to add the given attribute to the class.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@attribute`：此用于向类添加指定的属性。'
- en: '`@code`: This is used to define a code block.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@code`：此用于定义代码块。'
- en: '`@implements`: This is used to implement an interface for the generated class.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@implements`：此用于为生成的类实现接口。'
- en: '`@inherits`: This is used to specify the parent class for the generated class.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inherits`：此用于指定生成的类的父类。'
- en: '`@inject`: This is used to inject a service using dependency injection.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inject`：此用于通过依赖注入注入服务。'
- en: '`@layout`: This is used to specify a layout for routable Razor components.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@layout`：此用于指定可路由的 Razor 组件的布局。'
- en: '`@namespace`: This is used to define the namespace for the generated class.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@namespace`：此用于为生成的类定义命名空间。'
- en: '`@page`: This is used to define a route for the page.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@page`：此用于定义页面的路由。'
- en: '`@using`: This is similar to the `using` keyword in C#, which imports a namespace.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@using`：此类似于 C# 中的 `using` 关键字，用于导入命名空间。'
- en: Directive attributes
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令属性
- en: 'In a Razor page, HTML tags can act as classes, and attributes can serve as
    members of the class. Let’s examine the following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Razor 页面中，HTML 标签可以充当类，属性可以作为类的成员。让我们考察以下示例：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `input` is an HTML tag, which is a class. The attribute `type` serves
    as a property of the `input` tag and its value is `text`, which indicates the
    type of this `input` tag. You might have noticed another attribute, `@bind`, which
    appears somewhat different from regular attributes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`input`是一个HTML标签，它是一个类。属性`type`作为`input`标签的属性，其值是`text`，这表示这个`input`标签的类型。你可能已经注意到了另一个属性，`@bind`，它看起来与常规属性有些不同。
- en: 'It looks like a Razor implicit expression. In fact, it is an implicit expression,
    with `bind` being a reserved keyword. This attribute functions as a directive
    attribute. The distinction between a Razor directive and a Razor directive attribute
    lies in the fact that the latter acts as an attribute for an HTML tag. Throughout
    this book, we will be using the following directive attributes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像是一个Razor隐式表达式。实际上，它是一个隐式表达式，其中`bind`是一个保留关键字。这个属性作为一个指令属性。Razor指令和Razor指令属性之间的区别在于后者作为HTML标签的属性。在这本书中，我们将使用以下指令属性：
- en: '`@bind`: This is used in data binding.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@bind`：这个指令用于数据绑定。'
- en: '`@on{EVENT}`: This is used in event handling.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@on{EVENT}`：这个指令用于事件处理。'
- en: '`@on{EVENT}:preventDefault`: This is used to prevent the default action for
    the event.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@on{EVENT}:preventDefault`：这个指令用于防止事件的默认行为。'
- en: '`@on{EVENT}:stopPropagation`: This is used to stop event propagation.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@on{EVENT}:stopPropagation`：这个指令用于停止事件传播。'
- en: '`@ref`: This is used to provide a way to reference a component instance.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ref`：这个指令用于提供一个引用组件实例的方法。'
- en: '`@typeparam`: This is used to declare a generic type parameter.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@typeparam`：这个指令用于声明一个泛型类型参数。'
- en: Having familiarized ourselves with the fundamental syntax of the Razor markup
    language, it is time to put it into practice by developing a Razor component within
    our application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了Razor标记语言的语法基础之后，是时候通过在我们应用程序中开发一个Razor组件来将其付诸实践了。
- en: Creating a Razor component
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Razor组件
- en: In developing a .NET MAUI Blazor Hybrid application, we have the option to either
    construct the entire UI utilizing Blazor or combine Razor components with XAML
    components. We will initially explore the second option, as we have already completed
    a password manager application in the first part of this book.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发.NET MAUI Blazor混合应用程序时，我们有两种选择：要么完全使用Blazor构建整个UI，要么将Razor组件与XAML组件结合。我们将首先探索第二种选择，因为我们已经在本书的第一部分完成了一个密码管理器应用程序。
- en: Redesigning the login page using a Razor component
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Razor组件重新设计登录页面
- en: The first UI we aim to replace is the login page. We can accomplish this by
    utilizing a Razor page instead of the XAML page, thereby maintaining the same
    functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旨在替换的第一个UI是登录页面。我们可以通过使用Razor页面而不是XAML页面来实现这一点，从而保持相同的功能。
- en: 'In a Blazor Hybrid application, the `BlazorWebView` serves as the control that
    hosts Razor components. We can modify `LoginPage.xaml` to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor混合应用程序中，`BlazorWebView`作为承载Razor组件的控件。我们可以将`LoginPage.xaml`修改为以下内容：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On the previous page, there is only a `BlazorWebView` control. We should focus
    on the following aspects:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一页中，只有一个`BlazorWebView`控件。我们应该关注以下方面：
- en: '**(1)** The `HostPage` attribute is utilized to indicate the HTML page that
    should be loaded in `BlazorWebView`. In this instance, `login.xhtml` (as shown
    in *Listing 8.2*) is the specified page.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1）** `HostPage`属性被用来指示应该加载到`BlazorWebView`中的HTML页面。在这个例子中，`login.xhtml`（如*清单8.2*所示）是指定的页面。'
- en: 'The attributes of `RootComponent` specify the Razor component and CSS selector
    to be used:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`RootComponent`的属性指定了要使用的Razor组件和CSS选择器：'
- en: '**(2)** The `ComponentType` attribute indicates the Razor `Login` component,
    which we will be discussing in detail shortly.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**（2）** `ComponentType`属性指示我们将详细讨论的Razor `Login`组件。'
- en: '**(3)** The `Selector` attribute indicates the CSS selector where our web UI
    will be loaded. We have defined the CSS `#login-app` ID in `login.xhtml`. This
    `login.xhtml` HTML page is created and saved in the `wwwroot` folder. Let’s take
    a look at it in *Listing 8.2*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**（3）** `Selector`属性指示我们的Web UI将被加载的CSS选择器。我们在`login.xhtml`中定义了CSS `#login-app`
    ID。这个`login.xhtml` HTML页面是在`wwwroot`文件夹中创建和保存的。让我们在*清单8.2*中看看它：'
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8.2: `login.xhtml` ([https://epa.ms/Login8-2](https://epa.ms/Login8-2))'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8.2：`login.xhtml` ([https://epa.ms/Login8-2](https://epa.ms/Login8-2))
- en: 'In *Listing 8.2*, we observe that it closely resembles `index.xhtml`, which
    we have examined earlier. The CSS ID `"``login-app"` **(1)** is defined here,
    serving the purpose of loading our Razor component:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单 8.2* 中，我们可以看到它与之前考察过的 `index.xhtml` 非常相似。这里定义了 CSS ID `"``login-app"`
    **(1**），其目的是加载我们的 Razor 组件：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the .NET MAUI Blazor Hybrid app template, the default CSS framework is Bootstrap
    (`bootstrap.min.css`). At the time of writing, the embedded Bootstrap version
    was 5.1\. However, you might find a newer version in your project.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI Blazor 混合应用模板中，默认的 CSS 框架是 Bootstrap (`bootstrap.min.css`)。在撰写本文时，嵌入式
    Bootstrap 版本是 5.1。然而，你可能在项目中找到更新的版本。
- en: 'Bootstrap is a renowned framework for web development, which provides numerous
    examples of its usage. For instance, there is a sign-in example available on the
    Bootstrap website for creating a login page, as illustrated in *Figure 8.7*. We
    will utilize this example to construct our `Login` component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个著名的 Web 开发框架，它提供了许多其使用的示例。例如，Bootstrap 网站上有一个创建登录页面的登录示例，如图 8.7
    所示。我们将利用这个示例来构建我们的 `Login` 组件：
- en: '![Figure 7.6: Bootstrap sign-in example](img/B21554_08_07.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6：Bootstrap 登录示例](img/B21554_08_07.png)'
- en: 'Figure 8.7: Bootstrap sign-in example'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：引导登录示例
- en: You can find this sign-in example at [https://getbootstrap.com/docs/5.1/examples/sign-in/](https://getbootstrap.com/docs/5.1/examples/sign-in/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://getbootstrap.com/docs/5.1/examples/sign-in/](https://getbootstrap.com/docs/5.1/examples/sign-in/)
    找到这个登录示例。
- en: 'This sign-in example includes two files:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此登录示例包括两个文件：
- en: '`index.xhtml` (*Listing 8.3*) is the UI of the sign-in page. It defines the
    following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.xhtml` (*清单 8.3*) 是登录页面的 UI。它定义了以下内容：'
- en: Two `<input>` tags for the username **(1)** and password **(2)**
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `<input>` 标签用于用户名 **(1**) 和密码 **(2**)
- en: An `<input>` tag **(3)** for a checkbox to remember the username
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<input>` 标签 **(3**）用于记住用户名
- en: A `<button>` tag **(4)** to process the login activity
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<button>` 标签 **(4**）用于处理登录活动
- en: It uses Bootstrap CSS styles and its own styles defined in `signin.css`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 Bootstrap CSS 样式和 `signin.css` 中定义的自身样式。
- en: '`signin.css` (*Listing 8.4*) defines the CSS styles specific to the sign-in
    page:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`signin.css` (*清单 8.4*) 定义了特定于登录页面的 CSS 样式：'
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8.3: `index.xhtml` (Bootstrap sign-in example)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8.3：`index.xhtml`（Bootstrap 登录示例）
- en: 'In `signin.css` (*Listing 8.4*), we modify the `form-signin` CSS class, which
    is used in the sign-in section of `index.xhtml`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `signin.css` (*清单 8.4*）中，我们修改了用于 `index.xhtml` 登录部分的 `form-signin` CSS 类：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8.4: `signin.css` (Bootstrap sign-in example)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8.4：`signin.css`（Bootstrap 登录示例）
- en: 'To create a new Razor component, first, a folder named `Pages` needs to be
    created within the project. Next, right-click on the newly created `Pages` folder
    in Visual Studio and select **Add** | **Razor Component**…. Name this component
    `Login.razor` and proceed to create the file. Once created, copy the part between
    the `<main>` tag from *Listing 8.3* and paste it into the Razor page within a
    `<div>` tag, as demonstrated in *Listing 8.5*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Razor 组件，首先需要在项目内创建一个名为 `Pages` 的文件夹。接下来，在 Visual Studio 中右键单击新创建的 `Pages`
    文件夹，选择 **添加** | **Razor 组件**…。将此组件命名为 `Login.razor` 并继续创建文件。创建完成后，将 `<main>` 标签之间的部分从
    *清单 8.3* 复制并粘贴到 Razor 页面内的 `<div>` 标签中，如 *清单 8.5* 中所示：
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 8.5: `Login.razor`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8.5：`Login.razor`
- en: We employ the directive inject to instantiate `LoginViewModel` as the `viewModel`
    variable **(1)**, and `LoginService` as the `currentUser` variable **(2)**. This
    enables us to reference the `Username` **(3)** and `Password` **(4)** properties
    of `currentUser` in the HTML via the `@` symbol. Similarly, we can define the
    `OnLogin` event handler and associate it with the `onclick` event.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用指令注入将 `LoginViewModel` 实例化为 `viewModel` 变量 **(1**），并将 `LoginService` 实例化为
    `currentUser` 变量 **(2**）。这使得我们能够通过 `@` 符号在 HTML 中引用 `currentUser` 的 `Username`
    **(3**）和 `Password` **(4**）属性。同样，我们可以定义 `OnLogin` 事件处理程序并将其与 `onclick` 事件关联。
- en: Upon entering their username and password, the `currentUser` properties are
    populated accordingly. When the login button is clicked, the `OnLogin` function
    is triggered. Consequently, the view model’s `LoginCommand` is executed to initiate
    the login process.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入用户名和密码后，`currentUser` 属性会相应地填充。当点击登录按钮时，会触发 `OnLogin` 函数。因此，会执行视图模型的 `LoginCommand`
    以启动登录过程。
- en: The Model-View-ViewModel (MVVM) pattern in Blazor
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor 中的模型-视图-视图模型 (MVVM) 模式
- en: One of the benefits of utilizing Blazor for UI design is that it allows us to
    create most of the UI using HTML initially. After ensuring the UI design meets
    our expectations, we can then implement the programming logic. By employing the
    MVVM pattern, which we explored in *Chapter 3*, *User Interface Design with XAML*,
    we can effectively separate responsibilities within the Razor component development.
    For a Razor component, we can consider the HTML markup as the view and the code
    block as the ViewModel. Should the logic in the code block become overly complex,
    we have the option to separate it into a C# code-behind file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Blazor 进行 UI 设计的一个好处是，它允许我们最初使用 HTML 创建大部分 UI。在确保 UI 设计符合我们的预期后，我们再实现编程逻辑。通过采用我们在
    *第 3 章*，*使用 XAML 进行用户界面设计* 中探讨的 MVVM 模式，我们可以在 Razor 组件开发中有效地分离责任。对于一个 Razor 组件，我们可以将
    HTML 标记视为视图，将代码块视为 ViewModel。如果代码块中的逻辑变得过于复杂，我们可以选择将其分离到一个 C# 代码后文件中。
- en: On the login page, we may proceed with utilizing the `LoginViewModel` from the
    XAML domain. This is made possible by the transition from Blazor to the XAML UI
    occurring within `LoginViewModel`. The primary objective is to demonstrate the
    seamless integration of Blazor and XAML UIs within a single application. In the
    subsequent chapter, we will completely replace the XAML UI with the Blazor UI.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录页面上，我们可以继续使用来自 XAML 域的 `LoginViewModel`。这是通过 `LoginViewModel` 中从 Blazor 到
    XAML UI 的转换实现的。主要目标是展示在单个应用程序中 Blazor 和 XAML UI 的无缝集成。在下一章中，我们将完全用 Blazor UI 替换
    XAML UI。
- en: In a Razor component, it is possible to incorporate both HTML and C# within
    a single file or divide them between a Razor file and a C# code-behind file, similar
    to XAML.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Razor 组件中，可以在单个文件中结合 HTML 和 C#，或者将它们分别放在一个 Razor 文件和一个 C# 代码后文件中，类似于 XAML。
- en: 'Let’s apply this concept to `Login.razor`. By splitting it into two files,
    the component will be divided into two partial classes found in `Login.razor`
    and `Login.razor.cs`, as demonstrated in *Listing 8.6* and *Listing 8.7*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个概念应用到 `Login.razor` 上。通过将其拆分为两个文件，组件将被拆分为两个部分类，分别位于 `Login.razor` 和 `Login.razor.cs`
    中，如 *列表 8.6* 和 *列表 8.7* 所示：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 8.6: `Login.razor` ([https://epa.ms/Login8-6](https://epa.ms/Login8-6))'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8.6: `Login.razor` ([https://epa.ms/Login8-6](https://epa.ms/Login8-6))'
- en: 'In *Listing 8.6*, the HTML markup is solely present in `Login.razor`, which
    effectively separates the UI from the underlying logic, resulting in a cleaner
    design. Now, let’s examine the corresponding C# code in *Listing 8.7*:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *列表 8.6* 中，HTML 标记仅存在于 `Login.razor` 中，这有效地将 UI 与底层逻辑分离，从而实现了更清晰的设计。现在，让我们来检查
    *列表 8.7* 中的相应 C# 代码：
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8.7*: `Login.razor.cs` ([https://epa.ms/Login8-7](https://epa.ms/Login8-7))'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8.7*: `Login.razor.cs` ([https://epa.ms/Login8-7](https://epa.ms/Login8-7))'
- en: In *Listing 8.7*, we have transferred all the code from the `@code` block to
    the C# file within the `Login` class, which inherits from the `ComponentBase`
    class. All Razor components inherit from `ComponentBase`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *列表 8.7* 中，我们将所有代码从 `@code` 块转移到了 `Login` 类中的 C# 文件，该类继承自 `ComponentBase`
    类。所有 Razor 组件都继承自 `ComponentBase`。
- en: You might have observed the usage of the `Inject` attribute in the declaration
    of the `viewModel` and `currentUser` properties. These properties are initialized
    using dependency injection.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在 `viewModel` 和 `currentUser` 属性声明中使用 `Inject` 属性。这些属性是通过依赖注入进行初始化的。
- en: Dependency injection in Blazor
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor 中的依赖注入
- en: In *Chapter 6*, *Software Design with Dependency Injection*, we introduced how
    to use dependency injection in .NET MAUI development. All the concepts presented
    in that chapter are equally applicable here; however, Blazor offers additional
    features. With Blazor, we can utilize dependency injection in both HTML and C#
    code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*使用依赖注入进行软件设计* 中，我们介绍了如何在 .NET MAUI 开发中使用依赖注入。该章节中提出的所有概念在这里同样适用；然而，Blazor
    提供了额外的功能。使用 Blazor，我们可以在 HTML 和 C# 代码中利用依赖注入。
- en: 'As demonstrated in *Listing 8.5*, the following declaration is defined at the
    beginning of the `Login.razor` file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *列表 8.5* 所示，以下声明位于 `Login.razor` 文件的开始部分：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we initialize the `viewModel` property through dependency
    injection. This approach employs property injection using the Razor directive,
    which has become more straightforward to use in Blazor than in previous versions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过依赖注入初始化了 `viewModel` 属性。这种方法使用 Razor 指令进行属性注入，在 Blazor 中比之前的版本使用起来更加简单。
- en: 'When we move it to the C# code-behind file, we can use the `Inject` attribute
    to do the same:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它移动到C#代码背后文件时，我们可以使用`Inject`属性来完成同样的操作：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In web development, we frequently utilize HTML and CSS in conjunction to design
    UIs for websites. In the Bootstrap example, a `signin.css` file is present. Now,
    where should we store our CSS styles? We will explore this topic in the subsequent
    section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，我们经常结合使用HTML和CSS来设计网站的UI。在Bootstrap示例中，存在一个`signin.css`文件。现在，我们应该在哪里存储我们的CSS样式？我们将在下一节探讨这个话题。
- en: CSS isolation
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS隔离
- en: In the earlier discussion of the Bootstrap sign-in example, we mentioned the
    presence of an HTML file and a CSS file. Now, the question arises – where should
    the CSS file be placed in order to effectively reuse the sign-in CSS styles on
    our login page?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前对Bootstrap登录示例的讨论中，我们提到了HTML文件和CSS文件的存在。现在，问题来了——CSS文件应该放在哪里才能有效地在我们的登录页面上重用登录CSS样式？
- en: 'In HTML design, using a CSS framework like Bootstrap may require customization
    of styles at the page level. To facilitate this in Blazor, a technique called
    CSS isolation for Razor components is employed. For CSS styles specific to a component
    or page, we can store them in a file with the `.razor.css` extension. The filename
    should correspond to the `.razor` file in the same folder. For instance, on our
    login page, we can copy the `sign-in.css` file from the Bootstrap example to `Login.razor.css`,
    making minor adjustments as demonstrated in *Listing 8.8*:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML设计中，使用像Bootstrap这样的CSS框架可能需要在页面级别进行样式定制。为了在Blazor中实现这一点，采用了一种称为Razor组件CSS隔离的技术。对于特定于组件或页面的CSS样式，我们可以将它们存储在具有`.razor.css`扩展名的文件中。文件名应与同一文件夹中的`.razor`文件相对应。例如，在我们的登录页面上，我们可以将Bootstrap示例中的`sign-in.css`文件复制到`Login.razor.css`，并根据*列表8.8*中展示的进行调整：
- en: '[PRE34]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 8.8: `Login.razor.css` ([https://epa.ms/Login8-8](https://epa.ms/Login8-8))'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8：`Login.razor.css` ([https://epa.ms/Login8-8](https://epa.ms/Login8-8))
- en: 'The styles defined in `Login.razor.css` are only applied to the rendered output
    of the `Login` component. Finally, let’s look at this new login UI in Blazor:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Login.razor.css`中定义的样式仅应用于`Login`组件的渲染输出。最后，让我们看看Blazor中的这个新登录UI：
- en: s![A screenshot of a phone  Description automatically generated](img/B21554_08_08.png)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![手机的截图  自动生成的描述](img/B21554_08_08.png)'
- en: 'Figure 8.8: Sign in page'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：登录页面
- en: In *Figure 8.8*, from left to right, we can see the login page on Windows, iOS,
    and Android. We observe that the look and feel of this new UI closely resemble
    the Bootstrap sign-in example, with the exception of a modified icon. The login
    functionality remains unchanged; however, we employed Blazor to develop a new
    UI.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.8*中，从左到右，我们可以看到Windows、iOS和Android上的登录页面。我们观察到这个新UI的外观和感觉与Bootstrap登录示例非常相似，除了修改了图标。登录功能保持不变；然而，我们使用了Blazor来开发新的UI。
- en: As the Blazor UI is constructed using web technologies, the appearance and user
    experience are consistent across different platforms. For instance, in the Android
    screenshot, you can see an overlap of the input fields with the placeholders upon
    entering the username and password. This behavior aligns with what you would encounter
    on all three platforms. Though this issue isn’t present on the desktop browser,
    BlazorWebView’s behavior does present some discrepancies compared with traditional
    desktop browsers. Therefore, while the Blazor UI maintains consistency across
    various platforms, it may behave differently when accessed through different browsers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Blazor UI是使用Web技术构建的，因此在不同平台上的一致性和用户体验保持一致。例如，在Android截图上，您可以看到在输入用户名和密码时输入字段与占位符的重叠。这种行为与您在所有三个平台上遇到的情况相符。尽管这个问题在桌面浏览器上不存在，但BlazorWebView的行为与传统桌面浏览器相比确实存在一些差异。因此，虽然Blazor
    UI在各个平台上保持一致性，但通过不同的浏览器访问时可能会有不同的行为。
- en: Upon logging in using this Razor page, the subsequent programming logic continues
    to align with what was demonstrated in *Chapter 6*, *Software Design with Dependency
    Injection*. After the login process, the UI framework reverts to XAML as no other
    modifications have been made thus far.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个Razor页面登录后，后续的编程逻辑继续与*第6章*中演示的依赖注入软件设计保持一致。在登录过程之后，UI框架恢复到XAML，因为没有进行其他修改。
- en: The code in this chapter illustrates the potential to combine a Blazor UI and
    XAML-based UI within a single application. However, it is advisable to avoid this
    approach unless there are no other alternatives available. As depicted in *Figure
    8.8*, Blazor and XAML UIs employ different technologies, which can present unique
    challenges during development. By mixing them, we essentially inherit the issues
    from both types of UI. This could introduce unforeseen complications in the design
    and development process of the UI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码展示了在单个应用程序中将 Blazor UI 和基于 XAML 的 UI 结合起来的潜力。然而，除非没有其他替代方案，否则建议避免这种做法。如图
    8.8 所示，Blazor 和 XAML UI 使用不同的技术，这可能在开发过程中带来独特的挑战。通过混合它们，我们本质上继承了这两种类型 UI 的问题。这可能会在
    UI 的设计和开发过程中引入未预见的复杂性。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored Blazor and how to develop a Blazor Hybrid app.
    Blazor serves as an alternative solution for UI design within .NET MAUI. The primary
    distinction between Blazor and XAML lies in their appearance: while the XAML UI
    closely resembles the native interface, the Blazor UI adopts the aesthetics of
    a web app. Functionality-wise, both offer similar capabilities. Moreover, it is
    possible to integrate Blazor and XAML within a single app and utilize the MVVM
    pattern in both.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们探讨了 Blazor 以及如何开发 Blazor 混合应用程序。Blazor 是 .NET MAUI 中 UI 设计的替代解决方案。Blazor
    与 XAML 之间的主要区别在于它们的外观：XAML UI 与原生界面非常相似，而 Blazor UI 则采用了 Web 应用程序的美学。在功能方面，两者提供类似的能力。此外，还可能将
    Blazor 和 XAML 集成到单个应用程序中，并在两者中利用 MVVM 模式。
- en: An advantage of using Blazor is the ability to share UI code between the Blazor
    Hybrid app and a web app. If you seek a solution compatible with both native and
    web apps, .NET MAUI Blazor could be an ideal choice.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor 的一个优点是能够在 Blazor 混合应用程序和 Web 应用程序之间共享 UI 代码。如果您正在寻找兼容原生和 Web 应用程序的解决方案，.NET
    MAUI Blazor 可能是一个理想的选择。
- en: In the upcoming chapter, we will transition to using Blazor for all UIs within
    our app. Additionally, we will discuss the initial UI design using layout and
    routing techniques.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将过渡到在应用程序的所有 UI 中使用 Blazor。此外，我们还将讨论使用布局和路由技术进行的初始 UI 设计。
- en: Further reading
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'ASP.NET Core updates in .NET 8 Preview 2: [https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 8 预览版 2 中的 ASP.NET Core 更新：[https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-2/#improved-blazor-webassembly-performance-with-the-jiterpreter)
- en: 'ASP.NET Core updates in .NET 8 Preview 7: [https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 8 预览版 7 中的 ASP.NET Core 更新：[https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-7/#auto-render-mode)
- en: 'What’s new in ASP.NET Core 8.0: [https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 8.0 的新特性：[https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0)
- en: 'ASP.NET Core Blazor hosting models: [https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core Blazor 托管模型：[https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0)
- en: 'ASP.NET Core Blazor render modes: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core Blazor 渲染模式：[https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0)
- en: Learn more on Discord
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code166522361691420406.png)'
