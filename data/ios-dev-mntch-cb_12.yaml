- en: Chapter 12. Multitasking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。多任务
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Detecting application states
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测应用程序状态
- en: Receiving notifications for application states
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收应用程序状态的通知
- en: Running code in the background
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行代码
- en: Playing audio in the background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台播放音频
- en: Network connectivity maintenance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络连接维护
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When the iOS platform was introduced in 2007, bringing lots of exciting new
    features to users, it drastically changed the concept of mobile devices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当2007年推出iOS平台时，为用户带来了许多令人兴奋的新功能，它彻底改变了移动设备的概念。
- en: Despite its huge success, it lacked some features at the time that were considered
    as "basic". One of these features was multitasking; that is, support for running
    multiple processes at the same time. The platform actually did support multitasking
    to system processes internally, but it was not available to developers. Starting
    with iOS 4, Apple provided support for multitasking, although it is still quite
    different to what most developers are accustomed to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当时它取得了巨大的成功，但它缺少了一些被认为是“基本”的功能。其中之一就是多任务处理；即同时运行多个进程的支持。实际上，该平台在内部支持多任务处理系统进程，但这对开发者来说并不可用。从
    iOS 4 开始，苹果提供了对多任务处理的支持，尽管它与大多数开发者习惯的方式仍然有很大不同。
- en: In this chapter, we will discuss how to make use of the platform's multitasking
    features. We will see under what circumstances we can use these features and what
    functionality we can provide through multitasking to the users of our applications.
    Specifically, we will learn about an application's states and its runtime lifecycle.
    Through a series of detailed example projects, we will be able to execute code
    while an application is in the background, support audio playback, and VoIP connection
    maintenance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何利用平台的多任务功能。我们将了解在什么情况下可以使用这些功能，以及我们可以通过多任务为应用程序用户提供哪些功能。具体来说，我们将学习应用程序的状态及其运行时生命周期。通过一系列详细的示例项目，我们能够在应用程序后台执行代码，支持音频播放和VoIP连接维护。
- en: Detecting application states
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测应用程序状态
- en: In this recipe, we will discuss how to detect and respond accordingly when an
    application transitions from the active to the inactive state, and vice versa.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将讨论如何检测应用程序从活动状态到非活动状态以及相反状态的变化，并相应地做出反应。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Create a new project in MonoDevelop, and name it `AppStateApp`. There is no
    need for a view controller in this example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `AppStateApp`。在这个例子中不需要视图控制器。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add the following method overrides in the `AppDelegate` class:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类中添加以下方法重写：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the application either on the simulator or on the device.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。
- en: Press the **home** button to suspend the application, and watch the **Application
    Output** pad in MonoDevelop.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**主页**按钮以挂起应用程序，并观察 MonoDevelop 中的**应用程序输出**面板。
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIApplicationDelegate` class contains methods that are triggered at specific
    notifications issued by the runtime. These methods are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIApplicationDelegate`类包含由运行时发出的特定通知触发的方法。这些方法是：'
- en: '`OnActivated:` This method is called when the application is made active, for
    example, when unlocking the screen, or when the application starts.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivated:` 当应用程序变为活动状态时，会调用此方法，例如，当解锁屏幕或应用程序启动时。'
- en: '`OnResignActivation:` This method is called when the application is about to
    become inactive, for example, when the screen is locked or when the multitasking
    bar is presented.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnResignActivation:` 当应用程序即将变为非活动状态时，会调用此方法，例如，当屏幕锁定或显示多任务栏时。'
- en: '`DidEnterBackground:` This method is called when the application has entered
    the background, for example, when pressing the **home** button. The application
    is suspended.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidEnterBackground:` 当应用程序进入后台时，会调用此方法，例如，当按下**主页**按钮。应用程序被挂起。'
- en: '`WillEnterForeground:` This method is called when the application is about
    to return to the foreground.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WillEnterForeground:` 当应用程序即将返回前台时，会调用此方法。'
- en: Note that when the application is moved to the background, both the `OnResignActivation`
    and `DidEnterBackground` methods are called. Similarly, when the application is
    moved to the foreground, both the `WillEnterForeground` and `OnActivated` methods
    are called.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当应用程序移动到后台时，会调用`OnResignActivation`和`DidEnterBackground`方法。同样，当应用程序移动到前台时，会调用`WillEnterForeground`和`OnActivated`方法。
- en: 'All these methods contain one parameter, which contains the `UIApplication`
    instance of the application. The `UIApplication` class contains the property `ApplicationState`,
    which returns the state of the application in values of the `UIApplicationState`
    property. These values are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都包含一个参数，该参数包含应用程序的 `UIApplication` 实例。`UIApplication` 类包含一个属性 `ApplicationState`，它返回
    `UIApplicationState` 属性中的应用程序状态值。这些值是：
- en: '`Active:` This value indicates that the application is active'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Active:` 此值表示应用程序处于活动状态'
- en: '`Inactive:` This value indicates that the application is inactive, for example,
    when a notification alert is displayed'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inactive:` 此值表示应用程序处于非活动状态，例如，当显示通知警报时'
- en: '`Background:` This value indicates that the application is in the background'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Background:` 此值表示应用程序处于后台'
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Multitasking is a feature of iOS 4+, and not all devices support multitasking,
    even if they are running on iOS 4+. For versions prior to 4, when the **home**
    button is pressed, the `WillTerminate` method is called:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务处理是 iOS 4+ 的一个功能，并且并非所有设备都支持多任务处理，即使它们运行在 iOS 4+ 上。对于 4 版本之前的版本，当按下 **主页**
    按钮时，会调用 `WillTerminate` 方法：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are cases, however, in which iOS will kill your application; for example,
    when a memory warning is issued and your application does not free up resources.
    The `WillTerminate` method will also be called in these cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，iOS 会终止您的应用程序；例如，当发出内存警告而您的应用程序没有释放资源时。在这些情况下，也会调用 `WillTerminate`
    方法。
- en: Support for multitasking
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多任务处理支持
- en: To check if the device supports multitasking, check the `UIDevice.CurrentDevice.IsMultitaskingSupported`
    property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查设备是否支持多任务处理，请检查 `UIDevice.CurrentDevice.IsMultitaskingSupported` 属性。
- en: Proper usage
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确使用
- en: These methods are very useful because they allow us to save the current data
    that is presented to the user when the application changes state. When the application
    transitions to an inactive or background state, each method is given a limited
    amount of time to execute, so we should make sure they do not perform long-running
    operations, or iOS will kill the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法非常有用，因为它们允许我们在应用程序状态改变时保存向用户展示的当前数据。当应用程序过渡到非活动或后台状态时，每个方法都有一定的时间限制来执行，因此我们应该确保它们不执行长时间运行的操作，否则
    iOS 会终止应用程序。
- en: Receiving notifications for application states
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收应用程序状态的通知
- en: In this recipe, we will discuss getting notified to application state changes
    outside the scope of the `UIApplicationDelegate` implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将讨论在 `UIApplicationDelegate` 实现范围之外接收应用程序状态变化的通知。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `NotifyStatesApp`. Add a view
    with controller to the project, and name it `MainController`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `NotifyStatesApp`。向项目中添加一个带有控制器的视图，并将其命名为 `MainController`。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enter the following fields in the `MainController` class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类中输入以下字段：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create the following methods:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `ViewDidLoad` override, call the `AddAppStateObservers` method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 覆盖中，调用 `AddAppStateObservers` 方法：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile and run the application on the simulator.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: 'Press the **home** button, and watch the output in the **Application Output**
    pad. It should be similar to the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **主页** 按钮，并观察 **应用程序输出** 面板中的输出。它应该类似于以下截图：
- en: '![How to do it...](img/1468EXP_12_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_12_01.jpg)'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Apart from calling the methods of the `UIApplicationDelegate` object for application
    states, iOS issues notifications that we can receive. This is very useful, because
    in most cases we need to be notified for application state changes outside of
    the scope of the `AppDelegate` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用 `UIApplicationDelegate` 对象的应用程序状态方法外，iOS 还会发出我们可以接收的通知。这非常有用，因为在大多数情况下，我们需要在
    `AppDelegate` 类的范围之外接收应用程序状态变化的通知。
- en: To accomplish this, we use the `NSNotificationCenter:`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们使用 `NSNotificationCenter:`
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The notification keys we are interested in are exposed through the `UIApplication`
    static properties. This example only adds notification observers for transition
    between background and foreground.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的通知密钥通过 `UIApplication` 静态属性公开。此示例仅添加了背景和前台之间的转换通知观察者。
- en: The result is similar to the example of the previous recipe, but only after
    the `MainController` is loaded.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类似于前一个菜谱的示例，但仅在 `MainController` 加载后。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To add notification observers for when the application is activated or resigns
    activation, we use the `UIApplication.DidBecomeActiveNotification` and `UIApplication.WillResignActiveNotification`
    keys, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要为应用程序激活或停用激活时添加通知观察者，我们分别使用 `UIApplication.DidBecomeActiveNotification` 和 `UIApplication.WillResignActiveNotification`
    键。
- en: Removing notification observers
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除通知观察者
- en: 'To remove the notification observers when they are no longer needed, call the
    `RemoveAppStateObservers` method inside the `ViewDidUnload` override:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要通知观察者时，在 `ViewDidUnload` 覆盖方法中调用 `RemoveAppStateObservers` 方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Detecting application states*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测应用程序状态*'
- en: Running code in the background
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行代码
- en: In this recipe, we will learn how to execute code in the background, taking
    full advantage of iOS' multitasking feature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在后台执行代码，充分利用iOS的多任务功能。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `BackgroundCodeApp`. There
    is no need for a view controller in this example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为 `BackgroundCodeApp`。在这个例子中不需要视图控制器。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Enter the following code in the `AppDelegate` class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中输入以下代码：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and run the application on the simulator.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译和运行应用程序。
- en: Press the **home** button to make the application enter the background, and
    watch the **Application Output**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**主页**按钮使应用程序进入后台，并观察**应用程序输出**。
- en: Before the background task completes (one minute), bring the application to
    the foreground by either tapping on its icon in the multitasking bar, or on its
    icon on the **home** screen.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台任务完成之前（一分钟），可以通过在多任务栏中点击其图标或在其**主页**屏幕上的图标来将应用程序带到前台。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous tasks, we learned how to get informed of an application's transitions
    from the foreground to the background, and vice versa.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的任务中，我们学习了如何得知应用程序从前台到后台以及相反的转换。
- en: Multitasking on iOS is not quite what we are used to on other platforms. The
    iOS platform makes sure that the foreground application will have all the available
    resources at its disposal (and the user's). To accomplish this, when the application
    enters the background, it is being suspended by the operating system. When it
    is suspended, it does not execute any code whatsoever.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: iOS上的多任务处理并不完全像我们在其他平台上所习惯的那样。iOS平台确保前台应用程序将拥有所有可用的资源（以及用户的）。为了实现这一点，当应用程序进入后台时，它会被操作系统挂起。当它被挂起时，它不会执行任何代码。
- en: If we want to prevent the application from being suspended when the user presses
    the **home** button, we can ask for background time. The time we ask for is limited
    to 600 seconds (10 minutes), which is more than enough for the majority of tasks
    we are likely to perform in the background (for example, save UI state, complete
    a file download/upload, close any open connections, and so on).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止用户按下**主页**按钮时应用程序被挂起，我们可以请求后台时间。我们请求的时间限制为600秒（10分钟），这对于我们可能在后台执行的大多数任务来说已经足够了（例如，保存UI状态，完成文件下载/上传，关闭任何打开的连接，等等）。
- en: 'To ask for background time, we call the `BeginBackgroundTask` method of our
    `UIApplication` instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求后台时间，我们调用我们的 `UIApplication` 实例的 `BeginBackgroundTask` 方法：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method accepts one parameter of the type `NSAction` and returns an integer,
    which corresponds to the task ID. The `NSAction` parameter represents the block
    of code that will be executed just before the background time elapses. Inside
    that block of code, we have to call the `EndBackgroundTask` method, passing the
    ID of the task that was started, which will inform the runtime that we no longer
    need background time. Each call of `BeginBackgroundTask` should be followed by
    a call to `EndBackgroundTask`. If we do not call this method and the background
    time elapses, the application will be terminated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个类型为 `NSAction` 的参数，并返回一个整数，该整数对应于任务ID。`NSAction` 参数表示在后台时间结束前将要执行的代码块。在这个代码块内部，我们必须调用
    `EndBackgroundTask` 方法，传递已启动的任务ID，这将通知运行时我们不再需要后台时间。每次调用 `BeginBackgroundTask`
    都应该跟随一个调用 `EndBackgroundTask`。如果我们不调用此方法并且后台时间结束，应用程序将被终止。
- en: After calling the `BeginBackgroundTask` method, we can execute the code we want.
    To allow the `DidEnterBackground` method to complete and to avoid blocking the
    main thread, we just enclose our code to either an asynchronous call, or in a
    separate thread. In this example, we use a thread from the `ThreadPool`. Since
    this specific task will be completed before the time we have elapses, we call
    the `EndBackgroundTask` method to let the system know that the job is done. The
    block of code we passed to the `BeginBackgroundTask` method will not be executed,
    since we ended the task.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`BeginBackgroundTask`方法后，我们可以执行我们想要的代码。为了允许`DidEnterBackground`方法完成并避免阻塞主线程，我们只需将我们的代码封装到异步调用中，或者在一个单独的线程中。在这个例子中，我们使用`ThreadPool`中的线程。由于这个特定任务将在我们设定的超时时间之前完成，我们调用`EndBackgroundTask`方法来让系统知道工作已完成。我们传递给`BeginBackgroundTask`方法的代码块将不会执行，因为我们已经结束了任务。
- en: There are cases, however, where the user might bring the application to the
    foreground while a background task is still running. To cover this scenario, we
    need to override the `WillEnterForeground` method and handle it in an appropriate
    manner. We can either stop the background task (by calling `EndBackgroundTask)`,
    or provide some sort of feedback to the user that a task is still running. Making
    an asynchronous call to our code in this scenario is best practice. If the code
    of our background task is synchronous, when the user brings the application to
    the foreground and the task is still running, the application will be frozen until
    the task completes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有可能用户在后台任务仍在运行时将应用程序带到前台。为了覆盖这种情况，我们需要重写`WillEnterForeground`方法并适当地处理它。我们可以停止后台任务（通过调用`EndBackgroundTask`），或者向用户提供某种反馈，表明任务仍在运行。在这种情况下对我们的代码进行异步调用是最佳实践。如果我们的后台任务代码是同步的，当用户将应用程序带到前台且任务仍在运行时，应用程序将冻结，直到任务完成。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'To know how much time is left to perform background tasks, we can check the
    value of the `BackgroundTimeRemaining` property:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道执行后台任务剩余多少时间，我们可以检查`BackgroundTimeRemaining`属性的值：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important considerations for background code
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台代码的重要注意事项
- en: '**Do not update the UI while the application is in the background:** doing
    so may cause your application to be terminated or crash. Any updates to UI elements
    that take place while the application is in the background are queued to be performed
    when it returns to the foreground. This will surely make the application unresponsive.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要在应用程序后台更新UI：**这样做可能会导致您的应用程序被终止或崩溃。在应用程序后台发生的任何UI元素更新都将排队，在它返回前台时执行。这肯定会使得应用程序无响应。'
- en: '**Do not inform the user to bring your application to the foreground, just
    to give more time to the task:** doing so will surely get your application rejected
    from the application store approval process. If a background task is in progress
    and the user brings the application to the foreground, moving the application
    back to the background again basically resets the background time.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要通知用户将您的应用程序带到前台，只是给任务更多时间：**这样做肯定会使得您的应用程序在应用商店的审批过程中被拒绝。如果一个后台任务正在进行，而用户将应用程序带到前台，再次将应用程序移回后台基本上会重置后台时间。'
- en: Perform lightweight operations in the background to avoid the runtime from killing
    your application.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台执行轻量级操作以避免运行时杀死您的应用程序。
- en: Avoid using external resources (for example, resources retrieved through the
    assets library).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用外部资源（例如，通过资源库检索的资源）。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Detecting application states*'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测应用程序状态*'
- en: Playing audio in the background
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台播放音频
- en: In this recipe, we will learn how to prevent the application from being suspended,
    in order to allow audio playback.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何防止应用程序挂起，以便允许音频播放。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `BackgroundAudioApp`. Add a
    button on the view of `MainController`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`BackgroundAudioApp`。在`MainController`的视图中添加一个按钮。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the `Info.plist` file, and add the key `UIBackgroundModes`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Info.plist`文件，并添加键`UIBackgroundModes`。
- en: Add the item audio under it. Add the `MonoTouch.AVFoundation` namespace.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下添加音频项。添加`MonoTouch.AVFoundation`命名空间。
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中输入以下代码：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add a sound file to the project, and set its **Build Action** to **Content**.
    This example uses a 20 second-long sound file named `sound.m4a`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将声音文件添加到项目中，并将其**构建操作**设置为**内容**。本例使用一个名为`sound.m4a`的20秒长声音文件。
- en: Compile and run the application on the device.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Tap the **Start playing** button, and press the **home** button to make the
    application enter the background. Notice that the sound continues playing.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始播放**按钮，然后按**主页**按钮使应用程序进入后台。注意，声音仍在播放。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make sure our application will be able to play audio while it is in the background,
    we have to set the audio item in the `UIBackgroundModes` key in the `Info.plist`
    file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的应用程序在后台播放音频时能够工作，我们必须在`Info.plist`文件中的`UIBackgroundModes`键中设置音频项。
- en: 'In this example, we use the `AVAudioPlayer` class to play a sound file. Just
    creating an instance of the class and calling its `Play` method is not enough
    though. We have to set a specific type for the audio session category:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`AVAudioPlayer`类来播放声音文件。然而，仅仅创建类的实例并调用其`Play`方法是不够的。我们必须为音频会话类别设置一个特定的类型：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The static method `AVAudioSession.SharedInstance` returns the current audio
    session object. The audio session category is set to `AVAudioSession.CategoryPlayback`,
    which allows the `AVAudioPlayer` to play sounds while the application is in the
    background. This requirement is specific to objects in the `MonoTouch.AVFoundation`
    namespace.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`AVAudioSession.SharedInstance`返回当前的音频会话对象。音频会话类别设置为`AVAudioSession.CategoryPlayback`，这允许`AVAudioPlayer`在应用程序处于后台时播放声音。这个要求是针对`MonoTouch.AVFoundation`命名空间中的对象。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The available audio session categories are the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的音频会话类别如下：
- en: '`CategoryAmbient:` In this category, sounds are silenced when the device screen
    locks or when the device sound silence switch is on. Sounds from external resources
    (such as the iPod application) are mixed with this category.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryAmbient:` 在这个类别中，当设备屏幕锁定或设备静音开关开启时，声音会被静音。来自外部资源（如iPod应用程序）的声音会与这个类别混合。'
- en: '`CategorySoloAmbient:` This is the default category. Sounds from external resources
    are silenced with this category. Sounds are silenced when the screen is locked
    or when the device silent switch is on.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategorySoloAmbient:` 这是默认类别。使用此类别，来自外部资源的声音会被静音。当设备屏幕锁定或设备静音开关开启时，声音会被静音。'
- en: '`CategoryPlayback:` In this category, sounds are not silenced when the screen
    is locked or when the silent switch is on. Sounds from external resources are
    silenced, but can be mixed if the `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`
    property is set to `true`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryPlayback:` 在这个类别中，当屏幕锁定或静音开关开启时，声音不会被静音。来自外部资源的声音会被静音，但如果将`MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`属性设置为`true`，则可以进行混合。'
- en: '`CategoryRecord:` This category is for recording audio. All audio playback
    is silenced. Recording continues even when the screen is locked.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryRecord:` 这个类别用于录音。所有音频播放都会被静音。即使屏幕锁定，录音也会继续。'
- en: '`CategoryPlayAndRecord:` This category is for applications that need to record
    and play audio. Sounds from external resources are silenced, but can be mixed
    if the `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers` property
    is set to `true`. Sounds continue playing when the screen is locked or the silent
    switch is on.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryPlayAndRecord:` 这个类别适用于需要录音和播放音频的应用程序。来自外部资源的声音会被静音，但如果将`MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`属性设置为`true`，则可以进行混合。当屏幕锁定或静音开关开启时，声音会继续播放。'
- en: '`CategoryAudioProcessing:` This category is specific for processing audio.
    Sound playback and recording is disabled.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryAudioProcessing:` 这个类别专门用于处理音频。声音播放和录音被禁用。'
- en: Background state for audio
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频的背景状态
- en: Even when the application is configured through the `Info.plist` file to support
    background audio playback, when the playback completes, the application will be
    suspended.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序通过`Info.plist`文件配置为支持后台音频播放，当播放完成后，应用程序将被挂起。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Network connectivity maintenance*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络连接维护*'
- en: 'In this book:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 10](ch10.html "Chapter 10. Location Services and Maps"), Location
    Services and Maps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。位置服务和地图"), 位置服务和地图：'
- en: '*Location services in the background*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后台位置服务*'
- en: Network connectivity maintenance
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络连接维护
- en: In this recipe, we will learn how to periodically wake the application to perform
    network connectivity checks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何定期唤醒应用程序以执行网络连接检查。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `NetCheckApp`. There is no
    need for a view controller in this example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`NetCheckApp`。在这个示例中不需要视图控制器。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add the following `DidEnterBackground` override in the `AppDelegate` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类中添加以下`DidEnterBackground`重写方法：
- en: '[PRE12]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Add the `UIBackgroundModes` key in the `Info.plist` file with the item `voip`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Info.plist`文件中添加`UIBackgroundModes`键，并包含项目`voip`。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Apple provides this multitasking feature to allow applications utilizing **Voice
    over Internet Protocol** (VoIP) communication to perform periodic network connectivity
    checks with the appropriate servers. To allow the application to be woken for
    this functionality, call the `SetKeepAliveTimeout` method of the `UIApplication`
    class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了这项多任务功能，允许使用**互联网协议语音**（VoIP）通信的应用程序与适当的服务器进行周期性的网络连接检查。为了允许应用程序为此功能唤醒，请调用`UIApplication`类的`SetKeepAliveTimeout`方法：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first parameter is the interval in seconds at which the application will
    be woken. The minimum interval that is allowed is 600 seconds (10 minutes). Setting
    an interval below the minimum value will cause the method to fail, and the application
    will be suspended. The second parameter is the handler that will be executed just
    before the interval elapses. This handler has only 30 seconds to execute. If it
    takes more than 30 seconds, the application will be terminated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是应用程序将被唤醒的时间间隔（以秒为单位）。允许的最小间隔是600秒（10分钟）。设置低于最小值的间隔将导致方法失败，并且应用程序将被挂起。第二个参数是在间隔即将结束时将要执行的处理程序。此处理程序只有30秒的时间执行。如果它需要超过30秒，则应用程序将被终止。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The objects that can be used for network connectivity in the keep alive handler
    are `NSInputStream, NSOutputStream`, and `NSUrlRequest`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持活动处理程序中可用于网络连接的对象是`NSInputStream, NSOutputStream`和`NSUrlRequest`。
- en: Combining items for the UIBackgroundModes key
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并UIBackgroundModes键的项目
- en: An application can use any combination or all of the available items for the
    `UIBackgroundModes` key. However, avoid adding a background mode for implementing
    different functionality than what it is intended for. In this case, your application
    will probably be rejected from the application store.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用`UIBackgroundModes`键的任何组合或所有可用项。然而，避免添加与预期功能不同的后台模式。在这种情况下，您的应用程序可能会被应用商店拒绝。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Playing audio in the background*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后台播放音频*'
- en: 'In this book:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 10](ch10.html "Chapter 10. Location Services and Maps"), Location
    Services and Maps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。位置服务和地图"), 位置服务和地图：'
- en: '*Location services in the background*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后台位置服务*'
