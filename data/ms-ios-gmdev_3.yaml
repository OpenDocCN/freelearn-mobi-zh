- en: Chapter 3. Blast Off! Starting with Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。发射！从开发开始
- en: 'Now the fun really begins! We are going to start the development of our game!
    Are you as excited as I am? If you aren''t, you should be! Just look at what we''re
    going to cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的乐趣开始了！我们将开始我们的游戏开发！你和我一样兴奋吗？如果你不兴奋，你应该兴奋！看看我们将要涵盖的内容：
- en: Creating a SpriteKit project in Xcode
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Xcode中创建SpriteKit项目
- en: Level design and implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别设计和实现
- en: Gravity – player movement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力 - 玩家移动
- en: Collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We will cover all these and a whole lot more!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖所有这些以及更多内容！
- en: Buckle up because we are going to shift into high gear, and we aren't going
    to look back! Well, maybe we will once or twice, but you get the point. Let's
    begin! Let's create our project!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带，因为我们即将全速前进，而且我们不会回头！好吧，也许我们会一两次，但你知道我的意思。让我们开始！让我们创建我们的项目！
- en: Creating a SpriteKit project in Xcode
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Xcode中创建SpriteKit项目
- en: 'Let''s begin straight away by opening up Xcode and clicking on **File** | **New**
    |**Project**. You will then be greeted by the New Project wizard, which will look
    like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即打开Xcode并点击**文件** | **新建** | **项目**。然后您将看到新项目向导，它看起来像这样：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_01.jpg)'
- en: For this project, we are—obviously—going to select **iOS** | **Application**
    | **Single View Application** and then click on **Next**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们显然将选择**iOS** | **应用程序** | **单视图应用程序**，然后点击**下一步**。
- en: 'Once you do that, you will be required to fill in some details on the project,
    such as product name, organization name, and so on. See the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成这些，您将需要填写一些关于项目的详细信息，例如产品名称、组织名称等。请参阅以下截图：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_02.jpg)'
- en: Fill in the required fields (if they aren't already populated) and then click
    **Next**. To begin, we are going to make some changes to the project. For instance,
    locate the `LaunchScreen.xib` file in the sidebar on the left and delete it by
    pressing *Delete* on your keyboard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所需的字段（如果尚未填写），然后点击**下一步**。首先，我们将对项目进行一些更改。例如，在左侧侧边栏中找到`LaunchScreen.xib`文件，并通过按键盘上的*Delete*键将其删除。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `.xib` and storyboard files are the interface files that you can use to
    create the interface of a view. In them you can create buttons, text labels, and
    other user interface elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`.xib`和Storyboard文件是您可以使用它们来创建视图界面的接口文件。在这些文件中，您可以创建按钮、文本标签和其他用户界面元素。'
- en: You will see a popup asking if you want to remove the reference or move it to
    the trash. We won't need it as we are going to program everything the player will
    see, so you can safely send it to the trash.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个弹出窗口询问您是否想要删除引用或将它移动到垃圾桶。由于我们将编写玩家将看到的所有内容，所以我们不需要它，可以安全地将其移动到垃圾桶。
- en: Then click on the main project file in the sidebar on the left; in the middle
    of the screen, you will see all the project's settings. We are also going to make
    some changes to this section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击左侧侧边栏中的主项目文件；在屏幕中间，您将看到所有项目设置。我们也将对这个部分进行一些更改。
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_03.jpg)'
- en: First things first. Under the **App Icons and Launch Images** rollout, locate
    the **Launch Screen File** dropdown. Where it says `LaunchScreen.xib`, simply
    select the text and delete it as shown in the following screenshot. Again, because
    we are going to be programming everything, we won't need it in our case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**应用程序图标和启动图像**展开中，找到**启动屏幕文件**下拉菜单。在它说`LaunchScreen.xib`的地方，只需选择文本并按以下截图所示删除它。同样，因为我们将要编程一切，所以我们不需要它在我们的情况下。
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_04.jpg)'
- en: Look down a little further and you will see the **Linked Frameworks and Libraries**
    roll out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微向下看，您将看到**链接的框架和库**展开。
- en: '**Frameworks** and **Libraries** are extensions you can add to further enhance
    the functionality of your app. Examples of what you can add are CoreGraphics and
    SpriteKit; even the Facebook API or Cocos2D can be downloaded and added for additional
    features.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架**和**库**是您可以添加以进一步增强您应用程序功能的扩展。您可以添加的内容示例包括CoreGraphics和SpriteKit；甚至可以下载并添加Facebook
    API或Cocos2D以获得更多功能。'
- en: 'This is where we add our various frameworks (if you didn''t know that already).
    We are going to add five frameworks and one library. To do this, click on the
    **+** button at the bottom of the section. The files we are going to add are as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们添加各种框架的地方（如果您还不知道的话）。我们将添加五个框架和一个库。为此，点击该部分底部的**+**按钮。我们将添加的文件如下：
- en: '`libz.dlib`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libz.dlib`'
- en: '`CoreGraphics.framework`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreGraphics.framework`'
- en: '`UIKit.framework`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIKit.framework`'
- en: '`SpriteKit.framework`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpriteKit.framework`'
- en: '`GLKit.framework`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLKit.framework`'
- en: '`Foundation.framework`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foundation.framework`'
- en: 'Here is a screenshot of **Linked Frameworks and Libraries**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**链接的框架和库**的截图：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_05.jpg)'
- en: Our game is going to make good use of these frameworks, as we will see throughout
    this chapter. I like to keep things nice and organized whereas Xcode just throws
    files at the top of the sidebar on the left-hand side. I selected the new frameworks
    that were just added, right-clicked on them, selected **New Group from Selection**,
    and called that folder `Frameworks`. I personally like to keep things good and
    organized when developing; I even make sure all the paragraphs of code are indented
    properly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将充分利用这些框架，正如我们将在本章中看到的那样。我喜欢保持事物整洁有序，而Xcode只是将文件扔到左侧侧边栏的顶部。我选择了刚刚添加的新框架，右键单击它们，选择**从选择新建组**，并将该文件夹命名为`Frameworks`。我在开发时喜欢保持良好的组织；我甚至确保所有代码段都正确缩进。
- en: After you've added the new frameworks, you must download the two folders in
    the resource section of this book. They include additional frameworks that are
    provided for free online and that will assist us further, especially with our
    level design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您添加了新的框架之后，您必须下载本书资源部分中的两个文件夹。它们包括免费在线提供的额外框架，这些框架将帮助我们进一步，尤其是在我们的关卡设计中。
- en: The Frameworks are `SKTUtils`, which is essentially an extension of `SpriteKit`,
    and `JSTileMap`, which we will use for our maps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是`SKTUtils`，它实际上是`SpriteKit`的扩展，以及`JSTileMap`，我们将用它来制作地图。
- en: The `SKUtils` framework is an extension of `SpriteKit` that adds more visual
    effects as well as further mathematical calculations for additional physics (such
    as the use of π (pi) in calculations for even more complex physics calculations).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKUtils`框架是`SpriteKit`的扩展，它增加了更多的视觉效果以及额外的物理计算（例如，在更复杂的物理计算中使用π（pi））。'
- en: The `JSTileMap` framework allows us to import a tile map file into Xcode. As
    you will find out later, Xcode doesn't natively support map files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSTileMap`框架允许我们将瓦片地图文件导入到Xcode中。正如您稍后会发现的那样，Xcode本身不支持地图文件。'
- en: 'Once you have them downloaded, simply select the two folders and drag them
    into the bar on the left-hand side of our project, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，只需选择这两个文件夹，并将它们拖到项目左侧的栏中，如下面的截图所示：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_06.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![在Xcode中创建SpriteKit项目](img/B03553_03_06.jpg)'
- en: Make sure you click on the **Copy items if needed** check box; this will copy
    these folders into your project folder so that any changes do not affect the originals.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您点击了**如果需要则复制项目**复选框；这将把这些文件夹复制到您的项目文件夹中，这样任何更改都不会影响原始文件。
- en: Importing the `SKTUtils` framework, I found, threw 20 errors at me, most of
    which were completely incomprehensible. So after much deliberation and debugging,
    I realized (halfway through writing this chapter, mind you), that we need to add
    a **prefix header**. The prefix header file is created to precompile headers a
    lot faster. So instead of compiling each header one by one, they are compiled
    once and way ahead of time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`SKTUtils`框架时，我发现它向我抛出了20个错误，其中大部分是完全无法理解的。所以在经过深思熟虑和调试后，我意识到（请注意，我在写本章的过程中意识到），我们需要添加一个**前缀头文件**。前缀头文件是为了更快地预编译头文件而创建的。所以不是逐个编译每个头文件，而是预先编译一次。
- en: Click on **File** | **New** | **File**. Once the wizard appears, click **Other**
    under **iOS**, select **PCH File (PreCompiledHeader File)**, and name it something
    like ***yourProjectName*-Prefix.pch**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**文件** | **新建** | **文件**。一旦出现向导，点击**iOS**下的**其他**，选择**PCH文件（预编译头文件）**，并将其命名为类似***yourProjectName*-Prefix.pch**的名称。
- en: 'Once that file is created, click on it to edit it; we are going to fill it
    with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建该文件后，点击它进行编辑；我们将填充以下代码：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to define our PCH file we just created in Xcode or else it will be rendered
    useless because it won't be doing anything!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义我们刚刚在 Xcode 中创建的 PCH 文件，否则它将变得毫无用处，因为它将不会做任何事情！
- en: 'Once we are done filling out that file, we are going to click on our project
    in the bar on the left. You will now see tabs at the top of the navigation bar:
    **General**, **Capabilities**, **Info**, **Build Settings**, **Build Phases**,
    and **Build Rules**. Click on **Build Settings**. Scroll down to find **Apple
    LLVM 6.1 – Language** and change the **Precompile Prefix Header** selection to
    **Yes**. Below that, double-click on the empty field in the **Prefix Header**
    section and fill it out according to your project. I named my project Adesa, so
    I filled in **Adesa/Adesa-Prefix.pch**, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们填写完那个文件，我们将点击左侧栏中的我们的项目。现在你将在导航栏顶部看到标签：**通用**、**能力**、**信息**、**构建设置**、**构建阶段**和**构建规则**。点击
    **构建设置**。向下滚动以找到 **Apple LLVM 6.1 – 语言** 并将 **预编译前缀头** 选择更改为 **是**。下面，双击 **前缀头**
    部分的空字段并填写它以符合你的项目。我命名为 Adesa，所以我填写了 **Adesa/Adesa-Prefix.pch**，如下面的截图所示：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_15.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xcode 中创建 SpriteKit 项目](img/B03553_03_15.jpg)'
- en: Moving on!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来！
- en: 'Now we have to add in some more main and header files; one set will be called
    **Player**, and the other will be **GameLevelScene**. Unsure how to add these?
    No problem! Simply click **File** | **New** | **File** or press *Command* + *N*.
    For these files, we will select the `Cocoa Class` file and click **Next**, as
    shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须添加更多的主和头文件；一组将被称为 **Player**，另一组将被称为 **GameLevelScene**。不确定如何添加这些？没问题！只需点击
    **文件** | **新建** | **文件** 或按 *Command* + *N*。对于这些文件，我们将选择 `Cocoa Class` 文件并点击 **下一步**，如下面的截图所示：
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_07.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xcode 中创建 SpriteKit 项目](img/B03553_03_07.jpg)'
- en: Again fill out the name of the **Class**, and again one will be **Player** and
    the other **GameLevelScene**. I know setting things up is a little boring, but
    we have to do it. Now, on to editing our code!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次填写 **类名** 的名称，再次一个将是 **Player**，另一个是 **GameLevelScene**。我知道设置东西有点无聊，但我们必须这样做。现在，让我们开始编辑我们的代码！
- en: Editing our code files
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑我们的代码文件
- en: 'We need to start making a few changes to our source code files. We will start
    with the `ViewController` interface set of files, the `.h` and `.m` files, that
    is—the files that control a defined view. We will start with the `.h` file; at
    the moment, it should read like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对源代码文件进行一些修改。我们将从 `ViewController` 接口文件集开始，即 `.h` 和 `.m` 文件，也就是控制一个定义视图的文件。我们将从
    `.h` 文件开始；目前，它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to add `#import<SpriteKit/SpriteKit.h>` directly below the line `#import
    <UIKit/UIkit.h>`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `#import <UIKit/UIkit.h>` 行下面直接添加 `#import<SpriteKit/SpriteKit.h>`。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**WHAT?!**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么？！**'
- en: This line we just inserted into our code imports the SpriteKit framework into
    that header file so that we can access the features of SpriteKit in the header
    we are working on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚插入到代码中的这一行将 SpriteKit 框架导入到该头文件中，这样我们就可以在正在工作的头文件中访问 SpriteKit 的功能。
- en: That's all for the `.h` file for the moment; we are going to be bouncing back
    and forth between files as we set our project up.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个 `.h` 文件就到这里；在我们设置项目的时候，我们将在文件之间来回跳动。
- en: 'On to the `ViewController.m` file, which should be edited to look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `ViewController.m` 文件，它应该被编辑成如下所示：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I know what you''re thinking: *What does all this mean?* I''ll start from the
    beginning to make it easy on those who don''t have coding experience:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想：*这一切意味着什么？* 我将从开始的地方开始，让那些没有编码经验的人更容易理解：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Again we have the import line; we import the `ViewController` header file where
    everything will be declared. Next we have the `GameLevelScene` header file; this
    will host the game scenes, where we will spend probably the majority of time in
    this file, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到导入行；我们导入 `ViewController` 头文件，所有声明都将在这里。接下来是 `GameLevelScene` 头文件；这个文件将托管游戏场景，我们可能会在这个文件上花费大部分时间，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this paragraph of code, we have set up the SpriteKit view. The first line,
    `SKView * skView = (SKView *)self.view;`, declares a new instance of a SpriteKit
    view, named `skView`, and places it in the `ViewController` header file's view,
    hence `self.view`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们设置了 SpriteKit 视图。第一行，`SKView * skView = (SKView *)self.view;` 声明了一个新的
    SpriteKit 视图实例，命名为 `skView`，并将其放置在 `ViewController` 头文件视图中的 `self.view`。
- en: The next two lines are completely optional as they are more for testing purposes,
    and you will delete them before you release your app. The first line shows the
    frames-per-second count, and the next shows the number of nodes or objects within
    the scene. Feel free to remove these lines now if you don't want to see them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行完全是可选的，因为它们更多是为了测试目的，您在发布应用程序之前会删除它们。第一行显示每秒帧数，下一行显示场景中的节点或对象数量。如果您不想看到这些行，现在可以随意删除它们。
- en: 'The next line actually creates and configures the scene. As `SKScene * scene
    = [GameLevelScene scenewithSize: skView.bound.size]` denotes, the data is being
    pulled from the `GameLevelScene` set of files we still have to set up. For now
    it will throw an error saying there is no known class method for selector `sceneWithSize`,
    but don''t worry because we haven''t done any declarations in the `GameLevelScene`
    set of files.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '下一行实际上创建并配置了场景。正如`SKScene * scene = [GameLevelScene scenewithSize: skView.bound.size]`所示，数据正在从我们还需要设置的`GameLevelScene`文件集中提取。目前它将抛出一个错误，表示没有已知类方法`sceneWithSize`，但请放心，因为我们还没有在`GameLevelScene`文件集中进行任何声明。'
- en: After that, we see the scaling for the scene which is set to `AspectFill`. You
    can select either aspect fit or stretch, but for this example we will use aspect
    fill. You can change it if you like.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到场景的缩放设置为`AspectFill`。您可以选择适应或拉伸，但在这个例子中我们将使用适应填充。如果您喜欢，可以更改它。
- en: Finally we present the scene!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示场景！
- en: 'Let''s bounce on over to the `GameLevelScene` files. We will again start with
    the header file, which should read like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到`GameLevelScene`文件。我们再次从头文件开始，它应该如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Simply, we have changed the `GameLevelScene` class to a `SpriteKit` scene;
    so now, when we go to build our project, the previously mentioned error will disappear.
    On to the `.m` file, which will read like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将`GameLevelScene`类更改为`SpriteKit`场景；因此，当我们构建项目时，之前提到的错误将消失。接下来是`.m`文件，它将如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, this is a simple initializing of the scene and setting the size. Now
    let's build our project! You don't have to have a device plugged in at the moment;
    we will run on the simulator. If you're running an older computer, I suggest selecting
    the iPhone 4S for the simulator, as shown in the following screenshot, mainly
    because it takes less time to load and the screen size is small enough to fit
    nicely on your screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是一个简单的场景初始化和设置大小。现在让我们构建我们的项目！目前您不需要连接设备；我们将在模拟器上运行。如果您正在使用较旧的电脑，我建议选择iPhone
    4S作为模拟器，如图所示，主要是因为它加载时间较短，屏幕尺寸足够小，可以很好地适应您的屏幕。
- en: '![Editing our code files](img/B03553_03_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![编辑我们的代码文件](img/B03553_03_08.jpg)'
- en: Simply click on the button shown in the previous screenshot (the one beside
    the play and stop button), and select whatever device you like for the simulator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地点击之前截图中的按钮（位于播放和停止按钮旁边的按钮），然后选择您喜欢的设备用于模拟器。
- en: Now let's build the project. Click on the **Play** button at the top, or press
    *cmd* + *B* (or *cmd* + *R* to build and run the project).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建项目。点击顶部的**Play**按钮，或者按*cmd* + *B*（或者按*cmd* + *R*来构建和运行项目）。
- en: If all goes well, it should build successfully and the iOS simulator should
    appear. Uh oh! Did you get an error that looks like this?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它应该会成功构建，iOS模拟器应该会出现。哎呀！你遇到了一个看起来像这样的错误吗？
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We also need to make changes to the `UIViewController` header file in the Storyboard.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在Storyboard中对`UIViewController`头文件进行更改。
- en: On the left-hand bar of our project, locate the `Main.storyboard` file (remember
    we discussed the storyboard and `.xib` files earlier?), and click on it. We can
    arrange the UI of the apps in this file, but we probably won't use it in this
    project. Now you will see a blank iOS layout, ripe for changing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目左侧的栏中找到`Main.storyboard`文件（记得我们之前讨论过Storyboard和`.xib`文件？），然后点击它。我们可以在这个文件中安排应用程序的UI，但在这个项目中我们可能不会使用它。现在您将看到一个空白iOS布局，非常适合更改。
- en: 'All we are going to do here is launch the **ViewController Scene** rollout
    on the sidebar, just next to the bar where all our project files are, then roll
    out the **View Controller** rollout, and click on **View**, as shown in the following
    screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要做的就是启动侧边栏上的**ViewController Scene**展开，就在所有我们的项目文件所在的栏旁边，然后展开**View Controller**展开，点击**View**，如图所示：
- en: '![Editing our code files](img/B03553_03_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![编辑我们的代码文件](img/B03553_03_09.jpg)'
- en: 'Now look over to the bar on the far right, and you will see the top bar has
    six different buttons. Click the third one, in which you see **Show the Identity
    Inspector**. Now you will see a section right below the buttons called **Custom
    Class**. In the **Class** text field in this section, we are going to type in
    **SKView**, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看最右边的栏，你将看到顶部栏有六个不同的按钮。点击第三个按钮，你会看到 **显示身份检查器**。现在你将看到按钮下方的一个名为 **自定义类**
    的部分。在这个部分的 **类** 文本框中，我们将输入 **SKView**，如以下截图所示：
- en: '![Editing our code files](img/B03553_03_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![编辑我们的代码文件](img/B03553_03_10.jpg)'
- en: Let's try running our project yet again. Does it build successfully? Good! Does
    it open the iOS simulator? Awesome! Does it show a blank device with the frame
    rate and zero nodes printed on the bottom of the screen? Amazing! We are right
    on track!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试运行我们的项目。它构建成功了吗？太好了！它打开了 iOS 模拟器吗？太棒了！它是否显示了一个带有帧率和屏幕底部打印的零节点的空白设备？太神奇了！我们正走在正确的轨道上！
- en: 'For our final changes, we are going to quickly edit the `Player` set of files.
    At this moment, all we have to do is edit the header file. Change it so it reads
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终修改，我们将快速编辑 `Player` 文件夹。此刻，我们只需编辑头文件。将其修改为以下内容：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now going to work on "pause for effect."
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将致力于“暂停以产生效果。”
- en: Level design and implementation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别设计和实现
- en: This is where we can have a lot of fun! We are now going to start designing
    our levels. You can spend hours adding the little details to each level to make
    them look perfect. Remember, a well-designed level will impress players and will
    give your game a professional look.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以玩得很开心的地方！我们现在将开始设计我们的级别。你可以花几个小时为每个级别添加细节，使它们看起来完美。记住，设计良好的级别会给玩家留下深刻印象，并给你的游戏带来专业的外观。
- en: Unfortunately, Xcode just doesn't have the drag-and-drop ease of level design,
    so we are going to create our maps using a third-party program called *Tiled Map
    Editor*, which can be downloaded for free at [www.mapeditor.org](http://www.mapeditor.org).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Xcode 并没有级别设计的拖放便捷性，因此我们将使用一个名为 *Tiled Map Editor* 的第三方程序来创建我们的地图，该程序可以在
    [www.mapeditor.org](http://www.mapeditor.org) 上免费下载。
- en: I have included a sprite sheet for our levels as well as a built level in the
    *Resources* section of this book. Do you remember the `JSTileMap` library that
    was included as well in this chapter? It's what is going to display these maps
    as SpriteKit doesn't support TMXTileMaps. So sad!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书的 *Resources* 部分包括了我们的级别精灵表以及一个构建好的级别。你还记得本章中包含的 `JSTileMap` 库吗？它就是用来显示这些地图的，因为
    SpriteKit 不支持 TMXTileMaps。真是太遗憾了！
- en: Anyway, moving on! Open up the level I have included, entitled `level1.tmx`,
    and get a feel for how the program works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，继续前进！打开我包含的级别，名为 `level1.tmx`，感受一下程序的工作方式。
- en: The side bar of Tiled shows you the different layers of the levels. In this
    case, we have **hazards**, which are things like spikes and other objects that
    could prove detrimental to our player's health. Then we have **walls**, fairly
    self-explanatory, and then **background**, for scene elements such as clouds and
    trees.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Tiled 的侧边栏显示了不同层级的层次。在这种情况下，我们有 **危险**，这包括像刺和其他可能对我们的玩家健康造成损害的物体。然后是 **墙壁**，相当直观，接着是
    **背景**，用于场景元素，如云和树。
- en: '![Level design and implementation](img/B03553_03_23.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![级别设计和实现](img/B03553_03_23.jpg)'
- en: Try making some edits to the level, and make it your own little masterpiece.
    The following screenshot shows all the tools you need; the selected tool in the
    image is the stamp tool, which allows you to place the selected image in the scene
    on the selected layer. Then you have the Paint Bucket and Eraser tools. Give it
    a try! When you're done, we are going to program the level into our game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对级别进行一些编辑，使其成为你自己的小杰作。以下截图显示了你需要的所有工具；图像中选中的工具是印章工具，它允许你在选定的层上放置选定的图像。然后你有油漆桶和橡皮擦工具。试试看！完成之后，我们将把级别编程到我们的游戏中。
- en: '![Level design and implementation](img/B03553_03_11.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![级别设计和实现](img/B03553_03_11.jpg)'
- en: Let's open up our `GameLevelScene.m` file and add `#import "JSTileMap.h"` at
    the top of the file, under `#import "GameLevelScene.h"`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的 `GameLevelScene.m` 文件，并在文件顶部 `#import "GameLevelScene.h"` 之下添加 `#import
    "JSTileMap.h"`。
- en: 'Directly under the import we just inserted, we are going to add in the following
    lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚插入的导入下面，我们将添加以下行：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is adding a private variable for the map we will be using into our `GameLevelScene`
    class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的 `GameLevelScene` 类中添加一个用于我们将会使用的地图的私有变量。
- en: 'Now we are going to actually load the map. In the `(id)initWithSize:(CGSize)size`
    block of code, inside the `if` statement, add in the following code to change
    the color of the sky, as well as load the map:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实际加载地图。在 `(id)initWithSize:(CGSize)size` 代码块中，在 `if` 语句内，添加以下代码以更改天空的颜色以及加载地图：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the project to see your awesome level is now in place on the screen. I decided
    to use a dark purple color for these levels because it's the environment I'm going
    for. You can go in for whatever you like, but remember to just adjust the colors
    accordingly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目以查看您的精彩关卡现在已显示在屏幕上。我决定使用深紫色来设计这些关卡，因为这正是我想要的环境。你可以选择任何你喜欢的颜色，但请记得相应地调整颜色。
- en: 'If for some reason it''s not showing up correctly or you are getting an error,
    make sure your `GameLevelScene.m` file now looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因它没有正确显示或你遇到了错误，请确保你的 `GameLevelScene.m` 文件现在看起来像这样：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looks pretty cool eh? Tiled is a great program, and you can add a whole lot
    more detail then I did here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当酷吧？Tiled 是一款很棒的程序，你可以添加比我这里更多的细节。
- en: '![Level design and implementation](img/B03553_03_12.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![关卡设计和实现](img/B03553_03_12.jpg)'
- en: Something's missing, though, isn't it? Hmm... Oh yes! Our player!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些东西缺失，对吧？嗯...哦，是的！我们的玩家！
- en: Gravity – player movement
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重力 – 玩家移动
- en: For now, import the `Player` images (in the `sprites.atlas` file) I have provided
    in the resources section of this book. Unless you have your own! Then by all means
    use yours.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导入我在本书资源部分提供的 `Player` 图片（在 `sprites.atlas` 文件中）。除非你有自己的！那么无论如何，请使用你的。
- en: 'Let''s go back to our `GameLevelScene.m` file and import yet another file.
    This time, it will be `#import "Player.h"`. Then, after the `@interface` section
    that we added earlier, we are going to add another property similar to the map
    property we just added: `@property (nonatomic, strong) Player *player1`. I used
    player1 because we will be adding in some multiplayer features later!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `GameLevelScene.m` 文件并导入另一个文件。这次，将是 `#import "Player.h"`。然后，在之前添加的
    `@interface` 部分之后，我们将添加另一个与刚刚添加的地图属性相似的属性：`@property (nonatomic, strong) Player
    *player1`。我使用 player1，因为我们将在以后添加一些多人游戏功能！
- en: 'Then again, inside the `initWithSize` function we will add the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `initWithSize` 函数内，我们将添加以下代码：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we build and run our project, we should get similar results as seen in
    the following image. I think it's starting to look pretty cool!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建并运行我们的项目时，我们应该得到以下图像中所示的结果。我认为它开始看起来相当酷了！
- en: '![Gravity – player movement](img/B03553_03_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![重力 – 玩家移动](img/B03553_03_13.jpg)'
- en: Hold on cowboy! What did we just do? Well let me explain what happened. The
    code we just added loaded our little space man as a sprite object, positioned
    him on the map, and then added him to the map object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下，牛仔！我们刚才做了什么？好吧，让我来解释一下发生了什么。我们刚才添加的代码将我们的太空人加载为一个精灵对象，将其定位在地图上，然后将其添加到地图对象中。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Here's something to keep in mind, as you may be wondering why our little guy
    is added to the map, instead of adding him directly to the scene. Well, let me
    tell you! It's all about control. I like to be in full control (and my wife says
    I can tell people that), and we want to control exactly which layers from our
    map are in front of and behind our little guy. So for example we can set the background
    objects, such as the trees and hills, to be way in the back, but if we want to
    we can position our space dude to be behind them. So then he needs to be a subobject,
    or a child, of the map class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事情，因为你可能想知道为什么我们的小家伙被添加到地图中，而不是直接添加到场景中。好吧，让我告诉你！这完全关乎控制。我喜欢完全控制（而且我的妻子说我可以说这个），我们想要精确控制地图中的哪些层在我们的小家伙之前和之后。例如，我们可以将背景对象，如树木和山丘，设置在后面，但如果我们想的话，我们可以将我们的太空人定位在它们后面。所以然后他需要成为地图类的子对象，或子类。
- en: 'Now we need to make this guy move! First off, let''s add some gravity into
    the scene. Back in our `GameLevelScene.m` file, we are again going to add another
    property in the same location we''ve been adding them, in the `Interface` section
    of our code. It will be this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要让这个家伙移动！首先，让我们在场景中添加一些重力。回到我们的 `GameLevelScene.m` 文件，我们再次在相同的位置添加另一个属性，即在代码的
    `Interface` 部分中。它将是这样的：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Refer to the following screenshot to ensure your code is filled out correctly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下屏幕截图以确保您的代码填写正确：
- en: '![Gravity – player movement](img/B03553_03_14.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![重力 – 玩家移动](img/B03553_03_14.jpg)'
- en: 'After this we are going to code in an `update` method, which we will place
    just before the `-(id)initWithSize:(CGSize)size {` line of code. To create this
    method, we will add this code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个`update`方法，并将其放置在`-(id)initWithSize:(CGSize)size {`代码行之前。为了创建这个方法，我们将添加以下代码：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will throw an error at the moment, saying there is no visible `@interface`
    for a player that declares the update selector. Confusing, right? Let's take it
    one step at a time and explain what we just did here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致当前抛出错误，表示没有可见的`@interface`用于声明更新选择器的玩家。是不是很困惑？让我们一步一步来解释我们在这里做了什么。
- en: Firstly, we added in this update method, which is automatically built into a
    SpriteKit scene, or `SKScene` object. All we have to do is code it in! Then every
    frame that we call before the scene will be rendered accordingly. The update method
    provides us with a timer value, or the `NSTimerInterval` value, that is the current
    time of our program.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了这个更新方法，它是自动构建到SpriteKit场景或`SKScene`对象中的。我们只需要编写代码！然后，在场景渲染之前，我们将调用每一帧。更新方法为我们提供了一个计时器值，即程序的当前时间。
- en: Secondly, we get the `delta` value, which is the current time, subtracted by
    the previous time. What's the `delta` value? It's essentially the interval since
    the previous time the update was called. With this `delta` time value, we can
    create movement, gravity, and other forces with a neat and smooth motion, as well
    as smooth animations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们获取`delta`值，即当前时间减去前一时间。`delta`值是什么？它本质上是从上次调用更新以来间隔的时间。有了这个`delta`时间值，我们可以创建平滑的运动、重力和其他力，以及平滑的动画。
- en: Then we have an `if` statement; if the `delta` value goes above 0.02, it is
    kept at 0.02\. Sometimes our devices lag, stutter, or slow down, and especially
    when first booting the game up, the device has a lot to load; thus, this `delta`
    value could be quite large. We keep it at a consistent value to reduce the chances
    of the physics acting weird. Why would this happen?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个`if`语句；如果`delta`值超过0.02，它将被保持在0.02。有时我们的设备会滞后、卡顿或变慢，尤其是在第一次启动游戏时，设备有很多要加载的内容；因此，这个`delta`值可能相当大。我们将其保持在一致值以减少物理行为异常的可能性。为什么会发生这种情况？
- en: Like I mentioned before, this `delta` value creates smooth movement and gravity
    by keeping a neat consistent value. If that value goes way over 0.02, the movement
    or any external forces we program won't work correctly and bad things could occur
    that we don't want happening. Call it preventative measures so we don't create
    any game-breaking bugs. After the `if` statement, we then set the current time
    (which for example could be 0.02), as the previous time so the device can determine
    the `delta` value. Let's clarify, in order to determine how quickly the time is
    advancing, we have the current time, and previous time, so before the time advances
    we set the current time as the previous time, and then the current time advances.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前提到的，这个`delta`值通过保持整洁一致的价值来创建平滑的运动和重力。如果这个值远远超过0.02，我们编写的运动或任何外部力将不会正常工作，可能会发生我们不希望发生的事情。这可以称为预防措施，这样我们就不创建任何破坏游戏的bug。在`if`语句之后，我们将当前时间（例如0.02）设置为前一时间，以便设备可以确定`delta`值。让我们澄清一下，为了确定时间前进的速度，我们有当前时间和前一时间，所以在时间前进之前，我们将当前时间设置为前一时间，然后当前时间前进。
- en: Broken down, the clock begins to count, the current time is 0.05, before the
    time advances we will set the previous time variable to 0.05, then the current
    time will increase to 0.06\. The device will then calculate the delta value. Make
    sense? I know it's a lot to take in.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 分解来看，时钟开始计时，当前时间是0.05，在时间前进之前，我们将前一时间变量设置为0.05，然后当前时间将增加到0.06。然后设备将计算`delta`值。明白了吗？我知道这听起来可能很多。
- en: Then we come to the line of code that causes the error. It's calling the error
    because we haven't implemented the `update` method in our `Player` set of files
    (or class). Let's do that now!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来到导致错误的代码行。它调用错误是因为我们没有在我们的`Player`文件集（或类）中实现`update`方法。现在让我们来做这件事！
- en: 'Go in to our `Player.h` file, and change the code so it looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 进入我们的`Player.h`文件，并更改代码，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Whoa, whoa buddy, this doesn't make sense! When programming a game, there's
    a lot of physics and math that goes into the coding. In the `@property (nonatomic,
    assign) CGPoint velocity;` line, we are creating a property that will measure
    how fast the player is moving.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，哇，朋友，这没有道理！在编写游戏时，有很多物理和数学知识需要应用到编码中。在`@property (nonatomic, assign) CGPoint
    velocity;`这一行，我们创建了一个属性，用来测量玩家移动的速度。
- en: What's a **CGPoint**, you ask? **CG** stands for **CoreGraphics** which is the
    main graphic rendering framework used by iOS devices, and **point** is a point
    on the screen, so `CGPoint` holds the positional value of an object; in this case
    the `velocity` will now have an `x` and `y` value, allowing us to calculate the
    exact speed the player is moving at and the exact direction they are moving in.
    Fun!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你问什么是**CGPoint**？**CG**代表**CoreGraphics**，这是iOS设备使用的主要图形渲染框架，**point**是屏幕上的一个点，所以`CGPoint`包含对象的定位值；在这种情况下，`velocity`现在将有一个`x`和`y`值，使我们能够计算出玩家移动的确切速度和方向。很有趣！
- en: 'Let''s hop on over to the `Player.m` class file and change the code to the
    following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到`Player.m`类文件，并将代码更改为以下内容：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's break down what we just did here. I know things can be confusing, but
    don't worry! I'm here to help you!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们刚才做了什么。我知道事情可能会很复杂，但别担心！我在这里帮助你！
- en: First, we imported the `SKUtils` framework into the `Player` class. After that,
    we created a new `initWithImageNamed` method and initialized the velocity variable
    to `0.0`. Then we declared the value of the gravity force. Each time the update
    method runs, we are increasing the velocity of the player 450 points downward.
    If the player starts out by standing still, after one second he'll be moving at
    450 pixels per second, at two seconds that value will be doubled, and so forth.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`SKUtils`框架导入到`Player`类中。之后，我们创建了一个新的`initWithImageNamed`方法，并将速度变量初始化为`0.0`。然后我们声明了重力力的值。每次更新方法运行时，我们都会增加玩家向下的速度450点。如果玩家一开始是静止的，一秒后他将以450像素每秒的速度移动，两秒后这个值将翻倍，以此类推。
- en: Sounds easy.... right?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单……对吧？
- en: Next, we used `CGPointMulitplyScalar` to decrease the acceleration down to the
    size of the current time step. Remember, `CGPointMulitplyScalar` increases the
    `CGPoint` values by a float value, and returns the `CGPoint` result. This is great
    because, when the device lags or for some odd reason we see a drop in frame rate,
    we will still get a consistent acceleration value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`CGPointMulitplyScalar`将加速度减小到当前时间步的大小。记住，`CGPointMulitplyScalar`通过一个浮点值增加`CGPoint`的值，并返回`CGPoint`结果。这很好，因为当设备延迟或由于某些奇怪的原因帧率下降时，我们仍然会得到一致的加速度值。
- en: In the `self.velocity =... block`, we calculate the gravity for the current
    time and then add it to the player's current velocity. With the new velocity calculated,
    we get the velocity for a single time step.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`self.velocity =...`代码块中，我们计算当前时间的重力，然后加到玩家的当前速度上。有了新的速度计算，我们得到了单次时间步的速度。
- en: Finally, with the velocity all calculated, we use the `CGPointAdd` function
    to change the position of the player. As you can see, `CGPointAdd` is equal to
    the player's current position, with the gravity added.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有速度都计算完毕后，我们使用`CGPointAdd`函数来改变玩家的位置。正如你所见，`CGPointAdd`等于玩家的当前位置，加上重力。
- en: OK! Let's run our project!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！让我们运行我们的项目！
- en: '![Gravity – player movement](img/B03553_03_16.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![重力 – 玩家移动](img/B03553_03_16.jpg)'
- en: What? He's falling through the ground? Hmm, I guess that means we need to detect
    collisions now?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？他穿过地面掉下去了？嗯，我想这意味着我们现在需要检测碰撞了？
- en: Collision detection
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We all know that collision detection is imperative to any game. Regardless of
    whether it's a hockey game, or Call of Angry eight year olds, the game needs to
    detect collisions of hockey pucks, bullets, swords, feet on the ground—you name
    it and there are a ton of collisions that need to be detected. For our game, we
    are only going to detect simple boxes colliding with each other between the player
    and enemies, the platforms, and the bullets colliding with enemies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，碰撞检测对任何游戏都是必不可少的。无论是一场比赛曲棍球，还是愤怒的八岁小孩的《愤怒的小鸟》，游戏都需要检测曲棍球、子弹、剑、地面上的脚——你叫得出名字的，都有大量的碰撞需要检测。对于我们的游戏，我们只将检测玩家和敌人、平台之间简单的箱子碰撞，以及子弹与敌人碰撞。
- en: We are going to make things super easy; first we are going to detect the player's
    bounding box.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使事情变得非常简单；首先，我们将检测玩家的边界框。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What's a bounding box? Simple! Think of when you're creating your sprites; there's
    a box surrounding your image? You could think of a collision bounding box like
    that, the small box that your sprite fits in or within a defined space. You can
    (and we will) adjust the size of the bounding box to fit the sprite; you can have
    it larger or smaller depending on your needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞框是什么？简单！想象一下你创建精灵的时候；你的图像周围有一个框吗？你可以将碰撞框想象成那样，就是你的精灵适合其中的小框或者在一个定义的空间内。你可以（我们也会）调整碰撞框的大小以适应精灵；你可以根据需要将其放大或缩小。
- en: 'With that all explained, let''s hop into our `Player.h` file and add the following
    line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解释完这些后，让我们跳到我们的`Player.h`文件，并添加以下行：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We just created a core-graphics rectangle named `collisionBox`. Easy, right?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个名为`collisionBox`的核心图形矩形。很简单，对吧？
- en: 'Now add the following code into `Player.m`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下代码添加到`Player.m`文件中：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The value of `CGRectInset` decreases the size of the rectangle, or our collision
    box, by the last two bracketed numbers, `2` and `0` respectively. We set the player's
    frame as the base size, and then shrink it by `two` pixels on each side of the
    player. If you want, you don't have to shrink the bounding box, you can leave
    the two values at `0`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGRectInset`的值会减小矩形的大小，或者我们的碰撞框，通过最后两个括号内的数字，分别是`2`和`0`。我们将玩家的框架设置为基本大小，然后在玩家的每一边减少`两个`像素。如果你愿意，你不必缩小边界框，可以将这两个值保留为`0`。'
- en: 'Now things will start to get a little more complicated. We need to detect the
    various images in our level and select which one we want our player to collide
    with and those that we don''t. Let''s shoot on over to our `GameLevelScene.m`
    class and add in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情将开始变得稍微复杂一些。我们需要检测我们关卡中的各种图像，并选择我们想要玩家与之碰撞的图像以及那些我们不想要的。让我们快速跳到我们的`GameLevelScene.m`类，并添加以下代码：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This first block locates the pixel origin coordinate; we do this so we know
    exactly where to place the map in the scene. We need to flip the height coordinate
    because SpriteKit''s origin is in the bottom-left corner of the screen but the
    tile map''s origin is at the top left. In order to detect the origin, we need
    to add in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个代码块定位像素原点坐标；我们这样做是为了知道在场景中确切地放置地图的位置。我们需要翻转高度坐标，因为SpriteKit的原点在屏幕的左下角，而瓷砖地图的原点在左上角。为了检测原点，我们需要添加以下代码：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next we add `1` to the tile coordinate. Why do we do this? Actually, the tile
    coordinate system starts at `0`, so if we have 50 tiles, the 50th tile's actual
    coordinate will be 49\. So we need to add one to get the right value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将`1`添加到瓷砖坐标上。我们为什么要这样做呢？实际上，瓷砖坐标系统从`0`开始，所以如果我们有50个瓷砖，第50个瓷砖的实际坐标将是49。因此，我们需要加一以获得正确的值。
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This next method accesses our saved map''s layer info that is saved in *Tiled
    Map Editor*. Remember we had three layers: Background, walls, and hazards? If
    you want to have more than three layers, absolutely feel free to do so. I am only
    doing three in this example because we are going to add in our enemies and some
    special effects programmatically. This block of code will access those layers.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个下一个方法访问我们保存的地图层信息，这些信息保存在*Tiled Map Editor*中。记得我们有三层：背景、墙壁和危险区域吗？如果你想有超过三个层，绝对可以这样做。我在这例子中只做三个，因为我们将要程序化地添加敌人和一些特殊效果。这段代码将访问这些层。
- en: For our collision system, we are going to detect the surrounding eight tiles
    of our player. In the following blocks of code, we are going to detect the surrounding
    tiles, which will inspect the `CGRect` (or Core-Graphics rectangles) for a collision
    with the player's collision bounding box.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的碰撞系统，我们将检测玩家周围的八个瓷砖。在接下来的代码块中，我们将检测周围的瓷砖，这将检查`CGRect`（或核心图形矩形）与玩家碰撞边界框的碰撞。
- en: 'Let''s go back to our `GameLevelScene.m` file and add in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`GameLevelScene.m`文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Wow! So much code! Let's break it down. The first block creates an array that
    shows the position of the tiles surrounding our cool little player dude. As you
    can see, we find the eight surrounding tiles and then we store those values in
    the `tileIndex` variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这么多代码！让我们来分解一下。第一个代码块创建了一个数组，显示了围绕我们酷炫的小玩家角色的瓷砖位置。正如你所见，我们找到了八个周围的瓷砖，然后将这些值存储在`tileIndex`变量中。
- en: Now, remember what I said about the tile coordinates being flipped? Notice the
    order of tiles? `7`, `1`, `3`, `5`, `0`, `2`, `6`, `8`. Tile 7 is the tile that
    is directly below our player, so it needs to be figured out right away. We need
    to know if he's on the ground or not; if he is, he can jump, but if not, no jumping!
    If we don't resolve this tile immediately, the player could potentially jump without
    the character touching the ground—if they pressed the jump button quickly enough.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得我之前提到的瓦片坐标是颠倒的吗？注意瓦片的顺序？`7`，`1`，`3`，`5`，`0`，`2`，`6`，`8`。瓦片 7 是位于我们玩家直接下方的瓦片，所以需要立即确定。我们需要知道他是否在地面上；如果是，他可以跳跃，但如果没有，就不能跳跃！如果我们不立即解决这个瓦片，玩家可能会在没有角色接触地面的情况下跳跃——如果他们足够快地按下跳跃按钮。
- en: Then we retrieved the player's collision box that we coded earlier and found
    the exact tile location of the player. We did this so we could then locate the
    surrounding tiles of our player. After we located the position of the player,
    we then divided the `tileIndex` variable we created earlier to find the row and
    column values around the player.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检索了我们之前编写的玩家碰撞框，并找到了玩家的确切瓦片位置。我们这样做是为了然后定位我们玩家的周围瓦片。在我们定位了玩家的位置之后，我们然后把之前创建的
    `tileIndex` 变量除以找到玩家周围的行和列值。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Let's break this down into an example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来分解这个过程。
- en: Say the value of `tileIndex` is `3`; the value of `tileColumn` would be `0`
    (3 % 3 = 0) and the value of `tileRow` would be `1` (3 / 3 = 1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `tileIndex` 的值为 `3`；则 `tileColumn` 的值将是 `0`（3 % 3 = 0），而 `tileRow` 的值将是 `1`（3
    / 3 = 1）。
- en: If our space guy's position was found to be at tile coordinate (`50`, `10)`,
    the surrounding tile at `tileIndex 3` would be 50 + (0 – 1) and 10 + (1 – 1) or
    `49` and `10`, respectively. This equals the tile directly to the left of our
    space man's tile position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的太空人的位置被发现在瓦片坐标（`50`，`10`），则 `tileIndex 3` 的周围瓦片将是 `50` + (0 – 1) 和 `10`
    + (1 – 1) 或 `49` 和 `10`，分别。这等于我们太空人瓦片位置的左侧瓦片。
- en: I know that this can be a little confusing, but don't worry; you'll start to
    get it soon!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能会有些令人困惑，但别担心；你很快就会明白的！
- en: In the next step, we look up the GID value for the tile at the coordinate found
    in the previous instance of `tileIndex`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们查找在之前实例中找到的 `tileIndex` 坐标处的瓦片的 GID 值。
- en: Woah, halt! What in the wide, wide world of sports is a GID?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，停下！在广阔的体育世界中，GID 是什么？
- en: A **GID** is the number that represents the index of an image from a tile set.
    Each `TMXLayer` class has a tile set that has images arranged in a grid. Simply
    put, the GID is the position of a particular image.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**GID** 是表示从瓦片集中图像索引的数字。每个 `TMXLayer` 类都有一个瓦片集，其中的图像以网格形式排列。简单来说，GID 就是特定图像的位置。'
- en: 'Next we figure if the GID has a value of `0`. There is no tile. It''s just
    blank space, so we don''t resolve or test a collision. However, if there is a
    value in the GID, we get the `CGRect` position for that tile. Then we simply log
    the results. This is not a required block of code, but it is very helpful when
    things aren''t working properly—you can look at the debugger to see what''s going
    on. The following figure shows you how tiles are handled:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们判断 GID 是否有值为 `0`。没有瓦片。它只是空白空间，所以我们不需要解决或测试碰撞。然而，如果 GID 中有值，我们就获取该瓦片的 `CGRect`
    位置。然后我们简单地记录结果。这不是必需的代码块，但在事情不正常时非常有帮助——你可以查看调试器来查看发生了什么。以下图显示了如何处理瓦片：
- en: '![Collision detection](img/B03553_03_17.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞检测](img/B03553_03_17.jpg)'
- en: The big bold numbers represent the order in which tile collisions are handled,
    bottom first, top second, left-hand side third, and right-hand side fourth, then
    the corners. The smaller numbers represent the order in which those tiles are
    stored in the `tileIndex` variable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大号粗体数字表示处理瓦片碰撞的顺序，从底部开始，然后是顶部，接着是左侧，最后是右侧，然后是角落。小号数字表示这些瓦片在 `tileIndex` 变量中的存储顺序。
- en: 'Next we are going to go back into our `GameLevelScene.m` file, and add in the
    following lines:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到我们的 `GameLevelScene.m` 文件，并添加以下行：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you were to run the project now, it would just crash into the oblivion of
    **SIGABRT** (**signal abort**). SIGABRT signifies that, though an error wasn't
    shown within your code, your app failed when it attempted to run a section of
    code. You will be able to see what's going on and why it happened in the console
    log. We are going to further discuss debugging later in this book. We need to
    do a little more work.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行项目，它将直接崩溃到 **SIGABRT**（**信号终止**）的深渊。SIGABRT 表示，尽管你的代码中没有显示错误，但你的应用程序在尝试运行代码段时失败了。你将能够在控制台日志中看到发生了什么以及为什么发生。我们将在本书的后面进一步讨论调试。我们需要做更多的工作。
- en: When our `Player` class updates its position and the `GameLevelScene` class
    detects a collision, we will want the player to stop. So we need to create a new
    variable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `Player` 类更新其位置，而 `GameLevelScene` 类检测到碰撞时，我们希望玩家停止。因此，我们需要创建一个新的变量。
- en: This variable will allow the `Player` class to do all its positioning calculations,
    and the `GameLevelScene` class will update the position after the collisions have
    been detected.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将允许 `Player` 类执行所有其位置计算，而 `GameLevelScene` 类将在检测到碰撞后更新位置。
- en: 'Let''s go on over to our `Player.h` file and add this new property:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们的 `Player.h` 文件并添加这个新属性：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to make changes to our `collisionBox` method in the `Player.m`
    file, which should now read as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 `Player.m` 文件中的 `collisionBox` 方法，现在它应该如下所示：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This creates a collision bounding box based on the desired position. The layer
    will now use this for collision detection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个基于期望位置的碰撞边界框。层现在将使用这个边界框进行碰撞检测。
- en: 'Now let''s scroll down to our `update` method and locate this line:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们滚动到 `update` 方法并找到这一行：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace it with the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now this will update our `desiredPosition` property instead of the actual position
    property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将更新我们的 `desiredPosition` 属性而不是实际位置属性。
- en: Back in our `GameLevelScene.m` file, look for our `-(void)checkForAndResolveCollisionsForPlayer:(Player
    *)player forLayer:(TMXLayer *)layer` method. We wrote `CGPoint playerCoord = [layer
    coordForPoint:player.position]`; we have to change this from `player.position`
    to `player.desiredPosition`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `GameLevelScene.m` 文件，查找我们的 `-(void)checkForAndResolveCollisionsForPlayer:(Player
    *)player forLayer:(TMXLayer *)layer` 方法。我们写了 `CGPoint playerCoord = [layer coordForPoint:player.position]`；我们必须将
    `player.position` 从 `player.desiredPosition` 改变过来。
- en: 'Back into our `checkForAndResolveCollisionsForPlayer` method, after the commented
    out text `//after this is where we write our collision resolving`, we need to
    add in our collision resolution code. So that there''s no confusion, the `checkForAndResolveCollisionsForPlayer`
    method should look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `checkForAndResolveCollisionsForPlayer` 方法，在注释掉的文本 `//after this is where
    we write our collision resolving` 之后，我们需要添加我们的碰撞解决代码。为了避免混淆，`checkForAndResolveCollisionsForPlayer`
    方法应该看起来像这样：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What did we just do?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做了什么？
- en: We used the `CGRectIntersectsRect` method to see if the player and the tile
    rectangles collide. We then used our `tileIndex` to determine the exact position
    of that tile and checked to see if it's a vertical or a horizontal collision.
    We also created a variable to determine the distance required to move our player
    so he no longer collides with the tile. Then, we checked to see if our player
    needs to be moved up or down. When that is determined, we either add or subtract
    the collision height from our player.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `CGRectIntersectsRect` 方法来查看玩家和瓦片矩形是否碰撞。然后，我们使用我们的 `tileIndex` 确定那个瓦片的精确位置，并检查是否是垂直或水平碰撞。我们还创建了一个变量来确定移动玩家所需的距离，以便他不再与瓦片碰撞。然后，我们检查玩家是否需要向上或向下移动。当确定这一点后，我们要么从玩家中添加要么从玩家中减去碰撞高度。
- en: We also set up Booleans (true or false statements) that will detect whether
    the player is colliding with the ground; if he is, make him stop, and set the
    `onGround` Boolean to `true`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了布尔值（真或假陈述），用于检测玩家是否与地面碰撞；如果是，让他停止，并将 `onGround` 布尔值设置为 `true`。
- en: Lastly, we set the position of our player to finally resolve the collision.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将玩家的位置设置以最终解决碰撞。
- en: 'Now, in our `Player.h` file, we need to add the `onGround` Boolean property.
    With all our other properties, add in the following line of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `Player.h` 文件中，我们需要添加一个 `onGround` 布尔属性。在所有其他属性中，添加以下代码行：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have our little man working properly, we are going to get to programming
    his movement! Let's get him dancing! (I won't actually be programming him to dance;
    however, if that is something you want to do, absolutely be my guest. I won't
    judge.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的这个小人物已经正常工作，我们就将进入编程他的移动！让我们让他跳舞吧！（实际上我不会编程让他跳舞；然而，如果你想要这样做，绝对欢迎。我不会评判。）
- en: Making our player dance!
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们的玩家跳舞！
- en: For this game, we are going to make the controls super easy. Touch the right
    side of the screen, and the player will move forward; touch the left side, and
    he will jump. You can use the same methods to have him moving forwards and backwards,
    but this is how we will do it for this example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，我们将使控制非常简单。触摸屏幕的右侧，玩家将向前移动；触摸左侧，他将跳跃。你可以使用相同的方法让他前后移动，但这就是我们在这个例子中的做法。
- en: 'In our `Player.h` file, add the following properties:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Player.h`文件中，添加以下属性：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Popping over to our `GameLevelScene.m` file, we are going to add the following
    methods:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到我们的`GameLevelScene.m`文件，我们将添加以下方法：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a pretty simple set of methods. We set up the two touch areas on the
    device's screen, each half of the width of the screen. Once one is touched, it
    fires the respective Boolean for either walking or jumping, which we will then
    detect if the Booleans have been fired in our `Player` class. Easy? Yup!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组相当简单的方法。我们在设备的屏幕上设置了两个触摸区域，每个区域占屏幕宽度的一半。一旦触摸其中一个，就会触发相应的布尔值，无论是行走还是跳跃，然后我们将在`Player`类中检测这些布尔值是否被触发。简单？是的！
- en: 'We need to add a small line of code up in our `(id)initWithSize` block of code
    so that we can enable touch controls in our app. Add this line anywhere in that
    method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`(id)initWithSize`代码块中添加一小行代码，以便在我们的应用中启用触摸控制。将此行添加到该方法中的任何位置：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This line just gives us the ability to detect user interaction. If we were to
    run our app right now and touch the sides of the screen, our player would do absolutely
    nothing. Because he's a rebel? Not really. We have only set up the touches; we
    haven't told him what to do when he receives those touches.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行只是给了我们检测用户交互的能力。如果我们现在运行我们的应用并触摸屏幕的边缘，我们的玩家将绝对不做任何事情。因为他是个叛逆者？其实不是。我们只设置了触摸；我们还没有告诉他当收到这些触摸时该做什么。
- en: 'Let''s jump on over to our `Player.m` class and edit the `update` method so
    we can get him moving. The update method should look like this, with the highlighted
    code being the new lines we add:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到我们的`Player.m`类并编辑`update`方法，这样我们就可以让他移动了。`update`方法应该看起来像这样，其中高亮显示的代码是我们添加的新行：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Seem easy enough? No? Ok, let's explain things a little more. First we added
    a moving forward "force" that will be added when the user touches the screen,
    which is being added at 750 points per second in relation to the delta frame step
    for smooth motion. Mmmm, smoooooth!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单？不？好的，让我们更详细地解释一下。首先，我们添加了一个前进的“力”，当用户触摸屏幕时将添加，这个力以每秒750点的速度相对于帧步长添加，以实现平滑的运动。嗯，很平滑！
- en: Next we controlled the moving forward force to imitate the friction of the ground
    so that, when the player stops moving, he glides briefly instead of coming to
    an immediate halt.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们控制了前进的力，以模仿地面的摩擦力，这样当玩家停止移动时，他会短暂地滑行而不是立即停止。
- en: Next we checked if the screen is being touched, and if so we add velocity!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查屏幕是否被触摸，如果是，则添加速度！
- en: Then came the clamping. Clamping? Think of when you clamp a piece of wood to
    a work bench, that thing isn't moving. It's the same with the clamp methods; we
    are "clamping" or limiting the player's maximum and minimum horizontal and vertical
    speeds. The player will not move outside those limits.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是限制。限制？想想当你把一块木头夹在工作台上时，那东西是不会动的。限制方法也是一样；我们正在“限制”或限制玩家的最大和最小水平和垂直速度。玩家不会超出这些限制。
- en: 'We shall now add in the jumping method. Back in our `update` block of code,
    just above the `if (self.walking)` statement, we are going to add the following
    code to make our player jump:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加跳跃方法。回到我们的`update`代码块，就在`if (self.walking)`语句之上，我们将添加以下代码来让我们的玩家跳跃：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This jumping system is similar to that of *Super Mario* where, if you press
    and hold the jump button, he will accelerate to a certain point, at which juncture
    the `jumpTime` function then stops him from further accelerating. However, if
    the player stops pressing the jump button before the jump reaches the `jumpTime`
    function cut off, the jump will be reduced.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跳跃系统与 *超级马里奥* 的类似，如果你按住跳跃按钮，他会加速到某个点，然后 `jumpTime` 函数会阻止他进一步加速。然而，如果在跳跃达到
    `jumpTime` 函数截止之前玩家停止按跳跃按钮，跳跃将会减少。
- en: '![Making our player dance!](img/B03553_03_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![让我们玩家跳舞！](img/B03553_03_18.jpg)'
- en: 'See that? You''re on your way to creating the next *Super Mario*! If you run
    your project and click on the sides of the screen, he will move around and jump!
    But you know what, I don''t like the fact that our player can only move forward.
    What if he gets stuck? (Like in my level, he can get stuck almost immediately.
    Oops!) So let''s go back to our `Player.h` class and add another property:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？你正在朝着创建下一个 *超级马里奥* 的方向前进！如果你运行你的项目并点击屏幕的边缘，他会四处移动并跳跃！但你知道吗，我不喜欢我们的玩家只能向前移动。如果他卡住了怎么办？（就像在我的关卡中，他几乎可以立即卡住。哎呀！）所以让我们回到我们的
    `Player.h` 类，并添加另一个属性：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then on over to our `GameLevelScene.m` file, where we make a slight change
    to our `touchesBegan` function and the `TouchesMoved` block of code that we added
    earlier:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到我们的 `GameLevelScene.m` 文件，在那里我们对之前添加的 `touchesBegan` 函数和 `TouchesMoved`
    代码块进行轻微的修改：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So now, instead of having the screen halved with one walking button and one
    jumping button, we have the screen split into three, with the walking button as
    one half of the screen, and that half has been split height-wise, as shown in
    the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在，我们不再有一个屏幕被一个行走按钮和一个跳跃按钮平分，而是屏幕被分成三部分，行走按钮作为屏幕的一半，而这半部分在高度上被分割，如下面的截图所示：
- en: '![Making our player dance!](img/B03553_03_19.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![让我们玩家跳舞！](img/B03553_03_19.jpg)'
- en: 'Let''s pop over to our `Player.m` file and make some very small adjustments
    to our `update` method. We are going to add in the following lines:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们的 `Player.m` 文件，并对我们的 `update` 方法做一些非常小的调整。我们将添加以下行：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These lines are a reverse of the walking forward method we created, hence the
    -750 value. Now under our `if (self.walking)` method, we are going to add the
    following `if` statement:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行是我们在创建向前行走方法时的反转，因此有 -750 的值。现在在我们的 `if (self.walking)` 方法下，我们将添加以下 `if`
    语句：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This again is just a reverse of the walking forward movement. Test it out to
    see if it's working; if so, he should be backtracking on his steps like a scared
    cat!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样是对向前行走运动的反转。测试一下看看是否工作；如果工作，他应该会像受惊的猫一样后退。
- en: 'Now we are going to get the screen scrolling as our player moves towards the
    edge of the screen. On to our `GameLevelScene.m` class, to which we add the following
    code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使屏幕随着玩家向屏幕边缘移动而滚动。转到我们的 `GameLevelScene.m` 类，我们添加以下代码：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This block constrains the position of the screen to the player when he reaches
    the center of the view.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方块将屏幕的位置限制在玩家达到视图中心时。
- en: Test it to see if it works!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下看看是否工作！
- en: '![Making our player dance!](img/B03553_03_20.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![让我们玩家跳舞！](img/B03553_03_20.jpg)'
- en: This is starting to look so good! But if you've noticed, he can't die. Sadly,
    we do want him to die when he hits spikes or falls down those scary pits, don't
    we?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来越来越好了！但如果你注意到了，他不会死。遗憾的是，我们确实希望他在碰到尖刺或掉进那些可怕的山谷时死去，不是吗？
- en: 'Let''s integrate the hazards layer in our TMX map. To do this, we have to go
    to our `GameLevelScene.m` file and add in the following detection method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 TMX 地图中整合危险层。为此，我们必须转到我们的 `GameLevelScene.m` 文件，并添加以下检测方法：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is essentially the same code that we used for our `checkForAndResolveCollisionsForPlayer`
    function. We only added a `gameOver` method whereby, when it equals `0`, the player
    dies, and when it's `1`, the player beats the level.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们用于 `checkForAndResolveCollisionsForPlayer` 函数的相同代码。我们只添加了一个 `gameOver`
    方法，当它等于 `0` 时，玩家死亡，当它是 `1` 时，玩家通关关卡。
- en: 'You will have errors showing at the moment. We haven''t incorporated our game
    over feature yet, so let''s do that now. Again in our `GameLevelScene.m` file,
    let''s add the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你会看到错误提示。我们还没有整合我们的游戏结束功能，所以现在让我们来做这件事。再次在我们的 `GameLevelScene.m` 文件中，让我们添加以下代码：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's break it down as we usually do. Firstly, we set up the new game over the
    Boolean, which we use whenever the player collides with a hazard, or later an
    enemy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像往常一样分解它。首先，我们通过布尔值设置新游戏，我们每次玩家与危险碰撞，或者后来与敌人碰撞时都会使用这个布尔值。
- en: After that, we set a level win and a level failed string (or text) to pop up
    whenever the player either beats the level or loses. I used *Avenir Next Heavy*
    as a font. There are a ton of fonts that you can use for your game. For an awesome
    site showing all the fonts you can use, check out [iosfonts.com](http://iosfonts.com).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们设置了一个关卡胜利和关卡失败的字符串（或文本），以便在玩家要么通关要么失败时弹出。我使用了*Avenir Next Heavy*作为字体。你可以为你的游戏使用很多字体。如果你想查看所有可用的字体，请访问[iosfonts.com](http://iosfonts.com)。
- en: We then created a `UIButton` the user will be able to tap to restart the level.
    (Don't forget to add in the `replay.png` and `replay@2x.png` image files that
    I supplied in the resources section of this chapter.)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`UIButton`，用户可以点击来重新开始关卡。别忘了添加我在这章资源部分提供的`replay.png`和`replay@2x.png`图像文件。
- en: Finally we added in the method that checks the player's position; if he is below
    the map—in other words, if he's fallen down a hole or crack in the map—we call
    game over.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个检查玩家位置的方法；如果他在地图下方——换句话说，如果他掉进了地图上的一个洞或裂缝——我们就会调用游戏结束。
- en: But our poor little guy isn't going to experience just death! He needs to win
    every once and a while, right? Well we need to add those methods as well! Don't
    worry, it's super easy!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的这个小家伙不仅仅会经历死亡！他偶尔也需要赢一次，对吧？嗯，我们还需要添加这些方法！别担心，这很简单！
- en: 'In our `GameLevelScene.m` file, we need to add a new method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`GameLevelScene.m`文件中，我们需要添加一个新方法：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a positionally based win, so once our player reaches the `x` value
    of `3200` on the map we will call a win. We can have a win layer on the TMX map
    and incorporate that layer, but this just seems easier! Finally, in the `handleHazardCollisions`
    section, we need to check if our little guy has won:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于位置的胜利，所以一旦我们的玩家到达地图上的`x`值为`3200`，我们就会宣布胜利。我们可以在TMX地图上有一个胜利层并将其集成，但这似乎更容易！最后，在`handleHazardCollisions`部分，我们需要检查我们的这个小家伙是否已经赢了：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We now test this to see if it works and you will see the following screen:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在测试一下看看它是否工作，你将看到以下屏幕：
- en: '![Making our player dance!](img/B03553_03_21.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![让我们玩家跳舞！](img/B03553_03_21.jpg)'
- en: 'When we fail a level, we land on spikes, ouch! But we reach the end of the
    level, as shown in the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们失败一个关卡时，我们会落在尖刺上，哎呀！但正如以下截图所示，我们到达了关卡终点：
- en: '![Making our player dance!](img/B03553_03_22.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![让我们玩家跳舞！](img/B03553_03_22.jpg)'
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Oh my goodness! It's starting to look great, isn't it? We've done a lot of work
    in this chapter! What with our level design, figuring a way around implementing
    our maps into our project, creating our little player, and making him move, collide,
    and jump around, we certainly have done a lot.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！它开始看起来很棒了，不是吗？在这一章中我们做了很多工作！包括我们的关卡设计，想出一种方法将我们的地图集成到项目中，创建我们的小玩家，并让他移动、碰撞和跳跃，我们确实做了很多。
- en: For now, let's go take a break! In the next chapter, we are going to do some
    more creation, such as adding awesome music and sound effects, to polish the game
    up a bit, and maybe add some menus, particle effects, and even some enemies!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们休息一下！在下一章中，我们将进行更多的创作，比如添加令人惊叹的音乐和音效，稍微润色一下游戏，也许还会添加一些菜单、粒子效果，甚至一些敌人！
- en: Go get yourself a nice strong <insert beverage of choice here>, and I'll see
    you in the next chapter!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 去拿一杯你喜欢的美酒，下一章见！
