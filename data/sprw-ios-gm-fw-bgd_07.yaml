- en: Chapter 7. User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。用户界面
- en: '*In the previous chapter, we learned about adding the first gameplay elements
    into our game. Our pirate ship can now shoot cannonballs, and if the cannonballs
    hit the enemy enough number of times, the enemy ship will be destroyed.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了如何将第一个游戏元素添加到我们的游戏中。现在，我们的海盗船可以发射炮弹，如果炮弹击中敌人足够多次，敌人的船就会被摧毁。*'
- en: 'In this chapter, we are going to add user interface elements. Specifically,
    we will improve our game in the following aspects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加用户界面元素。具体来说，我们将从以下方面改进我们的游戏：
- en: Display and update the health of each ship
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和更新每艘船的生命值
- en: Add buttons on the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上添加按钮
- en: Display text on the screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示文本
- en: So, let's start by adding a visual representation for hit points on the screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先在屏幕上添加生命值的视觉表示。
- en: Displaying the hit points of each ship
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示每艘船的生命值
- en: By default, each ship has 100 hit points, and each cannonball does 25 points
    of damage to those hit points. We do have some visual feedback when a cannonball
    hits a ship, but we don't know how many hit points a ship has once hit a few times.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每艘船有100点生命值，每颗炮弹对生命值造成25点伤害。当炮弹击中船时，我们确实有一些视觉反馈，但一旦被击中几次，我们就不知道船有多少生命值了。
- en: Time for action – placing a health bar on top of each ship
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在每艘船顶部放置生命值条
- en: 'To display the hit points for each ship, we just need to follow these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示每艘船的生命值，我们只需遵循以下步骤：
- en: Open our game's project file if it's not already open.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏项目文件尚未打开，请打开我们的游戏项目文件。
- en: Switch to the `Ship.h` file.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Ship.h`文件。
- en: 'Add an instance variable called `_quadHitpoints`, which is a pointer to `SPQuad`,
    as shown in the following line of code:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`_quadHitpoints`的实例变量，它是指向`SPQuad`的指针，如下面的代码行所示：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Switch to the `Ship.m` file. Just after where we create the cannonball images
    in the initializer, we add a quad which should be the border for our hit point
    representation, as shown in the following code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Ship.m`文件。在初始化器中创建炮弹图像之后，我们添加一个四边形，它应该是我们的生命值表示的边界，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We add the background for the hit points box, as shown in the following code:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了生命值框的背景，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We set the background for the hit points box to have a one point margin, which
    means its position needs to be one point to the left and one point up from the
    local coordinate system:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将生命值框的背景设置为一点边距，这意味着其位置需要相对于本地坐标系向左和向上各一点：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then create `SPQuad` from the `_quadHitpoints` instance variable, as shown
    in the following code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从`_quadHitpoints`实例变量创建`SPQuad`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As shown in the following code, we set the hit points to the same coordinates
    as the background:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码所示，我们将生命值设置为与背景相同的坐标：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then add all of the hit point quads to the display tree, as shown in the
    following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将所有的生命值四边形添加到显示树中，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the `setHitpoints` method, add the following line of code just after
    the statement where we set the instance variable to the value of the parameter:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setHitpoints`方法内部，在将实例变量设置为参数值的语句之后添加以下代码行：
- en: '[PRE7]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the example.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'As seen in the following screenshot, both ships now have the amount of their
    hit points represented as red and green bars:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，两艘船现在都以其红色和绿色条表示其生命值数量：
- en: '![Time for action – placing a health bar on top of each ship](img/1509OS_07_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 在每艘船顶部放置生命值条](img/1509OS_07_01.jpg)'
- en: '*What just happened?*'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our Xcode template from where we had left off in the previous
    chapter. First of all, we need an instance variable that should represent our
    hit points. If we think about how other games display the current hit points,
    in strategy games mostly, the hit points are represented as little green and red
    bars above each unit. In fighting games, the hit points are displayed at the top
    left- and right-hand sides for each player. As we might have more than one enemy
    on the screen, the best representation will be to have red and green bars above
    each of the ship. The green portion of the bar would be the amount of hit points
    the ship currently has and the red portion is the amount that is currently missing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们打开了我们在上一章中停止的 Xcode 模板。首先，我们需要一个实例变量来表示我们的生命值。如果我们考虑其他游戏如何显示当前的生命值，在策略游戏中通常，生命值以每个单位上方的绿色和红色条表示。在格斗游戏中，每个玩家的生命值显示在顶部左和右两侧。由于我们可能在屏幕上有多个敌人，最好的表示方法是在每个飞船上方都有红色和绿色的条。条上的绿色部分将是飞船当前拥有的生命值数量，而红色部分是当前缺失的数量。
- en: 'In step 2, we switched to the `Ship.h` file as we wanted to define an instance
    variable. To represent the hit points, we chose `SPQuad` and called our variable
    `_quadHitpoints`. To actually implement the hit point mechanics, we switched to
    the `Ship.m` file. Our hit points bar actually consists of three different boxes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们切换到 `Ship.h` 文件，因为我们想要定义一个实例变量。为了表示生命值，我们选择了 `SPQuad` 并将我们的变量命名为 `_quadHitpoints`。为了实际实现生命值机制，我们切换到
    `Ship.m` 文件。我们的生命值条实际上由三个不同的框组成：
- en: A border around the hit points
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕生命值的边界
- en: The background for the hit points (a red bar)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值的背景（一个红色条）
- en: The actual hit point bar (a green bar which is represented by our `_quadHitpoints`
    instance variable)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的击中点生命值条（一个表示为我们的 `_quadHitpoints` 实例变量的绿色条）
- en: In step 5, we defined a black rectangle that will act as the border for our
    hit point bar. The width of the rectangle should be the width of the ship. We
    got the width from the `clipNorth` movie clip. Actually, we can also get the ship's
    width from any other movie clips. We set the height of the black rectangle to
    five points. We don't want the hit points bar to be too thick, but it has to be
    easily visible and recognizable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们定义了一个黑色矩形，它将作为我们的生命值条的边界。矩形的宽度应该是飞船的宽度。我们从 `clipNorth` 动画剪辑中获取了宽度。实际上，我们也可以从任何其他动画剪辑中获取飞船的宽度。我们将黑色矩形的长度设置为五点。我们不希望生命值条太粗，但它必须易于可见和识别。
- en: In the next step, we set the background of the hit points. We defined a `SPQuad`
    instance, which we call `quadMaxHitpoints`. It should be one point smaller than
    the black rectangle on each side. We used the width from the `hitpointsBorder`
    instance and had set the height to three points.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们设置了生命值的背景。我们定义了一个 `SPQuad` 实例，我们称之为 `quadMaxHitpoints`。它应该在每一边比黑色矩形小一个点。我们使用了
    `hitpointsBorder` 实例的宽度，并将高度设置为三点。
- en: We set the left and the top of the `quadMaxHitpoints` instance to one point
    each so that it will actually look as if the hit point bar has a border.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `quadMaxHitpoints` 实例的左和上边距各设置为一点，这样它实际上看起来就像生命值条有一个边界。
- en: We then initialized the `quadHitpoints` instance variable in step 8\. It's a
    `SPQuad` class as well and has the same dimensions as our background hit point
    bar.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在第八步初始化了 `quadHitpoints` 实例变量。它也是一个 `SPQuad` 类，并且与我们的背景生命值条具有相同的尺寸。
- en: With the `quadMaxHitpoints` instance, we want `_quadHitpoints` to be displayed
    inside the border. So, we set the position of`_quadHitpoints` one point to the
    left and top relative to the ship itself. In this case, we can adjust the position
    from the `quadMaxHitpoints` quad.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `quadMaxHitpoints` 实例，我们希望 `_quadHitpoints` 在边界内显示。因此，我们将 `_quadHitpoints`
    的位置相对于飞船本身向左和向上调整一个点。在这种情况下，我们可以从 `quadMaxHitpoints` 四边形调整位置。
- en: For the red and green rectangles, we refrained from using bright colors, as
    this might strain the eyes and distract us from the action. Also, as we are going
    for a darker tone in general, having bright colors would not fit in this context.
    Keep in mind when coloring and designing the user interface that the elements
    should be tested on the actual device. The brightness is usually not at its maximum,
    especially if the device is running on battery. In some cases, graphics are even
    given additional contrast or are brightened so that they don't look too dark on
    mobile devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于红色和绿色的矩形，我们避免使用鲜艳的颜色，因为这可能会使眼睛疲劳，并分散我们对动作的注意力。此外，由于我们总体上追求较暗的色调，鲜艳的颜色并不适合这个环境。在着色和设计用户界面时，请记住，元素应该在实际设备上进行测试。亮度通常不会达到最大值，尤其是如果设备正在使用电池。在某些情况下，图形甚至会被赋予额外的对比度或被调亮，这样在移动设备上看起来就不会太暗。
- en: In step 10, we added all of the quads to the display tree; all of the quads
    are children of the `Ship` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 步中，我们将所有四边形添加到显示树中；所有四边形都是 `Ship` 类的子类。
- en: 'After this point, our code snippet will look like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，我们的代码片段将看起来像以下这样：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we were to use the hit points' creation code more than once, it is considered
    a best practice to put this piece of code into a separate method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要多次使用生命值创建代码，将这部分代码放入一个单独的方法中是一种最佳实践。
- en: In the next step, we updated the hit points setter. The `_quadHitpoints` instance
    will be scaled horizontally. As both `_hitpoints` and `self.maxHitpoints` are
    integer values, we needed to cast it to a float value. If we don't do this, the
    hit points bar would either be red or green with nothing in between.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们更新了生命值设置器。`_quadHitpoints` 实例将在水平方向上缩放。由于 `_hitpoints` 和 `self.maxHitpoints`
    都是整数值，我们需要将其转换为浮点值。如果我们不这样做，生命值条要么是红色，要么是绿色，中间没有其他颜色。
- en: 'The `setHitpoints` method will look like the following piece of code after
    step 10:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 步之后，`setHitpoints` 方法将看起来像以下代码片段：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We ran the example in the last step and saw that the enemy ship as well as our
    ship have hit point bars on top of them. When the ships moved, the hit point bars
    also moved with them, and when we hit the enemy ship, the hit points bar updated
    itself accordingly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后一步运行了示例，并看到敌方飞船以及我们的飞船上方都有生命值条。当飞船移动时，生命值条也会随之移动，当我们击中敌方飞船时，生命值条会相应更新。
- en: Adding buttons to the screen
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上添加按钮
- en: Now that we have hit point bars on the screen, let's add some things that the
    user can actually interact with.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上有了生命值条，让我们添加一些用户可以与之交互的东西。
- en: Pausing and resuming the game
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停和继续游戏
- en: The first thing we are going to add is the ability to pause and resume the game
    at will. This is actually quite important, especially for mobile action games.
    If a call comes on the mobile device (iPhone) and we don't have a pause functionality,
    the player might get frustrated by not being able to pause the game and lose their
    progress or winning streak.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的第一件事是能够随意暂停和继续游戏。这实际上非常重要，尤其是对于移动动作游戏。如果移动设备（iPhone）上有电话进来，而我们没有暂停功能，玩家可能会因为无法暂停游戏而感到沮丧，从而丢失进度或连胜。
- en: Before we get into implementing these buttons, let's download the necessary
    graphics for this chapter which are available at [https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip).
    Copy the contents of the extracted file into the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现这些按钮之前，让我们下载本章所需的图形资源，这些资源可在[https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip)找到。将提取文件的
    contents 复制到项目中。
- en: 'Let''s think of what we need to do when pausing the game:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下在暂停游戏时需要做什么：
- en: Display a button to pause the game
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示暂停游戏的按钮
- en: Display a button to resume the game
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示继续游戏的按钮
- en: Stop all current tweens when the player clicks on the pause button
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家点击暂停按钮时，停止所有当前缓动
- en: Resume all current tweens when the player clicks on the resume button
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家点击继续按钮时，恢复所有当前缓动
- en: As this is a bigger task, we are splitting it into two parts; first, we are
    going to display the buttons, and then we will implement the functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个更大的任务，我们将它分为两部分；首先，我们将显示按钮，然后我们将实现功能。
- en: Displaying the pause and resume buttons on the screen
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕上显示暂停和继续按钮
- en: In this example, we are going to add all of the buttons we need and will display
    them at the correct position on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将添加所有需要的按钮，并将它们显示在屏幕的正确位置。
- en: Time for action – putting buttons on the screen
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动——将按钮放置在屏幕上
- en: 'To add our first buttons, follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的第一个按钮，请按照以下步骤操作：
- en: Open the `Battlefield.h` file.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Battlefield.h`文件。
- en: 'Add one instance variable for each button. We will use the `SPButton` type,
    as shown in the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个按钮添加一个实例变量。我们将使用`SPButton`类型，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Switch to the `Battlefield.m` file.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.m`文件。
- en: 'Construct the instances for our two instance variables, as shown in the following
    code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的两个实例变量，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the position of both the pause and resume buttons to the top-right corner
    of the screen using the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将暂停和恢复按钮的位置设置为屏幕的右上角：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Hide the resume button using the following line of code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码隐藏恢复按钮：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For later usage, create methods to tap the pause and resume buttons, as shown
    in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了后续使用，创建点击暂停和恢复按钮的方法，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Bind the newly created methods to the pause and resume buttons, as shown in
    the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的方法绑定到暂停和恢复按钮上，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add both buttons to the display tree as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将两个按钮添加到显示树中：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the example to see the result. We now have a pause button on the screen,
    as shown in the following screenshot:![Time for action – putting buttons on the
    screen](img/1509OS_07_02.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。我们现在在屏幕上有一个暂停按钮，如下面的截图所示：![是时候采取行动——将按钮放置在屏幕上](img/1509OS_07_02.jpg)
- en: '*What just happened?*'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened the `Battlefield.h` file. We added two instance variables
    to this class, one for the pause button and one for the resume button. We used
    the `SPButton` class, which is pretty much an image, and optionally displayed
    some text on top of it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们打开了`Battlefield.h`文件。我们向这个类添加了两个实例变量，一个用于暂停按钮，一个用于恢复按钮。我们使用了`SPButton`类，它基本上是一个图像，并且可以选择在上面显示一些文本。
- en: 'Next, we switched to the `Battlefield.m` file. In step 4, we initialized both
    buttons. We need to take a closer look at the following two points:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们切换到`Battlefield.m`文件。在第4步中，我们初始化了两个按钮。我们需要更仔细地查看以下两个点：
- en: We already know that we can get an array of textures if we use the `texturesStartingWith`
    method. If we want only a single texture, we need to use `textureByName`, and
    we also have to specify the correct name.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经知道，如果我们使用`texturesStartingWith`方法，我们可以得到一个纹理数组。如果我们只想使用单个纹理，我们需要使用`textureByName`，并且我们还需要指定正确的名称。
- en: '`SPButton` provides several factory methods. The one we are using is the `buttonWithUpState`
    method in which we have to pass an `SPTexture` instance. The up state is the texture
    that is visible all the time. If we were to specify a down state, the down state
    would be visible once the button is tapped. Another factory method lets us specify
    either the down state or even some text.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPButton`提供了几个工厂方法。我们正在使用的是`buttonWithUpState`方法，我们必须传递一个`SPTexture`实例。正常状态是始终可见的纹理。如果我们指定了按下状态，按下状态将在按钮被点击时可见。另一个工厂方法允许我们指定按下状态，甚至是一些文本。'
- en: In the next step, we positioned the buttons at the top-right of the screen.
    We left a bit of space (four points) so that the button is not too close to the
    edge of the screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将按钮定位在屏幕的右上角。我们留出了一些空间（四个点），这样按钮就不会离屏幕边缘太近。
- en: In step 6, we hid the resume button so that we only see the pause button the
    first time the scene is being shown.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们隐藏了简历按钮，这样在第一次显示场景时，我们只能看到暂停按钮。
- en: In the next step, we added some dummy methods to pause and resume the game.
    We left these empty for now, but we'll fill them in a little bit.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们添加了一些暂停和恢复游戏的方法。我们目前将这些方法留空，但稍后我们会填充它们。
- en: Next, we linked these methods to the buttons so that they will be called when
    we touch these buttons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这些方法链接到按钮上，以便在触摸这些按钮时调用它们。
- en: To actually show the buttons on the screen, we need to add them to the display
    tree, which we did in step 9.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上实际显示按钮，我们需要将它们添加到显示树中，我们在第9步中已经做到了这一点。
- en: 'Let''s take a look at what exactly changed in the initializer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看初始化器中具体发生了什么变化：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when we ran the example, we saw the pause button in the top-right corner
    of the screen. When we tap the button, nothing happens except for the button scaling
    down a bit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行示例时，我们在屏幕右上角看到了暂停按钮。当我们点击按钮时，除了按钮稍微缩小一点外，没有任何反应。
- en: Implementing the logic to pause and resume the game
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现暂停和恢复游戏的逻辑
- en: Now that we have displayed the buttons on the screen, let's allow the player
    to pause and resume the game. We are going to utilize our own juggler and, save
    if the game is paused into a variable and if the game is not paused, we advance
    our juggler as well as the child elements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上显示了按钮，让我们允许玩家暂停和恢复游戏。我们将利用自己的`juggler`，如果游戏被暂停，则将其保存到一个变量中，如果没有暂停，我们也前进我们的`juggler`以及子元素。
- en: Time for action – allowing the player to pause and resume
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 – 允许玩家暂停和恢复
- en: 'To allow the player to pause and resume the game, we need to follow these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许玩家暂停和恢复游戏，我们需要遵循以下步骤：
- en: Open the `Ship.h` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Ship.h`文件。
- en: 'Add an instance variable called `_juggler` that is a pointer to `SPJuggler`,
    as shown in the following line of code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`_juggler`的实例变量，它是一个指向`SPJuggler`的指针，如下面的代码行所示：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare a property called `paused`, which is of the type `BOOL`, as shown in
    the following line of code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`paused`的属性，其类型为`BOOL`，如下面的代码行所示：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare a method called `advanceTime`, as shown in the following line of code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`advanceTime`的方法，如下面的代码行所示：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Switch to the `Ship.m` file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Ship.m`文件。
- en: 'Inside the initializer, set the `paused` property to `NO` using its instance
    variable, as shown in the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，使用其实例变量将`paused`属性设置为`NO`，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initialize the `_juggler` instance variable inside the initializer with the
    following line of code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中使用以下代码行初始化`_juggler`实例变量：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Update all references from `Sparrow.juggler` to `_juggler`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有从`Sparrow.juggler`到`_juggler`的引用更新。
- en: 'Implement the `advanceTime` method with the following lines of code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行实现`advanceTime`方法：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Switch to the `Battlefield.h` file.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.h`文件。
- en: 'Add an instance variable for `juggler` here as well:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里也为`juggler`添加一个实例变量：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add an instance variable for the background using the following line of code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行添加一个背景的实例变量：
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a property called `paused` which is a `BOOL` type. As we are going to add
    custom getters and setters for this property, we also need an instance variable
    called `_paused` as shown in the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`paused`的属性，其类型为`BOOL`。由于我们将为这个属性添加自定义的获取器和设置器，我们还需要一个名为`_paused`的实例变量，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Switch to the `Battlefield.m` file.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.m`文件。
- en: Inside the initializer, update the reference from the local background variable
    to the `_background` instance variable.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，将本地背景变量更新为`_background`实例变量。
- en: 'Inside the `Battlefield` initializer, initialize the `_juggler` instance. This
    has to be done before we add `shipTween` to `juggler`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Battlefield`初始化器中，初始化`_juggler`实例。这必须在将`shipTween`添加到`juggler`之前完成：
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Update all references from `Sparrow.juggler` to `_juggler`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有从`Sparrow.juggler`到`_juggler`的引用更新。
- en: 'Add a custom setter for the `paused` property with the following content:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`paused`属性添加一个自定义setter，内容如下：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a custom getter for the `paused` property that returns the `_paused` instance
    variable:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`paused`属性添加一个自定义获取器，它返回`_paused`实例变量：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implement the `onButtonPause` and `onButtonResume` methods by setting the `paused`
    property to its correct values (`YES` in the `onButtonPause` method, `NO` in the
    `onButtonResume` method).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`paused`属性的正确值（在`onButtonPause`方法中为`YES`，在`onButtonResume`方法中为`NO`）来实现`onButtonPause`和`onButtonResume`方法。
- en: Update the parameter type in `onEnterFrame` from being a pointer to `SPEvent`
    to being a pointer to `SPEnterFrameEvent`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`onEnterFrame`中的参数类型从指向`SPEvent`更改为指向`SPEnterFrameEvent`。
- en: 'Add the following lines of code to the `onEnterFrame` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onEnterFrame`方法中添加以下代码行：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the example.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'We can now tap the pause and resume buttons. In the following screenshot, you
    can see that when the game is paused, all animations stop until we press the resume
    button:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以点击暂停和恢复按钮。在下面的屏幕截图中，你可以看到当游戏被暂停时，所有动画都会停止，直到我们按下恢复按钮：
- en: '![Time for action – allowing the player to pause and resume](img/1509OS_07_03.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间 – 允许玩家暂停和恢复](img/1509OS_07_03.jpg)'
- en: '*What just happened?*'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In the `Ship.h` file, we updated the interface by performing the following
    tasks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ship.h`文件中，我们通过执行以下任务更新了接口：
- en: Added a new `juggler` instance variable, which is a pointer to `SPJuggler` (step
    2)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的`juggler`实例变量，它是一个指向`SPJuggler`的指针（步骤2）。
- en: Added a `paused` property with the type `BOOL` (step 3)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个类型为`BOOL`的`paused`属性（步骤3）。
- en: Declared a method called `advanceTime` (step 4)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为`advanceTime`的方法（步骤4）。
- en: Sparrow does not provide the pause and resume methods for its jugglers. We dealt
    with this by introducing our own jugglers and setting a flag if the game is paused,
    and we advanced all of our jugglers only if the game was not paused.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow没有为它的juggler提供暂停和恢复方法。我们通过引入我们自己的juggler并设置一个标志来处理这个问题，如果游戏被暂停，我们只前进所有的juggler。
- en: In step 5, we switched to the `Ship.m` file and we defined the `paused` property
    inside the initializer to `NO`, because by default, the ships should not be paused.
    This step is not necessary as Objective-C initializes this instance as `NO`; it's
    just a reminder to see which instance variables we have if we were to decide to
    change a value later on, and we know where to look.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们切换到`Ship.m`文件，并在初始化器中将`paused`属性定义为`NO`，因为默认情况下，船只不应该被暂停。这一步不是必需的，因为Objective-C默认将这个实例初始化为`NO`；这只是作为一个提醒，以便我们在稍后决定更改值时知道查看哪个实例变量，并且我们知道在哪里查找。
- en: In the next step, we initialized the `_juggler` instance variable. It does not
    matter where exactly we defined the juggler instance variable inside the initializer
    as we don't add any tweens to jugglers in the initializer method. Next, we searched
    and replaced all references from `Sparrow.juggler` to `_juggler`. The easiest
    way is to use *command* + *F*, select **Replace** from the drop-down list, put
    `Sparrow.juggler` in the first input box, `_juggler` in the second input, and
    select **All** to replace all the references.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们初始化了`_juggler`实例变量。在初始化器中，我们确切地在哪里定义juggler实例变量并不重要，因为我们不会在初始化方法中向juggler添加任何tween。接下来，我们搜索并替换了所有从`Sparrow.juggler`到`_juggler`的引用。最简单的方法是使用*command*
    + *F*，从下拉列表中选择**Replace**，在第一个输入框中输入`Sparrow.juggler`，在第二个输入框中输入`_juggler`，并选择**All**以替换所有引用。
- en: In step 9, we implemented the `advanceTime` method, where we call the `advanceTime`
    method from `_juggler` and pass in `double` as the `seconds` parameter. This is
    only called if the `paused` property is set to `NO`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们实现了`advanceTime`方法，其中我们调用`_juggler`的`advanceTime`方法，并将`double`作为`seconds`参数传递。这只有在`paused`属性设置为`NO`时才会调用。
- en: 'Next, we switched to the `Battlefield.h` file. Here, we needed to perform the
    following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们切换到`Battlefield.h`文件。在这里，我们需要执行以下步骤：
- en: Add an instance variable for a juggler, similar to how we did for the `Ship`
    class (step 11).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个与`Juggler`类类似的实例变量，就像我们在`Ship`类中做的那样（第11步）。
- en: We now need an instance variable that references the background image instance
    (step 12).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个引用背景图像实例的实例变量（第12步）。
- en: We need a `paused` property. As we are going to implement custom getters and
    setters, we also need an instance variable corresponding to that property (step
    13).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个`paused`属性。由于我们将要实现自定义的getter和setter，我们还需要一个与该属性对应的实例变量（第13步）。
- en: Then, we switched to the `Battlefield.m` file. In the next step, we updated
    all references from the local background variable to the instance variable `_background`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们切换到`Battlefield.m`文件。在下一步中，我们将所有从局部背景变量到实例变量`_background`的引用进行了更新。
- en: In step 16, we initialized our `_juggler` instance variable. Here, it does matter
    where we initialize this instance; it should be right before the line `[Sparrow.juggler
    addObject:shipTween];`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16步中，我们初始化了我们的`_juggler`实例变量。在这里，初始化这个实例的位置很重要；它应该在`[Sparrow.juggler addObject:shipTween];`这一行之前。
- en: Next, we updated the references to use `_juggler` instead of `Sparrow.juggler`
    inside the battlefield scene.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新了引用，在战场场景中使用`_juggler`而不是`Sparrow.juggler`。
- en: 'Then, we defined the setter for the `paused` property. Let''s take a closer
    look at what exactly happened:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了`paused`属性的setter。让我们更仔细地看看到底发生了什么：
- en: We set the `_paused` instance variable to the value of the parameter.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`_paused`实例变量设置为参数的值。
- en: If `_paused` is set to `YES`, `_buttonPause` is not visible and `_buttonResume`
    is visible. If `_paused` is set to `NO`, it's the other way round.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`_paused`设置为`YES`，则`_buttonPause`不可见，而`_buttonResume`可见。如果`_paused`设置为`NO`，则情况相反。
- en: Each sprite has a `touchable` property. If this is set to `NO`, touch handlers
    won't fire. We set this to `NO` so the game can be paused.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个精灵都有一个`touchable`属性。如果这个设置为`NO`，则触摸处理程序不会触发。我们将这个设置为`NO`，以便游戏可以被暂停。
- en: We paused all ships on the screen.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们暂停了屏幕上的所有船只。
- en: In step 19, we defined the getter for the `paused` property. It just returned
    the `_paused` instance variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第19步中，我们定义了`paused`属性的getter。它只是返回了`_paused`实例变量。
- en: We then implemented the `onButtonPause` and `onButtonResume` methods, where
    we set the `paused` property to `YES` and `NO`, respectively.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了`onButtonPause`和`onButtonResume`方法，我们将`paused`属性分别设置为`YES`和`NO`。
- en: In step 21, we needed to update the parameter type in our `onEnterFrame` method.
    It needs to be a pointer to `SPEnterFrame`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21步，我们需要更新`onEnterFrame`方法中的参数类型。它需要是一个指向`SPEnterFrame`的指针。
- en: Then, we added some lines of code to the `onEnterFrame` method. Now that the
    event is a pointer to `SPEnterFrame`, we can actually get the time that has been
    passed by getting the `passedTime` property from the event parameter. We then
    called the `advanceTime` method from all the ships on the screen, and if the scene
    is paused, we call the `advanceTime` method from `_juggler`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`onEnterFrame`方法中添加了一些代码。现在，事件是一个指向`SPEnterFrame`的指针，我们可以通过从事件参数中获取`passedTime`属性来获取已经过去的时间。然后，我们调用屏幕上所有船只的`advanceTime`方法，如果场景被暂停，我们调用`_juggler`的`advanceTime`方法。
- en: When we ran the example, we can now pause and resume the game at will.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们现在可以随意暂停和恢复游戏。
- en: Have a go hero
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试吧，英雄
- en: 'Here are some suggestions of what we could improve:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们可以改进的建议：
- en: As there isn't much happening in the `onButtonPause` and `onButtonResume` methods,
    we could either try to use blocks or merge both methods into one.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`onButtonPause`和`onButtonResume`方法中并没有发生太多事情，我们可以尝试使用代码块或将两个方法合并为一个。
- en: We could extend the `Scene` class to use a `juggler` instance variable, so we
    don't need to redefine a custom juggler wherever we need it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将`Scene`类扩展以使用`juggler`实例变量，这样我们就不需要在需要它的任何地方重新定义一个自定义的juggler。
- en: Right now, we have custom user interface elements for each scene. However, if
    this were to change, we should think about abstracting the user interface logic
    into a separate class and maybe bind it to the `Scene` class.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们为每个场景都有自定义的用户界面元素。然而，如果这要改变，我们应该考虑将用户界面逻辑抽象成一个单独的类，并可能将其绑定到`Scene`类。
- en: Aborting the current game
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放弃当前游戏
- en: So far, we don't have the ability to switch to the pirate cove scene. However,
    we should introduce the option to abort the current fight.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有切换到海盗湾场景的能力。然而，我们应该引入放弃当前战斗的选项。
- en: Time for action – conceding the game
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 放弃游戏
- en: 'To abort the current game, we need to follow these steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要放弃当前游戏，我们需要遵循以下步骤：
- en: Open the `Battlefield.m` file.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Battlefield.m`文件。
- en: 'Inside the initializer, we should add the abort button right after the resume
    button:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，我们应该在恢复按钮之后立即添加放弃按钮：
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Position the abort button in the bottom-right corner:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将放弃按钮定位在右下角：
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Import the `SceneDirector` class, as shown in the following line of code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`SceneDirector`类，如下面的代码行所示：
- en: '[PRE33]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add a listener to the abort button using a block, as shown in the following
    code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码块为放弃按钮添加一个监听器，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the button to the display tree, as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码将按钮添加到显示树中：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the example to see the result.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。
- en: 'We now see the abort button as shown in the following screenshot:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以看到如下截图所示的放弃按钮：
- en: '![Time for action – conceding the game](img/1509OS_07_04.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 放弃游戏](img/1509OS_07_04.jpg)'
- en: '*What just happened?*'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In step 1, we opened the `Battlefield.m` file. For this example, we only need
    to take a look at the initializer method. We initialized the abort button similar
    to how we did for the pause and resume buttons before, the only difference is
    that we are using a different texture.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们打开了`Battlefield.m`文件。对于这个示例，我们只需要查看初始化方法。我们初始化放弃按钮的方式与之前初始化暂停和恢复按钮的方式相似，唯一的区别是我们使用了不同的纹理。
- en: In the next step, we positioned the abort button at the bottom-right corner.
    Just like how we left a bit of space with the pause and resume buttons, we did
    the same here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将放弃按钮定位在右下角。就像我们在暂停和恢复按钮中留出一些空间一样，这里我们也做了同样的事情。
- en: We then imported the `SceneDirector.h` file in the next step.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在下一步中导入了`SceneDirector.h`文件。
- en: In step 5, we added an event listener to the abort button. Inside the event
    listener, we switched to the pirate cove scene. Although we do have a reference
    to the scene director using the `director` property, it is of the type `id`. So,
    we needed to recast it to a pointer to the `SceneDirector` class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步，我们为放弃按钮添加了一个事件监听器。在事件监听器内部，我们切换到了海盗湾场景。尽管我们确实通过`director`属性有一个场景导演的引用，但它是一个`id`类型。因此，我们需要将其重新转换为指向`SceneDirector`类的指针。
- en: Then, we added the abort button to the display tree.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将放弃按钮添加到显示树中。
- en: When we ran the example, we saw the abort button, and when we tapped it, we
    jumped to the pirate cove scene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们看到了中止按钮，当我们点击它时，我们跳转到了海盗湾场景。
- en: Adding dialogs to the screen
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向屏幕添加对话框
- en: 'Now that we have added the abort button on the screen, we might run into a
    few problems, which are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上添加了中止按钮，我们可能会遇到一些问题，如下所述：
- en: We might tap on the abort button by accident
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会不小心点击中止按钮
- en: We don't have any way to get from the pirate cove scene back to the battlefield
    scene
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有从海盗湾场景返回到战场场景的方法
- en: So, to counteract this, at least on the surface, let's add a dialog which should
    be shown when we tap the abort button.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了应对这种情况，至少表面上，让我们添加一个对话框，当我们在中止按钮上点击时应该显示。
- en: Time for action – creating a dialog class
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 创建对话框类
- en: 'To add dialogs, we need to follow these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加对话框，我们需要遵循以下步骤：
- en: Add a new group inside the **Classes** folder called **UI**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**文件夹内添加一个新的组，命名为**UI**。
- en: Inside the **UI** group, add a new Objective-C class called `Dialog`, which
    derives from `SPSprite`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UI**组内，添加一个新的Objective-C类，命名为`Dialog`，它继承自`SPSprite`。
- en: 'Implement the dialog initializer with the following lines of code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现对话框初始化器：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Switch to the `Battlefield.m` file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.m`文件。
- en: Import the `Dialog.h` file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Dialog.h`文件。
- en: 'Right before the abort button event, initialize the dialog, as shown in the
    following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中止按钮事件之前，初始化对话框，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The dialog should be hidden by default, as shown in the following line of code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框默认应该是隐藏的，如下面的代码行所示：
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update the abort button event to show the dialog:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新中止按钮事件以显示对话框：
- en: '[PRE39]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the example to see the result.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。
- en: 'When we tap the abort button, we now see a dialog popping up:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们点击中止按钮时，我们现在看到对话框弹出：
- en: '![Time for action – creating a dialog class](img/1509OS_07_05.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手实践 – 创建对话框类](img/1509OS_07_05.jpg)'
- en: '*What just happened?*'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: First, we structured the `Dialog` class. To keep it separate from the game logic
    code, we created it within a new group. The `Dialog` class itself should inherit
    from `SPSprite`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们结构化了`Dialog`类。为了将其与游戏逻辑代码分开，我们在一个新的组中创建了它。`Dialog`类本身应该继承自`SPSprite`。
- en: 'In step 3, we defined the initializer for the `Dialog` class, where we performed
    the following actions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们为`Dialog`类定义了初始化器，在那里我们执行了以下操作：
- en: We added a background image for the dialog.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为对话框添加了背景图片。
- en: We added the **Yes** and **No** buttons. We called the factory methods for `SPButton`,
    where we put some text on the buttons, which in our case is **Yes** and **No**,
    respectively.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了**是**和**否**按钮。我们调用了`SPButton`的工厂方法，我们在按钮上放置了一些文本，在我们的例子中是**是**和**否**。
- en: We positioned these elements at the bottom of the dialog.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这些元素放置在对话框的底部。
- en: Inside the `Battlefield.m` file, we imported the `Dialog.h` file to be able
    to use the `Dialog` class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Battlefield.m`文件中，我们导入了`Dialog.h`文件以便使用`Dialog`类。
- en: Inside the initializer of the battlefield scene, we needed to initialize the
    dialog, which we did right before the abort button event.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在战场场景的初始化器中，我们需要初始化对话框，我们就在中止按钮事件之前做了这件事。
- en: We set the dialog to be invisible by default and updated the abort button event
    to show the dialog.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认将对话框设置为不可见，并更新了中止按钮的事件以显示对话框。
- en: When we ran the example, we saw the dialog when we tapped the abort button.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们在点击中止按钮时看到了对话框。
- en: Have a go hero
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'Having the abort button on the bottom-right of the screen is not ideal from
    a usability point of view. If we accidently tapped the button, a dialog is now
    being shown instead of just aborting the current battle. Still, it doesn''t seem
    to be ideal. The following are some suggestions on how to improve the situation:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用性的角度来看，将中止按钮放置在屏幕的右下角并不理想。如果我们不小心点击了按钮，现在会显示一个对话框而不是仅仅中止当前战斗。尽管如此，这似乎也不太理想。以下是一些改进这种情况的建议：
- en: Placing the abort button (`buttonAbort`) next to the pause button. All user
    interface elements would be in the same area.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将中止按钮（`buttonAbort`）放置在暂停按钮旁边。所有用户界面元素都会在同一区域。
- en: Combine the pause button and the abort button into a game menu button. Clicking
    on the button will pause the game and will open a menu. An abort button can be
    found there.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将暂停按钮和中止按钮组合成一个游戏菜单按钮。点击该按钮将暂停游戏并打开菜单。可以在那里找到中止按钮。
- en: Adding custom events to the dialogs
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向对话框添加自定义事件
- en: Now that a dialog is on the screen, we would like to attach listeners to the
    dialog buttons themselves. While we can go for simply attaching touch events,
    Sparrow provides a way to define custom events.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对话框已经在屏幕上，我们希望将监听器附加到对话框按钮本身。虽然我们可以简单地附加触摸事件，但Sparrow提供了一种定义自定义事件的方法。
- en: Time for action – adding our own buttons to our dialog
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们自己的按钮到对话框的行动时间
- en: 'To add custom events for our dialogs, we just need to follow these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的对话框添加自定义事件，我们只需遵循以下步骤：
- en: 'Inside the `Dialog.h` file, we need to define the event names before the interface
    declaration:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dialog.h`文件中，我们需要在接口声明之前定义事件名称：
- en: '[PRE40]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Switch to `Dialog.m`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Dialog.m`。
- en: 'Register the following listeners to our buttons:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下监听器注册到我们的按钮上：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement the `onButtonYes` and `onButtonNo` methods, as shown in the following
    code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码中的`onButtonYes`和`onButtonNo`方法：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Switch to `Battlefield.m`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.m`。
- en: The local dialog variable inside the initializer needs to be refactored into
    an instance variable called `_dialogAbort`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化器中的本地对话框变量需要重构为一个名为`_dialogAbort`的实例变量。
- en: Move the `#import "Dialog.h"` statement from `Battlefield.m` to `Battlefield.h`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`#import "Dialog.h"`语句从`Battlefield.m`移动到`Battlefield.h`。
- en: 'Add event listeners for both dialog buttons in `Battlefield.m`, as shown in
    the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Battlefield.m`中为两个对话框按钮添加事件监听器，如下所示：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the corresponding methods, as shown in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现相应的函数，如下所示：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Update the abort button event to also pause the game when the dialog is being
    shown:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新中止按钮事件，以便在显示对话框时也暂停游戏：
- en: '[PRE45]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the example to see the result. When we tap the abort button, we can now
    tap the buttons of the dialog:![Time for action – adding our own buttons to our
    dialog](img/1509OS_07_06.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。当我们点击“中止”按钮时，我们现在可以点击对话框中的按钮：![添加我们自己的按钮到对话框的时间 - 行动时间](img/1509OS_07_06.jpg)
- en: '*What just happened?*'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the first step, we defined the event names for our buttons. In the `Dialog.m`
    file, we needed to add listeners for our dialog. We used `SP_EVENT_TYPE_TRIGGERED`,
    so if any kind of event is triggered on either of the buttons, the selector will
    be called.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们为我们的按钮定义了事件名称。在`Dialog.m`文件中，我们需要为我们的对话框添加监听器。我们使用了`SP_EVENT_TYPE_TRIGGERED`，因此如果任一按钮上触发任何类型的事件，都会调用选择器。
- en: In step 4, we implemented the necessary methods. We created an event with our
    custom event type and dispatched this event afterwards.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们实现了必要的方法。我们创建了一个自定义事件类型的事件，并在之后分发了该事件。
- en: In the next step, we refactored the local dialog variable in the battlefield
    initializer. It now needs to be an instance variable called `_dialogAbort` and
    it is still a pointer to `Dialog`. We updated all references and the initialization
    part of the instance variable. Consequently, we imported a statement to the header
    file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将战场初始化器中的本地对话框变量重构。现在它需要一个名为`_dialogAbort`的实例变量，它仍然是指向`Dialog`的指针。我们更新了所有引用和实例变量的初始化部分。因此，我们在头文件中导入了一个语句。
- en: We then called the `addEventListener` method on our dialog using our custom
    events.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在我们的对话框上使用自定义事件调用了`addEventListener`方法。
- en: In step 9, we implemented the methods that should be fired when the button is
    tapped. If we select **Yes**, we need to show the pirate cove scene, and if we
    select **No**, we need the dialog to disappear. We also resume the game in this
    case.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们实现了当按钮被点击时应触发的函数。如果我们选择“是”，我们需要显示海盗湾场景，如果我们选择“否”，我们需要对话框消失。在这种情况下，我们还需要恢复游戏。
- en: As we resume the game if we tap **Yes**, we also need to update the abort button
    event to actually pause the game once the dialog is being shown.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击“是”，在恢复游戏时，我们也需要更新中止按钮的事件，以便在显示对话框时实际暂停游戏。
- en: When we ran the example and tapped the abort button, our dialog pops up and
    the game pauses. If we tap **No**, the dialog closes and the game resumes. If
    we tap **Yes**, we shift to the pirate cove scene.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例并点击中止按钮时，我们的对话框弹出，游戏暂停。如果我们点击“否”，对话框关闭，游戏继续。如果我们点击“是”，我们将切换到海盗湾场景。
- en: Drawing text on the screen
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制文本
- en: There are two ways to display text on the screen. We can either use one of the
    iOS fonts (so-called system fonts) or we could try to create a more customized
    font that fits our needs better.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示文本有两种方式。我们可以使用iOS字体（所谓的系统字体）之一，或者尝试创建一个更适合我们需求的更定制化的字体。
- en: Displaying our first text field
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示我们的第一个文本字段
- en: We already drew some text on the screen utilizing the capabilities of `SPButton`
    when we added the dialog buttons. However, we are now going to draw some text
    on the screen for the dialog message.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加对话框按钮时，我们已经利用 `SPButton` 的功能在屏幕上绘制了一些文本。然而，我们现在将绘制一些文本用于对话框消息。
- en: Time for action – adding a text field to the dialog
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候给对话框添加文本字段了
- en: 'To draw text on the screen, we need to follow these steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上绘制文本，我们需要遵循以下步骤：
- en: 'As shown in the following line of code, add a property called `content`, which
    is a pointer to `SPTextField`, inside the `Dialog.h` file:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码行所示，在 `Dialog.h` 文件中添加一个名为 `content` 的属性，它是一个指向 `SPTextField` 的指针：
- en: '[PRE46]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `Dialog` initializer, create the following content instance and position
    it between the title box and the buttons:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Dialog` 初始化器中，创建以下内容实例并将其放置在标题框和按钮之间：
- en: '[PRE47]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the `content` property to the display tree, as shown in the following code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码所示，将 `content` 属性添加到显示树中：
- en: '[PRE48]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Switch to the `Battlefield.m` file.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Battlefield.m` 文件。
- en: 'Add a custom message for the abort dialog, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为中止对话框添加一个自定义消息，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Run the example.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: Now, we see the text message inside the dialog.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们看到了对话框内的文本消息。
- en: '![Time for action – adding a text field to the dialog](img/1509OS_07_07.jpg)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![是时候给对话框添加文本字段了](img/1509OS_07_07.jpg)'
- en: '*What just happened?*'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'First of all, we needed a property for the message we are going to display.
    A `SPTextField` class works like this: we define a rectangle and some text, and
    the text will automatically be aligned inside the bounds of the rectangle. By
    default, the text is centered horizontally and vertically. If we want to change
    this, we need to change the `hAlign` and `vAlign` properties to our desired values.
    In addition to all of the properties it inherits from being a display object (such
    as color or scale), a text field also has the `fontName` property to use different
    fonts and the `fontSize` property for the size of the text.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个属性来表示我们将要显示的消息。`SPTextField` 类的工作方式是这样的：我们定义一个矩形和一些文本，文本将自动在矩形的边界内对齐。默认情况下，文本在水平和垂直方向上居中。如果我们想改变这一点，我们需要将
    `hAlign` 和 `vAlign` 属性更改为我们想要的值。除了从显示对象继承的所有属性（如颜色或缩放）之外，文本字段还有一个 `fontName` 属性来使用不同的字体，以及一个
    `fontSize` 属性来设置文本的大小。
- en: In step 2, we created the `_content` instance, where the text field should be
    a bit smaller than the dialog itself. We gave the text field a default text and
    then updated its position to be more or less in the center of the dialog.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 中，我们创建了 `_content` 实例，其中文本字段应该略小于对话框本身。我们为文本字段设置了一个默认文本，然后更新其位置，使其大致位于对话框的中心。
- en: After we added the text field to the display tree in step 3, we updated the
    default message, a custom one, inside the `Battlefield` initializer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中我们将文本字段添加到显示树之后，我们在 `Battlefield` 初始化器中更新了默认消息，一个自定义消息。
- en: When we ran the example, we saw our custom message in the dialog.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们在对话框中看到了我们的自定义消息。
- en: Explaining system fonts
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释系统字体
- en: System fonts are the fonts iOS has built-in, out of the box. The selection ranges
    from Arial and Helvetica to Verdana, including the light, bold, and italic variants.
    For a complete list of all available system fonts, visit [http://iosfonts.com/](http://iosfonts.com/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 系统字体是 iOS 内置的字体，无需额外安装。选择范围从 Arial 和 Helvetica 到 Verdana，包括轻、粗体和斜体变体。要查看所有可用系统字体的完整列表，请访问
    [http://iosfonts.com/](http://iosfonts.com/)。
- en: Explaining bitmap fonts
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释位图字体
- en: A bitmap font is very similar to a texture atlas; every character is an image.
    All of these smaller images are put into a big one. Although system fonts can
    display Unicode characters with ease, if we need umlauts or similar characters,
    we would need to add them ourselves. As a result, this would directly increase
    the size of the image.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 位图字体与纹理图集非常相似；每个字符都是一个图像。所有这些较小的图像都被放入一个大的图像中。尽管系统字体可以轻松显示 Unicode 字符，但如果我们需要变音符号或类似字符，我们就需要自己添加它们。因此，这将直接增加图像的大小。
- en: 'A sample bitmap font would look like the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例位图字体可能看起来像以下截图：
- en: '![Explaining bitmap fonts](img/1509OS_07_08.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![解释位图字体](img/1509OS_07_08.jpg)'
- en: 'A portion of the data might look something like the following portion of code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的一部分可能看起来像以下代码片段：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Similar to a texture atlas, the actual data is represented in XML.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理图集类似，实际数据以 XML 格式表示。
- en: There are multiple tools to create bitmap fonts, with each of them having their
    own advantages and disadvantages. Littera is a free online tool available at [http://kvazars.com/littera/](http://kvazars.com/littera/)
    (requires Adobe Flash Player); other popular commercial solutions are **Glyph
    Designer** by 71squared and **bmGlyph** by Stéphane Queraud.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种工具可以创建位图字体，每个都有自己的优缺点。Littera是一个免费的在线工具，可在[http://kvazars.com/littera/](http://kvazars.com/littera/)找到（需要Adobe
    Flash Player）；其他流行的商业解决方案包括71squared的**Glyph Designer**和Stéphane Queraud的**bmGlyph**。
- en: Creating our very own bitmap font
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的位图字体
- en: For this example, we will use bmGlyph, as it allows us to create multiple scaled
    bitmap fonts similar to the mechanic `TexturePacker` provides. The bmGlyph solution
    is available on the Mac App Store at [https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12](https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12)
    for $9.99 or your regional equivalent.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用bmGlyph，因为它允许我们创建多个缩放位图字体，类似于`TexturePacker`提供的机制。bmGlyph解决方案可在Mac
    App Store中找到，价格为$9.99或您所在地区的等值货币。[https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12](https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12)
- en: If you don't want to use bmGlyph, the complete bitmap font is also included
    in the graphics package.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用bmGlyph，完整的位图字体也包含在图形包中。
- en: Time for action – using bmGlyph to create a bitmap font
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用bmGlyph创建位图字体
- en: 'To create our first bitmap font, we just need to follow these steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个位图字体，我们只需遵循以下步骤：
- en: Open **bmGlyph**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**bmGlyph**。
- en: Select **Arial Rounded MT Bold** as the font.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体设置为**Arial Rounded MT Bold**。
- en: Set **Font size** to **72** points.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**字体大小**设置为**72**点。
- en: Scroll down to the **Color Tools** section and check **Shadow**.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**颜色工具**部分并勾选**阴影**。
- en: In the **Shadow** pane, set the **x** property to **2**, the **y** property
    to **-2**, and the **radius** to **8**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**阴影**面板中，将**x**属性设置为**2**，**y**属性设置为**-2**，并将**半径**设置为**8**。
- en: In the **Fill Mode** section, select a brown-yellowish color and select the
    **Glossy** checkbox.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**填充模式**部分，选择棕色-黄色并勾选**光泽**复选框。
- en: Hit the **Publish** button.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发布**按钮。
- en: In the **Default** target, enter `PirateFont` as the **File Name** and font
    name (**Force Font Name**). In the **Suffix** input box, add `@4x`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**默认**目标中，将**文件名**和字体名称（**强制字体名称**）输入为`PirateFont`。在**后缀**输入框中添加`@4x`。
- en: Click on the **50** button inside the **Duplicate with scale** box and add the
    suffix `@2x`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**重复并缩放**框内点击**50**按钮并添加后缀`@2x`。
- en: Click on the **25** button.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**25**按钮。
- en: Select **Sparrow** in the **Format** drop-down list.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**格式**下拉列表中选择**Sparrow**。
- en: Make sure that **PirateFont** is displayed in all of the targets as the **File
    Name** and in **Force Font Name**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在所有目标中**PirateFont**都显示为**文件名**和**强制字体名称**。
- en: Hit **Publish** and then the **Close** button.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发布**然后点击**关闭**按钮。
- en: 'After these steps, we should see the following screen:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些步骤之后，我们应该看到以下屏幕：
- en: '![Time for action – using bmGlyph to create a bitmap font](img/1509OS_07_09.jpg)'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 使用bmGlyph创建位图字体](img/1509OS_07_09.jpg)'
- en: '*What just happened?*'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: After we opened **bmGlyph**, we set the base font, size, color, and the shadow
    of the bitmap font. To export the bitmap font, we clicked on the **Publish** button,
    which we did in step 7\. For each separate image, we need to define a new target
    with a scale. In our case, this is `100%`, `50%`, and `25%` with the suffixes
    `@4x` and `@2x`, respectively. For the `25%` target, we don't need a suffix.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开**bmGlyph**后，设置了位图字体的基本字体、大小、颜色和阴影。要导出位图字体，我们点击了**发布**按钮，这在第7步中已经完成。对于每个单独的图像，我们需要定义一个新的目标并设置缩放。在我们的例子中，这是`100%`、`50%`和`25%`，分别带有后缀`@4x`和`@2x`。对于`25%`的目标，我们不需要后缀。
- en: To export a Sparrow-compatible bitmap font, we needed to select the **Sparrow**
    format. We needed to make sure that `PirateFont` is written in both **File Name**
    and **Force Font Name**. If we don't do the latter, the font won't become available
    as `PirateFont`, but will replace **Arial Rounded MT Bold**.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出与Sparrow兼容的位图字体，我们需要在**格式**下拉列表中选择**Sparrow**。我们需要确保`PirateFont`在**文件名**和**强制字体名称**中都被写入。如果我们不这样做，字体将不会作为`PirateFont`可用，而是会替换**Arial
    Rounded MT Bold**。
- en: When we hit the **Publish** button, our font files became available in the location
    where we wanted to save them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**发布**按钮时，我们的字体文件出现在我们想要保存它们的位置。
- en: Displaying a text field with bitmap fonts
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示带有位图字体的文本字段
- en: Now that we have displayed a system in our dialog, let's display text using
    our fresh bitmap font as the dialog's title.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在对话框中显示了一个系统，让我们使用我们新创建的位图字体作为对话框的标题来显示文本。
- en: Time for action – using our bitmap font for a text field
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在行动起来——使用我们的位图字体进行文本字段
- en: 'Follow these steps to display bitmap fonts in `SPTextField`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在`SPTextField`中显示位图字体：
- en: 'We need to add another property called `title` inside the `Dialog.h` file,
    which is also a pointer to `SPTextField`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`Dialog.h`文件中添加另一个名为`title`的属性，它也是一个指向`SPTextField`的指针：
- en: '[PRE51]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We register our bitmap font, as shown in the following code:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注册了位图字体，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We create and position the `_title` instance with the following lines of code:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码行创建并定位`_title`实例：
- en: '[PRE53]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We need to add the `_title` instance to the display tree, as shown in the following
    code:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`_title`实例添加到显示树中，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Inside the `Battlefield.m` file, we replace the default title with a custom
    one:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Battlefield.m`文件中，我们用自定义标题替换了默认标题：
- en: '[PRE55]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the example to see the result.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。
- en: 'Our dialog now has a message and a title:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在的对话框包含了一条消息和标题：
- en: '![Time for action – using our bitmap font for a text field](img/1509OS_07_10.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![现在行动起来——使用我们的位图字体进行文本字段](img/1509OS_07_10.jpg)'
- en: '*What just happened?*'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Displaying bitmap fonts is very similar to displaying system fonts on the screen.
    Before we can use any bitmap font, we need to register it first. When we want
    to display a text field with this font, we need to update the `fontName` property
    to reflect the name of the bitmap font.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 显示位图字体与在屏幕上显示系统字体非常相似。在我们能够使用任何位图字体之前，我们需要首先注册它。当我们想要使用这种字体显示文本字段时，我们需要更新`fontName`属性以反映位图字体的名称。
- en: Another thing to consider is that Sparrow displays all text in black by default.
    We need to change this in order to see the color effect of our bitmap font.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事需要考虑的是，Sparrow默认将所有文本显示为黑色。我们需要更改这一点才能看到位图字体的颜色效果。
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that the complete source code for this chapter can also be found on
    GitHub: [https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733](https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本章的完整源代码也可以在GitHub上找到：[https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733](https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733)。
- en: Pop quiz
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. In order for custom jugglers to show their tweens, which method needs to
    be called?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 为了让自定义的juggler显示其tween，需要调用哪种方法？
- en: '`advanceTime`'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`advanceTime`'
- en: '`update`'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`'
- en: '`addJuggler`'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addJuggler`'
- en: Q2\. Are bitmap fonts similar to texture atlases?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 位图字体与纹理图集相似吗？
- en: 'Yes'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Q3\. What kind of fonts can be used with `SPTextField`?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 可以与`SPTextField`一起使用的字体类型有哪些？
- en: System fonts
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统字体
- en: Bitmap fonts
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位图字体
- en: Both
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about adding user interface elements to the screen.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将用户界面元素添加到屏幕上。
- en: Specifically, we covered health bars, buttons, and drawing text on the screen,
    and we got a deeper knowledge of jugglers and how to update elements through custom
    getters and setters.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了健康条、按钮以及在屏幕上绘制文本，并且我们对juggler以及如何通过自定义getter和setter更新元素有了更深入的了解。
- en: Now that we have a basic user interface, let's add some artificial intelligence—which
    is the topic of the next chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本用户界面，让我们添加一些人工智能——这是下一章的主题。
