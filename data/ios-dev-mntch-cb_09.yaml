- en: Chapter 9. Interacting with Device Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章.与设备硬件交互
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Detecting device orientation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测设备方向
- en: Adjusting UI orientation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整UI方向
- en: Proximity sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接近传感器
- en: Retrieving battery information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取电池信息
- en: Handling motion events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理运动事件
- en: Handling touch events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: Recognizing gestures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别手势
- en: Custom gestures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义手势
- en: Using the accelerometer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: Using the gyroscope
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陀螺仪
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Today's mobile devices are equipped with very advanced hardware. Be it accelerometers
    to detect motion and orientation, proximity sensors, GPS modules, and among many
    other components, quite sophisticated multi-touch screens.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的移动设备配备了非常先进的硬件。无论是加速度计来检测运动和方向，接近传感器，GPS模块，以及许多其他组件，多触控屏幕相当复杂。
- en: In this chapter, we will be focusing on how to use this hardware within our
    applications to provide the user with an experience that extends into the 3D world.
    Specifically, we will discuss how to adjust the user interface orientation according
    to the position of the device, how to use the proximity sensor, and read battery
    information. In a series of four tasks, we will learn how to capture user touches
    on the screen and recognize gestures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注如何在我们的应用程序中使用这些硬件，为用户提供一个扩展到3D世界的体验。具体来说，我们将讨论如何根据设备的位置调整用户界面方向，如何使用接近传感器，以及读取电池信息。在一系列四个任务中，我们将学习如何捕获屏幕上的用户触摸并识别手势。
- en: Last but not least, we will create advanced applications that read the raw data
    from the accelerometer and gyroscope sensors to detect device motion and rotation,
    with detailed and simple guides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将创建高级应用程序，从加速度计和陀螺仪传感器读取原始数据以检测设备运动和旋转，并提供详细且简单的指南。
- en: Detecting device orientation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测设备方向
- en: In this recipe, we will learn how to make an application that is aware of device
    orientation changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何制作一个能够感知设备方向变化的应用程序。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DeviceOrientationApp`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`DeviceOrientationApp`。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个标签。在`MainController`类中输入以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the application on the simulator.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Rotate the simulator by holding the **Command** key on your Mac and pressing
    the left or right arrow keys.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Mac上按住**Command**键并按左或右箭头键来旋转模拟器。
- en: '![How to do it...](img/1468EXP_09_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1468EXP_09_01.jpg)'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although the simulator lacks accelerometer hardware, it supports notifications
    for orientation changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟器缺少加速度计硬件，但它支持方向变化的通知。
- en: 'The device orientation notification mechanism can be accessed through the `UIDevice.CurrentDevice`
    singleton object. To receive notifications, we first need to instruct the runtime
    to issue them. We do this with the following method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`UIDevice.CurrentDevice`单例对象访问设备方向通知机制。为了接收通知，我们首先需要指示运行时发出它们。我们使用以下方法来完成此操作：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method turns the accelerometer on and starts generating orientation notifications.
    We then need to start observing for the notifications, in order to respond to
    changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法打开加速度计并开始生成方向通知。然后我们需要开始观察通知，以便响应变化：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each time the device orientation changes, the observer triggers the anonymous
    method. In it, we output the orientation, which we get from the `Orientation`
    property, to the label.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当设备方向改变时，观察者触发匿名方法。在其中，我们将从`Orientation`属性获取的方向输出到标签。
- en: 'The `ViewDidUnload` method is the method that is being called when the view
    controller unloads its view. Inside it, we make sure to remove the orientation
    observer, and we instruct the runtime to stop generating orientation notifications:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewDidUnload`方法是在视图控制器卸载其视图时被调用的方法。在其中，我们确保移除方向观察者，并指示运行时停止生成方向通知：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Orientation` property returns an enumeration of the type `UIDeviceOrientation`.
    Its values are the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orientation`属性返回类型为`UIDeviceOrientation`的枚举。其值如下：'
- en: '`Unknown:` This value specifies that the device orientation is unknown'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown:` 此值指定设备方向未知'
- en: '`Portrait:` This value specifies that the device is in its normal portrait
    orientation, with the **home** button on the bottom side'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Portrait:` 此值指定设备处于正常的纵向方向，**主页**按钮在底部'
- en: '`PortraitUpsideDown:` This value specifies that the device is in upside-down
    portrait orientation, with the **home** button on the top side'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortraitUpsideDown:` 这个值指定设备处于颠倒的纵向方向，**主页**按钮在顶部'
- en: '`LandscapeLeft:` This value specifies that the device is in landscape orientation,
    with the **home** button on the left side'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LandscapeLeft:` 这个值指定设备处于横向方向，**主页**按钮在左侧'
- en: '`LandscapeRight:` This value specifies that the device is in landscape orientation,
    with the **home** button on the right side'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LandscapeRight:` 这个值指定设备处于横向方向，**主页**按钮在右侧'
- en: '`FaceUp:` This value specifies that the device is parallel to the ground, with
    the screen facing up'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceUp:` 这个值指定设备与地面平行，屏幕向上'
- en: '`FaceDown:` This value specifies that the device is parallel to the ground,
    with the screen facing down'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceDown:` 这个值指定设备与地面平行，屏幕向下'
- en: '`FaceUp` and `FaceDown` are two values that cannot be reproduced on the simulator.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`FaceUp`和`FaceDown`是模拟器上无法复制的两个值。'
- en: Device orientation and user interface orientation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备方向和用户界面方向
- en: What can be clearly noticed in this example is that there is a difference between
    a device's orientation and that of the user interface. If the device is rotated,
    the label gets updated with the new orientation value, but the user interface
    does not respond to changes. In the next recipe, we will discuss how to rotate
    the user interface.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中可以明显看出，设备方向和用户界面方向之间存在差异。如果设备旋转，标签会更新为新方向值，但用户界面不会对变化做出响应。在下一个菜谱中，我们将讨论如何旋转用户界面。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Adjusting UI orientation*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整UI方向*'
- en: '*Using the accelerometer*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*'
- en: Adjusting UI orientation
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整UI方向
- en: In this recipe, we will learn how to rotate the **User Interface (UI)** according
    to the screen orientation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何根据屏幕方向旋转**用户界面 (UI)**。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `UIOrientationApp`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`UIOrientationApp`。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`视图上添加一个标签。在`MainController`类中输入以下代码：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile and run the application on the simulator.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: 'Use *Command* + arrow keys to rotate the simulator. The **LandscapeRight**
    orientation is shown in the following image:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Command* + 方向键旋转模拟器。以下图像显示了**LandscapeRight**方向：
- en: '![How to do it...](img/1468EXP_09_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_09_02.jpg)'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To make our UI adjust to device orientations, all we need to do is override
    the view controller''s `ShouldAutorotateToInterfaceOrientation` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的UI适应设备方向，我们只需要重写视图控制器的`ShouldAutorotateToInterfaceOrientation`方法：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the view controller loads, it checks the outcome of the method for each
    of the available orientations. The first time it receives `true` from it, it will
    automatically rotate the interface to that orientation. After loading, whenever
    the device rotates, the same process gets repeated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图控制器加载时，它会检查每个可用方向的方法结果。第一次接收到`true`时，它会自动将界面旋转到该方向。加载后，每次设备旋转时，都会重复相同的流程。
- en: The parameter of the method is an enumeration of the type `UIInterfaceOrientation`,
    and each time the method gets called, it contains the value of the orientation
    the interface checks for.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数是类型为`UIInterfaceOrientation`的枚举，每次方法被调用时，它包含界面检查的方向值。
- en: 'The `DidRotate` method is called after the interface orientation completes.
    We use the `UIViewController.InterfaceOrientation` property, which holds the information
    on the view controller''s current orientation, to update the label:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面方向完成旋转后，会调用`DidRotate`方法。我们使用`UIViewController.InterfaceOrientation`属性，它包含视图控制器当前方向的信息，来更新标签：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Returning `true` from the `ShouldAutorotateToInterfaceOrientation` method means
    that the interface will rotate on all device orientations. In most cases, this
    is not necessary and should even be avoided, depending on our application design.
    To make our interface rotate to landscape orientations only, the method should
    be implemented as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ShouldAutorotateToInterfaceOrientation`方法返回`true`意味着界面将在所有设备方向上旋转。在大多数情况下，这并不是必要的，甚至应该根据我们的应用程序设计避免。要使我们的界面仅旋转到横向方向，方法应实现如下：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this implementation will force the UI to load at landscape mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此实现将强制UI以横屏模式加载。
- en: User interface orientation on the simulator
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟器中的用户界面方向
- en: If you implement the `ShouldAutorotateToInterfaceOrientation` method to only
    support landscape orientations, then the controller that loads the simulator "device"
    will also rotate at landscape orientation. However, this is for convenience only,
    since if you check the `UIDevice.CurrentDevice.Orientation` property, its value
    will be `UIDeviceOrientation.Portrait`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只实现`ShouldAutorotateToInterfaceOrientation`方法以支持横屏方向，那么加载模拟器“设备”的控制器也将以横屏方向旋转。然而，这只是为了方便，因为如果你检查`UIDevice.CurrentDevice.Orientation`属性，其值将是`UIDeviceOrientation.Portrait`。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Detecting device orientation*'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测设备方向*'
- en: '*Using the accelerometer*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*'
- en: Proximity sensor
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近传感器
- en: In this recipe, we will discuss using the proximity sensor to disable the device
    screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论使用接近传感器来禁用设备屏幕。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `ProximitySensorApp`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`ProximitySensorApp`。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the proximity sensor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持接近传感器。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: For this task, no controls are needed, besides the `MainController` itself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，除了`MainController`本身之外，不需要任何控件。
- en: 'Declare an `NSObject` field that will hold the notification observer:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`NSObject`字段，它将包含通知观察者：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Enter the following code in the `ViewDidLoad` override:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`重写方法中输入以下代码：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, enter the following code in the `ViewDidUnload` override:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`ViewDidUnload`重写方法中输入以下代码：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile and run the application on the device.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Put your finger over the proximity sensor, or just hold it next to your ear
    as you would do when on a call. Watch the **Application Output** pad in MonoDevelop
    display the state of the sensor.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将手指放在接近传感器上，或者就像在通话时那样，将其靠近你的耳朵。观察MonoDevelop中的**应用程序输出**面板显示传感器的状态。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Although the functionality of the proximity sensor is quite simple, it provides
    a very important feature. iOS devices have only one button on the front, which
    is the **home** button. Almost every user-device interaction is based on the touch-sensitive
    screen. This poses a problem on the iPhone: apart from its multiple features,
    it is also a phone. This means that it will most likely spend some time on the
    side of the user''s face for making calls.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接近传感器的功能相当简单，但它提供了一个非常重要的特性。iOS设备正面只有一个按钮，那就是**主**按钮。几乎每一次用户与设备的交互都是基于触摸屏的。这在iPhone上造成了一个问题：除了它的多种功能外，它也是一个电话。这意味着它很可能会在用户的面部侧面花费一些时间来进行通话。
- en: To avoid accidental virtual buttons being tapped, the proximity sensor gets
    activated when the phone application is running, to disable the screen when the
    device is near the user's ear, or whatever is over the sensor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外触碰到虚拟按钮，当手机应用程序运行时，接近传感器会被激活，以在设备靠近用户的耳朵或传感器上方的任何物体时禁用屏幕。
- en: To enable the proximity sensor, set the property of the `UIDevice.CurrentDevice.ProximityMonitoringEnabled`
    to `true:`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用接近传感器，将`UIDevice.CurrentDevice.ProximityMonitoringEnabled`属性的值设置为`true`：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the device does not support the proximity sensor, this property will return
    `false`, even after it has been set to `true`. So, after setting it to `true`,
    we can check it to see if the device supports the sensor:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备不支持接近传感器，即使将其设置为`true`，此属性也将返回`false`。因此，在将其设置为`true`之后，我们可以检查它以查看设备是否支持传感器：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After checking, we can add an observer for getting notified of the sensor''s
    state with the `UIDevice.ProximityStateDidChangeNotification` key:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查后，我们可以使用`UIDevice.ProximityStateDidChangeNotification`键添加一个观察者来通知传感器的状态：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ProximityState` property returns `true` if the sensor has turned the screen
    off and `false` if it has turned it back on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProximityState`属性返回`true`表示传感器已经关闭了屏幕，如果它重新打开屏幕则返回`false`。'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The proximity sensor usage is not limited to phone call functionality. For example,
    if you are developing an application that could do some work while the device
    is in the user's pocket or purse, enabling the proximity sensor would make sure
    that no accidental controls are tapped. Or even save battery power, by just turning
    the screen off.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接近传感器的使用不仅限于电话功能。例如，如果你正在开发一个在设备放在用户的口袋或钱包中时可以执行一些工作的应用程序，启用接近传感器可以确保不会意外触碰到控制按钮。甚至可以通过仅关闭屏幕来节省电池电量。
- en: Sensor support
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传感器支持
- en: Not all devices support a proximity sensor. If you are targeting various iOS
    devices, consider that the sensor will not be available on all of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备都支持接近传感器。如果你针对各种iOS设备，请考虑传感器可能不会在所有设备上可用。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Retrieving battery information*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索电池信息*'
- en: Retrieving battery information
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索电池信息
- en: In this recipe, we will learn how to read the charging states of the device
    and its battery usage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何读取设备的充电状态及其电池使用情况。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `BatteryInfoApp`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `BatteryInfoApp`。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的视图中添加一个标签。在 `MainController` 类中输入以下代码：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Compile and run the application on the device.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: After the application loads, disconnect and/or connect the USB cable of the
    device. Watch the battery state on the label.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序加载后，断开并/或连接设备的USB线缆。观察标签上的电池状态。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can retrieve battery information through the `UIDevice` class. The first
    thing we have to do is to enable battery monitoring:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `UIDevice` 类检索电池信息。我们必须做的第一件事是启用电池监控：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On the simulator, which does not support battery monitoring, this property will
    return false, even after we have set it to true.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持电池监控的模拟器上，即使我们将其设置为 true，此属性也将返回 false。
- en: 'We can then add an observer for battery state change notifications through
    the `UIDevice.BatteryStateDidChangeNotification` key, as indicated in the highlighted
    code previously. The battery state can be retrieved through the `BatteryState`
    property:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `UIDevice.BatteryStateDidChangeNotification` 键添加一个观察者来监听电池状态变化通知，如之前高亮显示的代码所示。可以通过
    `BatteryState` 属性检索电池状态：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Possible values of the `BatteryState` property are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryState` 属性的可能值包括：'
- en: '`Unknown:` This value specifies that the battery state cannot be determined,
    or battery monitoring is disabled'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown:` 此值指定无法确定电池状态，或者电池监控被禁用'
- en: '`Unplugged:` This value specifies that the device is running on battery power'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unplugged:` 此值指定设备正在使用电池供电'
- en: '`Charging:` This value specifies that the device battery is charging, and the
    USB cable is connected'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charging:` 此值指定设备电池正在充电，并且USB线缆已连接'
- en: '`Full:` This value specifies that the device battery is full, and the USB cable
    is connected'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Full:` 此值指定设备电池已满电，并且USB线缆已连接'
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Apart from the battery state, we can get information on its power level. To
    do this, we need to add an observer for the `UIDevice.BatteryLevelDidChangeNotification`
    key:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了电池状态外，我们还可以获取其电量信息。为此，我们需要为 `UIDevice.BatteryLevelDidChangeNotification` 键添加一个观察者：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `BatteryLevel` property returns a float value in the range from `0.0` (battery
    empty) to `1.0` (battery full at 100 percent). If battery monitoring is disabled,
    it will return a value of `-1.0`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatteryLevel` 属性返回一个范围从 `0.0`（电池耗尽）到 `1.0`（电池满电100%）的浮点值。如果电池监控被禁用，它将返回 `-1.0`
    的值。'
- en: Disabling battery monitoring
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用电池监控
- en: Always disable battery monitoring when not needed. The actual monitoring mechanism
    itself consumes battery power.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要时始终禁用电池监控。实际的监控机制本身会消耗电池电量。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Proximity sensor*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接近传感器*'
- en: Handling motion events
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理运动事件
- en: In this recipe, we will learn how to intercept and respond to shake gestures.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何拦截和响应摇动手势。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `MotionEventsApp`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `MotionEventsApp`。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的视图中添加一个标签。在 `MainController` 类中输入以下代码：
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile and run the application on the device.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Shake the device and watch the output on the label. You can also test this application
    on the simulator.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摇动设备并观察标签上的输出。你还可以在模拟器上测试这个应用程序。
- en: After it loads, click on **Hardware | Shake Gesture** on the menu bar.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载完成后，点击菜单栏上的 **硬件 | 摇动手势**。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By overriding the motion methods of the `UIViewController` class, we can intercept
    and respond to the motion events sent by the system. Just overriding these methods
    is not enough, though. For a controller to receive motion events, it needs to
    be the first responder. To make sure of this, we first override the `CanBecomeFirstResponder`
    property and return `true` from it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`UIViewController`类的运动方法，我们可以拦截并响应用户系统发送的运动事件。尽管如此，仅仅重写这些方法是不够的。为了使控制器接收运动事件，它需要成为第一个响应者。为了确保这一点，我们首先重写`CanBecomeFirstResponder`属性并从中返回`true`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we make sure our controller becomes the first responder when its view
    has appeared by calling the `BecomeFirstResponder` method in the `ViewDidAppear`
    override:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过在`ViewDidAppear`重写方法中调用`BecomeFirstResponder`方法来确保当其视图出现时，我们的控制器成为第一个响应者：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ViewDidAppear` method gets called after the view has appeared on the screen.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewDidAppear`方法在视图出现在屏幕上之后被调用。'
- en: 'The system determines if a motion is a shake gesture and calls the appropriate
    methods. We can use the following three methods to override and capture shake
    gestures:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 系统确定一个运动是否是摇动手势，并调用适当的方法。我们可以使用以下三个方法来重写并捕获摇动手势：
- en: '`MotionBegan:` This method specifies that shaking motion started'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionBegan:` 此方法指定摇动动作开始'
- en: '`MotionEnded:` This method specifies that shaking motion ended'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionEnded:` 此方法指定摇动动作结束'
- en: '`MotionCancelled:` This method specifies that shaking motion cancelled'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MotionCancelled:` 此方法指定摇动动作取消'
- en: When the device starts moving, the `MotionBegan` method is called. If the motion
    lasts for about a second or less, the `MotionEnded` method is called. If it lasts
    longer, the system classifies it as not being a shake gesture and calls the `MotionCancelled`
    method. It is advisable to override all three methods and react accordingly when
    we want to implement shake gestures in an application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备开始移动时，会调用`MotionBegan`方法。如果运动持续大约一秒或更短，则调用`MotionEnded`方法。如果持续时间更长，系统将其分类为非摇动手势，并调用`MotionCancelled`方法。当我们在应用程序中实现摇动手势时，建议重写所有三个方法并相应地做出反应。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Motion events are only sent to objects inheriting the `UIResponder` class. This
    includes the `UIView` and `UIViewController` classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有从继承自`UIResponder`类的对象才会发送运动事件。这包括`UIView`和`UIViewController`类。
- en: More info motion events
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息：运动事件
- en: The motion event mechanism is fairly simple. It merely detects near-instant
    device shakes, without providing any information on their direction or rate. To
    handle motion events based on different characteristics, the accelerometer can
    be used in combination.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运动事件机制相当简单。它仅检测几乎瞬间的设备摇动，而不提供有关其方向或速率的任何信息。为了根据不同的特性处理运动事件，可以将加速度计与组合使用。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using the accelerometer*'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*'
- en: Handling touch events
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理触摸事件
- en: In this recipe, we will learn how to intercept and respond to user touches.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何拦截和响应用户触摸。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `TouchEventsApp`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`TouchEventsApp`。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Add a label on the view of `MainController`, and enter the following code in
    the `MainController` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个标签，并在`MainController`类中输入以下代码：
- en: '[PRE21]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and run the application on the simulator.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Click-and-drag sideways with the cursor on the simulator's screen, and watch
    the view's background color gradually change from white to black. Note that clicking
    with the cursor on the simulator screen is the equivalent of touching the device's
    screen with a finger.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器屏幕上使用光标进行侧向点击和拖动，并观察视图的背景颜色逐渐从白色变为黑色。请注意，在模拟器屏幕上使用光标点击相当于用手指触摸设备的屏幕。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To respond to user touches, the object that acts as a touch receiver must have
    its `UserInteractionEnabled` property set to `true`. Almost every object is enabled
    for user interaction by default, except for those whose primary usage is not intended
    for direct user interaction, for example, the `UILabel` and the `UIImageView`.
    We need to set the `UserInteractionEnabled` to these objects explicitly. Apart
    from this, the objects that can handle touch events must inherit from the `UIResponder`
    class. Note that although the `UIViewController` class inherits from `UIResponder`
    and therefore can capture touch events, it does not have a `UserInteractionEnabled`
    property, and it is its main property of `UIView` that controls the delivery of
    touch events. What this means is that if you override the touch methods of a `UIViewController`
    but its view's `UserInteractionEnabled` property is set to `false`, these methods
    will not respond to user touches.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应用户的触摸，作为触摸接收器的对象必须将其 `UserInteractionEnabled` 属性设置为 `true`。几乎每个对象默认都启用了用户交互，除非其主要用途不是直接用于用户交互，例如，`UILabel`
    和 `UIImageView`。我们需要明确地将 `UserInteractionEnabled` 设置到这些对象上。除此之外，可以处理触摸事件的对象必须继承自
    `UIResponder` 类。请注意，尽管 `UIViewController` 类继承自 `UIResponder`，因此可以捕获触摸事件，但它没有 `UserInteractionEnabled`
    属性，而是其主要的 `UIView` 属性控制着触摸事件的传递。这意味着，如果你重写了 `UIViewController` 的触摸方法，但它的视图的 `UserInteractionEnabled`
    属性设置为 `false`，则这些方法将不会响应用户的触摸。
- en: 'The methods responsible for handling the touch events are the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理触摸事件的以下方法：
- en: '`TouchesBegan:` This method is called when the user touches the screen'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesBegan:` 当用户触摸屏幕时，会调用此方法。'
- en: '`TouchesMoved:` This method is called when the user drags the finger on the
    screen'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesMoved:` 当用户在屏幕上拖动手指时，会调用此方法。'
- en: '`TouchesEnded:` This method is called when the user lifts the finger from the
    screen'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesEnded:` 当用户从屏幕上抬起手指时，会调用此方法。'
- en: '`TouchesCancelled:` This method is called when the touch event has been cancelled
    by a system event, for example, when a notification alert is displayed'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchesCancelled:` 当触摸事件被系统事件取消时，会调用此方法，例如，当显示通知警报时。'
- en: The full project can be found in the downloaded source code. The `TouchesMoved`
    method implementation is explained here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目可以在下载的源代码中找到。`TouchesMoved` 方法的实现在此处解释。
- en: Every touch method has two parameters. The first parameter is of the type `NSSet`
    and contains the `UITouch` objects. The `NSSet` class represents a collection
    of objects, while the `UITouch` class holds the information for each user touch.
    The second parameter is of the type `UIEvent` and holds the information of the
    actual event.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个触摸方法都有两个参数。第一个参数是 `NSSet` 类型，包含 `UITouch` 对象。`NSSet` 类表示对象的集合，而 `UITouch`
    类保存每个用户触摸的信息。第二个参数是 `UIEvent` 类型，包含实际事件的详细信息。
- en: 'We can retrieve the `UITouch` object related to the actual touch through the
    `NSSet.AnyObject` return value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `NSSet.AnyObject` 返回值检索与实际触摸相关的 `UITouch` 对象：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It returns an object of type `NSObject`, which we convert to a `UITouch`. We
    can get the previous and current locations of the touch through the following
    methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 `NSObject` 类型的对象，我们将它转换为 `UITouch`。我们可以通过以下方法获取触摸的先前和当前位置：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both of them return a `PointF struct` containing the location of the touch in
    the receiver's coordinate system. After receiving the location of the touch, we
    adjust the background color accordingly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都返回一个包含触摸接收器坐标系中触摸位置的 `PointF` 结构体。在接收到触摸位置后，我们相应地调整背景颜色。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'This example is based on single user touches. To enable a view to respond to
    multiple touches, we have to set its `MultipleTouchEnabled` property to `true`.
    We can then get all the `UITouch` objects in an array:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例基于单个用户的触摸。为了使视图能够响应用户的多个触摸，我们必须将其 `MultipleTouchEnabled` 属性设置为 `true`。然后我们可以获取数组中的所有
    `UITouch` 对象：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Getting the tap count
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取点击次数
- en: We can determine the number of consecutive user taps through the `UITouch.TapCount`
    property inside the `ToucheEnded` method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ToucheEnded` 方法中的 `UITouch.TapCount` 属性确定连续用户点击的次数。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*MotionEvents*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触摸事件*'
- en: '*Recognizing gestures*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别手势*'
- en: '*Custom gestures*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义手势*'
- en: Recognizing gestures
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别手势
- en: In this recipe, we will discuss how to recognize touch gestures and respond
    accordingly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何识别触摸手势并相应地做出反应。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `GestureApp`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `GestureApp`。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add a label on the view of `MainController`. Enter the following `using` directive
    in the `MainController` class source file:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个标签。在`MainController`类的源文件中输入以下`using`指令：
- en: '[PRE25]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中输入以下代码：
- en: '[PRE26]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run the application on the simulator.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Hold down the **Option** key and click-drag with the mouse to perform the equivalent
    of a pinch on the simulator screen.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住**Option**键，并用鼠标点击拖动以在模拟器屏幕上执行捏合动作的等效操作。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since the iOS 3.2 version was released along with the iPad, Apple introduced
    the `UIGestureRecognizer` class and its derivatives. The gesture recognizers make
    use of the multiple touch screens on iOS devices. **Gestures** are basically touch
    combinations, which can be performed for specific actions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 3.2版本的发布，iPad一同推出，苹果引入了`UIGestureRecognizer`类及其派生类。手势识别器利用iOS设备上的多点触控屏幕。**手势**基本上是触摸组合，可以执行特定操作。
- en: For example, pinching on a full-screen image in the native **Photos** application
    will zoom out. The action of pinching is the gesture the user performs, while
    the gesture recognizer is responsible for recognizing and delivering the gesture
    event to its receiver.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在原生**照片**应用程序的全屏图像上捏合将缩小视图。捏合动作是用户执行的手势，而手势识别器负责识别并将手势事件传递给接收者。
- en: 'In this example, we create a `UIPinchGestureRecognizer`, which will recognize
    pinches performed on the screen. Its instance is created with the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`UIPinchGestureRecognizer`，它将识别屏幕上的捏合手势。其实例使用以下代码创建：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The constructor that initializes the instance takes two parameters. The first
    one is of type `NSObject`, and it is the target object that will receive the gesture.
    In this case, it is the `MainController` instance, which we pass with the `this`
    keyword. The second parameter is of the type `Selector`, contained in the `MonoTouch.ObjCRuntime`
    namespace that we added, and it represents the method that will be called when
    the recognizer receives a gesture. In simple words, a `Selector` in Objective-C
    is basically a method signature. The string we pass to its constructor represents
    the Objective-C method that will be called.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化实例的构造函数接受两个参数。第一个参数是`NSObject`类型，它是将接收手势的目标对象。在这种情况下，它是`MainController`实例，我们使用`this`关键字传递。第二个参数是`MonoTouch.ObjCRuntime`命名空间中的类型，它表示当识别器接收到手势时将被调用的方法。简单来说，Objective-C中的`Selector`基本上是一个方法签名。传递给其构造函数的字符串代表将被调用的Objective-C方法。
- en: 'Since we are using C#, we can easily expose a method as an Objective-C `Selector`.
    We just create the method we want and decorate it with the `ExportAttribute`,
    making sure the string we pass to it is the same that we have passed to the `Selector`
    constructor:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用C#，我们可以轻松地将一个方法暴露为Objective-C的`Selector`。我们只需创建我们想要的方法，并用`ExportAttribute`装饰它，确保传递给它的字符串与传递给`Selector`构造函数的字符串相同：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside the method, we read the `State` property of the gesture recognizer object
    and respond accordingly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们读取手势识别器对象的`State`属性，并相应地做出反应。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The state of each gesture recognizer is represented by an enumeration of the
    type `UIGestureRecognizerState`. Its values are:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个手势识别器的状态由类型为`UIGestureRecognizerState`的枚举表示。其值包括：
- en: '`Possible:` This value specifies that the gesture has not yet been recognized
    and is the default value'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Possible:` 此值指定手势尚未被识别，并且是默认值'
- en: '`Began:` This value specifies that the gesture has started'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Began:` 此值指定手势已开始'
- en: '`Changed:` This value specifies that the gesture has changed'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Changed:` 此值指定手势已更改'
- en: '`Ended:` This value specifies that the gesture has ended'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ended:` 此值指定手势已结束'
- en: '`Cancelled:` This value specifies that the gesture has been cancelled'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cancelled:` 此值指定手势已被取消'
- en: '`Failed:` This value specifies that the gesture cannot be recognized'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed:` 此值指定手势无法被识别'
- en: '`Recognized:` This value specifies that the gesture has been recognized'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recognized:` 此值指定手势已被识别'
- en: Advantage of gesture recognizers
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手势识别器的优势
- en: The advantage of gesture recognizers is that they save developers the time to
    create their own gesture recognition mechanisms, through the touch events. Furthermore,
    they are based on the gestures that users are accustomed to using on iOS devices.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 手势识别器的优点是它们可以节省开发者创建自己的手势识别机制的时间，通过触摸事件。此外，它们基于用户在 iOS 设备上习惯使用的手势。
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Touch events*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触摸事件*'
- en: '*Custom gestures*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义手势*'
- en: Custom gestures
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义手势
- en: In this recipe, we will learn how to create a custom gesture recognizer to create
    our own gesture.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何创建一个自定义手势识别器来创建我们自己的手势。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `CustomGestureApp`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `CustomGestureApp`。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a label on the view of `MainController`. Create the following nested class
    in the `MainController` class:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 视图中添加一个标签。在 `MainController` 类中创建以下嵌套类：
- en: '[PRE29]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Use the custom gesture recognizer as shown in the previous recipe.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面食谱中展示的自定义手势识别器。
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To create a gesture recognizer, declare a class that inherits from the `UIGestureRecognizer`
    class. In this example, we are creating a gesture that will be recognized by dragging
    the finger on the screen towards a `50x50` point rectangle in the lower-left corner.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个手势识别器，声明一个继承自 `UIGestureRecognizer` 类的类。在这个例子中，我们创建一个手势，通过在屏幕上拖动手指指向左下角的一个
    `50x50` 点矩形来识别这个手势。
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `UIGestureRecognizer` class contains the same touch methods that we use
    to intercept touches in views. We also have access to the view it was added to
    through its `View` property. Inside the `TouchesBegan` method, we determine the
    initial touch location. If it is outside the lower-left portion of the view, we
    set the `State` property to `Began`. If it is inside the lower-left portion, we
    set the `State` property to `Failed` so that the selector will not be called.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizer` 类包含我们在视图中拦截触摸事件时使用的相同触摸方法。我们还可以通过其 `View` 属性访问它所添加的视图。在
    `TouchesBegan` 方法中，我们确定初始触摸位置。如果它在视图的左下部分之外，我们将 `State` 属性设置为 `Began`。如果它在左下部分内部，我们将
    `State` 属性设置为 `Failed`，这样就不会调用选择器。'
- en: Inside the `TouchesEnded` method, we consider the gesture as `Ended` if the
    touch's location was inside the lower-left portion of the view. If it was not,
    the gesture recognition is considered as `Failed`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TouchesEnded` 方法中，如果触摸的位置在视图的左下部分内部，我们考虑手势为 `Ended`。如果没有，则手势识别被认为是 `Failed`。
- en: The `TouchesMoved` method is where the `Changed` state will be set. For this
    simple gesture recognizer that we are creating, no other logic is needed in it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchesMoved` 方法是设置 `Changed` 状态的地方。对于这个简单的手势识别器，我们不需要在其中添加其他逻辑。'
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: This is a simple gesture recognizer that depends on a single touch. With the
    information provided in the touch methods, we can create more complex gestures
    that will support multiple touches.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的手势识别器，它依赖于单个触摸。通过触摸方法提供的信息，我们可以创建更复杂的支持多个触摸的手势。
- en: Another usage of custom gesture recognizers
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义手势识别器的另一种用法
- en: There are some views that inherit from the `UIView` class, which according to
    Apple Developer Documentation should not be sub-classed. The `MKMapView` is one
    of these views, which is used to display maps. This poses a problem if we want
    to intercept the touch events from these views. Although we could use another
    view over it and intercept its touch events, it is a bit complex. A more simple
    approach is to create a simple custom gesture recognizer and add it to the view
    that we cannot sub-class. This way, we can intercept its touches without having
    to sub-class it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有些视图继承自 `UIView` 类，根据苹果开发者文档，这些视图不应该被子类化。`MKMapView` 就是这些视图之一，用于显示地图。如果我们想拦截这些视图的触摸事件，这会带来一个问题。虽然我们可以在其上方使用另一个视图并拦截其触摸事件，但这有点复杂。一个更简单的方法是创建一个简单的自定义手势识别器并将其添加到我们无法子类化的视图中。这样，我们就可以在不子类化的情况下拦截其触摸事件。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Recognizing gestures*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别手势*'
- en: '*Touch events*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触摸事件*'
- en: Using the accelerometer
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计
- en: In this recipe, we will learn how to receive accelerometer events to create
    an application that is aware of device movement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何接收加速度计事件来创建一个能够感知设备运动的应用程序。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `AccelerometerApp`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `AccelerometerApp`。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the accelerometer hardware. The project in this
    example will work correctly on a device.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持加速度计硬件。本例中的项目将在设备上正确运行。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add two buttons and a label on the view of `MainController`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加两个按钮和一个标签。
- en: 'Override the `ViewDidLoad` method, and implement it with the following code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`ViewDidLoad`方法，并使用以下代码实现它：
- en: '[PRE31]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following method in the class:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE32]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compile and run the application on the device.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Tap the **Start accelerometer** button, and watch the values display on the
    label while moving or shaking the device.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始加速度计**按钮，在移动或摇晃设备时，观察标签上显示的值。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The `UIAccelerometer` class provides access to the accelerometer hardware through
    its `SharedAccelerometer` static property. To activate it, all we need to do is
    to assign a handler to its `Acceleration` event:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAccelerometer`类通过其`SharedAccelerometer`静态属性提供对加速度计硬件的访问。要激活它，我们只需要将其`Acceleration`事件分配给一个处理程序：'
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the handler, we receive the accelerometer values through the `UIAccelerometerEventArgs.Acceleration`
    property. The property returns an object of the type `UIAcceleration`, which contains
    the accelerometer amount in three properties: `X, Y`, and `Z`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序内部，我们通过`UIAccelerometerEventArgs.Acceleration`属性接收加速度计的值。该属性返回一个`UIAcceleration`类型的对象，它包含三个属性：`X`、`Y`和`Z`，分别表示加速度计在三个轴上的量。
- en: 'These properties represent motion in the `X, Y`, and `Z` axes. Consider the
    following diagram:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性表示在`X`、`Y`和`Z`轴上的运动。考虑以下图示：
- en: '![How it works...](img/1468EXP_09_03.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_09_03.jpg)'
- en: 'Each of these values measures the amount of gravitational force by which the
    device moved on each axis. For example, if `X` has a value of `1`, then the device
    is moving on the `X-axis` to the right, with an acceleration of `1g`. If `X` has
    a value of `-1`, then the device is moving on the `X-axis` to the left, with an
    acceleration of `1g`. When the device is placed on a table with its back facing
    the floor and is not moving, the normal values of the acceleration should be close
    or equal to the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中的每一个都测量设备在每个轴上移动的重力量。例如，如果`X`的值为`1`，则设备在`X轴`上向右移动，加速度为`1g`。如果`X`的值为`-1`，则设备在`X轴`上向左移动，加速度为`1g`。当设备放在桌子上，背面朝向地面且不移动时，加速度的正常值应接近或等于以下值：
- en: '`X: 0`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X: 0`'
- en: '`Y: 0`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y: 0`'
- en: '`Z: -1`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z: -1`'
- en: Although the device is not moving, `Z` will be `-1`, because the device measures
    the Earth's gravity.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设备没有移动，`Z`的值将是`-1`，因为设备测量地球的重力。
- en: 'We can set the interval by which the accelerometer will issue acceleration
    events by setting its `UpdateInterval` property:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置其`UpdateInterval`属性来设置加速度计发布加速度事件的时间间隔：
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It accepts a `double`, which represents the interval by which the accelerometer
    will issue its acceleration events in seconds. Care must be taken when setting
    the update interval, because the more events the accelerometer has to issue for
    a specific period of time, the more battery power it consumes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个`double`，表示加速度计在秒内发布加速度事件的时间间隔。设置更新间隔时必须小心，因为加速度计在特定时间段内需要发布的事件越多，它消耗的电量就越多。
- en: 'To stop using the accelerometer, all we need to do is to unhook the handler
    from the `Acceleration` event:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用加速度计，我们只需要将其处理程序从`Acceleration`事件中取消绑定：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `UIAcceleration` class contains another useful property, named `Time`. It
    is a double representing the relative time on which the acceleration event occurred.
    It is relative to CPU time, and it is not suggested to use this value to calculate
    the exact timestamp of the event.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAcceleration`类还包含另一个有用的属性，名为`Time`。它是一个表示加速度事件发生相对时间的`double`值。它是相对于CPU时间的，不建议使用此值来计算事件的精确时间戳。'
- en: Consideration using the accelerometer
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用加速度计的注意事项
- en: Although the iPhone's accelerometer is a very accurate and sensitive sensor,
    it should not be used for precise measurements. Also, the results it produces
    may vary among different iOS devices, even if those devices are of the same model.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管iPhone的加速度计是一个非常精确和敏感的传感器，但它不应该用于精确测量。此外，即使是同一型号的设备，不同iOS设备产生的结果也可能会有所不同。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using the gyroscope*'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用陀螺仪*'
- en: Using the gyroscope
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用陀螺仪
- en: In this recipe, we will learn how to use the built-in gyroscope.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用内置的陀螺仪。
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `GyroscopeApp`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`GyroscopeApp`。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator does not support the gyroscope hardware. Also, only newer devices
    contain a gyroscope. If this application is executed on a device without a gyroscope,
    or on the simulator, no error will occur, but no data will be displayed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器不支持陀螺仪硬件。此外，只有较新的设备才包含陀螺仪。如果在这个没有陀螺仪的设备或模拟器上运行此应用程序，不会发生错误，但不会显示任何数据。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add two buttons and a label on the view of `MainController`. Add the namespace
    `MonoTouch.CoreMotion` in the `MainController.cs` file. Enter the following private
    field in the class:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加两个按钮和一个标签。在`MainController.cs`文件中添加命名空间`MonoTouch.CoreMotion`。在类中输入以下私有字段：
- en: '[PRE36]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Override the `ViewDidLoad` method, and implement it with the following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ViewDidLoad`方法，并使用以下代码实现它：
- en: '[PRE37]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following method:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE38]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile and run the application on the device.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Tap the **Start gyroscope** button and rotate the device in all axes. Watch
    the values displayed in the **Application Output**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始陀螺仪**按钮，并在所有轴上旋转设备。观察**应用程序输出**中显示的值。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The gyroscope is a mechanism that measures orientation. Newer iOS devices support
    gyroscope hardware, along with the accelerometer, to give even more accurate measurements
    of device motion.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪是一种测量方向的机制。较新的iOS设备支持陀螺仪硬件，以及加速度计，以提供更精确的设备运动测量。
- en: 'The `MonoTouch.CoreMotion` namespace wraps the objects contained in the native
    **CoreMotion Framework**. The process of using the gyroscope hardware in-code
    is similar to the one used for the accelerometer. The first difference is that
    there is no singleton object for the gyroscope in the `UIApplication` class. So,
    we need to create an instance of the `CMMotionManager` class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreMotion`命名空间封装了原生**CoreMotion框架**中包含的对象。在代码中使用陀螺仪硬件的过程与加速度计类似。第一个区别是`UIApplication`类中没有陀螺仪的单例对象。因此，我们需要创建`CMMotionManager`类的实例：'
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Just like using the accelerometer, we can set the interval by which we will
    be receiving gyroscope events, in seconds:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用加速度计一样，我们可以设置接收陀螺仪事件的间隔，单位为秒：
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To start receiving gyroscope events, we call the object''s `StartGyroUpdates`
    method:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始接收陀螺仪事件，我们调用对象的`StartGyroUpdates`方法：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method is overloaded; the first overload is parameterless and when called,
    the values of gyroscopic measurements are set to the `GyroData` property. Using
    this overload is quite simple and easy, but there no events are triggered, and
    we have to provide a mechanism for reading the measurements from the property.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法被重载；第一个重载是无参数的，当调用时，将陀螺仪测量的值设置为`GyroData`属性。使用此重载非常简单且容易，但没有触发任何事件，我们必须提供一个机制从属性中读取测量值。
- en: The second overload, which is used in this example, accepts two parameters.
    The first parameter is the `NSOperationQueue`, on which the updates will occur,
    and the second parameter is the handler that will be executed when an update occurs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重载，在此示例中使用，接受两个参数。第一个参数是`NSOperationQueue`，更新将在其上发生，第二个参数是当发生更新时将被执行的处理器。
- en: The `NSOperationQueue` class represents an iOS mechanism for managing `NSOperation`
    objects execution. We access the runtime's main operation queue through the static
    `NSOperationQueue.MainQueue` property. Basically, this way, we instruct the runtime
    to manage the delivery of the handler in a more effective manner.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperationQueue`类表示iOS管理`NSOperation`对象执行的一种机制。我们通过静态属性`NSOperationQueue.MainQueue`访问运行时的主操作队列。基本上，这种方式，我们指示运行时以更有效的方式管理处理器的传递。'
- en: 'The second parameter is a delegate of the type `CMGyroHandler`. Its signature,
    represented by the method we created, is like the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`CMGyroHandler`类型的委托。其签名，由我们创建的方法表示，如下所示：
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `CMGyroData` object contains the actual measurement values received from
    the gyroscope through its `RotationRate` property:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMGyroData`对象包含通过其`RotationRate`属性从陀螺仪接收的实际测量值：'
- en: '[PRE43]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The rotation rate is reflected on the `X, Y`, and `Z` axes, represented by the
    corresponding `X, Y`, and `Z` properties. Each value is the amount of rotation-angle-per-second
    that occurred on that axis, in radians.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转速率反映在`X, Y`和`Z`轴上，分别由相应的`X, Y`和`Z`属性表示。每个值是该轴上发生的每秒旋转角度的数量，以弧度为单位。
- en: Although it might seem a bit complicated at first, it is actually simple. For
    example, a value of `0.5` in the `Z-axis` means that the device rotated with a
    rate of `0.5` radians/sec to the left. A value of `-0.5` in the `Z-axis` means
    that the device rotated with a rate of `0.5` radians/sec to the right. The pattern
    for determining the rotation direction is based on the *right-hand rule*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能看起来有点复杂，但实际上很简单。例如，`Z轴`上的`0.5`值表示设备以`0.5`弧度/秒的速率向左旋转。`Z轴`上的`-0.5`值表示设备以`0.5`弧度/秒的速率向右旋转。确定旋转方向的模式基于*右手定则*。
- en: There's more...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want your application to be available only for devices that support the
    gyroscope, then add the key `UIRequiredDeviceCapabilities` in your project's `Info.plist`
    file, with the value `gyroscope`. If your application's functionality is based
    fully on the gyroscope, adding this key must be considered essential to avoid
    the application being downloaded by users with older devices, ending up with an
    application that does not work.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的应用程序仅适用于支持陀螺仪的设备，那么请在项目的`Info.plist`文件中添加键`UIRequiredDeviceCapabilities`，其值为`gyroscope`。如果您的应用程序的功能完全基于陀螺仪，添加此键必须被视为必要，以避免应用程序被使用较旧设备的用户下载，最终导致应用程序无法使用。
- en: Determining gyroscope availability
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定陀螺仪可用性
- en: To determine if the device the application is running on supports gyroscope
    hardware, check the value of the `GyroAvailable` property of the `CMMotionManager`
    instance.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定应用程序运行在的设备是否支持陀螺仪硬件，请检查`CMMotionManager`实例的`GyroAvailable`属性的值。
- en: Converting radians to degrees
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将弧度转换为度
- en: 'A radian is an angle measurement unit. To convert an angle measurement from
    radians to degrees, consider the following method:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度是角度的测量单位。要将角度测量值从弧度转换为度，请考虑以下方法：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using the accelerometer*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用加速度计*'
