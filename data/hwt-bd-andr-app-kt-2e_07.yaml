- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Android Permissions and Google Maps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 权限和 Google Maps
- en: This chapter will teach you how to request and obtain app permissions in Android.
    You will gain a solid understanding of how to include local and global interactive
    maps in your app by using the Google Maps API and how to request permissions to
    use device features that provide richer functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教您如何在 Android 中请求和获取应用权限。您将通过使用 Google Maps API 深入了解如何将本地和全局交互式地图包含到您的应用中，以及如何请求使用提供更丰富功能的设备功能的权限。
- en: By the end of the chapter, you will be able to create permission requests for
    your app and handle missing permissions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够为您的应用创建权限请求并处理缺失的权限。
- en: In the previous chapter, we learned how to present data in lists using `RecyclerView`.
    Then, we used that knowledge to present the user with a list of secret cat agents.
    In this chapter, we will learn how to find the user’s location on the map and
    how to deploy cat agents to the field by selecting locations on the map.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 `RecyclerView` 在列表中展示数据。然后，我们利用这些知识向用户展示了一个秘密猫特工的列表。在本章中，我们将学习如何在地图上找到用户的位置，以及如何通过在地图上选择位置来部署猫特工到现场。
- en: First, we will explore the Android permissions system. Many Android features
    are not immediately available to us. These features are gated behind a permission
    system to protect the user. For us to access those features, we must ask the user
    to allow us to do so. Some such features include but are not limited to obtaining
    the user’s location, accessing the user’s contacts, accessing their camera, and
    establishing a Bluetooth connection. Different Android versions enforce different
    permission rules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索 Android 权限系统。许多 Android 功能对我们来说并不是立即可用的。这些功能被权限系统所限制，以保护用户。为了访问这些功能，我们必须请求用户允许我们这样做。这些功能包括但不限于获取用户的位置、访问用户的联系人、访问他们的相机以及建立蓝牙连接。不同的
    Android 版本实施不同的权限规则。
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When Android 6 (Marshmallow) was introduced in 2015, for example, several permissions
    you could silently obtain on installation were deemed insecure and became runtime
    permissions, requiring explicit user consent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 Android 6（棉花糖）在 2015 年推出时，您可以在安装时静默获取的一些权限被认为是不安全的，并成为运行时权限，需要明确的用户同意。
- en: We will then look at the Google Maps API. This API allows us to present the
    user with a map of any desired location in the world. We will add data to that
    map and let the user interact with the map. The API also lets you show points
    of interest and render a street view of supported locations, though we will not
    explore these features in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接着查看 Google Maps API。此 API 允许我们向用户提供世界上任何期望位置的地图。我们将在该地图上添加数据，并让用户与地图进行交互。API
    还允许您显示兴趣点并渲染支持位置的道路视图，尽管我们不会在本书中探索这些功能。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Requesting permission from the user
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户那里请求权限
- en: Showing a map of the user’s location
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户的位置地图
- en: Map clicks and custom markers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图点击和自定义标记
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/6ShZd](https://packt.link/6ShZd)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有练习和活动的完整代码可在 GitHub 上找到，链接为 [https://packt.link/6ShZd](https://packt.link/6ShZd)
- en: Requesting permission from the user
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户那里请求权限
- en: Our app might want to implement certain features that Google deems dangerous.
    This usually means access to those features could risk the user’s privacy. For
    example, some permissions may allow you to read users’ messages or determine their
    current location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用可能需要实现一些谷歌认为危险的功能。这通常意味着访问这些功能可能会危及用户的隐私。例如，某些权限可能允许您读取用户的消息或确定他们的当前位置。
- en: Depending on the required permission and the target Android API level we are
    developing, we may need to request that permission from the user. If the device
    is running on Android 6 (Marshmallow, API level 23), and the target API of our
    app is 23 or higher (it almost certainly will be, as most devices by now will
    run newer versions of Android), there will be no alert for the user about any
    permissions requested by the app at install time. Instead, our app must ask the
    user to grant those permissions at runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所需的权限和目标 Android API 级别，我们可能需要请求用户授予该权限。如果设备运行在 Android 6（棉花糖，API 级别 23），并且我们的应用的目标
    API 是 23 或更高（几乎肯定是这样，因为现在大多数设备都将运行 Android 的新版本），则在安装时不会有关于应用请求的任何权限的用户警报。相反，我们的应用必须在运行时请求用户授予这些权限。
- en: When we request permission, the user sees a dialog like the one shown in *Figure
    7**.1*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求权限时，用户会看到一个类似于*图7.1*所示的对话框。
- en: '![Figure 7.1 – Permission dialog for device location access](img/B19411_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 设备位置访问权限对话框](img/B19411_07_01.jpg)'
- en: Figure 7.1 – Permission dialog for device location access
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 设备位置访问权限对话框
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full list of permissions and their protection level, see here: [https://developer.android.com/reference/android/Manifest.permission](https://developer.android.com/reference/android/Manifest.permission).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看权限及其保护级别的完整列表，请参阅此处：[https://developer.android.com/reference/android/Manifest.permission](https://developer.android.com/reference/android/Manifest.permission)。
- en: 'We must include permissions in our manifest file when we intend to use them.
    A manifest with the `SEND_SMS` permission would look something like the following
    snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打算使用权限时，我们必须在我们的清单文件中包含权限。具有`SEND_SMS`权限的清单文件可能看起来像以下片段：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Safe permissions (or normal permissions, as Google calls them) would be automatically
    granted to the user. However, dangerous ones would only be granted if explicitly
    approved by the user. If we fail to request permission from the user and try to
    execute an action that requires that permission, the result would be the action
    not running at best and our app crashing at worst.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安全权限（或谷歌称之为常规权限）将自动授予用户。然而，危险权限只有在用户明确批准的情况下才会被授予。如果我们未能从用户那里请求权限并尝试执行需要该权限的操作，最坏的结果是应用崩溃。
- en: We should first check whether the user has already granted us that permission
    before asking the user for permission. If the user has not yet granted us permission,
    we may need to check whether a rationale dialog should be shown prior to the permission
    request. This depends on how obvious the justification for the request would be
    to the user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求用户权限之前，我们应该首先检查用户是否已经授予我们该权限。如果用户尚未授予我们权限，我们可能需要检查是否需要在权限请求之前显示一个理由对话框。这取决于请求的理由对用户来说是否明显。
- en: For example, if a camera app requests permission to access the camera, we can
    safely assume the reason would be clear to the user. However, some cases may not
    be as clear to the user, especially if the user is not tech-savvy. In those cases,
    we may have to justify the request to the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个相机应用请求访问摄像头的权限，我们可以安全地假设原因对用户来说是清晰的。然而，有些情况可能对用户来说并不那么清晰，特别是如果用户不是技术达人。在这些情况下，我们可能需要向用户解释请求的理由。
- en: Google provides us with a function called `shouldShowRequestPermissionRationale(Activity,
    String)` for this purpose. Under the hood, this function checks whether the user
    has previously denied the permission but also whether the user has denied us permission
    before.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google为我们提供了一个名为`shouldShowRequestPermissionRationale(Activity, String)`的函数来实现这个目的。在底层，这个函数检查用户是否之前拒绝过该权限，同时也检查用户是否之前拒绝过我们。
- en: The idea is to allow us to justify our request to the user for permission before
    requesting it, thus increasing the likelihood of them approving the request. Once
    we determine whether the app should present the user with our rationale or whether
    no rationale was required, we can proceed to request the permission.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是让我们在请求权限之前向用户解释我们的请求理由，从而增加他们批准请求的可能性。一旦我们确定应用是否应该向用户展示我们的理由，或者是否不需要理由，我们就可以继续请求权限。
- en: 'Let’s see how we can request permission. First, we must include the Jetpack
    Activity and Fragment dependencies in our app `gradle` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何请求权限。首先，我们必须在我们的应用`gradle`文件中包含Jetpack Activity和Fragment依赖项：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will provide us with `ActivityResultLauncher`, which we will use to launch
    the permission request dialog and handle the user’s response.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供`ActivityResultLauncher`，我们将使用它来启动权限请求对话框并处理用户的响应。
- en: 'The following is an example of an `Activity` class requesting the `Location`
    permission:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个请求`Location`权限的`Activity`类的示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When `Activity` is created, we register the launcher to handle permission request
    responses. We keep a reference to the result for later use. When `Activity` is
    resumed, we check the status of the permission and continue accordingly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Activity`被创建时，我们注册启动器来处理权限请求响应。我们保留结果的引用以供以后使用。当`Activity`恢复时，我们检查权限的状态并相应地继续：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start by checking the location permission (`ACCESS_FINE_LOCATION`) by calling
    `getHas``LocationPermissions()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`getHasLocationPermissions()`来检查位置权限（`ACCESS_FINE_LOCATION`）：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function checks whether the user has granted us the requested permissions
    by calling `checkSelfPermission(Context, String)` with the requested permission.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过调用`checkSelfPermission(Context, String)`并传入请求的权限来检查用户是否授予了我们请求的权限。
- en: If the user hasn’t granted us permission, we call `shouldShowRequestPermission`
    **Rationale(Activity, String)**, which we mentioned earlier, to check whether
    a rationale dialog should be presented to the user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有授予我们权限，我们调用之前提到的`shouldShowRequestPermissionRationale(Activity, String)`来检查是否应该向用户展示理由对话框。
- en: 'If showing our rationale is needed, we call `showPermissionRationale(() ->
    Unit)`, passing in a lambda that will use `requestPermissionLauncher` to launch
    the request dialog after the user dismisses our rationale dialog using the positive
    button. If no rationale is needed, we launch the dialog with `requestPermissionLauncher`
    directly. The following code is for presenting the rationale dialog:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要显示我们的理由，我们调用`showPermissionRationale(() -> Unit)`，传入一个lambda，该lambda将在用户使用正面按钮关闭我们的理由对话框后，使用`requestPermissionLauncher`启动请求对话框。如果不需要理由，我们直接使用`requestPermissionLauncher`启动对话框。以下代码用于显示理由对话框：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `showPermissionRationale` function presents the user with a dialog with
    a brief explanation of why we need their permission. The **OK** button will execute
    the positive action provided, and the **Cancel** one will dismiss the dialog:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`showPermissionRationale`函数向用户展示一个对话框，简要解释我们为什么需要他们的权限。**确定**按钮将执行提供的正面操作，而**取消**按钮将关闭对话框：
- en: '![Figure 7.2 – Rationale dialog](img/B19411_07_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 理由对话框](img/B19411_07_02.jpg)'
- en: Figure 7.2 – Rationale dialog
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 理由对话框
- en: Lastly, we request permission by calling `requestPermissionLauncher.launch(ACCESS_FINE_LOCATION)`
    using the request permission launcher we declared earlier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用之前声明的请求权限启动器`requestPermissionLauncher.launch(ACCESS_FINE_LOCATION)`来请求权限。
- en: 'If we’ve requested the location permission from the user, the response will
    be processed by the request permission launcher depending on the value returned
    via `isGranted`, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经从用户那里请求了位置权限，请求权限启动器将根据`isGranted`返回的值处理响应，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is the expansion of the code we observed earlier, added to the `onCreate`
    function of `Activity`. This chapter will take us through the development of an
    app that shows us our current location on a map and allows us to place a marker
    where we want to deploy our secret cat agent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我们之前观察到的代码的扩展，添加到了`Activity`的`onCreate`函数中。本章将带我们开发一个应用程序，它可以在地图上显示我们的当前位置，并允许我们在想要部署我们的秘密猫特工的地方放置标记。
- en: Let’s start with our first exercise.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个练习开始。
- en: Exercise 7.01 – requesting the location permission
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01 – 请求位置权限
- en: 'In this exercise, we will request that the user provide the location permission.
    We will first create a **Google Maps Activity** project. Then, we will define
    the permission required in the manifest file. To get started, let’s implement
    the code required to request permission from the user to access their location:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将请求用户提供位置权限。我们首先创建一个**Google Maps Activity**项目。然后，我们在清单文件中定义所需的权限。要开始，让我们实现请求用户允许访问其位置的代码：
- en: 'Start by creating a new Google Maps Activity project (**File** | **New** |
    **New Project** | **Google Maps Activity**). We’re not using Google Maps in this
    exercise. However, the Google Maps Activity is still a good choice in this case.
    It will save you a lot of boilerplate coding in the next exercise (*Exercise 7.02*).
    Don’t worry; it will have no impact on your current exercise. Click **Next**,
    as shown in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Google Maps Activity项目（**文件** | **新建** | **新建项目** | **Google Maps Activity**）。在这个练习中，我们不会使用Google
    Maps。然而，在这种情况下，Google Maps Activity仍然是一个不错的选择。它将在下一个练习（*练习7.02*）中为你节省大量的样板代码。不用担心，它对你的当前练习没有任何影响。点击**下一步**，如图所示：
- en: '![Figure 7.3 – Choose your project](img/B19411_07_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 选择你的项目](img/B19411_07_03.jpg)'
- en: Figure 7.3 – Choose your project
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 选择你的项目
- en: Name your application `Cat` `Agent Deployer`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的应用程序命名为`Cat Agent Deployer`。
- en: Make sure your package name is `com.example.catagentdeployer`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的包名为`com.example.catagentdeployer`。
- en: Set the save location to where you want to save your project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目保存位置设置为你要保存项目的地方。
- en: Leave everything else at its default values and click **Finish**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有设置保留为默认值，然后点击**完成**。
- en: 'Make sure you are on the **Android** view in your **Project** pane:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在**项目**面板的**Android**视图中：
- en: '![Figure 7.4 – The Android view](img/B19411_07_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – Android 视图](img/B19411_07_04.jpg)'
- en: Figure 7.4 – The Android view
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Android 视图
- en: 'Open your `AndroidManifest.xml` file. Make sure the location permission was
    already added to your app:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `AndroidManifest.xml` 文件。确保位置权限已经添加到你的应用中：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ACCESS_FINE_LOCATION` is the permission you will need to obtain the user’s
    location based on GPS in addition to the less accurate Wi-Fi and mobile data-based
    location information you could obtain by using the `ACCESS_COARSE_LOCATION` permission.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCESS_FINE_LOCATION` 是你将需要根据 GPS 获取用户位置，以及使用 `ACCESS_COARSE_LOCATION` 权限可以获得的基于
    Wi-Fi 和移动数据的不太准确的位置信息。'
- en: 'Open your `MapsActivity.kt` file. At the bottom of the `MapsActivity` class
    block, add an empty `getLastLocation()` function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `MapsActivity.kt` 文件。在 `MapsActivity` 类块底部添加一个空的 `getLastLocation()` 函数：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will be the function you will call when you have ensured the user has granted
    you the location permission.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是当你确保用户已经授予你位置权限时将调用的函数。
- en: 'Next, add the request permission launcher to the top of the `MapsActivity`
    class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将请求权限启动器添加到 `MapsActivity` 类的顶部：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the variable through which we will launch the permission request and
    track user responses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将通过它启动权限请求并跟踪用户响应的变量。
- en: 'Now navigate to the bottom of the `onCreate()` function and register for activity
    results, storing the result in `requestPermissionLauncher`, which you declared
    in the previous step:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导航到 `onCreate()` 函数的底部并注册活动结果，将结果存储在你在上一步中声明的 `requestPermissionLauncher`
    中：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To present users with the rationale for the permission request, implement the
    `show` **PermissionRationale(() -> Unit)** function right before the `getLast``Location()`
    function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向用户展示权限请求的理由，在 `getLastLocation()` 函数之前实现 `show` **PermissionRationale(() ->
    Unit)** 函数：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function will present the user with a simple alert dialog explaining that
    the app will not work without knowing their current location, as shown in *Figure
    7**.1*. Tapping `positiveAction` lambda. Tapping **CANCEL** will dismiss the dialog.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将向用户展示一个简单的警告对话框，解释说明应用在没有知道他们当前位置的情况下无法工作，如图 *图 7**.1* 所示。点击 `positiveAction`
    lambda。点击 **取消** 将关闭对话框。
- en: 'To determine whether or not your app already has the location permission, introduce
    the following `hasLocationPermission()` function right before the `requestPermissionWithRationaleIfNeeded()`
    function:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定你的应用是否已经具有位置权限，在 `requestPermissionWithRationaleIfNeeded()` 函数之前引入以下 `hasLocationPermission()`
    函数：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, update the `onMapReady()` function of your `MapsActivity` class to
    determine the permission status and proceed accordingly:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新你的 `MapsActivity` 类的 `onMapReady()` 函数以确定权限状态并相应地执行：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `when` statement will check whether the permission was already granted.
    If not, it will check whether a rationale dialog should be presented. Then, if
    the rationale is accepted by the user or no rationale dialog is required, it will
    present a standard permission request dialog to the user (as shown in *Figure
    7**.1*), asking them to allow the app to access their location. You pass the requested
    permission you want the user to grant your app (`Manifest.permission.ACCESS_FINE_LOCATION`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 语句将检查权限是否已经授予。如果没有，它将检查是否应该显示解释对话框。然后，如果用户接受了解释或不需要解释对话框，它将向用户展示一个标准的权限请求对话框（如图
    *图 7**.1* 所示），请求他们允许应用访问他们的位置。你传递给用户请求的权限，即你希望用户授予你的应用 (`Manifest.permission.ACCESS_FINE_LOCATION`)。'
- en: Run your app. You should now see a system permission dialog requesting you to
    allow the app to access the location of the device, as shown in *Figure 7**.5*.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用。你现在应该看到一个系统权限对话框，请求你允许应用访问设备的地理位置，如图 *图 7**.5* 所示。
- en: '![Figure 7.5 – App requesting the location permission](img/B19411_07_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 应用请求位置权限](img/B19411_07_05.jpg)'
- en: Figure 7.5 – App requesting the location permission
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 应用请求位置权限
- en: If the user denies the permission, the rationale dialog will appear. If the
    rationale is accepted, the system permission dialog will show again. Up until
    SDK 31, the user had the option to choose not to let the app ask for permission
    again (*Figure 7**.6*). From SDK 31 onwards, not asking a third time is the default.
    Allowing it afterwards requires using the device settings.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拒绝权限，将显示解释对话框。如果接受了解释，系统权限对话框将再次显示。直到 SDK 31，用户可以选择不让应用再次请求权限（*图 7**.6*）。从
    SDK 31 开始，不再询问是默认设置。之后允许它需要使用设备设置。
- en: '![Figure 7.6 – The Don’t ask again message](img/B19411_07_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – “不再询问”消息](img/B19411_07_06.jpg)'
- en: Figure 7.6 – The Don’t ask again message
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – “不再询问”消息
- en: Once the user has allowed or permanently denied the permission, the dialog will
    never show again. To reset the state of your app permissions, you would have to
    manually grant it permission via the **App** **Info** interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户允许或永久拒绝权限，对话框将不再显示。要重置应用权限的状态，您必须通过**应用****信息**界面手动授予它权限。
- en: Now that we can get the location permission, we will now look into obtaining
    the user’s current location.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了位置权限，我们将现在查看如何获取用户的当前位置。
- en: Showing a map of the user’s location
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示用户的位置地图
- en: Having successfully obtained permission from the user to access their location,
    we can now ask the user’s device to provide us with its last known location. This
    is also usually the user’s current location. We will then use this location to
    present the user with a map of their current location.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功从用户那里获取访问其位置的权限后，我们现在可以要求用户的设备提供其最后已知的位置。这通常也是用户的当前位置。然后我们将使用这个位置向用户展示其当前位置的地图。
- en: To obtain the user’s last known location, Google has provided us with the Google
    Play Location service and, more specifically, with the `FusedLocationProviderClient`
    class. The `FusedLocationProviderClient` class helps us interact with Google’s
    Fused Location Provider API, which is a location API that intelligently combines
    different signals from multiple device sensors to provide us with device location
    information.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取用户最后已知的位置，谷歌为我们提供了谷歌播放位置服务，更具体地说，提供了`FusedLocationProviderClient`类。`FusedLocationProviderClient`类帮助我们与谷歌的融合位置提供者API交互，这是一个智能地结合来自多个设备传感器的不同信号以提供设备位置信息的API。
- en: 'To access the `FusedLocationProviderClient` class, we must first include the
    Google Play Location service library in our project. This simply means adding
    the following code snippet to the `dependencies` block of our `build.gradle` app:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`FusedLocationProviderClient`类，我们必须首先在我们的项目中包含谷歌播放位置服务库。这仅仅意味着将以下代码片段添加到我们的`build.gradle`应用的`dependencies`块中：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the location service imported, we can now obtain an instance of the `FusedLocation`
    **ProviderClient** class by calling `LocationServices.getFusedLocationProvider``Client(this@MainActivity)`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入位置服务后，我们现在可以通过调用`LocationServices.getFusedLocationProviderClient(this@MainActivity)`来获取`FusedLocation`**ProviderClient**类的实例。
- en: Once we have a fused location client, we can obtain the user’s last location
    by calling `fused``LocationClient.lastLocation`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了融合位置客户端，我们可以通过调用`fusedLocationClient.lastLocation`来获取用户的最后位置。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is given that we have already received the location permission from the
    user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们已经从用户那里收到位置权限的前提下。
- en: Since this is an asynchronous call, we should also provide a success listener
    as a minimum. If we wanted to, we could also add listeners for cancellation, failure,
    and the completion of requests. Calling `lastLocation` returns `Task<Location>`.
    `Task` is a Google API abstract class whose implementations perform async operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个异步调用，我们还应该提供一个最小成功监听器。如果我们想的话，我们还可以添加取消、失败和请求完成的监听器。调用`lastLocation`返回`Task<Location>`。`Task`是谷歌API的一个抽象类，其实现执行异步操作。
- en: 'In this case, that operation is returning a location. So, adding listeners
    is simply a matter of chaining calls. We will add the following code snippet to
    our call:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该操作返回一个位置。因此，添加监听器只是简单地链式调用。我们将添加以下代码片段到我们的调用中：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `location` parameter could be `null` if the client fails to obtain
    the user’s current location. This is not very common but could happen if, for
    example, the user disabled their location services during the call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果客户端未能获取用户的当前位置，`location`参数可能是`null`。这种情况并不常见，但如果例如用户在调用期间禁用了他们的位置服务，则可能会发生。
- en: Once the code inside our success listener block is executed, and `location`
    is not `null`, we have the user’s current location in the form of a `Location`
    instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功监听器块内的代码执行，并且`location`不是`null`，我们就有了用户当前的位置，形式为一个`Location`实例。
- en: A `Location` instance holds a single coordinate on Earth, expressed using longitude
    and latitude.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Location`实例在地球上持有单个坐标，使用经纬度表示。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For our purpose, it is sufficient to know that each point on the surface of
    the Earth is mapped to a single pair of **longitude** (**Lng**) and **latitude**
    (**Lat**) values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，知道地球表面的每个点都映射到一对唯一的**经度**（**Lng**）和**纬度**（**Lat**）值就足够了。
- en: This is where it gets exciting. Google lets us present any location on an interactive
    map by using a `SupportMapFragment` class. All it takes is to sign up for a free
    API key. When you create your application with a Google Maps Activity, Android
    Studio immediately opens the `AndroidManifest.xml` file. A comment in the file
    sends us to [https://packt.link/FK58V](https://packt.link/FK58V) to obtain the
    required API key. You can copy that link to your browser or press *Ctrl*/*Command*
    + click on it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是令人兴奋的地方。谷歌允许我们通过使用`SupportMapFragment`类在交互式地图上展示任何位置。只需注册一个免费的API密钥即可。当你使用Google
    Maps Activity创建你的应用程序时，Android Studio会立即打开`AndroidManifest.xml`文件。文件中的一个注释会引导我们前往[https://packt.link/FK58V](https://packt.link/FK58V)以获取所需的API密钥。你可以将此链接复制到浏览器中，或者按*Ctrl*/*Command*
    + 点击它。
- en: On the page, follow the directions and click `YOUR_API_KEY` string in the meta
    tag value with your newly obtained key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上，按照说明操作，并点击元标签值中的`YOUR_API_KEY`字符串，使用你新获得的密钥。
- en: At this point, if you run your app, you will already see an interactive map
    on your screen, as seen in *Figure 7**.7*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你运行你的应用程序，你已经在屏幕上看到了一个交互式地图，如图*图7.7*所示。
- en: '![Figure 7.7 – Interactive map](img/B19411_07_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 交互式地图](img/B19411_07_07.jpg)'
- en: Figure 7.7 – Interactive map
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 交互式地图
- en: 'To position the map based on our current location, we create a `LatLng` instance
    with the coordinates from our `Location` instance and call `moveCamera(CameraUpdate)`
    on the `GoogleMap` instance. To satisfy the `CameraUpdate` requirement, we call
    `CameraUpdateFactory.newLatLng(LatLng)`, passing in the `LatLng` parameter created
    earlier. The call would look something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据我们的当前位置定位地图，我们创建一个`LatLng`实例，其中包含来自我们的`Location`实例的坐标，并在`GoogleMap`实例上调用`moveCamera(CameraUpdate)`。为了满足`CameraUpdate`的要求，我们调用`CameraUpdateFactory.newLatLng(LatLng)`，传入之前创建的`LatLng`参数。调用看起来可能如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To discover the rest of the available `CameraUpdateFactory` options, visit [https://packt.link/EBRnt](https://packt.link/EBRnt).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现可用的`CameraUpdateFactory`选项的其余部分，请访问[https://packt.link/EBRnt](https://packt.link/EBRnt)。
- en: We could also call `newLatLngZoom(LatLng, Float)` to modify the zoom-in and
    zoom-out features of the map.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用`newLatLngZoom(LatLng, Float)`来修改地图的缩放和缩放功能。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Valid zoom values range between 2.0 (farthest) and 21.0 (closest). Values outside
    of that range are capped.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的缩放值范围在2.0（最远）到21.0（最近）之间。超出此范围的值将被限制。
- en: Some areas may not have tiles to render the closest zoom values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些区域可能没有瓦片来渲染最近的缩放值。
- en: 'We call `addMarker(MarkerOptions)` on the `GoogleMap` instance to add a marker
    at the user’s coordinate. The `MarkerOptions` parameters are configured by chaining
    calls to a `MarkerOptions()` instance. We could call `position(LatLng)` and `title(String)`
    for a simple marker at our desired position. The call would look like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GoogleMap`实例上调用`addMarker(MarkerOptions)`来在用户的坐标处添加一个标记。`MarkerOptions`参数通过链式调用`MarkerOptions()`实例进行配置。我们可以调用`position(LatLng)`和`title(String)`来为所需位置创建一个简单的标记。调用可能如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The order in which we chain the calls does not matter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链式调用顺序并不重要。
- en: Let’s practice this in the following exercise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的练习中实践一下。
- en: Exercise 7.02 – obtaining the user’s current location
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02 – 获取用户当前位置
- en: 'Now that your app can be granted location permission, you can use the location
    permission to get the user’s current location. You will then display the map and
    update it to zoom into the user’s current location and show a pin at that location.
    To do this, perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你的应用程序可以授予位置权限，你可以使用位置权限来获取用户的当前位置。然后你将显示地图，并更新它以缩放到用户的当前位置，并在该位置显示一个标记。为此，请执行以下步骤：
- en: 'First, add the Google Play location service to your `build.gradle` file. You
    should add it within the `dependencies` block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将Google Play位置服务添加到你的`build.gradle`文件中。你应该在`dependencies`块内添加它：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Click the **Sync Project with Gradle Files** button in Android Studio for Gradle
    to fetch the newly added dependency.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中点击**同步项目与Gradle文件**按钮，以便Gradle获取新添加的依赖项。
- en: 'Obtain an API key: open the `AndroidManifest.xml` file (`app/src/main/AndroidManifest.xml`)
    and *Ctrl* / *Cmd* + click the link [https://developers.google.com/maps/documentation/android-sdk/get-api-key](https://developers.google.com/maps/documentation/android-sdk/get-api-key).'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取API密钥：打开`AndroidManifest.xml`文件（`app/src/main/AndroidManifest.xml`），使用*Ctrl*
    / *Cmd* + 点击链接[https://developers.google.com/maps/documentation/android-sdk/get-api-key](https://developers.google.com/maps/documentation/android-sdk/get-api-key)。
- en: Follow the instructions on the website until you have generated a new API key.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照网站上的说明操作，直到你生成了新的API密钥。
- en: 'Update your `google_maps_api.xml` file by replacing `YOUR_API_KEY` with your
    new API key in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下代码将`google_maps_api.xml`文件中的`YOUR_API_KEY`替换为你的新API密钥：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open your `MapsActivity.kt` file. At the top of your `MapsActivity` class,
    define a lazily initialized fused location provider client:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`MapsActivity.kt`文件。在`MapsActivity`类的顶部，定义一个懒加载的融合位置提供者客户端：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By making `fusedLocationProviderClient` initialize lazily, you are ensuring
    it is only initialized when needed, which essentially guarantees the `Activity`
    class will have been created before initialization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过懒加载初始化`fusedLocationProviderClient`，你确保它仅在需要时初始化，这基本上保证了在初始化之前`Activity`类已经被创建。
- en: 'Introduce an `updateMapLocation(LatLng)` function and an `addMarkerAtLocation(LatLng,
    String)` function immediately after the `getLastLocation()` function to zoom the
    map at a given location and add a marker at that location, respectively:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getLastLocation()`函数之后立即引入一个`updateMapLocation(LatLng)`函数和一个`addMarkerAtLocation(LatLng,
    String)`函数，分别用于在给定位置放大地图和在位置处添加标记：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now update your `getLastLocation()` function to retrieve the user’s location:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新你的`getLastLocation()`函数以检索用户的位置：
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Your code requests the last location by calling `lastLocation` and then attaches
    a `lambda` function as an `OnSuccessListener` interface. Once a location is obtained,
    the `lambda` function is executed, updating the map location. The code then adds
    a marker at that location with the `You` title if a non-null location was returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码通过调用`lastLocation`请求最后位置，然后附加一个`lambda`函数作为`OnSuccessListener`接口。一旦获得位置，`lambda`函数将被执行，更新地图位置。如果返回了非空位置，代码将在该位置添加一个带有`You`标题的标记。
- en: Run your app. It should look like *Figure 7**.8*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用。它应该看起来像*图7.8*。
- en: '![Figure 7.8 – Interactive map with a marker at the current location](img/B19411_07_08.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 在当前位置带有标记的交互式地图](img/B19411_07_08.jpg)'
- en: Figure 7.8 – Interactive map with a marker at the current location
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 在当前位置带有标记的交互式地图
- en: Once the app has been granted permission, it can request the user’s last location
    from the Google Play location service via the fused location provider client.
    This gives you an easy and concise way to fetch the user’s current location. Remember
    to turn on the location on your device for the app to work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用被授予权限，它可以通过融合位置提供者客户端从Google Play位置服务请求用户的最后位置。这为你提供了一个简单且简洁的方式来获取用户的当前位置。请记住，为了应用能够工作，请确保在设备上开启位置服务。
- en: With the user’s location, your app can tell the map where to zoom and where
    to place a marker. If the user clicks on the marker, they will see the title you
    assigned to it (`You` in the exercise).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用户的当前位置，你的应用可以告诉地图如何缩放以及放置标记的位置。如果用户点击标记，他们将看到你分配给它的标题（练习中的`You`）。
- en: In the next section, we will learn how to respond to clicks on the map and how
    to move markers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何响应用户在地图上的点击以及如何移动标记。
- en: Map clicks and custom markers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图点击和自定义标记
- en: With a map showing the user’s current location by zooming in at the right location
    and placing a marker there, we have a rudimentary knowledge of how to render the
    desired map and how to obtain the required permissions and the user’s current
    location.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过放大到正确的位置并在那里放置一个标记来显示用户当前位置的地图，我们有了如何渲染所需的地图以及如何获取所需的权限和用户当前位置的基本知识。
- en: In this section, we will learn how to respond to a user interacting with the
    map and how to use markers more extensively. We will learn how to move markers
    on the map and replace the default pin marker with custom icons. When we know
    how to let the user place a marker anywhere on the map, we can let them choose
    where to deploy the secret cat agent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何响应用户与地图的交互以及如何更广泛地使用标记。我们将学习如何在地图上移动标记，并用自定义图标替换默认的图钉标记。当我们知道如何让用户在地图的任何位置放置标记时，我们可以让他们选择部署秘密猫特工的位置。
- en: 'We need to add a listener to the `GoogleMap` instance to listen for clicks
    on the map. Looking at our `MapsActivity.kt` file, the best place to do so would
    be in `onMapReady(GoogleMap)`. A naïve implementation might look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `GoogleMap` 实例添加一个监听器，以便监听地图上的点击。查看我们的 `MapsActivity.kt` 文件，这样做最好的地方是在
    `onMapReady(GoogleMap)` 中。一个简单的实现可能看起来像这样：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, if we ran this code, we’d find that a new marker is added for every
    click on the map. This is not our desired behavior.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行此代码，我们会发现每次在地图上点击都会添加一个新的标记。这不是我们期望的行为。
- en: To control a marker on the map, we need to keep a reference to that marker.
    That is achieved easily enough by keeping a reference to the output of `GoogleMap.addMarker(MarkerOptions)`.
    The `addMarker` function returns a `Marker` instance. To move a marker on the
    map, we assign a new position value to it by calling its `position` setter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制地图上的标记，我们需要保留对该标记的引用。这可以通过保留 `GoogleMap.addMarker(MarkerOptions)` 的输出来实现。`addMarker`
    函数返回一个 `Marker` 实例。要移动地图上的标记，我们通过调用其 `position` 设置器给它分配一个新的位置值。
- en: To replace the default pin icon with a custom icon, we must provide a `BitmapDescriptor`
    to the marker or the `MarkerOptions()` instance. The `BitmapDescriptor` wrappers
    work around bitmaps used by `GoogleMap` to render markers and ground overlays,
    but we won’t cover that in this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要用自定义图标替换默认的图钉图标，我们必须向标记或 `MarkerOptions()` 实例提供 `BitmapDescriptor`。`BitmapDescriptor`
    包装器绕过 `GoogleMap` 使用的位图来渲染标记和地面叠加层，但在此书中我们不会涉及这一点。
- en: We obtain `BitmapDescriptor` by using `BitmapDescriptorFactory`. The factory
    will require an asset, which can be provided in a few ways. You can provide it
    with the name of a bitmap in the `assets` directory, a `Bitmap`, a filename of
    a file in the internal storage, or a resource ID.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `BitmapDescriptorFactory` 获取 `BitmapDescriptor`。工厂将需要一个资产，可以通过几种方式提供。你可以提供
    `assets` 目录中位图的名称，一个 `Bitmap`，内部存储中文件的文件名，或者资源 ID。
- en: The factory can also create default markers of different colors. We are interested
    in the `Bitmap` option because we intend to use a vector drawable, and the factory
    does not directly support those. In addition, when converting the drawable to
    a `Bitmap`, we can manipulate it to suit our needs (for example, we could change
    its color).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂还可以创建不同颜色的默认标记。我们感兴趣的是 `Bitmap` 选项，因为我们打算使用矢量可绘制内容，而工厂不支持这些。此外，在将可绘制内容转换为
    `Bitmap` 时，我们可以根据需要对其进行操作（例如，我们可以更改其颜色）。
- en: Android Studio offers us quite a wide range of free vector `Drawables` out of
    the box. For this example, we want the `paw` drawable. To do this, right-click
    anywhere in the left Android pane, and select **New** | **Vector Asset**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 默认提供了一系列免费的矢量 `Drawables`。对于这个例子，我们想要 `paw` 可绘制内容。为此，在左侧 Android
    窗格的任何位置右键单击，然后选择 **新建** | **矢量资产**。
- en: 'Now, click the Android icon next to the **Clip Art** label for the list of
    icons (see *Figure 7**.9*):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 **剪贴画** 标签旁边的 Android 图标以获取图标列表（见 *图 7.9*）：
- en: '![Figure 7.9 – Asset Studio](img/B19411_07_09.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 资产工作室](img/B19411_07_09.jpg)'
- en: Figure 7.9 – Asset Studio
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 资产工作室
- en: 'We’ll now access a window to choose from the offered pool of clip art (*Figure
    7**.10*):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将访问一个窗口，从提供的剪贴画库中选择（*图 7.10*）：
- en: '![Figure 7.10 – Selecting an icon](img/B19411_07_010.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 选择图标](img/B19411_07_010.jpg)'
- en: Figure 7.10 – Selecting an icon
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 选择图标
- en: Once we choose an icon, we can name it, and it will be created for us as a vector
    drawable XML file. We will name it `target_icon`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个图标，我们就可以给它命名，它将作为一个矢量可绘制 XML 文件为我们创建。我们将命名为 `target_icon`。
- en: To use the created asset, we must first get it as a `Drawable` instance. This
    is done by calling `Context` **Compat.getDrawable(Context, Int)**, passing in
    the activity and `R.drawable.target_icon` as a reference to our asset. Next, we
    need to define bounds for the `Drawable` instance to draw in.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用创建的资产，我们首先必须将其作为 `Drawable` 实例获取。这是通过调用 `ContextCompat.getDrawable(Context,
    Int)` 来完成的，传入活动和 `R.drawable.target_icon` 作为我们资产的引用。接下来，我们需要为 `Drawable` 实例定义绘制边界。
- en: Calling `Drawable.setBound(Int, Int, Int, Int)` with (`0`, `0`, `drawable.intrinsic`
    **Width**, `drawable.intrinsicHeight`) will tell the drawable to draw within its
    intrinsic size.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 (`0`, `0`, `drawable.intrinsicWidth`, `drawable.intrinsicHeight`) 调用 `Drawable.setBound(Int,
    Int, Int, Int)` 将告诉可绘制内容在其固有尺寸内绘制。
- en: To change the color of our icon, we can tint it. To tint a `Drawable` instance
    in a way that is supported by devices running APIs older than `21`, we must first
    wrap our `Drawable` instance with `DrawableCompat` by calling `DrawableCompat.wrap(Drawable)`.
    The returned `Drawable` can then be tinted using `DrawableCompat.setTint(Drawable,
    Int)`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改我们图标的颜色，我们可以着色它。为了以支持运行API低于`21`的设备的方式着色`Drawable`实例，我们必须首先通过调用`DrawableCompat.wrap(Drawable)`将我们的`Drawable`实例包装在`DrawableCompat`中。然后，可以使用`DrawableCompat.setTint(Drawable,
    Int)`着色返回的`Drawable`。
- en: Next, we need to create a `Bitmap` to hold our icon. Its dimensions can match
    those of the `Drawable` bounds, and we want its `Config` to be `Bitmap.Config.ARGB_8888`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`Bitmap`来保存我们的图标。其尺寸可以与`Drawable`边界匹配，我们希望其`Config`为`Bitmap.Config.ARGB_8888`。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`8` indicates the number of bits per channel. `ARGB_8888` means we want 8-bit
    red, green, blue, and alpha channels.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`8`表示每个通道的位数。`ARGB_8888`意味着我们想要8位的红色、绿色、蓝色和alpha通道。'
- en: 'We then create a `Canvas` for the `Bitmap`, allowing us to draw our `Drawable`
    instance by calling…you guessed it, `Drawable.draw(Canvas)`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`Bitmap`创建一个`Canvas`，这样我们就可以通过调用……你猜对了，`Drawable.draw(Canvas)`来绘制我们的`Drawable`实例：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the `Bitmap` containing our icon, we are now ready to obtain a `BitmapDescriptor`
    instance from `BitmapDescriptorFactory`. Don’t forget to recycle your `Bitmap`
    afterward. This will avoid a memory leak.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含我们图标的`Bitmap`，我们现在可以从`BitmapDescriptorFactory`获取一个`BitmapDescriptor`实例。别忘了之后回收你的`Bitmap`。这将避免内存泄漏。
- en: You have learned how to present the user with a meaningful map by centering
    it on their current location and showing their current location using a custom
    marker.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何通过将地图居中在用户当前位置并使用自定义标记显示他们的当前位置来向用户提供一个有意义的地图。
- en: Exercise 7.03 – adding a custom marker where the map was clicked
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03 – 在地图点击处添加自定义标记
- en: 'In this exercise, you will respond to a user’s map click by placing a red paw-shaped
    marker at the location on the map the user clicked:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过在用户点击的地图位置放置一个红色的爪形标记来响应用户的地图点击：
- en: 'In `MapsActivity.kt` (found under `app/src/main/java/com/example/catagentdeployer`),
    right below the definition of the `mMap` variable, define a nullable `Marker`
    variable to hold a reference to the paw marker on the map:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MapsActivity.kt`文件中（位于`app/src/main/java/com/example/catagentdeployer`），在`mMap`变量定义下方，定义一个可空的`Marker`变量以保存对地图上爪形标记的引用：
- en: '[PRE25]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update `addMarkerAtLocation(LatLng, String)` to also accept a nullable `BitmapDescriptor`
    with a default value of `null`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`addMarkerAtLocation(LatLng, String)`以接受一个可空的`BitmapDescriptor`，默认值为`null`：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the `markerIcon` provided is not null, the app sets it to `MarkerOptions`.
    The function now returns the marker it added to the map.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的`markerIcon`不为null，则应用程序将其设置为`MarkerOptions`。函数现在返回它添加到地图上的标记。
- en: 'Create a `getBitmapDescriptorFromVector(Int): BitmapDescriptor?` function below
    your `addMarkerAtLocation(LatLng, String, BitmapDescriptor?): Marker` function
    to provide `BitmapDescriptor` given a `Drawable` resource ID:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在您的`addMarkerAtLocation(LatLng, String, BitmapDescriptor?)`函数下方创建一个`getBitmapDescriptorFromVector(Int):
    BitmapDescriptor?`函数，以提供给定`Drawable`资源ID的`BitmapDescriptor`：'
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function first obtains a drawable using `ContextCompat` by passing in the
    provided resource ID. It then sets the drawing bounds for the drawable, wraps
    it in `DrawableCompat`, and sets its tint to red.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先通过传递提供的资源ID使用`ContextCompat`获取一个drawable，然后设置drawable的绘制边界，将其包装在`DrawableCompat`中，并将其着色为红色。
- en: Then, it creates a `Bitmap` and a `Canvas` for that `Bitmap`, upon which it
    draws the tinted drawable. The bitmap is then returned to be used by `BitmapDescriptorFactory`
    to build `BitmapDescriptor`. Lastly, `Bitmap` is recycled to avoid a memory leak.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它创建一个`Bitmap`和一个`Canvas`，用于该`Bitmap`，在该`Canvas`上绘制着色的drawable。然后，将bitmap返回以供`BitmapDescriptorFactory`构建`BitmapDescriptor`使用。最后，回收`Bitmap`以避免内存泄漏。
- en: Before you can use the `Drawable` instance, you must first create it. Right-click
    on the Android pane, and then select **New** | **Vector Asset**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您可以使用`Drawable`实例之前，您必须首先创建它。在Android面板上右键单击，然后选择**新建** | **矢量资产**。
- en: 'In the window that opens, click on the Android icon next to the **Clip Art**
    label to select a different icon (*Figure 7**.11*):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，点击**剪贴画**标签旁边的Android图标以选择不同的图标（*图7.11*.11）：
- en: '![Figure 7.11 – Asset Studio](img/B19411_07_011.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 资产工作室](img/B19411_07_011.jpg)'
- en: Figure 7.11 – Asset Studio
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 资产工作室
- en: 'From the list of icons, select the `pets` into the search field if you can’t
    find the icon. Once you select the **pets** icon, click **OK**:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图标列表中选择 `pets` 到搜索字段中，如果你找不到图标。一旦你选择了 **pets** 图标，点击 **确定**：
- en: '![Figure 7.12 – Selecting an icon](img/B19411_07_012.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 选择图标](img/B19411_07_012.jpg)'
- en: Figure 7.12 – Selecting an icon
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 选择图标
- en: Name your icon `target_icon`. Click **Next** and **Finish**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的图标命名为 `target_icon`。点击 **下一步** 和 **完成**。
- en: 'Define an `addOrMoveSelectedPositionMarker(LatLng)` function to create a new
    marker or move it to the provided location if one has already been created. Add
    it after the `getBitmapDescriptorFromVector(Int)` function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `addOrMoveSelectedPositionMarker(LatLng)` 函数来创建一个新的标记或将它移动到提供的位置，如果已经创建了一个标记。在
    `getBitmapDescriptorFromVector(Int)` 函数之后添加它：
- en: '[PRE28]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Update your `onMapReady(GoogleMap)` function to set an `OnMapClickListener`
    event on `mMap`, which will add a marker to the clicked location or move the existing
    marker to the clicked location:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 `onMapReady(GoogleMap)` 函数，在 `mMap` 上设置一个 `OnMapClickListener` 事件，这将向点击的位置添加一个标记或将现有的标记移动到点击的位置：
- en: '[PRE29]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run your app. It should look like *Figure 7**.13*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序。它应该看起来像 *图 7**.13*。
- en: '![Figure 7.13 – The complete app](img/B19411_07_013.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 完整的应用程序](img/B19411_07_013.jpg)'
- en: Figure 7.13 – The complete app
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 完整的应用程序
- en: Clicking anywhere on the map will now move the paw icon to that location. Clicking
    the paw icon will show the **Deploy** **here** label.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击地图上的任何位置都会将爪子图标移动到该位置。点击爪子图标将显示 **部署** **此处** 标签。
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The location of the paw is a geographical one, not a screen one. That means
    if you drag your map or zoom in, the paw will move with the map and remain in
    the same geographical location.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 爪子的位置是地理上的，而不是屏幕上的。这意味着如果你拖动地图或放大，爪子会随着地图移动并保持在相同的地理位置。
- en: You now know how to respond to user clicks on the map and add and move markers
    around. You also know how to customize the appearance of markers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何响应用户在地图上的点击，并在周围添加和移动标记。你还知道如何自定义标记的外观。
- en: Activity 7.01 – creating an app to find the location of a parked car
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.01 – 创建一个查找停车位置的应用程序
- en: Some people often forget where it was that they parked their car. Let’s say
    you want to help these people by developing an app that lets the user store the
    last place they parked. The app will show a pin at the car’s location when the
    user launches the app. The user can click an **I’m parked here** button to update
    the pin location to the current location the next time they park.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人经常忘记他们停车的地方。假设你想通过开发一个允许用户存储他们最后一次停车位置的应用程序来帮助这些人。当用户启动应用程序时，应用程序将在汽车的位置显示一个图钉。用户可以点击一个
    **我停在这里** 按钮来更新下一次停车时图钉的位置。
- en: Your goal in this activity is to develop an app that shows the user a map of
    the current location. The app must first ask the user for permission to access
    their location. Make sure to also provide a rationale dialog, if needed, according
    to the SDK.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的目标是开发一个向用户显示当前位置地图的应用程序。应用程序必须首先请求用户允许访问他们的位置。根据 SDK，如果需要，请确保也提供合理的对话框。
- en: The app will show a car icon where the user last told it the car was. The user
    can click a button labeled **I’m parked here** to move the car icon to the current
    location. When the user relaunches the app, it will show the user’s current location
    and the car icon where the car was last parked.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在用户上次告诉它的汽车位置显示一个汽车图标。用户可以点击一个标签为 **我停在这里** 的按钮，将汽车图标移动到当前位置。当用户重新启动应用程序时，它将显示用户的当前位置和上次停车的汽车图标。
- en: As a bonus feature of your app, you can choose to add functionality that stores
    the car’s location so that it can be restored after the user has killed and then
    re-opened the app. This bonus functionality relies on using `SharedPreferences`;
    a concept that will be covered in [*Chapter 10*](B19411_10.xhtml#_idTextAnchor512),
    *Persisting Data*. As such, *steps 9* and *10* here will give you the required
    implementation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你应用程序的一个附加功能，你可以选择添加一个功能，用于存储汽车的位置，以便在用户关闭并重新打开应用程序后恢复。此附加功能依赖于使用 `SharedPreferences`；这是一个将在
    [*第 10 章*](B19411_10.xhtml#_idTextAnchor512)，*持久化数据* 中介绍的概念。因此，这里的 *步骤 9* 和 *步骤
    10* 将为你提供所需的实现。
- en: 'The following steps will help you complete the activity:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成活动：
- en: Create a Google Maps Activity app.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Google Maps Activity 应用程序。
- en: Obtain an API key for the app and update your `google_maps_api.xml` file with
    that key.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序获取一个 API 密钥，并使用该密钥更新你的 `google_maps_api.xml` 文件。
- en: Show a button at the bottom with an **I’m parked** **here** label.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底部显示一个带有 **我停在这里** 标签的按钮。
- en: Include the location service in your app.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用中包含位置服务。
- en: Request the user’s permission to access their location.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求用户权限以访问他们的位置。
- en: Obtain the user’s location and place a pin on the map at that location.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的位置并在该位置在地图上放置一个图钉。
- en: Add a car icon to your project.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将汽车图标添加到您的项目中。
- en: Add functionality to move the car icon to the user’s current location.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加功能以将汽车图标移动到用户的当前位置。
- en: 'Bonus step: store the selected location in `SharedPreferences`. This function,
    placed in your activity, will help you do this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奖励步骤：将选定的位置存储在`SharedPreferences`中。此函数，放置在您的活动中，将帮助您完成此操作：
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Bonus step: restore any saved location from `SharedPreferences`. You can use
    the following function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奖励步骤：从`SharedPreferences`恢复任何已保存的位置。您可以使用以下函数：
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this activity completed, you have demonstrated your understanding of requesting
    permissions in an Android app. You have also shown that you can present the user
    with a map and control pins on that map. Finally, you have also demonstrated your
    knowledge of obtaining the user’s current location. Well done.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，您已经证明了您对在Android应用中请求权限的理解。您还展示了您可以向用户展示地图并控制地图上的图钉。最后，您还展示了您获取用户当前位置的知识。做得好。
- en: Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://packt.link/By7eE](https://packt.link/By7eE)找到。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Android permissions. We touched on the reasons
    for having them and saw how we could request the user’s permission to perform
    certain tasks. We also learned how to use Google’s Maps API and how to present
    the user with an interactive map.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Android权限的内容。我们讨论了拥有权限的原因，并展示了如何请求用户权限以执行特定任务。我们还学习了如何使用Google的Maps
    API以及如何向用户展示交互式地图。
- en: Lastly, we leveraged our knowledge of presenting a map and requesting permissions
    to find out the user’s current location and present it on the map. Of course,
    there is a lot more that can be done with the Google Maps API, and you could explore
    a lot more possibilities with certain permissions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们利用了展示地图和请求权限的知识，以找出用户的当前位置并在地图上展示它。当然，使用Google Maps API还有更多可以做的事情，您可以使用某些权限探索更多可能性。
- en: You should now have enough understanding of the foundations to explore further.
    To read more about permissions, visit [https://packt.link/57BdN](https://packt.link/57BdN).
    To read more about the Maps API, visit [https://packt.link/8akrP](https://packt.link/8akrP).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对基础知识有足够的了解，可以进一步探索。要了解更多关于权限的信息，请访问[https://packt.link/57BdN](https://packt.link/57BdN)。要了解更多关于Maps
    API的信息，请访问[https://packt.link/8akrP](https://packt.link/8akrP)。
- en: In the next chapter, we will learn how to perform background tasks using `Services`
    and `WorkManager`. We will also learn how to present the user with notifications,
    even when the app is not running. These are powerful tools to have in your arsenal
    as a mobile developer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`Services`和`WorkManager`执行后台任务。我们还将学习如何在应用未运行时向用户展示通知。作为移动开发者，这些是您工具箱中非常强大的工具。
