- en: Chapter 1. Exploring Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：探索 Swift
- en: Apple announced Swift at WWDC 2014 as a new programming language that combines
    experience with the Objective-C platform and advances in dynamic and statically
    typed languages over the last few decades. Before Swift, most code written for
    iOS and OS X applications was in Objective-C, a set of object-oriented extensions
    to the C programming language. Swift aims to build upon patterns and frameworks
    of Objective-C but with a more modern runtime and automatic memory management.
    In December 2015, Apple open sourced Swift at [https://swift.org](https://swift.org)
    and made binaries available for Linux as well as OS X. The content in this chapter
    can be run on either Linux or OS X, but the remainder of the book is either Xcode-specific
    or depends on iOS frameworks that are not open source. Developing iOS applications
    requires Xcode and OS X.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司在 2014 年的 WWDC 上宣布 Swift 作为一种新的编程语言，它结合了 Objective-C 平台的经验以及过去几十年动态和静态类型语言的进步。在
    Swift 之前，大多数为 iOS 和 OS X 应用程序编写的代码都是 Objective-C，它是 C 编程语言的面向对象扩展集。Swift 旨在建立在
    Objective-C 的模式和框架之上，但具有更现代的运行时和自动内存管理。2015 年 12 月，苹果在 [https://swift.org](https://swift.org)
    上开源了 Swift，并为 Linux 以及 OS X 提供了二进制文件。本章中的内容可以在 Linux 或 OS X 上运行，但本书的其余部分要么是 Xcode
    特定的，要么依赖于非开源的 iOS 框架。开发 iOS 应用程序需要 Xcode 和 OS X。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: How to use the Swift REPL to evaluate Swift code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Swift REPL 来评估 Swift 代码
- en: The different types of Swift literals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 文字字面量的不同类型
- en: How to use arrays and dictionaries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用数组和字典
- en: Functions and the different types of function arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和不同类型的函数参数
- en: Compiling and running Swift from the command line
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行编译和运行 Swift
- en: Open source Swift
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源 Swift
- en: Apple released Swift as an open source project in December 2015, hosted at [https://github.com/apple/swift/](https://github.com/apple/swift/)
    and related repositories. Information about the open source version of Swift is
    available from the [https://swift.org](https://swift.org) site. The open-source
    version of Swift is similar from a runtime perspective on both Linux and OS X;
    however, the set of libraries available differ between the two platforms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司在 2015 年 12 月将 Swift 作为开源项目发布，托管在 [https://github.com/apple/swift/](https://github.com/apple/swift/)
    以及相关仓库中。有关 Swift 开源版本的信息可在 [https://swift.org](https://swift.org) 网站上找到。从运行时角度来看，Swift
    的开源版本在 Linux 和 OS X 上相似；然而，两个平台可用的库集合不同。
- en: For example, the Objective-C runtime was not present in the initial release
    of Swift for Linux; as a result, several methods that are delegated to Objective-C
    implementations are not available. `"hello".hasPrefix("he")` compiles and runs
    successfully on OS X and iOS but is a compile error in the first Swift release
    for Linux. In addition to missing functions, there is also a different set of
    modules (frameworks) between the two platforms. The base functionality on OS X
    and iOS is provided by the `Darwin` module, but on Linux, the base functionality
    is provided by the `Glibc` module. The `Foundation` module, which provides many
    of the data types that are outside of the base-collections library, is implemented
    in Objective-C on OS X and iOS, but on Linux, it is a clean-room reimplementation
    in Swift. As Swift on Linux evolves, more of this functionality will be filled
    in, but it is worth testing on both OS X and Linux specifically if cross platform
    functionality is required.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Objective-C 运行时最初并未包含在 Swift for Linux 的初始版本中；因此，一些委托给 Objective-C 实现的方法不可用。"`hello".hasPrefix("he")`
    在 OS X 和 iOS 上编译和运行成功，但在 Linux 的第一个 Swift 版本中是编译错误。除了缺少函数外，两个平台之间还有不同的模块（框架）。OS
    X 和 iOS 上的基本功能由 `Darwin` 模块提供，但在 Linux 上，基本功能由 `Glibc` 模块提供。`Foundation` 模块，它提供了许多在基础集合库之外的数据类型，在
    OS X 和 iOS 上用 Objective-C 实现，但在 Linux 上是一个干净的 Swift 重实现。随着 Swift 在 Linux 上的发展，更多的这些功能将被填补，但如果有跨平台功能的需求，特别值得在
    OS X 和 Linux 上进行测试。
- en: Finally, although the Swift language and core libraries have been open sourced,
    this does not apply to the iOS libraries or other functionality in Xcode. As a
    result, it is not possible to compile iOS or OS X applications from Linux, and
    building iOS applications and editing user interfaces is something that must be
    done in Xcode on OS X.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管 Swift 语言和核心库已经开源，但这并不适用于 iOS 库或其他 Xcode 中的功能。因此，无法从 Linux 编译 iOS 或 OS
    X 应用程序，并且构建 iOS 应用程序和编辑用户界面必须在 OS X 上的 Xcode 中完成。
- en: Getting started with Swift
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Swift
- en: Swift provides a runtime interpreter that executes statements and expressions.
    Swift is open source, and precompiled binaries can be downloaded from [https://swift.org/download/](https://swift.org/download/)
    for both OS X and Linux platforms. Ports are in progress to other platforms and
    operating systems but are not supported by the Swift development team.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了一个运行时解释器，用于执行语句和表达式。Swift 是开源的，可以从 [https://swift.org/download/](https://swift.org/download/)
    下载针对 OS X 和 Linux 平台的预编译二进制文件。正在对其他平台和操作系统进行端口移植，但这些移植不受 Swift 开发团队的支持。
- en: 'The Swift interpreter is called *swift* and on OS X can be launched using the
    `xcrun` command in a `Terminal.app` shell:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 解释器的名称为 *swift*，在 OS X 上可以通过在 `Terminal.app` 终端中运行 `xcrun` 命令来启动：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `xcrun` command allows a toolchain command to be executed; in this case,
    it finds `/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift`.
    The `swift` command sits alongside other compilation tools, such as `clang` and
    `ld`, and permits multiple versions of the commands and libraries on the same
    machine without conflicting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`xcrun` 命令允许执行工具链命令；在这种情况下，它找到 `/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift`。`swift`
    命令与其他编译工具（如 `clang` 和 `ld`）并列，允许在同一台机器上使用多个版本的命令和库而不会冲突。'
- en: On Linux, the `swift` binary can be executed provided that it and the dependent
    libraries are in a suitable location.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，只要 `swift` 二进制文件及其依赖库位于合适的位置，就可以执行 `swift` 二进制文件。
- en: 'The Swift prompt displays `>` for new statements and `.` for a continuation.
    Statements and expressions that are typed into the interpreter are evaluated and
    displayed. Anonymous values are given references so that they can be used subsequently:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提示符显示 `>` 用于新语句，显示 `.` 用于续行。输入到解释器的语句和表达式将被评估并显示。匿名值被赋予引用，以便随后使用：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Numeric literals
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值字面量
- en: 'Numeric types in Swift can represent both signed and unsigned integral values
    with sizes of 8, 16, 32, or 64 bits, as well as signed 32 or 64 bit floating point
    values. Numbers can include underscores to provide better readability; so, 68_040
    is the same as 68040:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的数值类型可以表示大小为 8、16、32 或 64 位的有符号和无符号整数值，以及有符号的 32 或 64 位浮点值。数字可以包含下划线以提高可读性；因此，68_040
    与 68040 相同：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Numbers can also be written in **binary**, **octal**, or **hexadecimal** using
    prefixes `0b`, `0o` (zero and the letter "o") or `0x.` Please note that Swift
    does not inherit C''s use of a leading zero (`0`) to represent an octal value,
    unlike Java and JavaScript which do. Examples include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数字也可以用 **二进制**、**八进制** 或 **十六进制** 表示，使用前缀 `0b`、`0o`（零和字母 "o"）或 `0x`。请注意，Swift
    不像 Java 和 JavaScript 那样继承 C 使用前导零 (`0`) 来表示八进制值。示例包括：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Floating point literals
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点字面量
- en: There are three floating point types that are available in Swift which use the
    IEEE754 floating point standard. The `Double` type represents 64 bits worth of
    data, while `Float` stores 32 bits of data. In addition, `Float80` is a specialized
    type that stores 80 bits worth of data (`Float32` and `Float64` are available
    as aliases for `Float` and `Double`, respectively, although they are not commonly
    used in Swift programs).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中提供了三种使用 IEEE754 浮点标准的浮点类型。`Double` 类型表示 64 位数据，而 `Float` 存储了 32 位数据。此外，`Float80`
    是一种特殊类型，存储了 80 位数据（`Float32` 和 `Float64` 分别作为 `Float` 和 `Double` 的别名，尽管在 Swift
    程序中不常用）。
- en: Some CPUs internally use 80 bit precision to perform math operations, and the
    `Float80` type allows this accuracy to be used in Swift. Not all architectures
    support `Float80` natively, so this should be used sparingly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 CPU 在内部使用 80 位精度进行数学运算，而 `Float80` 类型允许在 Swift 中使用这种精度。并非所有架构都原生支持 `Float80`，因此应谨慎使用。
- en: 'By default, floating point values in Swift use the `Double` type. As floating
    point representation cannot represent some numbers exactly, some values will be
    displayed with a rounding error; for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Swift 中的浮点值使用 `Double` 类型。由于浮点表示无法精确表示某些数字，一些值将显示为舍入误差；例如：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Floating point values can be specified in decimal or hexadecimal. Decimal floating
    point uses `e` as the exponent for base 10, whereas hexadecimal floating point
    uses `p` as the exponent for base 2\. A value of `AeB` has the value `A*10^B`
    and a value of `0xApB` has the value `A*2^B`. For example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值可以用十进制或十六进制指定。十进制浮点使用 `e` 作为 10 的底数的指数，而十六进制浮点使用 `p` 作为 2 的底数的指数。一个 `AeB`
    的值是 `A*10^B`，而一个 `0xApB` 的值是 `A*2^B`。例如：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: String literals
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'Strings can contain escaped characters, Unicode characters, and interpolated
    expressions. Escaped characters start with a slash (\) and can be one of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以包含转义字符、Unicode 字符和插值表达式。转义字符以反斜杠 (\) 开头，可以是以下之一：
- en: '`\\`: This is a literal slash `\`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`：这是一个文字斜杠 `\`'
- en: '`\0`: This is the null character'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\0`：这是一个空字符'
- en: '`\'':` This is a literal single quote `''`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\''`：这是一个文字单引号 `''`'
- en: '`\"`: This is a literal double quote `"`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`：这是一个文字双引号 `"`'
- en: '`\t`: This is a tab'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`：这是一个制表符'
- en: '`\n`: This is a line feed'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`：这是一个换行符'
- en: '`\r`: This is a carriage return'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`：这是一个回车符'
- en: '`\u{NNN}`: This is a Unicode character, such as the Euro symbol `\u{20AC}`,
    or a smiley `\u{1F600}`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u{NNN}`：这是一个 Unicode 字符，例如欧元符号 `\u{20AC}` 或笑脸 `\u{1F600}`'
- en: 'An *interpolated string* has an embedded expression, which is evaluated, converted
    into a `String`, and inserted into the result:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *插值字符串* 包含一个嵌入的表达式，该表达式将被评估，转换为 `String` 并插入到结果中：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables and constants
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和常量
- en: Swift distinguishes between variables (which can be modified) and constants
    (which cannot be changed after assignment). Identifiers start with an underscore
    or alphabetic character followed by an underscore or alphanumeric character. In
    addition, other Unicode character points (such as emoji) can be used although
    box lines and arrows are not allowed; consult the Swift language guide for the
    full set of allowable Unicode characters. Generally, Unicode private use areas
    are not allowed, and identifiers cannot start with a combining character (such
    as an accent).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 区分变量（可以修改）和常量（赋值后不能更改）。标识符以下划线或字母字符开头，后跟下划线或字母数字字符。此外，还可以使用其他 Unicode
    字符点（如表情符号），尽管不允许使用方框线和箭头；有关允许的 Unicode 字符的完整集合，请参阅 Swift 语言指南。通常，不允许使用 Unicode
    私用区域，并且标识符不能以下划线字符（如重音符号）开头。
- en: 'Variables are defined with the `var` keyword, and constants are defined with
    the `let` keyword. If the type is not specified, it is automatically inferred:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量使用 `var` 关键字定义，常量使用 `let` 关键字定义。如果未指定类型，则自动推断：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Types can be explicitly specified. For example, to store a 32 bit floating
    point value, the variable can be explicitly defined as a `Float`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式指定类型。例如，要将 32 位浮点值存储，变量可以显式定义为 `Float`：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, to store a value as an unsigned 8 bit integer, explicitly declare
    the type as `UInt8`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要将值存储为无符号 8 位整数，显式声明类型为 `UInt8`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A number can be converted to a different type using the type initializer or
    a literal that is assigned to a variable of a different type, provided that it
    does not underflow or overflow:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类型初始化器或分配给不同类型变量的文字将数字转换为不同类型，前提是它不会下溢或溢出：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Collection types
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合类型
- en: 'Swift has three collection types: *Array*, *Dictionary*, and *Set*. They are
    strongly typed and generic, which ensures that the values of types that are assigned
    are compatible with the element type. Collections that are defined with `var`
    are mutable; collections defined with `let` are immutable.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有三种集合类型：*数组*、*字典* 和 *集合*。它们是强类型和泛型的，这确保了分配给它们的类型值与元素类型兼容。使用 `var` 定义的集合是可变的；使用
    `let` 定义的集合是不可变的。
- en: 'The literal syntax for arrays uses `[]` to store a comma-separated list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的文字语法使用 `[]` 来存储逗号分隔的列表：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Literal dictionaries are defined with a comma-separated `[key:value]` format
    for entries:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文字字典使用逗号分隔的 `[key:value]` 格式定义条目：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For readability, array and dictionary literals can have a trailing comma. This
    allows initialization to be split over multiple lines, and if the last element
    ends with a trailing comma, adding new items does not result in an SCM diff to
    the previous line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，数组和字典的文字可以有一个尾随逗号。这允许初始化跨越多行，并且如果最后一个元素以尾随逗号结尾，添加新项目不会导致与上一行的 SCM 差异。
- en: 'Arrays and dictionaries can be indexed using subscript operators that are reassigned
    and added to:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用可重新分配和添加的下标运算符索引数组和字典：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sets are similar to dictionaries; the keys are unordered and can be looked
    up efficiently. However, unlike dictionaries, keys don''t have an associated value.
    As a result, they don''t have array subscripts, but they do have the `insert`,
    `remove`, and `contains` methods. They also have efficient set intersection methods,
    such as `union` and `intersect`. They can be created from an array literal if
    the type is defined or using the set initializer directly:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类似于字典；键是无序的，可以高效地查找。然而，与字典不同，键没有关联的值。因此，它们没有数组索引，但具有 `insert`、`remove` 和 `contains`
    方法。它们还有高效的集合交集方法，如 `union` 和 `intersect`。如果类型已定义，可以从数组字面量创建它们，或者直接使用集合初始化器：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When creating sets, use the explicit `Set` constructor as otherwise the type
    will be inferred to be an `Array`, which will have a different performance profile.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建集合时，请使用显式的 `Set` 构造函数，否则类型将被推断为 `Array`，这将具有不同的性能特征。
- en: Optional types
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选类型
- en: 'In the previous example, the return type of `costs["Milk"]` is `Int?` and not
    `Int`. This is an *optional type*; there may be an `Int` value or it may be empty.
    For a dictionary containing elements of type `T`, subscripting the dictionary
    will have an `Optional<T>` type, which can be abbreviated as `T?` If the value
    doesn''t exist in the dictionary, then the returned value will be `nil`. Other
    object-oriented languages, such as Objective-C, C++, Java, and C#, have optional
    types by default; any object value (or pointer) can be `null`. By representing
    optionality in the type system, Swift can determine whether a value really has
    to exist or might be `nil`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`costs["Milk"]` 的返回类型是 `Int?` 而不是 `Int`。这是一个 *可选类型*；可能有一个 `Int` 值，也可能为空。对于包含类型为
    `T` 的元素的字典，对字典进行索引将具有 `Optional<T>` 类型，可以简写为 `T?`。如果字典中不存在该值，则返回的值将是 `nil`。其他面向对象的语言，如
    Objective-C、C++、Java 和 C#，默认具有可选类型；任何对象值（或指针）都可以是 `null`。通过在类型系统中表示可选性，Swift 可以确定值是否确实存在或可能是
    `nil`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Optional types can be explicitly created using the `Optional` constructor.
    Given a value `x` of type `X`, an optional `X?` value can be created using `Optional(x)`.
    The value can be tested against `nil` to find out whether it contains a value
    and then unwrapped with `opt!`, for example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型可以使用 `Optional` 构造函数显式创建。给定一个类型为 `X` 的值 `x`，可以使用 `Optional(x)` 创建一个可选 `X?`
    值。可以通过将其与 `nil` 进行比较来测试值是否存在，然后使用 `opt!` 等展开它，例如：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If a `nil` value is unwrapped, an error occurs:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果展开了一个 `nil` 值，将发生错误：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Particularly when working with Objective-C based APIs, it is common for values
    to be declared as an optional although they are always expected to return a value.
    It is possible to declare such variables as *implicitly unwrapped optionals*;
    these variables behave as optional values (they may contain `nil`), but when the
    value is accessed, they are automatically unwrapped on demand:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在处理基于 Objective-C 的 API 时，通常会将值声明为可选，尽管始终期望它们返回一个值。可以将此类变量声明为 *隐式展开的可选值*；这些变量的行为类似于可选值（它们可能包含
    `nil`），但在访问值时，它们会根据需要自动展开：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In general, implicitly unwrapped optionals should be avoided as they are likely
    to lead to errors. They are mainly useful for interaction with existing Objective-C
    APIs when the value is known to have an instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免隐式展开的可选值，因为它们很可能会导致错误。它们主要用于与已知具有实例值的现有 Objective-C API 进行交互：
- en: Nil coalescing operator
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nil 合并运算符
- en: 'Swift has a *nil coalescing operator*, which is similar to Groovy''s `?:` operator
    or C#''s `??` operator. This provides a means to specify a default value if an
    expression is `nil`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一个 *nil 合并运算符*，类似于 Groovy 的 `?:` 运算符或 C# 的 `??` 运算符。这提供了一种在表达式为 `nil`
    时指定默认值的方法：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `nil` coalescing operator can also be used to unwrap an optional value.
    If the optional value is present, it is unwrapped and returned; if it is missing,
    then the right-hand side of the expression is returned. Similar to the `||` shortcut,
    and the `&&` operators, the right-hand side is not evaluated unless necessary:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`nil` 合并运算符也可以用来展开可选值。如果可选值存在，它将被展开并返回；如果不存在，则返回表达式的右侧值。类似于 `||` 短路和 `&&` 运算符，除非必要，否则右侧不会进行评估：'
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Conditional logic
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件逻辑
- en: 'There are three key types of conditional logic in Swift (known as branch statements
    in the grammar): the `if` statement, the `switch` statement, and the `guard` statement.
    Unlike other languages, the body of the `if` must be surrounded with braces `{}`;
    and if typed in at the interpreter, the `{` opening brace must be on the same
    line as the `if` statement. The `guard` statement is a specialized `if` statement
    for use with functions and is covered in the section on functions later in this
    chapter.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有三种主要的条件逻辑类型（在语法中称为分支语句）：`if`语句、`switch`语句和`guard`语句。与其他语言不同，`if`的主体必须用大括号`{}`包围；如果在使用解释器时输入，则大括号`{`必须与`if`语句在同一行上。`guard`语句是一个用于函数的特殊`if`语句，将在本章后面的函数部分介绍。
- en: If statements
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: If语句
- en: 'Conditionally unwrapping an optional value is so common that a specific Swift
    pattern *optional binding* has been created to avoid evaluating the expression
    twice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 条件性地解包可选值如此常见，以至于Swift创建了一个特定的模式**可选绑定**来避免对表达式进行两次评估：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `if` block only executes if the optional value exists. The definition of
    the `cc` constant only exists for the body of the `if` block, and it does not
    exist outside of that scope. Furthermore, `cc` is a non-optional type, so it is
    guaranteed not to be `nil`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当可选值存在时，`if`块才会执行。`cc`常量的定义仅存在于`if`块的主体中，并且在该作用域之外不存在。此外，`cc`是一个非可选类型，因此它保证不会是`nil`。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift 1 only allowed a single `let` assignment in an `if` block causing a pyramid
    of nested `if` statements. Swift 2 allows multiple comma-separated `let` assignments
    in a single `if` statement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 1只允许在`if`块中有一个`let`赋值，导致嵌套的`if`语句形成金字塔。Swift 2允许在单个`if`语句中使用多个以逗号分隔的`let`赋值。
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To execute an alternative block if the item cannot be found, an `else` block
    can be used:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到项目，可以使用`else`块来执行替代块：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other boolean expressions can include the `true` and `false` literals, and any
    expression that conforms to the `BooleanType` protocol, the `==` and `!=` equality
    operators, the `===` and `!==` identity operators, as well as the `<`, `<=`, `>`,
    and `>=` comparison operators. The `is type` operator provides a test to see whether
    an element is of a particular type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 其他布尔表达式可以包括`true`和`false`字面量，以及任何符合`BooleanType`协议的表达式，`==`和`!=`相等运算符，`===`和`!==`身份运算符，以及`<`、`<=`、`>`和`>=`比较运算符。`is
    type`运算符提供了一个测试，以查看元素是否为特定类型。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The difference between the equality operator and the identity operator is relevant
    for classes or other reference types. The equality operator asks *Are these two
    values equivalent to each other?*, whereas the identity operator asks *Are these
    two references equal to each other?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 等于运算符和身份运算符之间的区别对于类或其他引用类型是相关的。等于运算符询问“这两个值是否彼此等效？”，而身份运算符询问“这两个引用是否彼此相等？”
- en: There is a boolean operator that is specific to Swift, which is the `~=` *pattern
    match operator*. Despite the name, this isn't anything to do with regular expressions;
    rather, it's a way of asking whether a pattern matches a particular value. This
    is used in the implementation of the `switch` block, which is covered in the next
    section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有一个特定的布尔运算符，即`~=`**模式匹配运算符**。尽管名称如此，但这与正则表达式无关；相反，它是一种询问模式是否与特定值匹配的方法。这在`switch`块的实现中使用，下一节将介绍。
- en: 'As well as the `if` statement, there is a *ternary if expression* that is similar
    to other languages. After a condition, a question mark (?) is used followed by
    an expression to be used if the condition is true, then a colon (:) followed by
    the false expression:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`if`语句外，还有一个类似于其他语言的**三元if表达式**。在条件之后，使用一个问号(?)，然后是一个当条件为真时使用的表达式，然后是一个冒号(:)，后面是当条件为假时使用的表达式：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Switch statements
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Switch语句
- en: Swift has a `switch` statement that is similar to C and Java's `switch`. However,
    it differs in two important ways. Firstly, `case` statements no longer have a
    default fall-through behavior (so there are no bugs introduced by missing a `break`
    statement), and secondly, the value of the `case` statements can be expressions
    instead of values, pattern matching on type and range. At the end of the corresponding
    `case` statement, the evaluation jumps to the end of the `switch` block unless
    the `fallthrough` keyword is used. If no `case` statements match, the `default`
    statements are executed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一个类似于 C 和 Java 的 `switch` 语句。然而，它在两个方面有所不同。首先，`case` 语句不再有默认的穿透行为（因此不会因为缺少
    `break` 语句而引入错误），其次，`case` 语句的值可以是表达式而不是值，进行类型和范围的模式匹配。在相应的 `case` 语句的末尾，评估将跳转到
    `switch` 块的末尾，除非使用了 `fallthrough` 关键字。如果没有 `case` 语句匹配，则执行 `default` 语句。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `default` statement is required when the list of cases is not exhaustive.
    If they are not, the compiler will give an error saying that the list is not exhaustive
    and that a `default` statement is required.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当情况列表不是详尽无遗的时候，需要有一个 `default` 语句。如果不是，编译器将给出错误，指出列表不是详尽无遗的，并且需要 `default` 语句。
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the expression prints out `First`, `Second`, or `Third`
    if the position is `1`, `2`, or `3`, respectively. For numbers between `4` and
    `20` (inclusive), it prints out the position with a `th` ordinal. Otherwise, for
    numbers that end with 1, it prints `st`; for numbers that end with 2, it prints
    `nd`, and for numbers that end with 3, it prints `rd`. For all other numbers it
    prints `th`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果位置是 `1`、`2` 或 `3`，表达式将分别打印出 `First`、`Second` 或 `Third`。对于 `4` 到 `20`（包含）之间的数字，它将打印出带有
    `th` 后缀的位置。否则，对于以 `1` 结尾的数字，它将打印 `st`；对于以 `2` 结尾的数字，它将打印 `nd`；对于以 `3` 结尾的数字，它将打印
    `rd`。对于所有其他数字，它将打印 `th`。
- en: 'The `4...20` range expression in a `case` statement represents a pattern. If
    the value of the expression matches that pattern, then the corresponding statements
    will be executed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句中的 `4...20` 范围表达式代表一个模式。如果表达式的值与该模式匹配，则将执行相应的语句：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are two range operators in Swift: an inclusive or *closed range*, and
    an exclusive or *half-open range*. The closed range is specified with three dots;
    so `1...12` will give a list of integers between one and twelve. The half-open
    range is specified with two dots and a less than operator; so `1..<10` will provide
    integers from 1 to 9 but excluding 10.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种范围运算符：包含或 *闭范围* 和排除或 *半开范围*。闭范围用三个点指定；因此 `1...12` 将给出介于 1 和 12 之间的整数列表。半开范围用两个点和小于运算符指定；因此
    `1..<10` 将提供从 1 到 9 的整数，但不包括 10。
- en: The `where` clause in the `switch` block allows an arbitrary expression to be
    evaluated provided that the pattern matches. These are evaluated in order, in
    the sequence they are in the source file. If a `where` clause evaluates to `true`,
    then the corresponding set of statements will be executed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 块中的 `where` 子句允许评估任意表达式，前提是模式匹配。这些表达式按顺序评估，即它们在源文件中的顺序。如果 `where`
    子句评估为 `true`，则将执行相应的语句集。'
- en: The `let` variable syntax can be used to define a constant that refers to the
    value in the `switch` block. This local constant can be used in the `where` clause
    or the corresponding statements for that specific case. Alternatively, variables
    can be used from the surrounding scope.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `let` 变量语法来定义一个常量，该常量引用 `switch` 块中的值。这个局部常量可以在 `where` 子句或对应的具体情况的语句中使用。或者，也可以使用周围作用域中的变量。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If multiple `case` statements need to match the same pattern, they can be separated
    with commas as an expression list. Alternatively, the `fallthrough` keyword can
    be used to allow the same implementation to be used for multiple `case` statements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要匹配多个 `case` 语句的相同模式，它们可以用逗号作为表达式列表分隔。或者，可以使用 `fallthrough` 关键字来允许为多个 `case`
    语句使用相同的实现。
- en: Iteration
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: 'Ranges can be used to iterate a fixed number of times, for example, `for i
    in 1...12`. To print out these numbers, a loop such as the following can be used:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用范围来迭代固定次数，例如，`for i in 1...12`。要打印这些数字，可以使用如下循环：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the number is not required, then an underscore (`_`) can be used as a hole
    to act as a throwaway value. An underscore can be assigned to but not read:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字不是必需的，则可以使用下划线 (`_`) 作为占位符来充当废弃值。下划线可以被赋值但不能被读取：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, it is more common to iterate over a collection''s contents using a
    `for in` pattern. This steps through each of the items in the collection, and
    the body of the `for` loop is executed over each one:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更常见的是使用 `for in` 模式遍历集合的内容。这会遍历集合中的每个项目，并且 `for` 循环的主体会针对每个项目执行：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To iterate over a dictionary, it is possible to extract the keys or the values
    and process them as an array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历字典，可以提取键或值并将它们作为数组处理：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of keys in a dictionary is not guaranteed; as the dictionary changes,
    the order may change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中键的顺序是不保证的；随着字典的变化，顺序可能会改变。
- en: 'Converting a dictionary''s values to an array will result in a copy of the
    data being made, which can lead to poor performance. As the underlying `keys`
    and `values` are of a `LazyMapCollection` type, they can be iterated over directly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典的值转换为数组将导致创建数据的副本，这可能导致性能不佳。由于底层 `keys` 和 `values` 是 `LazyMapCollection`
    类型，它们可以直接遍历：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To print out all the keys in a dictionary, the `keys` property can be used
    with a `for in` loop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出字典中的所有键，可以使用 `keys` 属性与 `for in` 循环一起使用：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Iterating over keys and values in a dictionary
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历字典中的键和值
- en: 'Traversing a dictionary to obtain all of the keys and then subsequently looking
    up values will result in searching the data structure twice. Instead, both the
    key and the value can be iterated at the same time, using a *tuple*. A tuple is
    like a fixed-sized array, but one that allows assigning pairs (or more) of values
    at a time:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典以获取所有键，然后随后查找值将导致在数据结构中搜索两次。相反，可以使用 *元组* 同时遍历键和值。元组类似于固定大小的数组，但它允许一次分配一对（或更多）值：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Tuples can be used to iterate pairwise over both the keys and values of a dictionary:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用元组对字典的键和值进行成对迭代：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both `Array` and `Dictionary` conform to the `SequenceType` protocol, which
    allows them to be iterated with a `for in` loop. Collections (as well as other
    objects, such as `Range`) that implement `SequenceType` have a `generate` method,
    which returns a `GeneratorType` that allows the data to be iterated over. It is
    possible for custom Swift objects to implement `SequenceType` to allow them to
    be used in a `for in` loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 和 `Dictionary` 都遵守 `SequenceType` 协议，这使得它们可以用 `for in` 循环进行迭代。实现 `SequenceType`
    的集合（以及其他对象，如 `Range`）有一个 `generate` 方法，它返回一个 `GeneratorType`，允许遍历数据。自定义 Swift
    对象可以实现 `SequenceType` 以允许它们在 `for in` 循环中使用。'
- en: Iteration with for loops
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 for 循环进行迭代
- en: Although the most common use of the `for` operator in Swift is in a `for in`
    loop, it is also possible (in Swift 1 and 2) to use a more traditional form of
    the `for` loop. This has an initialization, a condition that is tested at the
    start of each loop, and a step operation that is evaluated at the end of each
    loop. Although the parentheses around the `for` loop are optional, the braces
    for the block of code are mandatory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Swift 中 `for` 运算符最常见的使用是在 `for in` 循环中，但在 Swift 1 和 2 中也可以使用更传统的 `for` 循环形式。这有一个初始化部分，一个在每个循环开始时测试的条件，以及一个在每个循环结束时评估的步进操作。虽然
    `for` 循环周围的括号是可选的，但代码块的括号是强制性的。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It has been proposed that both the traditional `for` loop and the increment/decrement
    operators should be removed from Swift 3\. It is recommended that these forms
    of loops be avoided where possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有提议说，传统的 `for` 循环和增量/减量运算符都应该从 Swift 3 中移除。建议尽可能避免这些循环形式。
- en: 'Calculating the sum of integers between 1 and 10 can be performed without using
    the range operator:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 计算介于 1 和 10 之间的整数的和可以不使用范围运算符：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If multiple variables need to be updated in the `for` loop, Swift has an *expression
    list* that is a set of comma-separated expressions. To step through two sets of
    variables in a for loop, the following can be used:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在 `for` 循环中更新多个变量，Swift 有一个 *表达式列表*，它是一组以逗号分隔的表达式。要遍历两个变量的集合，可以使用以下方法：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Apple recommends the use of `++i` instead of `i++` (and conversely, `--i` instead
    of `i--`) because they will return the result of `i` after the operation, which
    may be the expected value. As noted earlier, these operators may be removed in
    a future version of Swift.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 推荐使用 `++i` 而不是 `i++`（以及相反的，`--i` 而不是 `i--`），因为它们会在操作后返回 `i` 的值，这可能是预期的值。如前所述，这些运算符可能在
    Swift 的未来版本中被移除。
- en: Break and continue
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言和继续
- en: The `break` statement leaves the innermost loop early, and control jumps to
    the end of the loop. The `continue` statement takes execution to the top of the
    innermost loop and the next item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句会提前退出最内层的循环，并将控制权跳转到循环的末尾。`continue`语句会将执行权带到最内层循环的顶部和下一个项目。'
- en: 'To *break* or *continue* from nested loops, a *label* can be used. Labels in
    Swift can only be applied to a loop statement, such as `while` or `for`. A label
    is introduced by an identifier and a colon just before the loop statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要从嵌套循环中*跳出*或*继续*，可以使用一个*标签*。Swift中的标签只能应用于循环语句，如`while`或`for`。标签通过一个标识符和一个冒号在循环语句之前引入：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Functions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions can be created using the `func` keyword, which takes a set of arguments
    and a body of statements. The `return` statement can be used to leave a function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`func`关键字创建函数，它包含一组参数和一组语句。可以使用`return`语句来退出函数：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The return type of the function is specified after the arguments with an arrow
    (`->`). If missing, the function cannot return a value; if present, the function
    must return a value of that type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回类型在参数之后指定，后面跟着一个箭头（`->`）。如果省略，则函数不能返回值；如果存在，则函数必须返回该类型的值。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The underscore (`_`) on the front of the `costs` parameter is required to avoid
    it being a named argument. The second and subsequent arguments in Swift functions
    are implicitly named. To ensure that it is treated as a positional argument, the
    `_` before the argument name is required.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`costs`参数前面的下划线（`_`）是必需的，以避免它成为一个命名参数。Swift函数中的第二个及以后的参数是隐式命名的。为了确保它被当作位置参数处理，需要在参数名称前加上下划线`_`。
- en: Functions with *positional arguments* can be called with parentheses, such as
    the `costOf(shopping,costs)` call. If a function takes no arguments, then the
    parentheses are still required.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 带有*位置参数*的函数可以通过括号调用，例如`costOf(shopping,costs)`调用。如果一个函数没有参数，则仍然需要括号。
- en: The `foo()` expression calls the `foo` function with no argument. The `foo`
    expression represents the function itself, so an expression, such as `let copyOfFoo
    = foo`, results in a copy of the function; as a result, `copyOfFoo()` and `foo()`
    have the same effect.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()`表达式调用没有参数的`foo`函数。`foo`表达式代表函数本身，因此一个表达式，如`let copyOfFoo = foo`，会导致函数的一个副本；因此，`copyOfFoo()`和`foo()`具有相同的效果。'
- en: Named arguments
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Swift also supports *named arguments*, which can either use the name of the
    variable or can be defined with an *external parameter name*. To modify the function
    to support calling with `basket` and `prices` as argument names, the following
    can be done:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还支持*命名参数*，可以使用变量的名称或使用*外部参数名称*定义。为了修改函数以支持使用`basket`和`prices`作为参数名称进行调用，可以执行以下操作：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example defines external parameter names `basket` and `prices` for the
    function. The function signature is often referred to as `costOf(basket:prices:)`
    and is useful when it may not be clear what the arguments are for (particularly
    if they are of the same type).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例为函数定义了外部参数名称`basket`和`prices`。函数签名通常被称为`costOf(basket:prices:)`，当参数的作用不明确时（尤其是如果它们是同一类型）非常有用。
- en: Optional arguments and default values
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数和默认值
- en: Swift functions can have *optional arguments* by specifying *default values*
    in the function definition. When the function is called, if an optional argument
    is missing, the default value for that argument is used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Swift函数可以通过在函数定义中指定*默认值*来具有*可选参数*。当函数被调用时，如果缺少可选参数，则使用该参数的默认值。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An optional argument is one that can be omitted in the function call rather
    than a required argument that takes an optional value. This naming is unfortunate.
    It may help to think of these as default arguments rather than optional arguments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数是可以省略的函数调用参数，而不是必须的参数，它接受一个可选值。这种命名是不幸的。将其视为默认参数而不是可选参数可能会有所帮助。
- en: A default parameter value is specified after the type in the function signature,
    with an equals (`=`) and then the expression. This expression is re-evaluated
    each time the function is called without a corresponding argument.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数值在函数签名中的类型之后指定，后面跟着一个等号（`=`）然后是表达式。每次函数被调用而没有相应的参数时，此表达式都会重新评估。
- en: 'In the `costOf` example, instead of passing the value of `costs` each time,
    it could be defined with a default parameter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`costOf`示例中，而不是每次传递`costs`的值，它可以定义为一个默认参数：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Please note that the captured `costs` variable is bound when the function is
    defined.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，捕获的`costs`变量在函数定义时被绑定。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To use a named argument as the first parameter in a function, the argument name
    has to be duplicated. Swift 1 used a hash (`#`) to represent an implicit parameter
    name, but this was removed from Swift 2.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中将命名参数用作第一个参数，必须重复参数名称。Swift 1 使用哈希（`#`）来表示隐式参数名称，但这个特性在Swift 2中被移除。
- en: Guards
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫
- en: It is a common code pattern for a function to require arguments that meet certain
    conditions before the function can run successfully. For example, an optional
    value must have a value or an integer argument must be in a certain range.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常需要满足某些条件的参数才能成功运行。例如，可选值必须有值，或者整型参数必须在某个范围内。
- en: 'Typically, the pattern to implement this is either to have a number of `if`
    statements that break out of the function at the top, or to have an `if` block
    wrapping the entire method body:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，实现此模式的模式是有一系列`if`语句，在顶部跳出函数，或者有一个`if`块包裹整个方法主体：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Both of these approaches have drawbacks. In the first case, the condition has
    been negated; instead of looking for valid values, it's checking for invalid values.
    This can cause subtle bugs to creep in; for example, `card < 1 && card > 13` would
    never succeed, but it may inadvertently pass a code review. There's also the problem
    of what happens if the block doesn't `return` or `break`; it could be perfectly
    valid Swift code but still include errors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有缺点。在第一种情况下，条件已经被否定；不是寻找有效值，而是在检查无效值。这可能会导致微妙的错误悄悄出现；例如，`card < 1 && card
    > 13`永远不会成功，但它可能会无意中通过代码审查。还有如果块没有`return`或`break`会发生什么的问题；它可能是完全有效的Swift代码，但仍然包含错误。
- en: In the second case, the main body of the function is indented at least one level
    in the body of the `if` statement. When multiple conditions are required, there
    may be many nested `if` statements, each with their own error handling or cleanup
    requirements. If new conditions are required, then the body of the code may be
    indented even further, leading to code churn in the repository even when only
    whitespace has changed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，函数的主体在`if`语句的主体中至少缩进一个级别。当需要多个条件时，可能会有许多嵌套的`if`语句，每个都有自己的错误处理或清理要求。如果需要新的条件，则代码的主体可能需要进一步缩进，导致即使只有空白发生变化，仓库中的代码也会发生
    churn。
- en: 'Swift 2 adds a `guard` statement, which is conceptually identical to an `if`
    statement, except that it only has an `else` clause body. In addition, the compiler
    checks that the `else` block returns from the function, either by returning or
    by throwing an exception:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 添加了`guard`语句，从概念上讲与`if`语句相同，但它只有一个`else`子句体。此外，编译器检查`else`块是否从函数返回，无论是通过返回还是抛出异常：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Swift compiler checks that the `guard` `else` block leaves the function,
    and reports a compile error if it does not. Code that appears after the `guard`
    statement can guarantee that the value is in the `1...13` range without having
    to perform further tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Swift编译器检查`guard``else`块是否离开函数，如果没有，则报告编译错误。在`guard`语句之后的代码可以保证值在`1...13`范围内，而无需进行进一步测试。
- en: 'The `guard` block can also be used to perform *optional binding*; if the `guard`
    condition is a `let` assignment that performs an optional test, then the code
    that is subsequent to the `guard` statement can use the value without further
    unwrapping:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`块也可以用来执行*可选绑定*；如果`guard`条件是一个执行可选测试的`let`赋值，那么`guard`语句之后的代码可以使用该值而无需进一步展开：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As the `first` element of an array is an optional value, the `guard` test here
    acquires the value and unwraps it. When it is used later in the function, the
    unwrapped value is available for use without requiring further unwrapping.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组的第一元素是可选值，这里的`guard`测试获取了该值并展开了它。当它在函数的后续部分使用时，展开的值可用于使用，而无需进一步展开。
- en: Multiple return values and arguments
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重返回值和参数
- en: 'So far, the examples of functions have all returned a single type. What happens
    if there is more than one return result from a function? In an object-oriented
    language, the answer is to return a class; however, Swift has tuples, which can
    be used to return multiple values. The type of a tuple is the type of its constituent
    parts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，函数的示例都只返回单一类型。如果一个函数有多个返回结果会发生什么？在面向对象的语言中，答案是返回一个类；然而，Swift 有元组，可以用来返回多个值。元组的类型是其组成部分的类型：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This can be used to return multiple values from the function; instead of just
    returning one value, it is possible to return a tuple of values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来从函数中返回多个值；而不是只返回一个值，可以返回一个值的元组。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift also has in-out arguments, which will be seen in the *Handling errors*
    section of [Chapter 6](part0045_split_000.html#1AT9A2-d7e55eb5242648e89c396442afe4f84b
    "Chapter 6. Parsing Networked Data"), *Parsing Networked Data*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还有输入输出参数，这将在[第6章](part0045_split_000.html#1AT9A2-d7e55eb5242648e89c396442afe4f84b
    "第6章。解析网络数据")的*处理错误*部分中看到，*解析网络数据*。
- en: Separately, it is also possible to take a variable number of arguments. A function
    can easily take an array of values with `[]`, but Swift provides a mechanism to
    allow calling with multiple arguments, using a *variadic* parameter, which is
    denoted as an ellipses (…) after the type. The value can then be used as an array
    in the function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 分别，也可以接受可变数量的参数。一个函数可以轻松地使用`[]`接受值数组，但Swift提供了一个机制，允许使用*可变参数*调用，这表示在类型后面的省略号（…）。然后可以将该值用作函数中的数组。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift 1 only allowed the variadic argument as the last argument; Swift 2 relaxed
    that restriction to allow a single variadic argument to appear anywhere in the
    function's parameters.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 1只允许可变参数作为最后一个参数；Swift 2放宽了这一限制，允许在函数参数中任何位置出现单个可变参数。
- en: 'Taken together, these two features allow the creation of a `minmax` function,
    which returns both the minimum and maximum from a list of integers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这两个特性，可以创建一个`minmax`函数，它从整数列表中返回最小值和最大值：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `numbers:Int…` argument indicates that a variable number of arguments can
    be passed into the function. Inside the function, it is processed as an ordinary
    array; in this case, iterating through using a `for in` loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers:Int…`参数表示可以传递多个参数到函数中。在函数内部，它被处理为一个普通数组；在这种情况下，使用`for in`循环迭代。'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Int.max` is a constant representing the largest `Int` value, and `Int.min`
    is a constant representing the smallest `Int` value. Similar constants exist for
    other integral types, such as `UInt8.max`, and `Int64.min`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int.max`是一个表示最大`Int`值的常量，而`Int.min`是一个表示最小`Int`值的常量。对于其他整数类型，也存在类似的常量，例如`UInt8.max`和`Int64.min`。'
- en: 'What if no arguments are passed in? If run on a 64 bit system, then the output
    will be:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传入参数呢？如果在64位系统上运行，那么输出将是：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This may not make sense for a `minmax` function. Instead of returning an error
    value or a default value, the type system can be used. By making the tuple optional,
    it is possible to return a `nil` value if it doesn''t exist, or a tuple if it
    does:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对`minmax`函数没有意义。而不是返回错误值或默认值，可以使用类型系统。通过使元组为可选，如果不存在，则可以返回`nil`值，如果存在，则返回元组：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Returning an optional value allows the caller to determine what should happen
    in cases where the maximum and minimum are not present.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可选值允许调用者确定在最大值和最小值不存在的情况下应该发生什么。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If a function does not always have a valid return value, use an optional type
    to encode that possibility into the type system.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数不总是有一个有效的返回值，使用可选类型将这种可能性编码到类型系统中。
- en: Returning structured values
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回结构化值
- en: A tuple is an ordered set of data. The entries in the tuple are ordered, but
    it can quickly become unclear as to what data is stored, particularly if they
    are of the same type. In the `minmax` tuple, it is not clear which value is the
    minimum and which value is the maximum, and this can lead to subtle programming
    errors later on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是有序数据集。元组中的条目是有序的，但很快就会变得不清楚存储了哪些数据，尤其是如果它们是相同类型的话。在`minmax`元组中，不清楚哪个值是最小值，哪个值是最大值，这可能导致后续的微妙编程错误。
- en: A structure (`struct`) is like a tuple but with named values. This allows members
    to be accessed by name instead of by position, leading to fewer errors and greater
    transparency. Named values can be added to tuples as well; in essence, tuples
    with named values are anonymous structures.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体（`struct`）就像一个元组，但是具有命名值。这允许通过名称而不是位置来访问成员，从而减少错误并提高透明度。命名值也可以添加到元组中；本质上，具有命名值的元组是匿名结构体。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Structs are passed in a copy-by-value manner like tuples. If two variables are
    assigned the same struct or tuple, then changes to one do not affect the values
    of another.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体以值复制的方式传递，就像元组一样。如果两个变量被分配了相同的结构体或元组，那么对一个的更改不会影响另一个的值。
- en: 'A `struct` is defined with the `struct` keyword and has variables or values
    in the body:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `struct` 关键字定义 `struct` 并在主体中包含变量或值：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This defines a `MinMax` type, which can be used in place of any of the types
    that are seen so far. It can be used in the `minmax` function to return a `struct`
    instead of a tuple:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个 `MinMax` 类型，它可以替代迄今为止看到的任何类型。它可以在 `minmax` 函数中使用来返回一个 `struct` 而不是元组：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `struct` is initialized with a type initializer; if `MinMax()` is used,
    then the default values for each of the structure types are given (based on the
    structure definition), but these can be overridden explicitly if desired with
    `MinMax(min:-10,max:11)`. For example, if the `MinMax` struct is defined as `struct
    MinMax { var min:Int = Int.max; var max:Int = Int.min }`, then `MinMax()` will
    return a structure with the appropriate minimum and maximum values filled in.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 使用类型初始化器进行初始化；如果使用 `MinMax()`，则每个结构类型默认值（基于结构定义）将被给出，但如果需要，可以使用 `MinMax(min:-10,max:11)`
    明确覆盖这些值。例如，如果 `MinMax` 结构定义为 `struct MinMax { var min:Int = Int.max; var max:Int
    = Int.min }`，则 `MinMax()` 将返回一个填充了适当的最小和最大值的结构。'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a structure is initialized, all the non-optional fields must be assigned.
    They can be passed in as named arguments in the initializer or specified in the
    structure definition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构初始化时，所有非可选字段都必须被分配。它们可以作为命名参数传递给初始化器或在结构定义中指定。
- en: Swift also has classes; these are covered in the Swift classes section in the
    next chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还具有类；这些将在下一章的 Swift 类部分中介绍。
- en: Error handling
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: In the original Swift release, error handling consisted of either returning
    a `Bool` or an optional value from function results. This tended to work inconsistently
    with Objective-C, which used an optional `NSError` pointer on various calls that
    was set if a condition had occurred.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 的原始版本中，错误处理由函数结果返回的 `Bool` 或可选值组成。这通常与 Objective-C 的工作不一致，Objective-C
    在各种调用中使用可选 `NSError` 指针，如果发生条件，则设置该指针。
- en: Swift 2 adds an exception-like error model, which allows code to be written
    in a more compact way while ensuring that errors are handled accordingly. Although
    this isn't implemented in quite the same way as C++ exception handling, the semantics
    of the error handling are quite similar.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 添加了一个类似异常的错误模型，它允许以更紧凑的方式编写代码，同时确保错误得到相应处理。尽管这与 C++ 异常处理的方式不完全相同，但错误处理的语义非常相似。
- en: Errors can be created using a new `throw` keyword, and errors are stored as
    a subtype of `ErrorType`. Although swift `enum` values (covered in [Chapter 3](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 3. Creating an iOS Swift App"), *Creating an iOS Swift App*) are often
    used as error types, `struct` values can be used as well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用新的 `throw` 关键字创建错误，错误存储为 `ErrorType` 的子类型。尽管 Swift 的 `enum` 值（在[第 3 章](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "第 3 章。创建 iOS Swift 应用")，*创建 iOS Swift 应用*）中经常用作错误类型，但也可以使用 `struct` 值。
- en: 'Exception types can be created as subtypes of `ErrorType` by appending the
    supertype after the type name:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在类型名称后附加超类型来创建 `ErrorType` 的子类型作为异常类型：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Exceptions are thrown using the `throw` keyword and creating an instance of
    the exception type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `throw` 关键字和创建异常类型实例来抛出异常：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The REPL displays exception results with the `$E` prefix; ordinary results are
    displayed with the `$R` prefix.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 使用 `$E` 前缀显示异常结果；普通结果使用 `$R` 前缀显示。
- en: Throwing errors
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出错误
- en: 'Functions can declare that they return an error using the `throws` keyword
    before the return type, if any. The previous `cardName` function, which returned
    a dummy value if the argument was out of range, can be upgraded to throw an exception
    instead by adding the `throws` keyword before the return type and changing the
    `return` to a `throw`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以使用返回类型前的 `throws` 关键字声明返回错误，如果有的话。之前的 `cardName` 函数，如果参数超出范围则返回一个虚拟值，可以通过在返回类型前添加
    `throws` 关键字并将 `return` 改为 `throw` 来升级为抛出异常：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When the function is called with a real value, the result is returned; when
    it is passed an invalid value, an exception is thrown instead:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数使用实际值调用时，返回结果；当传递无效值时，将抛出异常：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When interfacing with Objective-C code, methods that take an `NSError**` argument
    are automatically represented in Swift as methods that throw. In general, any
    method whose arguments ends in `NSError**` is treated as throwing an exception
    in Swift.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Objective-C代码交互时，接受`NSError**`参数的方法在Swift中自动表示为抛出异常的方法。一般来说，任何参数以`NSError**`结尾的方法在Swift中都被视为抛出异常。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exception throwing in C++ and Objective-C is not as performant as exception
    handling in Swift because the latter does not perform stack unwinding. As a result,
    exception throwing in Swift is equivalent (from a performance perspective) to
    dealing with return values. Expect the Swift library to evolve in the future towards
    a throws-based means of error detection and away from Objective-C's use of `**NSError`
    pointers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++和Objective-C中抛出异常的性能不如Swift中的异常处理，因为Swift不执行栈回溯。因此，从性能角度来看，Swift中的异常抛出等同于处理返回值。预计Swift库在未来会朝着基于`throws`的错误检测方式发展，并远离Objective-C使用`**NSError`指针的方式。
- en: Catching errors
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获错误
- en: 'The other half of exception handling is the ability to catch errors when they
    occur. As with other languages, Swift now has a `try/catch` block that can be
    used to handle error conditions. Unlike other languages, the syntax is a little
    different; instead of a `try/catch` block, there is a `do/catch` block, and each
    expression that may throw an error is annotated with its own `try` statement:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的另一半是能够在错误发生时捕获错误。与其他语言一样，Swift现在有一个`try/catch`块，可以用来处理错误条件。与其他语言不同，语法略有不同；没有`try/catch`块，而是有一个`do/catch`块，并且每个可能抛出错误的表达式都带有自己的`try`语句：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the preceding code is executed, it will print out the generic error message.
    If a different choice is given, then it will run the successful path instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，它将打印出通用的错误消息。如果给出不同的选择，则将运行成功的路径。
- en: 'It''s possible to capture the error object and use it in the catch block:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以捕获错误对象并在`catch`块中使用它：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The default `catch` block will bind to a variable called `error` if not specified
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定，默认的`catch`块将绑定到一个名为`error`的变量
- en: Both of these two preceding examples will catch any errors thrown from the body
    of the code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个先前的示例都将捕获从代码主体抛出的任何错误。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to catch explicitly based on type if the type is an `enum` that
    is using pattern matching, for example, `catch Oops(let message)`. However, as
    this does not work for struct values, it cannot be tested here. [Chapter 3](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 3. Creating an iOS Swift App"), *Creating an iOS Swift App* introduces
    `enum` types.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型是一个使用模式匹配的`enum`，则可以显式地基于类型来捕获错误，例如`catch Oops(let message)`。然而，由于这不能用于结构体值，因此在这里无法进行测试。[第3章](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "第3章。创建iOS Swift应用程序")，*创建iOS Swift应用程序*介绍了`enum`类型。
- en: 'Sometimes code will always work, and there is no way it can fail. In these
    cases, it''s cumbersome to have to wrap the code with a `do/try/catch` block when
    it is known that the problem can never occur. Swift provides a short-cut for this
    using the `try!` statement, which catches and filters the exception:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时代码总是可以正常工作，并且没有失败的可能性。在这些情况下，如果已知问题永远不会发生，那么需要将代码包裹在`do/try/catch`块中是很麻烦的。Swift提供了一个简短的快捷方式，使用`try!`语句来捕获和过滤异常：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the expression really does fail, then it translates to a runtime error and
    halts the program:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式确实失败，那么它将转换为运行时错误并停止程序：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using `try!` is not generally recommended; if an error occurs then the program
    will crash. However, it is often used with user interface codes as Objective-C
    has a number of optional methods and values that are conventionally known not
    to be `nil`, such as the reference to the enclosing window.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`try!`通常不推荐；如果发生错误，程序将崩溃。然而，它通常与用户界面代码一起使用，因为Objective-C有许多可选方法和值，传统上被认为是非`nil`的，例如对封装窗口的引用。
- en: 'A better approach is to use `try?`, which translates the expression into an
    optional value: if evaluation succeeds, then it returns an optional with a value;
    if evaluation fails, then it returns a `nil` value:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用`try?`，它将表达式转换为可选值：如果评估成功，则返回一个包含值的可选；如果评估失败，则返回一个`nil`值：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is handy for use in the `if let` or `guard let` constructs, to avoid having
    to wrap in a `do/catch` block:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`if let`或`guard let`构造中使用时很方便，可以避免需要将代码包裹在`do/catch`块中：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Cleaning up after errors
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理错误后的代码
- en: It is common to have a function that needs to perform some cleanup before the
    function returns, regardless of whether the function has completed successfully
    or not. An example would be working with files; at the start of the function the
    file may be opened, and by the end of the function it should be closed again,
    whether or not an error occurs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有一个需要在函数返回之前执行一些清理工作的函数，无论函数是否成功完成。一个例子是与文件一起工作；在函数开始时文件可能被打开，而在函数结束时应该再次关闭，无论是否发生错误。
- en: A traditional way of handling this is to use an optional value to hold the file
    reference, and at the end of the method if it is not `nil`, then the file is closed.
    However, if there is the possibility of an error occurring during the method's
    execution, there needs to be a `do/catch` block to ensure that the cleanup is
    correctly called, or a set of nested `if` statements that are only executed if
    the file is successful.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况的传统方法是用可选值来持有文件引用，并在方法末尾如果它不是 `nil`，则关闭文件。然而，如果在方法执行过程中可能发生错误，则需要 `do/catch`
    块来确保正确调用清理，或者一组嵌套的 `if` 语句，只有当文件成功时才会执行。
- en: The downside with this approach is that the actual body of the code tends to
    be indented several times each with different levels of error handling and recovery
    at the end of the method. The syntactic separation between where the resource
    is acquired and where the resource is cleaned up can lead to bugs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是代码的实际主体通常在每个方法末尾都缩进几次，每次都有不同级别的错误处理和恢复。资源获取和清理之间的语法分离可能导致错误。
- en: 'Swift has a `defer` statement, which can be used to register a block of code
    to be run at the end of the function call. This block is run regardless of whether
    the function returns normally (with the `return` statement) or if an error occurs
    (with the `throw` statement). Deferred blocks are executed in reverse order of
    execution, for example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一个 `defer` 语句，可以用来注册一个在函数调用结束时运行的代码块。这个块无论函数是否正常返回（使用 `return` 语句）或发生错误（使用
    `throw` 语句）都会运行。延迟块按执行顺序的相反顺序执行，例如：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Please note that if a `defer` statement is not executed, then the block is
    not executed at the end of the method. This allows a `guard` statement to leave
    the function early, while executing the `defer` statements that have been added
    so far:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 `defer` 语句未执行，则该块不会在方法末尾执行。这允许 `guard` 语句提前退出函数，同时执行已添加的 `defer` 语句：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Command-line Swift
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行 Swift
- en: As Swift can be interpreted, it is possible to use it in shell scripts. By setting
    the interpreter to `swift` with a *hashbang*, the script can be executed without
    requiring a separate compilation step. Alternatively, Swift scripts can be compiled
    to a native executable that can be run without the overhead of the interpreter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 可以被解释，因此可以在 shell 脚本中使用它。通过使用 *hashbang* 将解释器设置为 `swift`，脚本可以执行而无需单独的编译步骤。或者，Swift
    脚本可以编译成原生可执行文件，可以在没有解释器开销的情况下运行。
- en: Interpreted Swift scripts
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释型 Swift 脚本
- en: 'Save the following as `hello.swift`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容保存为 `hello.swift`：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Linux, the first line should point to the location of the `swift` executable,
    such as `#!/usr/bin/swift`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，第一行应指向 `swift` 可执行文件的位置，例如 `#!/usr/bin/swift`。
- en: 'After saving, make the file executable by running `chmod a+x hello.swift`.
    The program can then be run by typing `./hello.swift`, and the traditional greeting
    will be seen:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，通过运行 `chmod a+x hello.swift` 使文件可执行。然后可以通过输入 `./hello.swift` 来运行程序，并看到传统的问候语：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Arguments can be passed from the command line and interrogated in the process
    using the `Process` class through the `arguments` constant. As with other Unix
    commands, the first element (0) is the name of the process executable; the arguments
    that are passed from the command line start from one (1).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过命令行传递，并在过程中使用 `Process` 类的 `arguments` 常量进行查询。与其他 Unix 命令一样，第一个元素（0）是进程可执行文件名；从命令行传递的参数从一（1）开始。
- en: The program can be terminated using the `exit` function; however, this is defined
    in the operating system libraries and so it needs to be imported in order to call
    this function. Modules in Swift correspond to Frameworks in Objective-C and give
    access to all functions that are defined as public API in the module. The syntax
    to import all elements from a module is `import module` although it's also possible
    to import a single function using `import func module.functionName`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `exit` 函数来终止程序；然而，这个函数是在操作系统库中定义的，因此需要导入才能调用此函数。Swift 中的模块对应于 Objective-C
    中的框架，并提供对模块中定义为公共 API 的所有函数的访问。从模块中导入所有元素的语法是 `import module`，尽管也可以使用 `import
    func module.functionName` 来导入单个函数。
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all foundation libraries are implemented for Linux, which results in some
    differences of behavior. In addition, the underlying module for the base functionality
    is `Darwin` on iOS and OS X, and is `Glibc` on Linux. These can also be accessed
    with `import Foundation`, which will include the appropriate operating system
    module.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的基础库都在 Linux 上实现，这导致了一些行为上的差异。此外，iOS 和 OS X 上的基本功能的基础模块是 `Darwin`，而在 Linux
    上是 `Glibc`。这些也可以通过 `import Foundation` 访问，这将包括适当的操作系统模块。
- en: 'A Swift program to print arguments in uppercase can be implemented as a script:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于将参数打印为大写的 Swift 程序可以作为一个脚本实现：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running this with `hello world` results in the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hello world` 运行此代码的结果如下：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Conventionally, the entry point to Swift programs is via a script called `main.swift`.
    If starting a Swift-based command-line application project in Xcode, a `main.swift`
    file will be created automatically. Scripts do not need to have a `.swift` extension;
    for example, the previous example could be called `upper` and it would still work.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Swift 程序的入口点是名为 `main.swift` 的脚本。如果在 Xcode 中启动基于 Swift 的命令行应用程序项目，将自动创建一个
    `main.swift` 文件。脚本不需要有 `.swift` 扩展名；例如，前面的示例可以命名为 `upper`，它仍然可以工作。
- en: Compiled Swift scripts
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译后的 Swift 脚本
- en: While interpreted Swift scripts are useful for experimenting and writing, each
    time the script is started, it is interpreted using the Swift compiler and then
    executed. For simple scripts (such as converting arguments to upper case), this
    can be a large proportion of the script's execution time.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解释的 Swift 脚本对于实验和编写代码很有用，但每次启动脚本时，它都会使用 Swift 编译器进行解释，然后执行。对于简单的脚本（如将参数转换为大写），这可能占脚本执行时间的大部分。
- en: 'To compile a Swift script into a native executable, use the `swiftc` command
    with the `-o` output flag to specify a file to write to. This will then generate
    an executable that does exactly the same as the interpreted script, only much
    faster. The `time` command can be used to compare the running time of the interpreted
    and compiled versions:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Swift 脚本编译成原生可执行文件，请使用带有 `-o` 输出标志的 `swiftc` 命令来指定要写入的文件。这将生成一个与解释脚本完全相同的可执行文件，但运行速度要快得多。可以使用
    `time` 命令来比较解释和编译版本的运行时间：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Of course, the numbers will vary, and the initial step only happens once, but
    startup is very lightweight in Swift. The numbers are not meant to be taken in
    magnitude but rather as relative to each other.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数字会有所不同，初始步骤只发生一次，但 Swift 的启动非常轻量级。这些数字并不是指它们的绝对值，而是指它们之间的相对值。
- en: The compile step can also be used to link together many individual Swift files
    into one executable, which helps create a more organized project; Xcode will encourage
    having multiple Swift files as well.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 编译步骤也可以用来将许多单独的 Swift 文件链接成一个可执行文件，这有助于创建一个更有组织的项目；Xcode 也会鼓励使用多个 Swift 文件。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Swift interpreter is a great way of learning how to program in Swift. It
    allows expressions, statements, and functions to be created and tested along with
    a command-line history that provides editing support. The basic collection types
    of arrays and collections, the standard data types, such as strings and numbers,
    optional values, and structures, were presented. Control flow and functions with
    positional, named, and variadic arguments, along with default values were also
    presented. Finally, the ability to write Swift scripts and run them from the command
    line was also demonstrated.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 解释器是学习 Swift 编程的绝佳方式。它允许创建和测试表达式、语句和函数，同时提供带有编辑支持的命令行历史记录。介绍了基本集合类型（如数组和集合）、标准数据类型（如字符串和数字）、可选值和结构体。还介绍了控制流和具有位置、命名和可变参数的函数，以及默认值。最后，还演示了如何编写
    Swift 脚本并在命令行中运行它们。
- en: The next chapter will look at the other way of working with Swift code that
    is available on OS X, through the Xcode playground.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨在 OS X 上使用 Swift 代码的另一种工作方式，即通过 Xcode 演示场。
