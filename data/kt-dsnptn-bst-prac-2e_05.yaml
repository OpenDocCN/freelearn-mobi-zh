- en: '*Chapter 4*: Getting Familiar with Behavioral Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：熟悉行为模式'
- en: This chapter discusses behavioral patterns in terms of Kotlin. **Behavioral
    patterns** deal with how objects interact with one another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将基于Kotlin讨论行为模式。**行为模式**处理对象之间如何相互交互。
- en: We'll learn how an object can alter its behavior based on the situation, how
    objects can communicate without knowledge of one another, and how to iterate over
    complex structures easily. We'll also touch on the concept of functional programming
    in Kotlin, which will help us implement some of these patterns easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习一个对象如何根据情况改变其行为，对象如何在不了解彼此的情况下进行通信，以及如何轻松地遍历复杂结构。我们还将简要介绍Kotlin中的函数式编程概念，这将帮助我们轻松实现一些这些模式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Strategy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Iterator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: State
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Chain of Responsibility
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Interpreter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Mediator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调解者
- en: Memento
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Visitor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Template method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Observer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: By the end of this chapter, you'll be able to structure your code in a highly
    decoupled and flexible manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够以高度解耦和灵活的方式组织代码。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the requirements from the previous chapters, you will also need
    a **Gradle**-enabled **Kotlin** project to be able to add the required dependencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章的要求外，您还需要一个**Gradle**启用的**Kotlin**项目，以便能够添加所需的依赖项。
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的源代码：[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04)。
- en: Strategy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: The goal of the **Strategy** design pattern is to allow an object to alter its
    behavior at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**设计模式的目标是允许对象在运行时改变其行为。'
- en: Let's recall the platformer game we were designing in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*, while discussing the **Facade** design pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在[*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)中设计的平台游戏，在讨论**外观**设计模式时，*理解结构模式*。
- en: Canary Michael, who acts as a game designer in our small indie game development
    company, came up with a great idea. *What if we were to give our hero an arsenal
    of weapons to protect us from those horrible carnivorous snails?*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 加那利迈克尔，在我们这家小型独立游戏开发公司担任游戏设计师，想出了一个绝妙的主意。*如果我们给我们的英雄配备一套武器来保护我们免受那些可怕的肉食性蜗牛的伤害会怎么样呢？*
- en: 'Weapons all shoot projectiles (you don''t want to get too close to those dangerous
    snails) in the direction our hero is facing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 武器都会朝英雄面对的方向发射弹丸（你不想离那些危险的蜗牛太近）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All projectiles should have a pair of coordinates (*our game is 2D, remember?*)
    and a direction:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有弹丸都应该有一对坐标（*记住，我们的游戏是2D的*）和一个方向：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we were to shoot only one type of projectile, that would be simple, since
    we covered the Factory pattern in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只发射一种类型的弹丸，那会很简单，因为我们已经在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)中介绍了**工厂模式**，*使用创建型模式*。
- en: 'We could do something like that here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里做类似的事情：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But Michael wants our hero to have at least three different weapons:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但迈克尔希望我们的英雄至少拥有三种不同的武器：
- en: '**Peashooter**: Shoots small peas that fly straight. Our hero starts with it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**豌豆射手**：发射直线飞行的豌豆。我们的英雄一开始就有它。'
- en: '**Pomegranate**: Explodes when hitting an enemy, much like a grenade.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**石榴**：击中敌人时会爆炸，就像手榴弹一样。'
- en: '**Banana**: Returns like a boomerang when it reaches the end of the screen.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**香蕉**：当它到达屏幕末端时会像回旋镖一样返回。'
- en: '*Come on, Michael, give us some slack! Can''t you just stick with regular guns
    that all work the same?*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*迈克尔，快点，给我们点空间！你不能就只坚持使用那些都一样的普通枪吗？*'
- en: Fruit arsenal
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水果武器库
- en: First, let's discuss how we could solve this in the Java way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下我们如何用Java的方式解决这个问题。
- en: 'In Java, we would have created an interface that abstracts these changes. In
    our case, what changes is our hero''s weapon:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们会创建一个接口来抽象这些变化。在我们的情况下，变化的是英雄的武器：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, all the other weapons would implement this interface. Since we don''t
    deal with aspects such as rendering or animating objects, no specific behavior
    will be implemented here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有其他武器都将实现这个接口。由于我们不处理诸如渲染或动画对象等方面，这里不会实现特定的行为：
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All of the weapons in our game will implement the same interface, overriding
    its single method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的所有武器都将实现相同的接口，并覆盖其单个方法。
- en: 'Our hero will hold a reference to a weapon, `Peashooter`, at the beginning:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄一开始会持有一把武器的引用，`Peashooter`：
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This reference will delegate the actual shooting process to it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引用将实际射击过程委托给它：
- en: '[PRE37]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What''s left is the ability to equip another `weapon`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是能够装备另一件“武器”：
- en: '[PRE38]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And that's what the **Strategy** design pattern is all about. It makes our algorithms
    – in this case, the weapons in our game – interchangeable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**策略**设计模式的核心所在。它使得我们的算法——在这个例子中，是我们游戏中的武器——可以互换。
- en: Citizen functions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 市民函数
- en: With Kotlin, there's a more efficient way to implement the same functionality
    using fewer classes. That's thanks to the fact that functions in Kotlin are first-class
    citizens. *But what does that mean?*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kotlin，有更有效的方法来实现相同的功能，同时使用更少的类。这要归功于 Kotlin 中函数是第一类公民的事实。*但这意味着什么呢？*
- en: 'For one, we can assign functions to the variables of our class, just like any
    other standard value. It makes sense that you can assign a primitive value to
    your variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将函数赋值给我们的类的变量，就像任何其他标准值一样。将原始值赋给变量是有意义的：
- en: '[PRE41]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You could also assign an object to a variable, as we have done many times already:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像我们已经多次做的那样，将一个对象赋值给一个变量：
- en: '[PRE42]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*So, why shouldn''t you be able to assign a function to your variable?*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，为什么你不能将一个函数赋值给变量呢？*'
- en: 'In Kotlin, you can easily do that. Here''s an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你可以轻松做到这一点。以下是一个例子：
- en: '[PRE43]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let's see how that may help us simplify our design.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这可能如何帮助我们简化我们的设计。
- en: 'First, we''ll define a namespace for all our weapons. We can use an object
    for that. This is not mandatory but it helps keep everything in check. Then, instead
    of classes, each of our weapons will become a function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为所有武器定义一个命名空间。我们可以使用一个对象来做到这一点。这不是强制性的，但它有助于保持一切井然有序。然后，而不是类，我们的每件武器都将成为一个函数：
- en: '[PRE46]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, instead of implementing an interface, we have multiple functions
    receiving the same parameters and returning the same object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们没有实现接口，而是有多个函数接收相同的参数并返回相同的对象。
- en: 'The most interesting part is our hero. The `OurHero` class now contains two
    values, both of which are functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是我们的英雄。`OurHero` 类现在包含两个值，都是函数：
- en: '[PRE59]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The interchangeable part is `currentWeapon`, while `shoot` is now an anonymous
    function that wraps it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以互换的部分是 `currentWeapon`，而 `shoot` 现在是一个包装它的匿名函数。
- en: 'To test that our idea works, we can shoot the default weapon once, then switch
    to another weapon and shoot with it again:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的想法是否可行，我们可以先射击默认武器一次，然后切换到另一件武器并再次射击：
- en: '[PRE65]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that this dramatically reduces the number of classes we have to write
    while keeping the same functionality. If your interchangeable algorithm doesn't
    have a state, you can replace it with a simple function. Otherwise, introduce
    an interface, and let each Strategy pattern implement it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这大大减少了我们需要编写的类的数量，同时保持了相同的功能。如果你的可互换算法没有状态，你可以用简单的函数来替换它。否则，引入一个接口，并让每个策略模式实现它。
- en: That's also the first time we used the function reference operator, `::`. This
    operator allows us to refer to a function as if it was a variable instead of invoking
    it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们第一次使用函数引用操作符 `::`。这个操作符允许我们将函数当作变量来引用，而不是调用它。
- en: '**Strategy** is a valuable pattern whenever your application needs to change
    its behavior at runtime. One example is a booking system for flights that allows
    for overbooking; that is, placing more passengers on a flight than there are seats.
    You may decide that you wish to enable overbooking up until one day before the
    flight and then disallow it. You can do this by switching strategies instead of
    adding complex checks to your code.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**是一个非常有价值的模式，当你的应用程序需要在运行时改变其行为时。一个例子是航班预订系统，允许超售；也就是说，将比座位更多的乘客放在航班上。你可能会决定你希望在航班前一天允许超售，然后禁止。你可以通过切换策略而不是在代码中添加复杂的检查来实现这一点。'
- en: Now, let's look at another pattern that should help us work with complex data
    structures.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个可以帮助我们处理复杂数据结构的模式。
- en: Iterator
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: When we were discussing the **Composite** design pattern in the previous chapter,
    we noted that the design pattern felt a bit incomplete. Now is the time to reunite
    the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito,
    they're very different but complement each other well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一章讨论**组合**设计模式时，我们注意到这个设计模式感觉有点不完整。现在是时候让出生时分开的双胞胎重聚了。就像阿诺德·施瓦辛格和丹尼·德维托一样，他们非常不同，但彼此很好地补充。
- en: 'As you may remember from the previous chapter, a squad consists of troopers
    or other squads. Let''s create one now:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一章所记得的，一个小队由士兵或其他小队组成。现在让我们创建一个：
- en: '[PRE69]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we created a platoon that consists of four troopers in total.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个由四个士兵组成的小队。
- en: It would be useful if we could print all the troopers in this platoon using
    a `for-each` loop, which we learned about back in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够使用我们之前在[*第一章*](B17816_01_ePub.xhtml#_idTextAnchor015)中学习的`for-each`循环打印出这个小队中的所有士兵，那将是有用的。
- en: 'Let''s just try to write that code and see what happens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着写这段代码，看看会发生什么：
- en: '[PRE81]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Although this code doesn''t compile, the Kotlin compiler provides us with a
    useful hint:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码无法编译，但Kotlin编译器为我们提供了一个有用的提示：
- en: '[PRE84]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Before we follow the compiler's guidance and implement the method, let's briefly
    discuss what problem we have at the moment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遵循编译器的指导并实现方法之前，让我们简要讨论一下目前我们面临的问题。
- en: Our platoon, which implements a Composite design pattern, is not a flat data
    structure. It can contain objects that contain other objects – squads can contain
    troopers as well as other squads. In this case, however, we want to abstract that
    complexity and work with it as if it was just a list of troopers. The Iterator
    pattern does just that – it *flattens* our complex data structure into a simple
    sequence of elements. The order of the elements and what elements to ignore is
    for the iterator to decide.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小队实现了组合设计模式，它不是一个扁平的数据结构。它可以包含包含其他对象的对象——小队可以包含士兵以及其他小队。然而，在这种情况下，我们想要抽象这种复杂性，并像处理一个士兵列表一样处理它。迭代器模式正是这样做的——它将我们的复杂数据结构简化为一个简单的元素序列。元素的顺序和要忽略的元素由迭代器决定。
- en: 'To use our `Squad` object in a `for-each` loop, we will need to implement a
    special function called `iterator()`. And since it''s a special function, we''ll
    need to use the `operator` keyword:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`for-each`循环中使用我们的`Squad`对象，我们需要实现一个特殊函数，称为`iterator()`。由于这是一个特殊函数，我们需要使用`operator`关键字：
- en: '[PRE85]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'What our function returns is an anonymous object that implements the `Iterator<T>`
    interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数返回的是一个实现了`Iterator<T>`接口的匿名对象：
- en: '[PRE86]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once again, we can see the use of generics in Kotlin. `Iterator<Trooper>` means
    that the objects that our `next()` method returns will always be of the `Trooper`
    type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以看到Kotlin中泛型的使用。`Iterator<Trooper>`意味着我们的`next()`方法返回的对象将始终是`Trooper`类型。
- en: 'To be able to iterate all the elements, we need to implement two methods –
    one to fetch the next element and one to let the loop know when to stop. Let''s
    do that by executing the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够迭代所有元素，我们需要实现两个方法——一个用于获取下一个元素，另一个让循环知道何时停止。让我们通过执行以下步骤来实现：
- en: 'First, we need a state for our iterator. It will remember that the last element
    is returned:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的迭代器提供一个状态。它将记住最后一个返回的元素：
- en: '[PRE94]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we need to tell it when to stop. In simple cases, this would be equal
    to the size of the underlying data structure:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉它何时停止。在简单的情况下，这等于底层数据结构的大小：
- en: '[PRE95]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This will be a bit more complex since we need to handle some edge cases. You
    can find the complete implementation in this book's GitHub repository.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将会有点复杂，因为我们需要处理一些边缘情况。你可以在本书的GitHub仓库中找到完整的实现。
- en: 'Finally, we need to know which unit to return. For simple cases, we could just
    return the current element and increase the element count by one:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要知道要返回哪个单位。在简单的情况下，我们只需返回当前元素，并将元素计数增加一个：
- en: '[PRE96]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In our case, this is a bit more complex since squads could contain other squads.
    Again, you can find the full implementation in this book's GitHub repository.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的情况下，这要复杂一些，因为小队可以包含其他小队。再次，你可以在本书的GitHub仓库中找到完整的实现。
- en: 'Sometimes, it also makes sense to receive an iterator as a parameter of a function:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时候，将迭代器作为函数的参数也是有意义的：
- en: '[PRE97]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This function will iterate over anything that supplies an iterator. This is
    also an example of a generic function in Kotlin. Note `<T>`, which comes before
    the function's name.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数将遍历任何提供迭代器的对象。这也是 Kotlin 中泛型函数的一个例子。注意函数名称前的 `<T>`。
- en: As a regular developer that doesn't invent new data structures for a living,
    you may not implement iterators often. However, it's still important to know how
    they work behind the scenes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名普通的开发者，你不会为了谋生而发明新的数据结构，你可能不会经常实现迭代器。然而，了解它们在幕后是如何工作的仍然很重要。
- en: The following section will show how to design finite-state machines efficiently.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何有效地设计有限状态机。
- en: State
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: You can think of the **State** design pattern as an opinionated Strategy pattern,
    which we discussed at the beginning of this chapter. But while the Strategy pattern
    is usually replaced from the outside by the client, the state may change internally
    based solely on the input it gets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把状态设计模式看作是一个有偏见的策略模式，我们在本章开头讨论过。但是，虽然策略模式通常是由客户端从外部替换的，状态可能会根据它接收到的输入而内部改变。
- en: 'Look at this dialog a client wrote with the Strategy pattern:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看看客户使用策略模式编写的这个对话：
- en: '**Client**: *Here''s a new thing to do, start doing it from now on.*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：*这里有一件新的事情要做，从现在开始做吧。*'
- en: '**Strategy**: *OK, no problem.*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：*好的，没问题。*'
- en: '**Client**: *What I like about you is that you never argue with me.*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：*我喜欢你的地方是你从不会和我争论。*'
- en: 'Compare it with this one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比：
- en: '**Client**: *Here''s some new input I got from you.*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：*这里有一些我从你那里得到的新输入。*'
- en: '**State**: *Oh, I don''t know. Maybe I''ll start doing something differently.
    Maybe not.*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：*哦，我不知道。也许我会开始做一些不同的事情。也许不会。*'
- en: 'The client should also expect that the state may even reject some of its inputs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端还应预期状态可能会拒绝其一些输入：
- en: '**Client**: *Here''s something for you to ponder, State.*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：*这里有一些东西让你思考，状态。*'
- en: '**State**: *I don''t know what it is! Don''t you see I''m busy? Go bother some
    Strategy with this!*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：*我不知道那是什么！你没看到我很忙吗？去找策略处理这件事吧！*'
- en: '*So, why do clients still tolerate that state of ours?* Well, the state is
    good at keeping everything under control.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，客户为什么还要容忍我们这种状态呢？* 好吧，状态擅长控制一切。'
- en: Fifty shades of State
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态的五十种色彩
- en: The carnivorous snails from our platformer game have had enough of this abuse.
    So, the player throws peas and bananas at them, only to get to another sorry castle.
    *Now, they shall act!*
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们平台游戏中的肉食性蜗牛已经受够了这种虐待。所以，玩家向它们扔豌豆和香蕉，结果只是到达另一个可怜的城堡。*现在，它们要采取行动了！*
- en: Let's see how the State design pattern can help us model a changing behavior
    of an actor – in our case, of the enemies in our platformer game. By default,
    the snail should stand still to conserve snail energy. But when the hero gets
    close, it should dash toward them aggressively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看状态设计模式如何帮助我们模拟一个角色的行为变化——在我们的案例中，是平台游戏中的敌人。默认情况下，蜗牛应该静止不动以节省蜗牛的能量。但是当英雄靠近时，它应该积极地冲向他们。
- en: If the hero manages to injure it, it should retreat to lick its wounds. Then,
    it will repeat attacking until either of them is dead.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果英雄设法伤害了它，它应该撤退舔舐伤口。然后，它将重复攻击直到其中一方死亡。
- en: 'First, we''ll declare what can happen during a snail''s life:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明蜗牛生命中可能发生的事情：
- en: '[PRE98]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Our snail implements this interface so that it is notified of anything that
    may happen to it and act accordingly:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蜗牛实现了这个接口，以便在它可能发生的事情上得到通知并相应地行动：
- en: '[PRE103]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we can declare the `Mood` class, which we will mark with the `sealed`
    keyword:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明一个 `Mood` 类，我们将用 `sealed` 关键字标记它：
- en: '[PRE112]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '**Sealed classes** are abstract and cannot be instantiated. We''ll see the
    benefit of using them in a moment. But before that, let''s declare other states:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**密封类**是抽象的，不能被实例化。我们将在稍后看到使用它们的优点。但在那之前，让我们声明其他状态：'
- en: '[PRE115]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: These are all the different states – sorry, moods – of our snail.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们蜗牛的不同状态——抱歉，心情。
- en: 'In terms of the State design pattern, `Snail` is the context. It holds the
    state. So, we declare a member for it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态设计模式中，`Snail` 是上下文。它持有状态。因此，我们为它声明一个成员：
- en: '[PRE119]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, let''s define what `Snail` should do when it sees our hero:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义当蜗牛看到我们的英雄时 `Snail` 应该做什么：
- en: '[PRE123]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Notice that this doesn't compile. This is where the `sealed` class comes into
    play. Much like with an `enum`, Kotlin knows that there's a finite number of classes
    that extend from it. So, it requires that our `when` is exhaustive and specifies
    all the different cases in it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不能编译。这就是`sealed`类发挥作用的地方。就像`enum`一样，Kotlin知道从它扩展的类数量是有限的。因此，它要求我们的`when`是详尽的，并指定其中的所有不同情况。
- en: 'Important Note:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: If you're using IntelliJ as your IDE, it will even suggest that you `Add remaining
    branches` automatically.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用IntelliJ作为你的IDE，它甚至会建议你自动`添加剩余的分支`。
- en: 'We can use `else` to describe no state change:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`else`来描述没有状态变化：
- en: '[PRE128]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'When the snail gets hit, we need to decide whether it''s dead or not. For that,
    we can use `when` without an argument:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当蜗牛被击中时，我们需要判断它是死是活。为此，我们可以使用不带参数的`when`：
- en: '[PRE134]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Note that we use the `is` keyword here, which is the same as `instanceof` in
    Java, but more concise.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用了`is`关键字，这与Java中的`instanceof`相同，但更简洁。
- en: State of the nation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国家状况
- en: The previous approach contains most of the logic for our context. You may sometimes
    see a different approach, which is valid as your context becomes bigger.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法包含了我们上下文的大多数逻辑。你有时可能会看到不同的方法，这是有效的，因为你的上下文变得更大。
- en: 'In this approach, `Snail` would become thin:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，`Snail`会变得很瘦：
- en: '[PRE142]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Note that we marked `mood` as `internal`. This lets other classes in the same
    package alter it. Instead of `Snail` implementing `WhatCanHappen`, our `Mood`
    will implement it instead:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`mood`标记为`internal`。这允许同一包中的其他类修改它。而不是让`Snail`实现`WhatCanHappen`，我们的`Mood`将实现它：
- en: '[PRE147]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, the logic resides within our state objects:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，逻辑位于我们的状态对象中：
- en: '[PRE148]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note that our state objects now receive a reference to their context in the
    constructor.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的状态对象现在在构造函数中接收对其上下文的引用。
- en: Use the first approach if the amount of code in your state is relatively small.
    Use the second approach for cases if the variants differ a lot. One example from
    the real world, where this pattern is widely used, is Kotlin's **Coroutines**
    mechanism. We'll discuss this in detail in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144),
    *Introducing Functional Programming*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的状态代码量相对较小，请使用第一种方法。如果变体差异很大，请使用第二种方法。一个现实世界的例子，其中广泛使用此模式，是Kotlin的**协程**机制。我们将在[*第5章*](B17816_05_ePub.xhtml#_idTextAnchor144)，*介绍函数式编程*中详细讨论。
- en: Now, let's look at another pattern that encapsulates actions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个封装动作的模式。
- en: Command
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: This design pattern allows you to encapsulate actions inside an object to be
    executed sometime later. Furthermore, if we can execute one action later, we could
    also execute many, or even schedule exactly when to execute them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式允许你将动作封装在对象中，稍后执行。此外，如果我们可以在稍后执行一个动作，我们也可以执行多个，甚至可以精确地安排何时执行它们。
- en: 'Let''s go back to our `Stormtrooper` management system from [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*. Here''s an example of implementing the `attack`
    and `move` functions from before:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Stormtrooper`管理系统，从[*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)，*理解结构型模式*。这里是一个实现之前提到的`attack`和`move`函数的例子：
- en: '[PRE159]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: We could even use the **Bridge** design pattern from the previous chapter to
    provide the actual implementations.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用上一章中提到的**桥接**设计模式来提供实际的实现。
- en: 'The problem we need to solve now is that our trooper can remember exactly one
    command. That''s it. If they start at `(0, 0)`, which is the top of the screen,
    we can tell them to `move(20, 0)`, which is 20 steps to the right, and then to
    `move(20, 20)`. In this case, they''ll move straight to `(20, 20)` and will probably
    get destroyed because there are rebels that we must try to avoid at all costs:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要解决的问题是我们的小兵只能记住一个命令。仅此而已。如果他们从`(0, 0)`开始，这是屏幕的顶部，我们可以告诉他们`move(20, 0)`，即向右移动20步，然后`move(20,
    20)`。在这种情况下，他们会直接移动到`(20, 20)`，并可能被摧毁，因为我们必须不惜一切代价避免那些叛军：
- en: '[PRE169]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: If you've been following this book from the start or at least joined at [*Chapter
    3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding Structural Patterns*,
    you probably have an idea of what we need to do, since we have already discussed
    the concept of *functions as first-class citizens* in the language.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从本书的开头开始跟随，或者至少在[*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)，*理解结构型模式*中加入了进来，你可能已经有一个想法我们需要做什么，因为我们已经讨论了语言中*函数作为一等公民*的概念。
- en: 'Let''s sketch a draft for this. We know that we want to hold a list of objects,
    but we don''t know what type they should be yet. So, we''ll use `Any` for now:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个草拟一个草案。我们知道我们想要持有对象列表，但我们还不知道它们应该是哪种类型。所以，我们现在将使用`Any`：
- en: '[PRE174]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Then, we want to iterate over the list and execute the orders we have:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要遍历列表并执行我们拥有的命令：
- en: '[PRE181]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note that Kotlin provides us with the `isNotEmpty()` function on collections,
    as an alternative to the `!orders.isEmpty()` check, as well as a `removeFirst()`
    function, which allows us to use our collection as if it was a queue.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kotlin为我们提供了`isNotEmpty()`函数，用于集合，作为`!orders.isEmpty()`检查的替代，以及一个`removeFirst()`函数，它允许我们像使用队列一样使用我们的集合。
- en: 'Even if you''re not familiar with the Command design pattern, you can guess
    that if we want our code to compile, we can define an interface with a single
    method, `execute()`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不熟悉命令设计模式，你也可以猜到，如果我们想让我们的代码编译，我们可以定义一个只有一个方法`execute()`的接口：
- en: '[PRE192]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Then, we can hold a list at the same time in a member property:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在成员属性中同时持有列表：
- en: '[PRE195]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Each type of order, be it a move order or an attack order, would implement this
    interface as needed. That's basically what the Java implementation of this pattern
    would suggest in most cases. *But isn't there a better way?*
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的命令，无论是移动命令还是攻击命令，都需要根据需要实现这个接口。这基本上就是Java实现这种模式的大多数情况下的建议。*但是有没有更好的方法呢？*
- en: 'Let''s look at `Command` again. The `execute()` method receives nothing, returns
    nothing, and does something. It''s the same as writing the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看`Command`。`execute()`方法不接受任何东西，也不返回任何东西，只是做些事情。这就像写以下代码：
- en: '[PRE196]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'It''s no different from what we''ve seen previously. We could simplify this
    further:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的不同。我们可以进一步简化这个：
- en: '[PRE199]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'And instead of having an interface for this called `Command`, we''ll have `typealias`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有一个名为`Command`的接口，我们将使用`typealias`：
- en: '[PRE200]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This makes our `Command` interface redundant and allows us to remove it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的`Command`接口变得冗余，并允许我们移除它。
- en: 'Now, this line stops compiling again:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一行再次停止编译：
- en: '[PRE201]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'This is because `execute()` is just some name we invented. In Kotlin, functions
    use `invoke()`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`execute()`只是我们发明的一个名字。在Kotlin中，函数使用`invoke()`：
- en: '[PRE202]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'We can also omit `invoke()`, which will leaves us with the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以省略`invoke()`，这将给我们以下代码：
- en: '[PRE203]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: That's nice, but currently, our function has no parameters at all. *What happens
    if our function receives arguments?*
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但当前，我们的函数没有任何参数。*如果我们的函数接收参数会发生什么？*
- en: 'One option would be to change the signature of our `Command` so that we receive
    two parameters:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是改变我们的`Command`签名，以便我们接收两个参数：
- en: '[PRE209]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '*But what if some commands receive no arguments, or only one, or more than
    two?* We also need to remember what to pass to `invoke()` at each step.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，如果某些命令没有接收任何参数，或者只接收一个，或者接收超过两个参数怎么办？* 我们还需要记住在每一步传递给`invoke()`的内容。'
- en: 'A much better way is to have a **function generator**. This is a function that
    returns another function. If you have ever worked with the JavaScript language,
    then you''ll know that it''s a common practice to use closures to limit the scope
    and remember stuff. We''ll do the same here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是有一个**函数生成器**。这是一个返回另一个函数的函数。如果你曾经使用过JavaScript语言，那么你会知道使用闭包来限制作用域和记住东西是一种常见的做法。我们在这里也会这样做：
- en: '[PRE210]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'When called with proper arguments, `moveGenerator` will return a new function.
    This function can be invoked whenever we find it suitable and it will remember
    three things:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用适当的参数调用时，`moveGenerator`将返回一个新的函数。这个函数可以在我们觉得合适的时候被调用，并且它会记住三件事：
- en: What method to call
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调用哪个方法
- en: Which arguments to use
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用哪些参数
- en: Which object to use it on
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪个对象上使用它
- en: 'Now, our `Trooper` may have a method like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Trooper`可能有一个这样的方法：
- en: '[PRE217]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This provides us with a nice fluent syntax:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个很好的流畅语法：
- en: '[PRE220]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '**Fluent syntax** means that we can chain methods on the same object easily
    without the need to repeat its name many times.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**流畅语法**意味着我们可以轻松地在同一对象上链式调用方法，而无需多次重复其名称。'
- en: 'This code will print the following output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印以下输出：
- en: '[PRE225]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Now, we may issue any number of commands to our `Trooper` without needing to
    know how they are executed internally.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向我们的`Trooper`发出任意数量的命令，而无需了解它们是如何在内部执行的。
- en: A function that receives or returns another function is called a **higher-order
    function**. We'll explore such functions many more times in this book.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接收或返回另一个函数的函数被称为**高阶函数**。在这本书中，我们将多次探索这样的函数。
- en: Undoing commands
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撤销命令
- en: While not directly related, one of the advantages of the Command design pattern
    is the ability to undo commands. *What if we wanted to support such a functionality?*
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是直接相关，但命令设计模式的一个优点是能够撤销命令。*如果我们想支持这样的功能会怎样呢？*
- en: 'Undoing is usually very tricky because it involves one of the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销操作通常非常棘手，因为它涉及到以下之一：
- en: Returning to the previous state (this is impossible if there's more than one
    client as this requires a lot of memory)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回到之前的状态（如果有多个客户端，这是不可能的，因为这需要大量的内存）
- en: Computing deltas (tricky to implement)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算增量（实现起来很棘手）
- en: Defining opposite operations (not always possible)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义相反的操作（不一定总是可能的）
- en: 'In our case, the opposite of the *move from (0,0) to (0, 20)* command would
    be *move from wherever you''re now to (0,0)*. This can be achieved by storing
    a pair of commands:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，与从(0,0)移动到(0, 20)的命令相反的命令将是*从你现在所在的位置移动到(0,0)*。这可以通过存储一对命令来实现：
- en: '[PRE228]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We''ll need to change our `appendMove` function so that it also stores the
    reverse command every time:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的`appendMove`函数，使其每次也存储反向命令：
- en: '[PRE229]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Computing the opposite move is quite complex as we don't save the position of
    our soldier currently (it was something we should have implemented anyway). We'll
    also have to deal with some edge cases. But this should provide you with an idea
    of how such behavior can be achieved.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 计算相反的移动相当复杂，因为我们没有保存我们的士兵当前的位置（这本来就是我们应该实现的）。我们还将不得不处理一些边缘情况。但这应该能给你一个这样的行为是如何实现的思路。
- en: The **Command** design pattern is yet another example of functionality that
    is already embedded inside the language. In this case, this functions as a first-class
    citizen, which reduces the need to implement design patterns yourself. In the
    real world, this pattern is practical whenever you want to enqueue multiple actions
    or schedule an action to be executed later.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**设计模式是功能已经嵌入到语言中的另一个例子。在这种情况下，它作为一个一等公民存在，这减少了你自己实现设计模式的需求。在现实世界中，当你想要排队多个动作或安排稍后执行的动作时，这个模式是实用的。'
- en: Chain of Responsibility
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 职责链
- en: I'm a horrible software architect, and I don't particularly appreciate speaking
    with people. Hence, while sitting in *The Ivory Tower* (*that's the name of the
    cafe I often visit*), I wrote a small web application. If a developer has a question,
    they shouldn't approach me directly, oh no! They'll need to send me a proper request
    through this system and I shall only answer them if I deem their request worthy.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个糟糕的软件架构师，我不太喜欢与人交谈。因此，当我坐在*象牙塔*（这是我经常去的咖啡馆的名字）时，我写了一个小的网络应用程序。如果一个开发者有问题，他们不应该直接找我，哦不！他们需要通过这个系统给我一个适当的请求，而我只有在我认为他们的请求有价值时才会回答他们。
- en: 'A **filter chain** is a ubiquitous concept in web servers. Usually, when a
    request reaches you, it''s expected that the following is true:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤器链**是网络服务器中的一个普遍概念。通常，当一个请求到达你这里时，预期以下情况是真实的：'
- en: Its parameters have already been validated.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的参数已经被验证过了。
- en: The user has already been authenticated, if possible.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，用户已经被认证了。
- en: User roles and permissions are known and the user is authorized to perform an
    action.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户角色和权限已知，并且用户有权执行操作。
- en: 'So, the code I initially wrote looked something like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我最初写的代码看起来像这样：
- en: '[PRE233]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: It's a bit messy, but it works.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 它有点乱，但它是有效的。
- en: Then, I noticed that some developers decided that they can send me two questions
    at once. We have to add some more logic to this function. But wait – I'm an architect,
    after all. *So, isn't there a better way to delegate this?*
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我注意到一些开发者决定他们可以一次性问我两个问题。我们必须给这个函数添加一些更多的逻辑。但是等等——毕竟，我是一个架构师。*那么，有没有更好的方法来委派这个任务呢？*
- en: The goal of the **Chain of Responsibility** design pattern is to break a complex
    piece of logic into a collection of smaller steps, where each step, or link in
    the chain, decides whether to proceed to the next one or to return a result.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**职责链**设计模式的目标是将一个复杂的逻辑部分分解成一系列较小的步骤，其中每个步骤，或链中的链接，决定是否继续到下一个步骤或返回一个结果。'
- en: 'This time, we won''t learn new Kotlin tricks but use those that we already
    know about. So, for example, we could start by implementing an interface such
    as this one:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会学习新的 Kotlin 技巧，而是使用我们已知的那些。所以，例如，我们可以从实现一个像这样的接口开始：
- en: '[PRE252]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'We never discussed what my response to one of the developers looked like. That''s
    because I keep my chain of responsibility so long and complex that usually, they
    tend to solve the problems by themselves. I''ve never had to answer one of them,
    quite frankly. But let''s assume the response looks something like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未讨论过我回应一位开发者时的样子。那是因为我保持的责任链非常长且复杂，通常情况下，他们倾向于自行解决问题。坦白说，我从未需要回答过他们中的任何一个。但让我们假设回应看起来可能像这样：
- en: '[PRE255]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'We could do this *the Java way* and start implementing each piece of logic
    inside its own handler:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 *Java 方式* 来做这件事，并在每个处理器内部实现每块逻辑：
- en: '[PRE256]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: As you can see, here, we are implementing an interface with a single method,
    which we override with our desired behavior.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里，我们正在实现一个接口，它有一个方法，我们用我们期望的行为来覆盖它。
- en: 'Other filters would look very similar to this one. We can compose them in any
    order we want:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 其他过滤器看起来会非常类似于这个。我们可以以任何我们想要的顺序来组合它们：
- en: '[PRE265]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'But I won''t even ask you the rhetorical question this time about better ways
    to do things. Of course, there''s a better way. We''re in the Kotlin world now.
    And we''ve seen how to use various functions in the previous section. So, let''s
    define a function for this task:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次我不会问你关于更好做事方式的修辞问题。当然，有更好的方法。我们现在处于 Kotlin 世界。我们已经在上一节中看到了如何使用各种函数。所以，让我们为这个任务定义一个函数：
- en: '[PRE274]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'We don''t have a separate class and interface for something that simply receives
    a request and returns a response. Here''s an example of how we can implement authentication
    in our application by using a simple function as a value:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅仅接收请求并返回响应的东西，我们没有单独的类和接口。以下是我们如何通过使用一个简单的函数作为值在我们的应用程序中实现身份验证的示例：
- en: '[PRE275]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Here, `authentication` is a function that receives a function and returns a
    function. This pattern allows us to easily compose those functions:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`authentication` 是一个接收函数并返回函数的函数。这种模式允许我们轻松地组合这些函数：
- en: '[PRE282]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Which method you choose to use is up to you. For example, using interfaces is
    more explicit and would suit you better if you're creating a library or framework
    that others may want to extend.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择使用哪种方法取决于你。例如，使用接口更加明确，如果你正在创建一个其他人可能想要扩展的库或框架，这可能更适合你。
- en: Using functions is more concise and if you just want to split your code in a
    more manageable way, it may be the better choice.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数更加简洁，如果你只是想以更可管理的方式拆分你的代码，这可能是一个更好的选择。
- en: You've probably seen this approach many times in the real world. For example,
    many web server frameworks use it to handle cross-cutting concerns, such as authentication,
    authorization, logging, and even routing requests. Sometimes, these are called
    **filters** or **middleware**, but it's the same Chain of Responsibility design
    pattern in the end. We'll discuss it again in more detail in [*Chapter 10*](B17816_10_ePub.xhtml#_idTextAnchor237),
    *Concurrent Microservices with Ktor*, and [*Chapter 11*](B17816_11_ePub.xhtml#_idTextAnchor251),
    *Reactive Microservices with Vert.x*, where we'll see how it's implemented by
    some of the most popular Kotlin frameworks.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在现实世界中多次看到这种方法。例如，许多网络服务器框架使用它来处理跨切面关注点，如身份验证、授权、日志记录，甚至路由请求。有时，这些被称为 **过滤器**
    或 **中间件**，但最终都是相同的责任链设计模式。我们将在 [*第 10 章*](B17816_10_ePub.xhtml#_idTextAnchor237)，*使用
    Ktor 的并发微服务* 和 [*第 11 章*](B17816_11_ePub.xhtml#_idTextAnchor251)，*使用 Vert.x 的响应式微服务*
    中更详细地讨论它，我们将看到一些最受欢迎的 Kotlin 框架是如何实现它的。
- en: The next design pattern will be a bit different from all the others and also
    somewhat more complex.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计模式将与其他所有设计模式都略有不同，并且也更为复杂。
- en: Interpreter
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器
- en: This design pattern may seem very simple or very hard, based on how much background
    you have in computer science. Some books that discuss classical software design
    patterns even decide to omit it altogether or put it somewhere at the end, for
    curious readers only.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式可能看起来非常简单或非常复杂，这取决于你在计算机科学方面的背景知识。一些讨论经典软件设计模式的书籍甚至决定完全省略它，或者把它放在某个地方，仅供好奇的读者阅读。
- en: The reason behind this is that the **Interpreter** design pattern deals with
    translating specific languages. *But why would we need that? Don't we have compilers
    to do that anyway?*
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的原因是 **解释器** 设计模式处理特定语言的翻译。*但我们为什么需要这个？我们不是已经有编译器来做这个了吗？*
- en: We need to go deeper
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要更深入
- en: All developers have to speak many languages or sub-languages. Even as regular
    developers, we use more than one language. Think of tools that build your projects,
    such as Maven or Gradle. You can consider their configuration files and build
    scripts as languages with specific grammar. If you put elements out of order,
    your project won't be built correctly. This is because such projects have interpreters
    to analyze configuration files and act upon them.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发者都必须掌握多种语言或子语言。即使是普通开发者，我们也使用不止一种语言。想想那些构建你项目的工具，比如Maven或Gradle。你可以将它们的配置文件和构建脚本视为具有特定语法的语言。如果你将元素顺序打乱，你的项目将无法正确构建。这是因为这样的项目有解释器来分析配置文件并对其采取行动。
- en: Other examples are query languages, whether one of the SQL variations or one
    of the languages specific to NoSQL databases. If you're an Android developer,
    you may think of XML layouts as such languages too. Even HTML could be considered
    as a language that defines user interfaces. And there are others, of course.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 其他示例包括查询语言，无论是SQL的某个变体还是NoSQL数据库的特定语言。如果你是Android开发者，你可能也会将XML布局视为此类语言。甚至HTML也可以被认为是定义用户界面的语言。当然，还有其他语言。
- en: Maybe you've worked with one of the testing frameworks that defines a custom
    language for testing, such as **Cucumber** ([github.com/cucumber](http://github.com/cucumber)).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经使用过一些定义了自定义测试语言的测试框架，例如**Cucumber**（[github.com/cucumber](http://github.com/cucumber)）。
- en: Each of these examples can be called a **domain-specific language** (**DSL**).
    A DSL is a language inside a language, built for a particular domain. We'll discuss
    how they work in the next section.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的每一个都可以被称为**领域特定语言（DSL）**。DSL是语言中的语言，为特定领域构建。我们将在下一节讨论它们是如何工作的。
- en: A language of your own
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您自己的语言
- en: 'In this section, we''ll define a simple *DSL-for-SQL* language. We won''t define
    the format or grammar for it; instead, we''ll provide an example of what it should
    look like:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一个简单的*SQL领域特定语言（DSL）*。我们不会定义其格式或语法；相反，我们将提供一个示例，说明它应该看起来像什么：
- en: '[PRE287]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The goal of our language is to improve readability and prevent some common SQL
    mistakes, such as typos (such as using *FORM* instead of `FROM`). We'll cover
    the compile-time validations and autocompletion along the way.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们语言的目标是提高可读性并防止一些常见的SQL错误，例如拼写错误（例如使用*FORM*而不是`FROM`）。我们将在过程中介绍编译时验证和自动完成。
- en: 'The preceding code prints the following output:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将输出以下内容：
- en: '[PRE293]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'We''ll start with the easiest part – implementing the `select` function:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的一部分开始——实现`select`函数：
- en: '[PRE294]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: We could write this using single expression notation, but we are using the more
    verbose version for clarity here. This is a function that has two parameters.
    The first is a `String`, which is simple. The second is another function that
    receives nothing and returns nothing.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单表达式符号来编写这个，但在这里我们使用更冗长的版本以提高可读性。这是一个有两个参数的函数。第一个是一个`String`，很简单。第二个是一个接收无参数并返回无参数的函数。
- en: 'The most interesting part is that we specify the receiver for our lambda:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是我们指定了lambda的接收者：
- en: '[PRE298]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'This is a very smart trick, so be sure to follow along. Remember extension
    functions, which we discussed in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, and expanded on in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*. The preceding code can be translated into
    the following code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常聪明的技巧，所以请务必跟上。记得我们在[*第1章*](B17816_01_ePub.xhtml#_idTextAnchor015)，*从Kotlin入门*中讨论的扩展函数，并在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)，*使用创建型模式*中进行了扩展。上一段代码可以转换为以下代码：
- en: '[PRE299]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'Here, you can see that although it may seem like this lambda receives nothing,
    it receives one argument: an object of the `SelectClause` type. The second trick
    lies in the usage of the `apply()` function, which we''ve already seen.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到尽管这个lambda看起来接收不到任何东西，但它接收一个参数：`SelectClause`类型的对象。第二个技巧在于`apply()`函数的使用，我们之前已经见过。
- en: 'Let''s look at this line:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这一行：
- en: '[PRE300]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'This can be translated into the following piece of code:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以转换为以下代码片段：
- en: '[PRE301]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'Here are the steps the preceding code will perform:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将执行的前一段代码的步骤：
- en: Initialize `SelectClause`, which is a simple object that receives one argument
    in its constructor.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`SelectClause`，这是一个简单的对象，其构造函数接收一个参数。
- en: Call the `from()` function with an instance of `SelectClause` as its only argument.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`from()`函数，并传入一个`SelectClause`实例作为其唯一参数。
- en: Return an instance of `SelectClause`.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个`SelectClause`实例。
- en: This code only makes sense if `from()` does something useful with `SelectClause`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有在 `from()` 对 `SelectClause` 做一些有用的事情时才有意义。
- en: 'Let''s look at our DSL example again:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的 DSL 示例：
- en: '[PRE304]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: We've made the receiver explicit now, meaning that the `from()` function will
    call the `from()` method on the `SelectClause` object.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明确指出了接收者，这意味着 `from()` 函数将调用 `SelectClause` 对象上的 `from()` 方法。
- en: 'You can start guessing what this method looks like. It receives `String` as
    its first argument and another lambda as its second:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始猜测这个方法的样子了。它接收 `String` 作为其第一个参数，并接收另一个 lambda 作为第二个参数：
- en: '[PRE309]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: This example could be shortened, but then we'd need to use `apply()` within
    `apply()`, which may seem confusing at this point.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以缩短，但那样我们就需要在 `apply()` 中使用 `apply()`，这在这个阶段可能会让人感到困惑。
- en: This is the first time we've seen the `lateinit` keyword. Remember that the
    Kotlin compiler is very serious about null safety. If we omit `lateinit`, it will
    require us to initialize the variable with a default value. But since we'll only
    know this at a later time, we are asking the compiler to relax a bit.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到 `lateinit` 关键字。记住，Kotlin 编译器对空安全非常严格。如果我们省略 `lateinit`，它将要求我们用默认值初始化变量。但由于我们将在稍后才知道这一点，我们是在请求编译器稍微放松一下。
- en: 'Important Note:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Note that if we don't make good on our promises and forget to initialize the
    variable, we'll get `UninitializedPropertyAccessException` when we access it for
    the first time.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们没有履行承诺并忘记初始化变量，当我们第一次访问它时，我们会得到 `UninitializedPropertyAccessException`。
- en: This keyword is quite dangerous, so use it with caution.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字相当危险，所以请谨慎使用。
- en: 'Let''s go back to our preceding code; all we do is the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前的代码；我们只是做了以下操作：
- en: Create an instance of `FromClause`.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `FromClause` 的实例。
- en: Store `FromClause` as a member of `SelectClause`.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FromClause` 存储为 `SelectClause` 的成员。
- en: Pass an instance of `FromClause` to the `where` lambda.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FromClause` 的实例传递给 `where` lambda。
- en: Return an instance of `FromClause`.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个 `FromClause` 的实例。
- en: 'Hopefully, you''re starting to get the gist of it:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在开始理解其精髓：
- en: '[PRE320]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '*What does this mean?* After understanding the `from()` method, this should
    be much simpler. `FromClause` must have a method called `where()` that receives
    one argument of the `String` type:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是什么意思？* 在理解了 `from()` 方法之后，这应该会简单得多。`FromClause` 必须有一个名为 `where()` 的方法，它接收一个
    `String` 类型的参数：'
- en: '[PRE325]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Note that we have made good on our promise and shortened the method this time.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经履行了承诺，这次缩短了方法。
- en: 'We initialized an instance of `WhereClause` with the string we received and
    returned it – simple as that:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接收到的字符串初始化了一个 `WhereClause` 的实例，并返回了它——就这么简单：
- en: '[PRE332]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '`WhereClause` only prints the word `WHERE` and the conditions it received:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhereClause` 只打印 `WHERE` 和它接收到的条件：'
- en: '[PRE335]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '`FromClause` prints the word `FROM`, as well as the table name it received
    and everything `WhereClause` printed:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromClause` 打印 `FROM` 以及它接收到的表名和 `WhereClause` 打印的内容：'
- en: '[PRE339]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '`SelectClause` prints the word `SELECT`, the columns it got, and whatever `FromClause`
    printed.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectClause` 打印 `SELECT`、它得到的列以及 `FromClause` 打印的内容。'
- en: Taking a break
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 休息一下
- en: Kotlin provides beautiful capabilities for creating readable and type-safe DSLs.
    But the Interpreter design pattern is one of the hardest in the toolbox. If you
    didn't get it from the get-go, take some time to debug the previous code. Understand
    what the `this` expression means at each step, as well as when we call the function
    of an object and when we call the method of an object.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了创建可读性和类型安全的 DSL 的美好功能。但解释器设计模式是工具箱中最难的一个。如果你一开始没有理解，请花些时间调试之前的代码。理解每一步中的
    `this` 表达式，以及我们调用对象函数和对象方法的时候。
- en: Call suffix
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用后缀
- en: We left out one last notion of Kotlin's DSL until the end of this section so
    that we didn't confuse you.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个部分的最后才提到了 Kotlin DSL 的最后一个概念，以免让你感到困惑。
- en: 'Let''s look at our DSL again:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的 DSL：
- en: '[PRE343]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: Note that although the `select` function receives two arguments – a string and
    a lambda – the lambda is written outside of the round brackets, not inside them.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `select` 函数接收两个参数——一个字符串和一个 lambda ——但 lambda 是写在圆括号外面的，而不是里面。
- en: This is called **call suffix** and is a widespread practice in Kotlin. If our
    function receives another function as its last argument, we can pass it out of
    parentheses.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **调用后缀**，在 Kotlin 中是一种常见的做法。如果我们的函数接收另一个函数作为其最后一个参数，我们可以将其传递出圆括号。
- en: This results in a much clearer syntax, especially for DSLs such as this one.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得语法更加清晰，特别是对于像这样的 DSL。
- en: The Interpreter design pattern and Kotlin's abilities to produce DSLs with type-safe
    builders are compelling. But as they say, *with great power comes great responsibility*.
    So, consider if your case is complex enough to construct a language within a language,
    or whether using the Kotlin basic syntax will be enough.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式和Kotlin生成类型安全的构建器的能力非常有吸引力。但正如他们所说，*权力越大，责任越大*。所以，考虑一下你的情况是否足够复杂，以至于需要构建一种语言中的语言，或者使用Kotlin的基本语法是否足够。
- en: Now, let's go back to the game we were building to see how we can decouple object
    communication.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们正在构建的游戏中，看看我们如何可以解耦对象通信。
- en: Mediator
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介
- en: The development team of our game has some real problems – and they're not related
    to code directly. As you may recall, our little indie company consists of only
    me, a canary named *Michael* that acts as a product manager, and two cat designers
    that sleep most of the day but produce some decent mockups from time to time.
    We have no **Quality** **Assurance** (**QA**) whatsoever. Maybe that's one of
    the reasons our game keeps crashing all the time.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏开发团队有一些真正的问题——这些问题与代码没有直接关系。如您所知，我们的小型独立公司只有我一个人，一只名叫*迈克尔*的金丝雀，他担任产品经理，以及两名猫设计师，他们大部分时间都在睡觉，但偶尔会制作一些不错的原型。我们完全没有**质量保证**（**QA**）。这可能也是我们的游戏总是崩溃的原因之一。
- en: 'Recently Michael has introduced me to a parrot named Kenny, who happens to
    be QA:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，迈克尔向我介绍了一只名叫肯尼的鹦鹉，他恰好是质量保证（QA）人员：
- en: '[PRE348]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '`Kenny` is a simple object that implements two interfaces: `QA`, to do QA work,
    and `Parrot`, because it''s a parrot.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kenny`是一个简单的对象，实现了两个接口：`QA`，用于进行质量保证工作，以及`Parrot`，因为它是一只鹦鹉。'
- en: 'Parrot QAs are very motivated. They''re ready to test the latest version of
    my game at any time. But they don''t like to be bothered when they are either
    sleeping or eating:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉质量保证人员非常积极。他们随时准备测试我游戏的最新版本。但他们不喜欢在睡觉或吃饭时被打扰：
- en: '[PRE358]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'In case Kenny has any questions, I gave him my direct number:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果肯尼有任何问题，我给了他我的直拨电话号码：
- en: '[PRE368]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'Kenny is a hard-working parrot. But we had so many bugs that we also had to
    hire a second parrot QA, Brad. If Kenny is free, I give the job to him as he''s
    more acquainted with our project. But if he''s busy, I check if Brad is free and
    give the task to him:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 肯尼是一只勤奋的鹦鹉。但我们有如此多的错误，我们不得不雇佣第二只鹦鹉质量保证人员，布拉德。如果肯尼有空，我会把工作交给他，因为他更熟悉我们的项目。但如果他忙，我会检查布拉德是否有空，然后把任务交给他：
- en: '[PRE371]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Brad, being more junior, usually checks with Kenny first. And Kenny also gave
    my number to him:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 布拉德作为初级员工，通常会先向肯尼确认。而且肯尼也把我的电话号码给了他：
- en: '[PRE381]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Then, Brad introduces me to George. George is an owl, so he sleeps at different
    times than Kenny and Brad. This means that he can check my code at night.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，布拉德向我介绍了乔治。乔治是一只猫头鹰，所以他的睡眠时间与肯尼和布拉德不同。这意味着他可以在晚上检查我的代码。
- en: 'George checks everything with Kenny and with me:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治会与肯尼和我一起检查一切：
- en: '[PRE386]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'The problem is that George is an avid football fan. So, before calling him,
    we need to check if he''s watching a game:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于乔治是一个狂热的足球迷。所以在给他打电话之前，我们需要检查他是否在看比赛：
- en: '[PRE391]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'Kenny, out of habit, checks in with George too, because George is a very knowledgeable
    owl:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 肯尼出于习惯，也会向乔治确认，因为乔治是一只知识渊博的猫头鹰：
- en: '[PRE401]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: 'Then, there''s Sandra. She''s a different kind of bird because she''s not part
    of QA but a copywriter:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有桑德拉。她是一种不同类型的鸟，因为她不是QA的一部分，而是一名文案：
- en: '[PRE405]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'I try not to bother her unless there''s a major release:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量不去打扰她，除非有重大发布：
- en: '[PRE414]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'I have a few problems here:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里有几个问题：
- en: First, my mind almost explodes trying to remember all those names. So might
    yours.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一，我试图记住所有那些名字时，我的大脑几乎要爆炸了。你们的可能也是。
- en: Second, I need to remember how to interact with each person. I'm the one doing
    all the checks before calling them.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点，我需要记住如何与每个人互动。我是那个在打电话给他们之前做所有检查的人。
- en: Third, notice how George tries to confirm everything with Kenny, and Kenny with
    George. Luckily, up until now, George has always been watching a football game
    when Kenny calls him. And Kenny is asleep when George needs to confirm something
    with him. Otherwise, they would get stuck on the phone for eternity.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，注意乔治如何试图与肯尼确认一切，肯尼也与乔治确认。幸运的是，到目前为止，当肯尼给他打电话时，乔治总是在看足球比赛。而肯尼在乔治需要确认某事时正在睡觉。否则，他们可能会在电话上永远卡住。
- en: Fourth, and what bothers me the most, is that Kenny plans to leave soon to open
    his own startup, ParrotPi. Imagine all the code we'll have to change now!
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四点，也是我最烦恼的事情，是肯尼计划很快就要离开去开设自己的初创公司，ParrotPi。想象一下我们现在得改多少代码！
- en: All I want to do is check if everything is alright with my code. Someone else
    should do all this talking!
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想检查我的代码是否一切正常。其他人应该做所有的谈话！
- en: The middleman
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介
- en: The **Mediator** design pattern is simply a control freak. It doesn't like it
    when one object speaks to the other directly. It gets mad sometimes when that
    happens. No – everybody should only speak through him. *What's the explanation
    for this?* It reduces coupling between objects. Instead of knowing some other
    objects, everybody should know only them, the mediator.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**中介**设计模式就是一个控制狂。它不喜欢一个对象直接与另一个对象交谈。有时当这种情况发生时，它会生气。不——每个人都应该只通过他来发言。*这个解释是什么？*它减少了对象之间的耦合。而不是了解一些其他对象，每个人都应该只了解他们，即调解人。'
- en: 'I decided that Michael should manage all those processes and act as the mediator
    of them:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定迈克尔应该管理所有这些流程，并作为它们的调解人：
- en: '[PRE424]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'Only Michael will know all the other birds:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 只有迈克尔会知道所有的其他鸟：
- en: '[PRE427]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Notice how the mediator encapsulates the complex interactions between different
    objects, exposing a very simple interface.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调解人如何封装不同对象之间的复杂交互，同时提供一个非常简单的接口。
- en: 'I''ll only remember Michael and he''ll do the rest:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会记住迈克尔，他会做剩下的：
- en: '[PRE439]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'I''ll also change my phone number and make sure that everybody gets only Michael''s:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我也会更改我的电话号码，并确保每个人都只得到迈克尔的：
- en: '[PRE444]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'Now, if somebody needs somebody else''s opinion, they''ll need to go through
    Michael first:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人需要别人的意见，他们需要先通过迈克尔：
- en: '[PRE448]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: As you can see, there's nothing new we can learn about Kotlin through this pattern.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们通过这个模式无法学到关于Kotlin的新知识。
- en: Mediator flavors
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调解人类型
- en: There are two *flavors* to the Mediator pattern. We'll call them *strict* and
    *loose*. We saw the strict version previously. We tell the mediator exactly what
    to do and expect an answer from it.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 中介模式有两种*类型*。我们将它们称为*严格*和*宽松*。我们之前看到了严格版本。我们告诉调解人确切要做什么，并期望从它那里得到答复。
- en: The loose version will expect us to notify the mediator of what happened, but
    not to expect an immediate answer. Instead, if they need to notify us in return,
    they should call us.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 简单版本会要求我们通知调解人发生了什么，但不要期望立即得到答复。相反，如果他们需要反过来通知我们，他们应该给我们打电话。
- en: Mediator caveats
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调解人注意事项
- en: Michael suddenly becomes ever so important. Everybody knows only him and only
    he can manage their interactions. He may even become a *God Object*, all-knowing
    and almighty, which is an antipattern from [*Chapter 9*](B17816_09_ePub.xhtml#_idTextAnchor216),
    *Idioms and Anti-Patterns*. Even if he's that important, be sure to define what
    this mediator should, and – even more importantly – shouldn't do.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔突然变得非常重要。每个人都只知道他，只有他才能管理他们的互动。他甚至可能成为一个*全能对象*，无所不知、无所不能，这是来自[*第9章*](B17816_09_ePub.xhtml#_idTextAnchor216)，*惯用和反模式*的反模式。即使他那么重要，也要确保定义这个调解人应该做什么，以及——更重要的是——不应该做什么。
- en: Let's continue with our example and discuss yet another behavioral pattern.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的例子，并讨论另一个行为模式。
- en: Memento
  id: totrans-723
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆
- en: Since Michael became a manager, it's been tough to catch him if I have a question.
    And when I do ask him something, he just throws something and runs to the next
    meeting.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 自从迈克尔成为经理以来，如果我有问题，就很难找到他。而且当我确实问他问题时，他只是扔下东西就跑去下一个会议。
- en: Yesterday, I asked him what new weapon we should introduce in our game. He told
    me it should be a *Coconut Cannon*, clear as day. But today, when I presented
    him with this feature, he chirped at me angrily! Finally, he said he told me to
    implement a *Pineapple Launcher* instead. I'm lucky he's just a canary.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 昨天，我问他我们游戏中应该引入什么新武器。他告诉我应该是一个*椰子加农炮*，一目了然。但今天，当我向他展示这个功能时，他生气地对我尖叫！最后，他说他告诉我实现一个*菠萝发射器*。我很幸运他只是一个金丝雀。
- en: It would be great if I could record him so that when we have another meeting
    that goes awry because he's not paying full attention, I can simply replay everything
    he said.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能记录他，那么当我们再次开会，因为他的注意力不集中而出现混乱时，我就可以简单地重放他说的所有内容。
- en: 'Let''s sum up my problems first – Michael''s thoughts are his and his only:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先总结一下我的问题——迈克尔的想法是他的，而且只有他的：
- en: '[PRE452]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: 'The problem is that since Michael is a canary, he can only hold `2` thoughts
    in his mind:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由于迈克尔是一个金丝雀，他只能在他脑海中保留`2`个想法：
- en: '[PRE456]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'If Michael thinks about more than `2` things at a time, he''ll forget the first
    thing he thought about:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迈克尔一次思考超过`2`件事情，他会忘记他最初思考的事情：
- en: '[PRE465]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Even in the recording, what he says is quite hard to understand (because he
    doesn't return anything).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在录音中，他说的内容也很难理解（因为他没有给出任何回应）。
- en: And even if I do record him, Michael can claim it's what he said, not what he
    meant.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我真的记录了他，迈克尔也可以声称那是他说的，而不是他真正想说的。
- en: The Memento design pattern solves this problem by saving the internal state
    of an object, which can't be altered from the outside (so that Michael cannot
    deny that he said it) and can only be used by the object itself.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录设计模式通过保存对象的内部状态来解决此问题，该状态不能从外部更改（这样迈克尔就不能否认他说过的话）并且只能由对象本身使用。
- en: 'In Kotlin, we can use an `inner` class to implement this:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以使用一个`inner`类来实现这一点：
- en: '[PRE469]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: Here, we can see a new keyword, `inner`, for marking our class. If we omit this
    keyword, the class is called `Nested` and is similar to the static nested class
    from Java. Inner classes have access to the private fields of the outer class.
    For that reason, our `Memory` class can change the internal state of the `Manager`
    class easily.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个新关键字`inner`，用于标记我们的类。如果我们省略这个关键字，类将被称为`Nested`，类似于Java中的静态嵌套类。内部类可以访问外部类的私有字段。因此，我们的`Memory`类可以轻松地改变`Manager`类的内部状态。
- en: 'Now, we can record what Michael says at this moment by creating an imprint
    of the current state:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过创建当前状态的印记来记录迈克尔此刻所说的话：
- en: '[PRE477]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'At this point, we can capture his thoughts in an object:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以通过一个对象来捕捉他的想法：
- en: '[PRE480]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'Now, we need to add a means of going back to a previous line of thought:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一种回到先前思考路径的方法：
- en: '[PRE486]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Here, we can see that if we want to use special characters in function names,
    such as spaces, we can, but only if a function name is wrapped in *backticks*.
    Usually, that's not the best idea, but it has its uses, as we'll cover in [*Chapter
    10*](B17816_10_ePub.xhtml#_idTextAnchor237), *Concurrent Microservices with Ktor*.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，如果我们想在函数名中使用特殊字符，如空格，我们可以这样做，但前提是函数名被反引号包围。通常这不是最好的主意，但它有其用途，我们将在[*第10章*](B17816_10_ePub.xhtml#_idTextAnchor237)中讨论，*使用Ktor的并发微服务*。
- en: 'What''s left is using `memento` to go back in time:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是使用`memento`回到过去：
- en: '[PRE492]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: The last invocation will return Michael's mind to thinking about Coconut Cannon,
    of all things.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次调用会将迈克尔的思想引回到思考椰子炮上。
- en: Note how we use the `with` standard function to avoid repeating `michael.think()`
    on each line. This function is helpful if you need to refer to the same object
    often in the same block of code and would like to avoid repetition.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`with`标准函数来避免在每一行重复`michael.think()`。这个函数在你需要在同一代码块中经常引用同一对象且希望避免重复时很有帮助。
- en: I don't expect you to see the Memento design pattern implemented very often
    in the real world. But it still may be useful in some types of applications that
    need to recover to some previous state.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我不期望你在现实世界中经常看到备忘录设计模式的实现。但它在某些需要恢复到先前状态的应用类型中可能仍然有用。
- en: At the beginning of this chapter, we discussed the Iterator design pattern,
    which helps us work with complex data structures. Next, we'll look at another
    design pattern with a somewhat similar goal.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了迭代器设计模式，它帮助我们处理复杂的数据结构。接下来，我们将探讨另一个具有类似目标的设计模式。
- en: Visitor
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: This design pattern is usually a close friend of the Composite design pattern,
    which we discussed in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding
    Structural Patterns*. It can either extract data from a complex tree-like structure
    or add behavior to each node of the tree, much like the Decorator design pattern
    does for a single object.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式通常是组合设计模式的亲密朋友，我们在[*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)中讨论过，*理解结构型模式*。它可以从复杂的树状结构中提取数据，或者为树的每个节点添加行为，就像装饰器设计模式对一个单一对象所做的那样。
- en: My plan, being a lazy software architect, worked out quite well. My request-answering
    system from the chain of responsibility worked quite well and I don't have plenty
    of time for coffee. But I'm afraid some developers begin to suspect that I'm a
    bit of a fraud.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计划，作为一个懒惰的软件架构师，实施得相当顺利。我的请求响应系统基于责任链模式运作得很好，以至于我没有太多时间喝咖啡。但我担心一些开发者开始怀疑我有点儿骗子。
- en: To confuse them, I plan to produce weekly emails with links to all the latest
    buzzword articles. Of course, I don't plan to read them myself – I just want to
    collect them from some popular technology sites.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让他们困惑，我计划每周发送包含所有最新流行词汇文章链接的电子邮件。当然，我并不打算亲自阅读它们——我只是想从一些流行的技术网站上收集它们。
- en: Writing a crawler
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写爬虫
- en: 'Let''s look at the following data structure, which is very similar to what
    we had when we discussed the Iterator design pattern:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下数据结构，它与我们在讨论迭代器设计模式时的情况非常相似：
- en: '[PRE497]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '`Page` is a container for other HTML elements, but not `HtmlElement` by itself.
    `Container` holds other containers, tables, links, and images. `Image` holds its
    link in the `src` attribute. `Link` has the `href` attribute instead.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page` 是其他 HTML 元素的容器，但本身不是 `HtmlElement`。`Container` 包含其他容器、表格、链接和图像。`Image`
    在 `src` 属性中持有其链接。`Link` 则有 `href` 属性。'
- en: What we would like to do is extract all the URLs from the object.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是从对象中提取所有 URL。
- en: 'We will start by creating a function that will receive the root of our object
    tree – a `Page` container, in this case – and return a list of all the available
    links:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数，该函数将接收我们对象树的根——在这种情况下是一个 `Page` 容器——并返回所有可用链接的列表：
- en: '[PRE507]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Using `run` allows us to control what we return from the block's body. In this
    case, we will return the `links` objects we've gathered. Inside the `run` block,
    this refers to the object it operates on – in our case, `LinksCrawler`.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run` 允许我们控制从块的主体返回的内容。在这种情况下，我们将返回我们收集到的 `links` 对象。在 `run` 块内部，这指的是它所操作的对象——在我们的例子中，是
    `LinksCrawler`。
- en: 'In Java, the suggested way to implement the Visitor design pattern is to add
    a method for each class that will accept our new functionality. We''ll do the
    same, but not for all the classes. Instead, we''ll only define this method for
    container elements:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，实现访问者设计模式的建议是为每个将接受我们新功能类的类添加一个方法。我们将这样做，但不是针对所有类。相反，我们只为容器元素定义此方法：
- en: '[PRE514]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: 'Our feature will need to hold a collection internally and expose it for read
    purposes. In Java, we will only specify the getter for this member; no setter
    is required. In Kotlin, we can specify the value without a backing field:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能需要内部持有集合并公开它以供读取。在 Java 中，我们只为这个成员指定 getter；不需要 setter。在 Kotlin 中，我们可以指定值而不需要后置字段：
- en: '[PRE519]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: We want our data structure to be immutable. That's the reason we're calling
    `toList()` on it.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的数据结构是不可变的。这就是我们调用 `toList()` 的原因。
- en: 'Important Note:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The functions that iterate over branches could be simplified even further if
    we use the Iterator design pattern.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用迭代器设计模式，遍历分支的函数可以进一步简化。
- en: 'For containers, we simply pass their elements further:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器，我们只需将它们的元素传递下去：
- en: '[PRE525]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: 'Specifying the parent class as `sealed` helps the compiler further. We discussed
    sealed classes earlier in this chapter while covering the State design pattern.
    Here is the code:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 将父类指定为 `sealed` 帮助编译器进一步优化。我们在本章讨论状态设计模式时讨论了密封类。以下是代码：
- en: '[PRE533]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'The most interesting logic is in the leaves of our tree-like structure:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们树状结构中最有趣的逻辑在叶子节点：
- en: '[PRE544]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: Note that in some cases, we don't want to do anything. This is specified by
    an empty block in our `else` clause, `else -> {}`. This is yet another example
    of **smart casts** in Kotlin.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下，我们可能不想做任何事情。这通过我们的 `else` 子句中的空块来指定，`else -> {}`。这是 Kotlin 中 **智能转换**
    的另一个例子。
- en: Notice that after we checked that the element is a `Link`, we gained type-safe
    access to its `href` attribute. That's because the compiler is doing the casts
    for us. The same is true for the `Image` element.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们检查元素是 `Link` 之后，我们获得了对其 `href` 属性的类型安全访问。这是因为编译器为我们做了转换。对于 `Image` 元素也是如此。
- en: Although we achieved our goals, the usability of this pattern can be debated.
    As you can see, it's one of the more verbose elements we have and introduces tight
    coupling between classes that are receiving additional behavior and the Visitor
    pattern itself.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管我们实现了目标，但这个模式的可用性可以讨论。正如你所见，它是我们更冗长的元素之一，并在接收额外行为和访问者模式本身之间引入了紧密耦合。 '
- en: Template method
  id: totrans-870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: 'Some lazy people make art out of their laziness. Take me, for example. Here''s
    my daily schedule:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 一些懒惰的人将他们的懒惰变成艺术。以我为例。以下是我的日常日程：
- en: '8:00 A.M. – 9:00 A.M.: Arrive at the office'
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上午 8:00 – 上午 9:00：到达办公室
- en: '9:00 A.M. – 10:00 A.M.: Drink coffee'
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上午 9:00 – 上午 10:00：喝咖啡
- en: '10:00 A.M. –1 2:00 P.M.: Attend some meetings or review code'
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上午 10:00 – 中午 12:00：参加一些会议或审查代码
- en: '12:00 P.M. – 1:00 P.M.: Go out for lunch'
  id: totrans-875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中午 12:00 – 下午 1:00：外出吃午餐
- en: '1:00 P.M. – 4:00 P.M.: Attend some meetings or review code'
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下午 1:00 – 下午 4:00：参加一些会议或审查代码
- en: '4:00 P.M.: Sneak back home'
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下午 4:00：偷偷溜回家
- en: Some parts of my schedule never change, while some do. Specifically, I have
    two slots in my calendar that any number of meetings could occupy.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我日程表中的某些部分永远不会改变，而有些则会。具体来说，我的日程表中有两个时间段，任何数量的会议都可能占据。
- en: At first, I thought I could decorate my changing schedule with that setup and
    teardown logic, which happens before and after. But then there's lunch, which
    is holy for architects and happens in between.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我以为我可以使用那种设置和销毁逻辑来装饰我的变动日程，这些逻辑发生在前后。但后来有午餐，对于建筑师来说这是神圣的，而且发生在中间。
- en: 'Java is pretty clear on what you should do. First, you create an abstract class.
    Then, you mark all the methods that you want to implement by yourself as `private`:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在你该做什么方面非常明确。首先，你创建一个抽象类。然后，你将所有你想自己实现的方法标记为 `private`：
- en: '[PRE557]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'All the methods that are changing from day to day should be defined as `abstract`:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 所有每天都会变化的方法都应该定义为 `abstract`：
- en: '[PRE576]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: 'If you want to be able to replace a function but also want to provide a default
    implementation, you should leave it `public`:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要能够替换一个函数，同时也想提供一个默认实现，你应该将其留为 `public`：
- en: '[PRE583]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: Remember that `public` is the default visibility in Kotlin.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Kotlin 中 `public` 是默认的可访问性。
- en: 'Finally, you have a method that executes your algorithm. It''s `final` by default:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你有一个执行你的算法的方法。它默认是 `final` 的：
- en: '[PRE590]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: 'Now, if we want to have a schedule for Monday, we can simply implement the
    missing parts:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想有一个周一的日程表，我们可以简单地实现缺失的部分：
- en: '[PRE601]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '*What does Kotlin add on top of that?* What it usually does – conciseness.
    As we saw previously, this can be achieved through functions.'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kotlin 在这个基础上又添加了什么？* 它通常做的事情 – 简洁。正如我们之前看到的，这可以通过函数来实现。'
- en: 'We have three *moving parts* – two mandatory activities (the software architect
    must do something before and after lunch) and one optional (the boss may stop
    him before he sneaks off home):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个 *动态部分* – 两个强制性的活动（软件架构师必须在午餐前后做些事情）和一个可选的（老板可能在他在家之前阻止他）：
- en: '[PRE614]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: 'We''ll have a function that accepts up to three other functions as its arguments.
    The first two are mandatory, while the third may not be supplied at all or assigned
    with `null` to explicitly state that we don''t want that function to occur:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个函数，它接受最多三个其他函数作为其参数。前两个是强制性的，而第三个可能根本不提供或用 `null` 分配，以明确表示我们不希望该函数发生：
- en: '[PRE619]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: 'Inside this function, we''ll have our algorithm. The invocations of `beforeLunch()`
    and `afterLunch()` should be clear; after all, those are the functions that are
    passed to us as arguments. The third one, `bossHook`, may be `null`, so we only
    execute it if it''s not. We can use the following construct for that:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们将有我们的算法。`beforeLunch()` 和 `afterLunch()` 的调用应该是清晰的；毕竟，这些是我们作为参数传递给我们的函数。第三个，`bossHook`
    可能是 `null`，所以我们只有在它不是 `null` 的情况下才执行它。我们可以使用以下结构来实现这一点：
- en: '[PRE629]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '*But what about the other functions – the ones we want to always implement
    by ourselves?*'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么其他函数呢 – 我们总是想自己实现的函数呢？*'
- en: 'Kotlin has a notion of **local functions**. These are functions that reside
    in other functions:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 有一个关于 **局部函数** 的概念。这些是位于其他函数中的函数：
- en: '[PRE630]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: These are all valid ways to declare a local function. No matter how you define
    them, they're invoked in the same way. Local functions can only be accessed by
    the parent function they were declared in and are a great way to extract common
    logic without the need to expose it.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是声明局部函数的有效方式。无论你如何定义它们，它们的调用方式都是相同的。局部函数只能由它们被声明的父函数访问，并且是提取常见逻辑而不需要暴露的好方法。
- en: With that, we're left with the code structure. Defining the algorithm's structure
    but letting others decide what to do at some points – that's what the Template
    method is all about.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就剩下了代码结构。定义算法的结构，但让其他人决定在某些点做什么 – 这就是模板方法的核心。
- en: We're almost at the end of this chapter. There is just one more design pattern
    to discuss, but it's one of the most important ones.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到了本章的结尾。还有最后一个设计模式要讨论，但它是最重要的之一。
- en: Observer
  id: totrans-984
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: Probably one of the highlights of this chapter, this design pattern provides
    us with a bridge to the following chapters, which are dedicated to functional
    programming.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本章的一个亮点，这个设计模式为我们提供了一个通往以下章节的桥梁，这些章节专门讨论函数式编程。
- en: '*So, what is the* **Observer** *pattern all about?* You have one *publisher*,
    which may also be called a *subject*, that may have many *subscribers*, also known
    as *observers*. Each time something interesting happens with the publisher, all
    of its subscribers should be updated.'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，观察者模式究竟是什么？* 你有一个 *发布者*，也可以称为 *主题*，它可能有多个 *订阅者*，也称为 *观察者*。每当发布者发生有趣的事情时，所有订阅者都应该得到更新。'
- en: This may look a lot like the **Mediator** design pattern, but there's a twist.
    Subscribers should be able to register or unregister themselves at runtime.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很像**中介者**设计模式，但有一个转折。订阅者应该能够在运行时注册或注销自己。
- en: In the classical implementation, all subscribers/observers need to implement
    a particular interface for the publisher to update them. But since Kotlin has
    higher-order functions, we can omit this part. The publisher will still have to
    provide a means for observers to be able to subscribe and unsubscribe.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典实现中，所有订阅者/观察者都需要实现一个特定接口，以便发布者可以更新它们。但由于Kotlin有高阶函数，我们可以省略这部分。发布者仍然需要提供一种方法，让观察者能够订阅和取消订阅。
- en: This may have sounded a bit complex, so let's take a look at the following example.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点复杂，所以让我们看看以下示例。
- en: Animal choir example
  id: totrans-990
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动物合唱团示例
- en: So, some animals have decided to have a choir of their own. The cat was elected
    as the conductor of the choir (it doesn't like to sing anyway).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些动物决定拥有自己的合唱团。猫被选为合唱团的指挥（它根本不喜欢唱歌）。
- en: 'The problem is that these animals escaped from the Java world, so they don''t
    have a common interface. Instead, each has a different way of making a sound:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这些动物逃离了Java世界，因此它们没有共同的接口。相反，每个都有不同的发声方式：
- en: '[PRE646]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: 'Luckily, the cat was elected not only because it was vocally challenged, but
    also because it was smart enough to follow this chapter until now. So, it knows
    that in the Kotlin world, it can accept functions:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，猫不仅因为嗓音不佳而被选为指挥，而且还因为足够聪明，能够一直跟随到这一章。所以，它知道在Kotlin世界中，它可以接受函数：
- en: '[PRE664]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Previously, we learned how to pass a new function as an argument, as well as
    a literal function. *But how do we pass a reference to a member function?*
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何传递一个新函数作为参数，以及一个字面量函数。*但是，我们如何传递成员函数的引用呢？*
- en: 'We can do this in the same way that we did in the Strategy design pattern;
    that is, by using the member reference operator (`::`):'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在策略设计模式中做的那样来做这件事；也就是说，通过使用成员引用操作符（`::`）：
- en: '[PRE672]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: 'Now, the cat needs to save all those subscribers somehow. Luckily, we can put
    them on a map. *What would be the key?* This should be the function itself:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，猫需要以某种方式保存所有这些订阅者。幸运的是，我们可以将它们放在一个映射中。*那这个键是什么？* 这应该是函数本身：
- en: '[PRE680]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: If all those `()->Unit` instances are making you dizzy, be sure to use `typealias`
    to give them more semantic meaning, such as *subscriber*.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有那些`()->Unit`实例让你感到头晕，请务必使用`typealias`来赋予它们更多的语义意义，例如 *订阅者*。
- en: 'Now, the bat decides to leave the choir. After all, no one can hear its beautiful
    singing:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，蝙蝠决定离开合唱团。毕竟，没有人能听到它那美妙的歌声：
- en: '[PRE687]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'All `bat` needs to do is pass its subscriber function again:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`bat`需要做的只是再次传递其订阅者函数：
- en: '[PRE694]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'That''s the reason we used the map in the first place. Now, the cat can call
    all its choir members and tell them to sing – well, produce sounds:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们最初使用映射的原因。现在，猫可以调用所有合唱团成员，告诉他们唱歌——好吧，发声：
- en: '[PRE695]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: 'So, the rehearsal went well. But the cat is very tired after doing all those
    loops. It would rather delegate the job to choir members. That''s not a problem:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，排练进行得很顺利。但猫在完成所有那些循环后非常累。它宁愿将任务委托给合唱团成员。这没问题：
- en: '[PRE706]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'Our subscribers will have to change slightly to receive a new argument. Here''s
    an example for the `Turkey` class:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微修改订阅者以接收一个新参数。以下是对`Turkey`类的示例：
- en: '[PRE721]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: 'This is a bit of a problem. *What if the cat was to tell each animal what sound
    to make: high or low?* We''d have to change all the subscribers again, as well
    as the cat.'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点问题。*如果猫要告诉每只动物发出什么样的声音：高音还是低音？* 我们将不得不再次更改所有订阅者以及猫。
- en: 'While designing your publisher, pass the single data classes with many properties,
    instead of sets of data classes or other types. That way, you won''t have to refactor
    your subscribers as much if new properties are added:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计发布者时，传递具有许多属性的单个数据类，而不是数据类集合或其他类型。这样，如果添加了新属性，你就不必对订阅者进行太多重构：
- en: '[PRE728]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: Here, we used `enum` to describe the different types of pitches and a data class
    to encapsulate the pitch to be used, as well as how many times the message should
    be repeated.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`enum`来描述不同的音调类型，并使用数据类来封装要使用的音调以及消息应该重复多少次。
- en: 'Make sure that your messages are immutable. *Otherwise, you may experience
    strange behavior! What if you have sets of different messages you''re sending
    from the same publisher?* We could use smart casts to solve this:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的消息是不可变的。*否则，你可能会遇到奇怪的行为！如果你有来自同一发布者的不同消息集怎么办？*我们可以使用智能转换来解决：
- en: '[PRE737]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '[PRE749]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: The Observer design pattern is enormously useful. Its power lies in its flexibility.
    The publisher doesn't need to know anything about the subscribers, except the
    signature of the function it invokes. In the real world, it is widely used both
    in reactive frameworks, which we'll discuss in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*, and [*Chapter 11*](B17816_11_ePub.xhtml#_idTextAnchor251),
    *Reactive Microservices with Vert.x*, and in Android, where all the UI events
    are implemented as subscriptions.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式非常有用。其力量在于其灵活性。发布者不需要了解任何关于订阅者的信息，除了它调用的函数的签名。在现实世界中，它在反应式框架中得到了广泛的应用，我们将在[*第6章*](B17816_06_ePub.xhtml#_idTextAnchor164)“线程和协程”和[*第11章*](B17816_11_ePub.xhtml#_idTextAnchor251)“使用Vert.x的反应式微服务”中讨论，以及在Android中，所有UI事件都实现为订阅。
- en: Summary
  id: totrans-1122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a long chapter, but we've also learned a lot. We finished covering
    all the classical design patterns, including 11 behavioral ones. In Kotlin, functions
    can be passed to other functions, returned from functions, and assigned to variables.
    That's what the higher-order functions and functions as first-class citizens concepts
    are all about. If your class is all about behavior, it often makes sense to replace
    it with a function. This concept helped us implement the Strategy and Command
    design patterns.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章很长的内容，但我们也学到了很多。我们完成了对所有经典设计模式的覆盖，包括11个行为模式。在Kotlin中，函数可以被传递到其他函数中，从函数中返回，并分配给变量。这就是高阶函数和函数作为一等公民的概念。如果你的类主要是关于行为，那么用函数替换它通常是有意义的。这个概念帮助我们实现了策略和命令设计模式。
- en: We learned that the Iterator design pattern is yet another `operator` in the
    language. Sealed classes make the `when` statements exhaustive and we used them
    to implement the State design pattern.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到迭代器设计模式是语言中的另一个`operator`。密封类使`when`语句变得详尽，我们使用它们来实现状态设计模式。
- en: We also looked at the Interpreter design pattern and learned that lambda with
    a receiver allows clearer syntax in your DSLs. Another keyword, `lateinit`, tells
    the compiler to relax a bit when it's performing its null safety checks. *Use
    it with care!*
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了解释器设计模式，并了解到带有接收者的lambda表达式可以使你的领域特定语言（DSL）的语法更清晰。另一个关键字`lateinit`告诉编译器在执行其空安全检查时可以稍微放松一些。*请谨慎使用！*
- en: Finally, we covered how to reference an existing method with function references
    while talking about the Observer design pattern.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在讨论观察者设计模式时，我们介绍了如何使用函数引用引用现有方法。
- en: In the next chapter, we'll move on from the object-oriented programming paradigm,
    with its well-known design patterns, to another paradigm – functional programming.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从面向对象编程范式及其众所周知的设计模式转移到另一个范式——函数式编程。
- en: Questions
  id: totrans-1128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between the Mediator and Observer design patterns?
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中介者和观察者设计模式之间的区别是什么？
- en: What is a **Domain-Specific Language** (**DSL**)?
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**领域特定语言**（**DSL**）？
- en: What are the benefits of using a sealed class or interface?
  id: totrans-1131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密封类或接口的好处是什么？
