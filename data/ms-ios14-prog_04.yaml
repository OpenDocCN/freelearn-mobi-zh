- en: '*Chapter 4*: Creating a Detail Page'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：创建详细页面'
- en: So far, you have managed to build an app that shows a set of contacts on a custom
    grid in a collection view. This is pretty impressive but not very useful. Typically,
    a user will expect to be able to see more information when tapping on an item
    in an overview.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功构建了一个应用，该应用在集合视图中以自定义网格显示一组联系人。这相当令人印象深刻，但并不十分有用。通常，用户会期望在点击概览中的项目时能够看到更多信息。
- en: In this case, they would likely expect to see more details about the tapped
    contact, for instance, their email address and phone number. In this chapter,
    you will see how to do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，他们可能会期望看到更多关于被点击联系人的详细信息，例如他们的电子邮件地址和电话号码。在本章中，你将看到如何做到这一点。
- en: We'll also be introduced to `UIStackView` for the first time too, a comprehensive
    and powerful way to lay out a display without the need for over-complex autolayout
    solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将首次接触到 `UIStackView`，这是一种无需过度复杂的自动布局解决方案，即可全面且强大地布局显示的方式。
- en: Finally, we'll touch on the best practices when it comes to passing data from
    one view controller to another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论在从一个视图控制器传递数据到另一个视图控制器时的最佳实践。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing navigation with segues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 segues 实现导航
- en: Creating our layout with `UIStackView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UIStackView` 创建布局
- en: Passing data between view controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图控制器之间传递数据
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要从 Apple 的 App Store 下载 Xcode 版本 11.4 或更高版本。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for Xcode in the App Store and select and download the latest version.
    Launch Xcode and follow any additional installation instructions that your system
    may prompt you with. Once Xcode has fully launched, you're ready to go.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要运行最新版本的 macOS（Catalina 或更高版本）。只需在 App Store 中搜索 Xcode，选择并下载最新版本。启动 Xcode
    并遵循系统可能提示的任何其他安装说明。一旦 Xcode 完全启动，你就可以开始了。
- en: 'Download the sample code from the following GitHub link: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下 GitHub 链接下载示例代码：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)
- en: Implementing navigation with segues
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 segues 实现导航
- en: Most good applications have more than a single screen. I bet that most app ideas
    you have in your head involve at least a couple of different screens. Maybe you
    would like to display a table view or a collection view that links to a detail
    page. Or perhaps you want your user to drill down into your app's contents in
    a different way. Maybe you don't have any detail views but you would like to display
    a couple of modal screens for data input instead.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优秀应用都有不止一个屏幕。我敢打赌，你头脑中的大多数应用想法至少涉及两个不同的屏幕。也许你希望显示一个表格视图或集合视图，这些视图可以链接到详细页面。或者，也许你希望用户以不同的方式深入到你的应用内容中。也许你没有任何详细视图，但你想显示几个用于数据输入的模态屏幕。
- en: Every time your user moves from one screen in your app to another, they are
    navigating. Navigation is an essential aspect of building an app, and you must
    understand the possibilities and patterns for building good navigation on the
    iOS platform. The easiest way to gain insight into navigation is by using a storyboard
    to explore the available options.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你的用户从你的应用中的一个屏幕移动到另一个屏幕时，他们就是在导航。导航是构建应用的一个基本方面，你必须了解在 iOS 平台上构建良好导航的可能性和模式。了解导航的最简单方法是通过使用故事板来探索可用的选项。
- en: Up until now, and with the exception of SwiftUI you have used your storyboard
    to create the layout for a single screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，除了 SwiftUI 之外，你一直使用你的故事板来创建单个屏幕的布局。
- en: However, the name storyboard implies that you can do a lot more than laying
    out a single screen. The purpose of using a storyboard is the ability to lay out
    all screens of your application in a single place so you can easily see how screens
    and sections of your app are related and how users navigate between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，故事板这个名字暗示你可以做很多不仅仅是布局单个屏幕的事情。使用故事板的目的在于能够在一个地方布局你应用的所有屏幕，这样你可以轻松地看到屏幕和你的应用部分之间的关系以及用户如何在它们之间导航。
- en: 'In this section, we''ll cover the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下内容：
- en: Creating our new details view
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的新详细视图
- en: Implementing and understanding segues
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 和 理解 segues
- en: Creating a manual segue
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建手动 segue
- en: Let's get started.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating our new details view
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的新详细视图
- en: In this section, you will add a second view controller to your storyboard that
    functions as a detail page when a user taps on a contact – we'll continue working
    on our collection view project from [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066),
    *Using Lists and Tables*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在故事板中添加一个第二个视图控制器，当用户点击联系人时，它将作为一个详细页面工作——我们将继续从[*第 3 章*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066)，*使用列表和表格*中我们的集合视图项目。
- en: 'Let''s start by doing the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做以下操作：
- en: Open the `Main.storyboard` file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Main.storyboard` 文件。
- en: Search and drag out a view controller from the **Object Library** (just like
    we did with our collection view objects).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象库**中搜索并拖出一个视图控制器（就像我们处理集合视图对象时做的那样）。
- en: Drop it next to the existing view controller.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在现有视图控制器旁边。
- en: Look for a label in the **Object Library** and add it to the new view controller
    you just added to the storyboard.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象库**中查找一个标签并将其添加到刚刚添加到故事板中的新视图控制器。
- en: 'All going well, it should look something like the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它应该看起来像以下图示：
- en: '![Figure 4.1 – Storyboard with new detail view'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 包含新详细视图的故事板'
- en: '](img/Figure_4.01_B14717.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.01_B14717.jpg)'
- en: Figure 4.1 – Storyboard with new detail view
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 包含新详细视图的故事板
- en: Before you add all the content for the contact detail page to the second view
    controller, it's a good idea to configure the navigation from the overview page
    to the detail page. To do this, you're going to create a selection segue.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将联系人详细页面的所有内容添加到第二个视图控制器之前，配置从概览页面到详细页面的导航是个好主意。为此，你需要创建一个选择过渡。
- en: Implementing and understanding segues
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现和理解过渡
- en: A **segue** is a transition from one screen to the next. Not all segues are
    animated; sometimes you might need to present the next screen without performing
    a smooth animation. Both animated and static transitions can be set up with segues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**过渡**是从一个屏幕到另一个屏幕的转换。并非所有过渡都是动画的；有时你可能需要在不执行平滑动画的情况下展示下一个屏幕。动画和静态转换都可以通过过渡来设置。'
- en: Any time you connect one screen to the next to perform navigation, you are creating
    a segue. Some segues are performed when the user taps a button; these are called
    **action segues**. Segues that are only triggered through code are called **manual
    segues**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你连接一个屏幕到下一个以执行导航时，你都在创建一个过渡。有些过渡是在用户点击按钮时执行的；这些被称为**动作过渡**。仅通过代码触发的过渡被称为**手动过渡**。
- en: The selection segue you're going to use in this sample is a segue that is set
    up by connecting a table view cell or collection view cell to the next screen.
    The segue is performed when the user taps on a cell.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个示例中将要使用的选择过渡是通过将表格视图单元格或集合视图单元格连接到下一个屏幕来设置的。当用户点击单元格时执行过渡。
- en: 'To set up your selection segue, follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的选择过渡，请按照以下步骤操作：
- en: Select the prototype collection view cell you have created for the contacts
    overview page.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择为联系人概览页面创建的原型集合视图单元格。
- en: Next, press and hold the *Ctrl* key while you drag from the cell to the second
    view controller.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按住 *Ctrl* 键，从单元格拖动到第二个视图控制器。
- en: 'When you release the mouse over the second view controller, a list of options
    is shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将鼠标移至第二个视图控制器上时，会显示一个选项列表：
- en: '![Figure 4.2 – Segue Connector for new Detail View'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 新的详细视图的过渡连接器'
- en: '](img/Figure_4.02_B14717.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B14717.jpg)'
- en: Figure 4.2 – Segue Connector for new Detail View
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 新的详细视图的过渡连接器
- en: This list of possibilities describes how the detail view will be presented to
    the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项列表描述了如何向用户展示详细视图。
- en: For example, select the modal presentation style from the generated list. This
    will display the detail page with an upward animation from the bottom of the screen
    (a model), this is not quite the route we are going to take. However, if you now
    launch the iOS simulator and select one of the cells, you'll see the effect it
    has.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从生成的列表中选择模态展示样式。这将从屏幕底部向上显示详细页面（一个模型），这并不是我们将要走的路线。然而，如果你现在启动 iOS 模拟器并选择其中一个单元格，你会看到它产生的影响。
- en: A better way to show the contact is by adding it to the navigation stack. Doing
    this will make a back button appear in the navigation bar, and the user will immediately
    understand that they are looking at a detail page due to the animation that moves
    the new view controller in from the right-hand side of the screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将联系人添加到导航堆栈中，可以更好地显示联系人。这样做将在导航栏中显示一个返回按钮，并且由于从屏幕右侧移动新视图控制器而产生的动画，用户会立即明白他们正在查看一个详情页面。
- en: To set this up, you need to select the **Show** segue – highlight the previously
    created segue and hit *Delete* on your keyboard.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置此选项，你需要选择 **Show** 转场 – 高亮显示之前创建的转场，然后在键盘上按 *Delete*。
- en: This segue pushes the newly presented view controller onto the existing navigation
    controller's navigation stack, but until we tell our app that we require navigation
    in this way, it will still be treated as a model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转场将新显示的视图控制器推送到现有导航控制器导航堆栈中，但直到我们告诉我们的应用我们以这种方式需要导航，它仍然被视为一个模型。
- en: To fix this, add a new object via the Object Library called **Navigation Controller**,
    and drag this into your storyboard. You'll notice this will have brought across
    what appears to be two view controllers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，通过对象库添加一个新的名为 **Navigation Controller** 的对象，并将其拖动到你的故事板中。你会注意到这会带来两个视图控制器。
- en: The first is the navigation view controller itself (the one we care about) and
    the other is a template or a pre-defined `rootViewController`, which is already
    hooked into the navigation view controller.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是导航视图控制器本身（我们关心的那个）和另一个是模板或预定义的 `rootViewController`，它已经连接到导航视图控制器。
- en: 'In order to modify this, do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改这个，执行以下操作：
- en: Simply delete this `rootViewController`, leaving the navigation controller where
    it is.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地删除这个 `rootViewController`，保留导航控制器在当前位置。
- en: Then, press *Ctrl* and primary click from the navigation controller and drag
    to our exiting `ViewController`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按住 *Ctrl* 并从导航控制器进行主点击，然后拖动到我们的现有 `ViewController`。
- en: When released, you'll be offered the option to make this the `rootViewController`.
    Select this option.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放时，你会得到一个选项来将其设置为 `rootViewController`。选择此选项。
- en: One final change to make is you'll notice an arrow going into the side of our
    existing **View Controller**; drag this from here to the **Navigation Controller**
    – all this is doing is setting this as our **Initial View Controller** so when
    the app is launched, it knows where to start.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的最后一个更改是你会注意到一个箭头进入我们现有的 **View Controller** 的侧面；将这个箭头从这里拖动到 **Navigation
    Controller** – 所有这些只是在设置这个为我们的 **Initial View Controller**，这样当应用启动时，它就知道从哪里开始。
- en: Go ahead now and run the app. You should be able to successfully navigate back
    and forth whilst clicking on cells. Let's take a look now at how we would create
    a manual segue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用。你应该能够在点击单元格时成功导航前后。现在让我们看看如何创建一个手动转场。
- en: Creating a manual segue
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建手动转场
- en: We'll start by deleting the segue we just created. Now drag from the yellow
    circle at the top of the first view controller window to the second view controller
    – you've now just created a manual segue.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将删除我们刚刚创建的转场。现在从第一个视图控制器窗口顶部的黄色圆圈拖动到第二个视图控制器 – 你现在已经创建了一个手动转场。
- en: When the dialog to determine how the segue is performed appears, select **show**
    again because you don't want to use a different animation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现确定如何执行转场对话框时，再次选择 **show**，因为你不想使用不同的动画。
- en: Click on the connecting line to inspect the segue and set the value for the
    `detailViewSegue` in **Attributes Inspector**. Similar to how you set a reuse
    identifier on table view cells and collection view cells, segues also use a string
    as their identifier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 点击连接线来检查转场，并在 **Attributes Inspector** 中设置 `detailViewSegue` 的值。类似于在表格视图单元格和集合视图单元格上设置重用标识符，转场也使用字符串作为它们的标识符。
- en: 'To trigger the segue after the animation, you must manually do so from your
    code. Open `ViewController.swift` and update the contents of `collectionView(_:didSelectItemAt:)`
    as shown in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在动画之后触发转场，你必须从你的代码中手动执行。打开 `ViewController.swift` 并更新 `collectionView(_:didSelectItemAt:)`
    的内容，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With one line of code, we can hook into our segue via its identifier and away
    we go. Run the app now and see how easy that was.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一行代码，我们可以通过其标识符连接到我们的转场，然后就可以开始了。现在运行应用，看看有多简单。
- en: In this section, we've started to create and build our very own details view
    page, learning all about how we can configure and control segues to push from
    one View Controller to the next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开始创建和构建我们自己的详细视图页面，了解我们如何配置和控制从一个视图控制器推送到下一个视图控制器。
- en: In the next section, we'll take a look at creating adaptive layouts without
    the need for `Autolayout`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看如何创建无需`Autolayout`的自适应布局。
- en: Creating our layouts with UIStackView
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UIStackView创建我们的布局
- en: Now we've got the foundations all set up, let's look at how we are going to
    build our details page.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有基础，让我们看看我们将如何构建我们的详细页面。
- en: We have several options. One way is `UIStackView`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个选择。一种方法是`UIStackView`。
- en: Stack views can lay out views that are added next to each other or on top of
    each other all by itself. This saves you adding constraints for the vertical spacing
    between labels like we did for the contact detail information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠视图可以自行布局相邻或堆叠在一起的视图。这节省了你添加标签之间垂直间距约束的需要，就像我们在联系人详细信息中做的那样。
- en: Since stack views can also lay out objects that are next to each other and stack
    views can be nested, it could also take care of the two-column layout that you
    implemented for screens with a regular width size class. And to top it all off,
    you can swap the direction in which a stack view lays out its items at runtime,
    meaning you can change it from horizontal to vertical depending on the available
    space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆叠视图也可以布局相邻的对象，并且堆叠视图可以嵌套，因此它还可以处理为常规宽度大小类屏幕实现的二维布局。而且，最重要的是，你可以在运行时交换堆叠视图布局项的方向，这意味着你可以根据可用空间将其从水平更改为垂直。
- en: This will simplify a lot of the work that needs to be done and it makes your
    layout a lot more maintainable as well. To use a stack view, all you need to do
    is add one to your new view controller in Interface Builder via `Stack View`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将大大简化需要完成的大量工作，并且使你的布局更容易维护。要使用堆叠视图，你只需要在Interface Builder中通过`Stack View`将一个添加到你的新视图控制器中）。
- en: Containing labels in a stack view
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在堆叠视图中包含标签
- en: 'Let''s start to create our page layout:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的页面布局：
- en: 'Adding in six UILabel''s, three will be titles, and the others will be variable
    data (make sure you set your colors correctly: see [*Chapter 2*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046),
    *Working with Dark Mode*). Something like this will work nicely:![Figure 4.3 –
    Updated storyboard with labels'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加六个`UILabel`，其中三个将是标题，其余将是变量数据（确保你设置好颜色：见[*第2章*](B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046)，*使用深色模式*)。像这样会很好用：![图4.3
    – 带有标签的更新后的故事板
- en: '](img/Figure_4.03_B14717.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.03_B14717.jpg)'
- en: Figure 4.3 – Updated storyboard with labels
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.3 – 带有标签的更新后的故事板
- en: Now, select the six labels in the contact info view and embed them in a stack
    view by using the **Embed In** menu as shown in the following screenshot:![Figure
    4.4 – Embed In Stack View
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择联系人信息视图中的六个标签，并使用以下截图所示的**嵌入到**菜单将它们嵌入到堆叠视图中：![图4.4 – 嵌入到堆叠视图
- en: '](img/Figure_4.04_B14717.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.04_B14717.jpg)'
- en: Figure 4.4 – Embed In Stack View
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.4 – 嵌入到堆叠视图
- en: Add in two other elements, such as image view or contact name, and group those
    together (separately from the labels you've just embedded).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个其他元素，例如图像视图或联系人名称，并将它们分组（与刚刚嵌入的标签分开）。
- en: Now, for the clever part, highlight both stack views and click on **Embed In**
    to embed them into a single Stack View.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于巧妙的部分，突出显示两个堆叠视图，然后点击**嵌入到**以将它们嵌入到一个单独的堆叠视图中。
- en: Looking good. Well, almost – we'll still need to make a few minor tweaks. First,
    we'll add an `Autolayout` constraint to our main stack view of `0,16,16,0` (basically,
    hugging this to our bounds apart from the trailing and leading).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。嗯，几乎是这样——我们仍然需要做一些小的调整。首先，我们将向主堆叠视图添加一个`Autolayout`约束`0,16,16,0`（基本上，除了尾部和头部之外，将其紧贴我们的边界）。
- en: 'Next, you''ll need to set a height in **Autolayout** for each label (and image)
    inside your stack view:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在堆叠视图中的每个标签（和图像）上设置**Autolayout**的高度：
- en: Set your constraint values to `250` and all labels to `25`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将约束值设置为`250`，并将所有标签设置为`25`。
- en: Once done, select the parent stack view and within **Attributes Inspector**,
    make sure that **Alignment** is set to **Fill** and **Distribution** is set to
    **Fill Proportionally**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，选择父堆叠视图，并在**属性检查器**中确保**对齐**设置为**填充**，**分布**设置为**按比例填充**。
- en: These settings make sure that items are positioned a certain way within the
    stack view. In this case, **Leading** makes the items stick to the left side of
    the stack view. Setting this value to **Center** would align them in the middle,
    and **Fill** ensures that the stack's children are all stretched out to fill the
    entire width.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置确保项目在堆叠视图中以某种方式定位。在这种情况下，**Leading** 使项目粘附在堆叠视图的左侧。将此值设置为 **Center** 将使它们居中，而
    **Fill** 确保堆叠的子项都拉伸以填充整个宽度。
- en: 'Once you''ve done that, you should have something that looks like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你应该会看到以下内容：
- en: '![Figure 4.5 – Detail View in Stack View'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 栈视图中的详细视图'
- en: '](img/Figure_4.05_B14717.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B14717.jpg)'
- en: Figure 4.5 – Detail View in Stack View
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 栈视图中的详细视图
- en: Now our detail view is all ready for some data, so let's see how we go about
    doing that in the next part, but first, we'll need to create a new **View Controller**
    file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的详细视图已经准备好接收一些数据了，所以让我们看看在下一部分我们将如何进行，但首先，我们需要创建一个新的 **视图控制器** 文件。
- en: 'In the navigation tree, highlight the root level group (folder) and do the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航树中，突出显示根级别组（文件夹），然后执行以下操作：
- en: Secondary-click to bring up the menu.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击以显示菜单。
- en: Click on **New File**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **新建文件**。
- en: Select **Cocoa Touch Class** from the list of options (click **Next**).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从选项列表中选择 **Cocoa Touch 类**（点击 **下一步**）。
- en: Name the new file `DetailsViewController` with a subclass of `UIViewController`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为 `DetailsViewController`，它是一个 `UIViewController` 的子类。
- en: Click **Next** and then **Create**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**，然后 **创建**。
- en: Once you've done this, add in all the required outlets and hook them up. But
    before Interface Builder will let you hook these up, you'll need to set the class
    of your `DetailsViewController` – just as we did with the custom cells back in
    [*Chapter 3*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066), *Using Lists and
    Tables*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，添加所有必需的出口并将它们连接起来。但在 Interface Builder 允许你连接这些出口之前，你需要设置 `DetailsViewController`
    的类 – 就像我们在 [*第 3 章*](B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066) 中做的那样，*使用列表和表格*。
- en: 'We''ll also need to add in the following variable, as we''ll be passing this
    model across to our new View Controller very soon:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加以下变量，因为我们很快就会将这个模型传递给新的视图控制器：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With all that done, we can now look to update our `retrieveContacts()` logic
    to fetch the new data we require.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们现在可以更新我们的 `retrieveContacts()` 逻辑以获取所需的新数据。
- en: Passing data between view controllers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图控制器之间传递数据
- en: So, the next part of our app is to pass some data over to our new details view
    but to do this, we need to create a new View Controller and hook up our labels
    and images to some outlets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应用程序的下一部分是将一些数据传递到我们的新详细视图中，但要做到这一点，我们需要创建一个新的视图控制器，并将我们的标签和图像连接到一些出口。
- en: The code that fetches contact information also needs to be updated too, so a
    contact's phone number, email address, and postal address are fetched.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 获取联系信息的代码也需要更新，以便获取联系人的电话号码、电子邮件地址和邮政地址。
- en: 'Finally, the contact data needs to be passed from the overview to the details
    page so the details page can display the data. The steps involved in this process
    are the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要将联系数据从概览页面传递到详细页面，以便详细页面可以显示数据。这个过程涉及以下步骤：
- en: Updating the data loading
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据加载
- en: Passing the model to the details page
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型传递到详细页面
- en: Updating our outlets
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的出口
- en: Best practices (creating a view model)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳实践（创建视图模型）
- en: Let's now go through each step.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在逐一介绍每个步骤。
- en: Updating the data loading
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据加载
- en: Currently, the code in `ViewController.swift` specifies that just the given
    name, family name, image data, and image availability for a contact should be
    fetched.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`ViewController.swift` 中的代码指定，只需获取联系人的给定名称、姓氏、图像数据和图像可用性。
- en: This needs to be expanded so the email address, postal address, and phone number
    are fetched as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 需要扩展以获取电子邮件地址、邮政地址和电话号码。
- en: 'Update the `retrieveContacts(store:)` method with the following code for `keysToFetch`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `retrieveContacts(store:)` 方法中的 `keysToFetch`：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are just explicitly setting the desired data we would like to retrieve
    from our contacts. Once we've done this, we're ready to pass the data across to
    our details view controller.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是明确设置我们希望从联系人中检索的数据。完成这些后，我们就准备好将数据传递到详细视图控制器了。
- en: Passing the model to the details page
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模型传递到详细页面
- en: The transition from the overview page to the details page is implemented with
    a segue. The segue is triggered when the user taps a contact, putting the details
    page on the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从概览页面切换到详情页面是通过过渡动画实现的。当用户点击一个联系人时，过渡动画被触发，详情页面将显示在屏幕上。
- en: Because this transition uses a segue, there is a special method that can be
    implemented to pass data from the first view controller to the second view controller.
    This special method is called `prepare(for:sender:)`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个过渡使用了过渡动画，所以可以实现一个特殊的方法来从第一个视图控制器传递数据到第二个视图控制器。这个特殊的方法被称为`prepare(for:sender:)`。
- en: This method is called on the source view controller right before a segue is
    performed and it provides access to the destination view controller.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在执行过渡动画之前在源视图控制器中被调用，并提供对目标视图控制器的访问。
- en: The segue's destination is used to configure data on the view controller that
    is about to be presented. Let's implement this right now so you can pass the selected
    contact to the details page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡的目标用于配置即将呈现的视图控制器上的数据。让我们立即实现这个功能，这样你就可以将选定的联系人传递到详情页面。
- en: 'Add the following extension to `ViewController.swift`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下扩展添加到`ViewController.swift`中：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A quick overview of the preceding code is the segue is checked to see if its
    identifier is `"detailViewSegue"` (as all segues will pass through this function).
    If this condition is satisfied, it checks the destination (which is of type `UIViewController`)
    is that of the `DetailsViewController` we are looking for.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的简要概述是检查过渡动画的标识符是否为`"detailViewSegue"`（因为所有过渡动画都会通过这个函数）。如果这个条件满足，它将检查目标（类型为`UIViewController`）是否是我们正在寻找的`DetailsViewController`。
- en: If all is well, we can assign our contact to a property on that View Controller
    and it will get passed across. Let's hook up our outlets now so we can start to
    bind some data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们可以将我们的联系人分配给该视图控制器上的一个属性，然后它将被传递过去。现在让我们连接我们的输出端口，以便我们可以开始绑定一些数据。
- en: Updating our outlets
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的输出端口
- en: 'We''re all set to go; we just need to hook up our data to our outlets. To do
    this, make the following changes in your `viewDidLoad()` in `DetailsViewController`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪；我们只需要将我们的数据连接到输出端口。为此，请在`DetailsViewController`中的`viewDidLoad()`中进行以下更改：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Go ahead and run your app. Lo and behold, if you tap on your contacts, you'll
    be navigated straight to your new view controller, where you'll be able to see
    all the details of that particular contact.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行你的应用程序。看看，如果你点击你的联系人，你会直接导航到你的新视图控制器，在那里你可以看到该特定联系人的所有详细信息。
- en: However, taking another look at the code we've just added in, it looks a little
    messy. We're concatenating `givenName` and `familyName` inside our **View Controller**,
    and also randomly grabbing the street value from the first persisted address that
    our contact has.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，再次查看我们刚刚添加的代码，它看起来有点杂乱。我们在**视图控制器**内部连接了`givenName`和`familyName`，并且还随机从联系人第一个持久化的地址中获取街道值。
- en: All this logic should not sit in our view controller – this is what we call
    View model logic, and by that I mean we should create our own contact model that
    takes everything we need along with all the logic to get it straight from our
    `CNContent` object. Let's take a look at how we'd do that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些逻辑都不应该放在我们的视图控制器中——这就是我们所说的视图模型逻辑，我的意思是我们应该创建自己的联系人模型，该模型包含我们所需要的一切，以及从我们的`CNContent`对象直接获取它的所有逻辑。让我们看看我们该如何做。
- en: Best practices – creating a view model
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践——创建视图模型
- en: In our example, our `CNContact` has multiple properties, some of which we've
    not even requested yet from `Contacts.framework`. As we saw with the logic in
    the previous section, making logic decisions based on what the view requires and
    what the model has should not be performed at this level.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们的`CNContact`有多个属性，其中一些我们甚至还没有从`Contacts.framework`请求。正如我们在上一节中看到的逻辑，基于视图所需的内容和模型拥有的内容进行逻辑决策不应在此级别执行。
- en: 'So how can we fix that? Easy. To start with, let''s create our custom model.
    Copy the following to a new file and call it `ContactModel.swift`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？很简单。首先，让我们创建我们的自定义模型。将以下内容复制到一个新文件中，并将其命名为`ContactModel.swift`：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we've simply created a struct and added properties based on exactly what
    we're going to display. We'll then create a custom initializer, which accepts
    a parameter of `CNContact`. From here, we strip out all the logic that we originally
    had in our View Controller and put it in here – one central location for this
    view model logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地创建了一个结构体，并添加了基于我们将要显示的确切内容的属性。然后我们将创建一个自定义初始化器，它接受一个`CNContact`参数。从这里，我们将原本在视图控制器中所有的逻辑移除，并将其放在这里——这是这个视图模型逻辑的一个集中位置。
- en: 'All we need to do now is a couple of tweaks. Update our class variable in `DetailsViewController`
    to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要做一些微调。更新`DetailsViewController`中的类变量如下：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And adjust our `prepare()` override in `ViewController` to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 并且调整我们的`ViewController`中的`prepare()`重写方法如下：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that done, run the app again. You'll see that nothing really changed, but
    you can walk away now knowing that you've taken some great steps into writing
    and managing good, maintainable code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，再次运行应用。你会发现实际上并没有什么变化，但现在你可以离开，知道你已经迈出了编写和管理良好、可维护代码的重要一步。
- en: In this section, we stitched everything together by using the prepare for segue
    function to transfer our model over to our `DetailViewController`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过使用准备转场函数将模型传递到我们的`DetailViewController`，将所有东西连接在一起。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we started by creating a brand-new View Controller dedicated
    to displaying selected user information. We learned about the different types
    of segues, including navigation-based segues and model-based segues. We were also
    introduced to creating segues both programmatically and via Interface Builder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先创建了一个全新的视图控制器，专门用于显示选定的用户信息。我们学习了不同类型的转场，包括基于导航的转场和基于模型的转场。我们还介绍了通过编程和通过Interface
    Builder创建转场的方法。
- en: Once we had our connectors all set up, we then started to build our new Detail
    View Controller, populating it with a contact's information and using the power
    of `UIStackView` to lay out our labels and image views.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了所有连接器，我们就开始构建我们的新详情视图控制器，用联系人的信息填充它，并利用`UIStackView`的力量来布局我们的标签和图像视图。
- en: We finished off by wiring everything together. We performed some best practices
    and created a custom view model that we can now pass over to our new `prepare()`
    override.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过连接一切来结束。我们执行了一些最佳实践，并创建了一个自定义视图模型，现在我们可以将其传递到我们的新`prepare()`重写方法中。
- en: In the next chapter, we'll go deep into the use of animations and transitions
    in iOS as we start to get creative!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在iOS中使用动画和过渡的效果，随着我们的创意开始涌现！
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Apple Documentation**: [https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果文档**：[https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html)'
