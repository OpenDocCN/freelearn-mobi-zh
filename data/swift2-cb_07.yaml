- en: Chapter 7. Swift Debugging with Xcode
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 使用 Xcode 进行 Swift 调试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Validating the values – developing a tax income simulator app
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证值 - 开发税收收入模拟应用程序
- en: Debugging with Xcode and Swift – the best checker movement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Xcode 和 Swift 进行调试 - 最佳检查运动
- en: Debugging with LLDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LLDB 进行调试
- en: Profiling an app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序分析
- en: Error handling in Swift 2.0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 2.0 中的错误处理
- en: Custom error handling in Swift 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 2.0 中的自定义错误处理
- en: Availability checking in Swift 2.0
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 2.0 中的可用性检查
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Let's face it, nobody writes a full program without any issues. Even the best
    programmer will see some situations that haven't been contemplated. Sometimes
    it's easy to find the bug, sometimes it is very hard, mainly you have a multithread
    app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实，没有人会编写一个没有任何问题的完整程序。即使是最好的程序员也会遇到一些未被考虑的情况。有时找到错误很容易，有时却非常困难，主要是因为你有一个多线程应用程序。
- en: In this chapter, we are going to learn how to debug an app step by step, it
    will make it easier for you to find out where the issue is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步学习如何调试应用程序，这将使你更容易找出问题所在。
- en: Validating the values – developing a tax income simulator app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证值 - 开发税收收入模拟应用程序
- en: When writing code and developing apps, we know that some variables of a function
    shouldn't contain certain values, but are you sure of that? How can we develop
    and check that everything has the right value?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码和开发应用程序时，我们知道函数中的一些变量不应该包含某些值，但你确定吗？我们如何开发和检查一切是否具有正确的值？
- en: In this recipe, we are going to learn how to check that the values are right
    during the development stage. To simulate this, let's create an app where we are
    sure that there will be people trying to cheat the values; in this case let's
    create an app to calculate tax income.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在开发阶段检查值是否正确。为了模拟这种情况，让我们创建一个应用程序，我们确信会有一些人试图篡改值；在这种情况下，让我们创建一个计算税收收入的程序。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a project called `Chapter 7 Tax Income` and make sure that you are in
    debug mode; to do it click on the project schema and select **Edit Scheme…**,
    as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 7 Tax Income` 的项目，并确保你处于调试模式；要做到这一点，请点击项目方案并选择 **编辑方案…**，如下截图所示：
- en: '![Getting ready](img/00074.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00074.jpeg)'
- en: 'Click on the **Run** option located on the left-hand side, then make sure that
    the **Info** tab is selected, and finally, make sure that the **Build** option
    is on **Debug**. We will have some explanations afterwards:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左侧的 **运行** 选项，然后确保选择 **信息** 选项卡，最后确保 **构建** 选项在 **调试** 上。之后我们将有一些解释：
- en: '![Getting ready](img/00075.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00075.jpeg)'
- en: Once these steps have been checked we need to open the project settings and
    create a macro called `DEBUG_MODE`, only on the debug configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检查了这些步骤，我们需要打开项目设置并创建一个名为 `DEBUG_MODE` 的宏，仅在调试配置中。
- en: '![Getting ready](img/00076.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00076.jpeg)'
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s create a new file called `Assertions.swift`. Here we are going
    to add some functions, all of them starting with `assert_`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `Assertions.swift` 的新文件。在这里，我们将添加一些函数，所有这些函数都以 `assert_` 开头：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can create another file, which will contain a class that should be able
    to calculate the income tax. Create a new file called `IncomeTaxCalculator.swift`;
    start with the following class header:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建另一个文件，该文件将包含一个能够计算所得税的类。创建一个名为 `IncomeTaxCalculator.swift` 的新文件；以下是一个类头：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is adding its attributes; as you can imagine, we have to store
    a few values for it:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加其属性；正如你可以想象的，我们必须为它存储一些值：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, all of them are initialized or are options; you don''t need
    to create an initializer in this case, except if you are using one of the first
    versions of Swift:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，所有这些都是在初始化或作为选项；在这种情况下，你不需要创建初始化器，除非你正在使用 Swift 的早期版本之一：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you paid attention, this class must implement the `Printable` protocol.
    So we need to add the description to this class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注意到了，这个类必须实现 `Printable` 协议。因此，我们需要向这个类添加描述：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To finish this class, we need a method that calculates the income tax based
    on the previous attributes. Of course, this is a fictional case; don''t use this
    app to calculate your income tax:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个类，我们需要一个方法来根据之前的属性计算所得税。当然，这是一个虚构的情况；不要使用这个应用程序来计算你的所得税：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once it is done, we have to create the graphical part of our app, so go to the
    storyboard and create a layout with six text fields, one button, and six labels;
    something similar to the following one:![How to do it…](img/00077.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们必须创建我们应用程序的图形部分，所以转到故事板并创建一个包含六个文本框、一个按钮和六个标签的布局；类似于以下的一个：![如何操作…](img/00077.jpeg)
- en: 'As you may imagine, we need to create some attributes to link with the text
    fields:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，我们需要创建一些属性来与文本框链接：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To complete our graphical part, we need to add an event for the button:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的图形部分，我们需要为按钮添加一个事件：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last step to do is testing our application and watching the assertions work.
    Press play and when the application appears, press calculate, without adding any
    information into the text fields. You should see your application stop running,
    and the Xcode should show you where:![How to do it…](img/00078.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是测试我们的应用程序并观察断言的工作情况。按播放键，当应用程序出现时，按计算键，不要在文本框中添加任何信息。你应该看到应用程序停止运行，Xcode应该显示在哪里：![如何操作…](img/00078.jpeg)
- en: If you pay attention, the log console will open and show you what happened,
    printing the message that you have written:![How to do it…](img/00079.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注意的话，日志控制台会打开并显示发生了什么，打印出你写入的消息：![如何操作…](img/00079.jpeg)
- en: Let's complete this recipe, changing from **Debug** to **Release** configuration;
    press play again, and see that the first assert was ignored.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们完成这个配方，将配置从**Debug**更改为**Release**；再次按播放键，你会看到第一个断言被忽略了。
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Assertions are like functions that interrupt the application when they find
    an unexpected value. Of course, when a program is released, it needs to accept
    these values, which means that the developer shouldn't trust on the assertions'
    power forever, he must fix the value, or at least interrupt the process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 断言就像在找到意外值时中断应用程序的函数。当然，当程序发布时，它需要接受这些值，这意味着开发者不应该永远依赖断言的力量，他必须修复值，或者至少中断进程。
- en: 'Swift comes with only two assertions functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift只提供了两个断言函数：
- en: '`assert`: This function has two arguments. The first one is a Boolean element
    which, in case of being false, is going to stop your program and show the next
    argument (the message) for the developer.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`：此函数有两个参数。第一个是一个布尔元素，如果为假，将停止你的程序并显示下一个参数（消息）给开发者。'
- en: '`assertionFailure`: This function stops the program execution without checking
    any condition. This function is used when there is a way where the app shouldn''t
    go through it. Imagine that you have a `switch` statement, and theoretically your
    program shouldn''t go to the default case because it isn''t considered, in this
    case you need to add an assertion.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertionFailure`：此函数在未检查任何条件的情况下停止程序执行。此函数用于应用程序不应该通过的情况。想象一下，你有一个`switch`语句，理论上你的程序不应该进入默认情况，因为它没有被考虑，在这种情况下你需要添加一个断言。'
- en: 'Another nagging question is: What does `autoclosure` mean? The reason is the
    following—`assert`, `assertionFailure`, and our assertions functions actually
    don''t receive a value as an argument, the reason is laziness. It means that Swift
    isn''t going to evaluate the values before entering into the function.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人烦恼的问题是：`autoclosure`是什么意思？原因如下——`assert`、`assertionFailure`以及我们的断言函数实际上不接受值作为参数，原因是惰性。这意味着Swift在进入函数之前不会评估值。
- en: Swift converts your argument into a function and the argument will be evaluated
    inside when the assert function calls it. Why? The reason is that assertions shouldn't
    work if you are compiling with Release configuration instead of Debug. Bear in
    mind that assertions stop your program, which is something good when you are developing,
    but for a user it won't be a good sensation. That's the reason that sometimes
    we call the autoclosure function between `#ifdef NDEBUG` and `#endif`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Swift将你的参数转换为一个函数，并且当断言函数调用它时，参数将在其中被评估。为什么？原因在于断言不应该在编译配置为Release而不是Debug时工作。记住，断言会停止你的程序，这在开发时是好事，但对于用户来说却不是好感觉。这就是为什么有时我们在`#ifdef
    NDEBUG`和`#endif`之间调用autoclosure函数的原因。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before Xcode 6 beta 5, `@autoclosure` used to be written as `@auto_closure`.
    If you are going to search for something about this modifier on the Internet,
    try writing it both ways.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 6 beta 5之前，`@autoclosure`通常写作`@auto_closure`。如果你打算在网上搜索有关此修饰符的信息，尝试两种写法都试一试。
- en: If assertions don't work on Release mode, why are they useful? The reason is
    that assertions are used for detecting development errors, you should track the
    source of the error and modify it to ensure that the source won't give you a wrong
    value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言在发布模式下不起作用，为什么它们还有用？原因在于断言用于检测开发错误，你应该追踪错误的来源并修改它，以确保来源不会给你一个错误值。
- en: The reason we created a different file for our own assertion functions is that
    you may have this file shared between projects; of course you can use the function
    `assert` for everything, but I would recommend creating assertions functions that
    can save us from work, like the one we have to check if an element is inside of
    an array.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的断言函数创建了一个不同的文件，原因是你可能在这个文件之间共享项目；当然，你可以为所有事情使用 `assert` 函数，但我建议创建可以为我们节省工作的断言函数，比如我们用来检查元素是否在数组中的那个。
- en: There's more…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe we learned about using the Swift assertions, which is the equivalent
    of the `NSAssert` in Objective-C. If you prefer using the other assertion features
    from the Objective-C foundation, such as `NSParameterAssert` and `NSAssertionHandler`,
    you are still able to use them in Swift.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜谱中，我们学习了如何使用 Swift 断言，它是 Objective-C 中的 `NSAssert` 的等价物。如果你更喜欢使用 Objective-C
    基础中的其他断言功能，如 `NSParameterAssert` 和 `NSAssertionHandler`，你仍然可以在 Swift 中使用它们。
- en: Assertions are very useful for finding paths that are receiving wrong values,
    however there are times when it is necessary to go step by step in the code. We
    will see how to do it with Xcode and Swift in the next recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 断言对于找到接收错误值的路径非常有用，然而有时有必要逐步进入代码。我们将在下一道菜谱中看到如何使用 Xcode 和 Swift 来实现。
- en: Debugging with Xcode and Swift – the best checker movement
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Xcode 和 Swift 进行调试 – 最佳的棋子移动
- en: If you have some experience with programming, you know that sometimes we need
    to go step by step into the code, mainly when we have those kinds of issues where
    nobody knows how it happened.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些编程经验，你就会知道有时我们需要一步一步地进入代码，主要是在我们遇到那种没有人知道为什么会发生的问题时。
- en: In this recipe we are going to learn how to debug with Xcode and Swift. To do
    it, we are going to recycle our checkers board. In this case we are going to make
    the best move using the white pieces. We are also going to leave it prepared for
    a second version of this app where we could use kings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜谱中，我们将学习如何使用 Xcode 和 Swift 进行调试。为了做到这一点，我们将回收我们的棋盘。在这种情况下，我们将使用白棋进行最佳移动。我们还将为这个应用程序的第二个版本做好准备，届时我们可以使用国王。
- en: We are not going to create the right algorithm in the beginning, the idea is
    to debug and find where the issue is, and then we are going to correct it afterwards.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始不会创建正确的算法，我们的想法是调试并找到问题所在，然后我们将在之后进行修正。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your playground from the previous chapter where you have the checkers board.
    Leave it open because we are going to reuse this code. Once it is opened, create
    a new project called `Chapter 7 checkerboard`, and let's start coding.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你上一章中的游乐场，其中包含棋盘。保持它打开，因为我们将要重用这段代码。一旦打开，创建一个名为 `第7章棋盘` 的新项目，然后开始编码。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file called `CheckersBoard.swift`, start by importing the `UIKit`
    library if it is not imported yet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CheckersBoard.swift` 的新文件，如果尚未导入，请先导入 `UIKit` 库：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that you can paste the class code from playground. Then, copy the last
    part from playground (variable instantiation and setup) and paste it in the `viewDidLoad`
    method on the view controller file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你可以将游乐场中的类代码粘贴过来。然后，复制游乐场中的最后一部分（变量实例化和设置），并将其粘贴到视图控制器文件中的 `viewDidLoad`
    方法上：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's create a breakpoint on the third time we assign a piece, by clicking
    on the gray area to the left of the code:![How to do it…](img/00080.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来在第三次分配棋子时设置一个断点，通过点击代码左侧的灰色区域：![如何操作…](img/00080.jpeg)
- en: Press play, wait until the Xcode stops on your breakpoint and move your mouse
    pointer over the board variable. It can be any of them, like the first one, where
    the variable is being declared, or the other ones where we assign a piece.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放，等待 Xcode 在你的断点处停止，并将鼠标指针移到棋盘变量上。它可以是任何一个，比如第一个，变量正在被声明，或者其他的，我们在那里分配棋子。
- en: After a short interval you will see a small dialog with two icons on the right.
    The first icon, which is an **i** with a circle around it, displays the content
    of the object with a text format similar to a JSON format:![How to do it…](img/00081.jpeg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在短暂的间隔后，你将看到一个带有两个图标的小对话框。第一个图标是一个带有圆圈的**i**，它以类似于JSON格式的文本格式显示对象的内容：![如何操作…](img/00081.jpeg)
- en: 'The other icon is very familiar to us, because it''s the same icon we''ve seen
    on the playground, it''s the quick look icon and we can also use it here. That
    way we retrieve a more visual way of watching the checkers board:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个图标对我们来说非常熟悉，因为它和我们在游乐场看到的图标一样，它是快速查看图标，我们也可以在这里使用它。这样我们就可以以更直观的方式查看跳棋棋盘：
- en: '![How to do it…](img/00082.jpeg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00082.jpeg)'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't create the method `debugQuickLookObject` for every single class you have,
    only for those classes that are hard to visualize and need to be debugged frequently.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要为每个类创建`debugQuickLookObject`方法，只为那些难以可视化且需要频繁调试的类创建。
- en: 'Now that we know how to visualize our object, we need to differentiate traditional
    pieces from kings. Our next goal is adding a Boolean to the `BoardSpace` enumeration.
    Replace the previous enumeration with this one:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了如何可视化我们的对象，我们需要区分传统棋子和国王。我们的下一个目标是向`BoardSpace`枚举添加一个布尔值。用以下枚举替换之前的枚举：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need to display something different, in this case we are going to add
    the letter `K` over the piece. Replace the `switch` statement inside the `debugQuickLookObject`
    with this one:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要显示不同的内容，在这种情况下，我们将在棋子上添加字母`K`。将`debugQuickLookObject`中的`switch`语句替换为以下内容：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Right, now after filling the pieces we need to add a code in case the current
    piece is a king:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在在填充棋子之后，我们需要添加一个代码块，以处理当前棋子是国王的情况：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we need to change the way we assign the pieces with the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要改变分配棋子的方式，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's repeat the operation by pressing play and watching the board with quick
    look; now you can press the step over button, just press the *F6* key.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下播放并使用快速查看观察棋盘来重复此操作；现在你可以按步骤覆盖按钮，只需按下**F6**键。
- en: Note
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: New Apple keyboards have an assigned function for the *F6* key, so you will
    probably have to press this key together with the *fn* key.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新款苹果键盘为**F6**键分配了功能，所以你可能需要同时按下这个键和**fn**键。
- en: Now check the quick look and see that you have the letter `K` over one of your
    pieces:![How to do it…](img/00083.jpeg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查快速查看，看看你的一枚棋子上是否有字母`K`：![如何操作…](img/00083.jpeg)
- en: 'Ok, now that we know how to visualize the board, we are going to see whether
    we can win a game with only one turn. To do it we will need to choose a piece
    and see every possibility we have. It means that we will need to clone our object
    frequently. Usually we would create a struct for it but in this case we are going
    to create a method for cloning our object. We will give explanations later; just
    add this code inside your `CheckersBoard` class:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了如何可视化棋盘，我们将看看是否可以用一回合赢得游戏。要做到这一点，我们需要选择一个棋子并查看我们所有的可能性。这意味着我们需要频繁地克隆我们的对象。通常我们会为它创建一个结构体，但在这个情况下，我们将为克隆我们的对象创建一个方法。我们稍后会给出解释；只需将此代码添加到你的`CheckersBoard`类中：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step to worry about is how to capture the opponent''s piece, to do
    it we will need to test which directions are possible. Let''s create an enumeration
    inside our `CheckersBoard` class to help us:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的步骤是担心如何捕获对手的棋子，要做到这一点，我们需要测试哪些方向是可能的。让我们在我们的`CheckersBoard`类中创建一个枚举来帮助我们：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to create a method that is going to find us the best move; remember
    that we are using only the white pieces:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个方法来找到最佳移动；记住我们只使用白棋：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we have two private methods, one for the best movement of a
    normal piece, and another one for a king. Here we are going to develop the single
    piece function, the other method I''ll leave as homework for you; otherwise it
    will be an extremely huge recipe:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们有两个私有方法，一个用于普通棋子的最佳移动，另一个用于国王。在这里，我们将开发单个棋子的功能，其他的方法我将留作你的作业；否则，这将是一个非常庞大的食谱：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To complete this class, we need to add more methods, one that will count the
    number of black pieces, and another that is going to capture the opponent''s piece:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成这个课程，我们需要添加更多方法，一个用于计算黑棋的数量，另一个用于捕获对手的棋子：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ok, now imagine that it's Monday. We had to type this whole amount of code and
    someone (probably your boss) tells us that there is a setup that doesn't find
    the best solution. Reviewing every single line of this code can be very boring,
    and it can be hard to find where the problem is.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，现在想象一下今天是星期一。我们不得不输入这么多代码，有人（可能是你的老板）告诉我们有一个设置找不到最佳解决方案。审查代码的每一行可能非常无聊，而且很难找到问题所在。
- en: 'Let''s debug starting with the setup that is not working, so replace the setup
    code with this one:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从那个不起作用的设置开始调试，所以用这个代码替换设置代码：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first thing you might have noticed is the `debugDescription`. This is something
    similar to `debugQuickLookObject` but instead of returning different kinds of
    objects it only returns a text, we are going to complete this property later.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是`debugDescription`。这类似于`debugQuickLookObject`，但它不返回不同类型的对象，而只返回文本，我们稍后会完成这个属性。
- en: 'As you know, we have to debug the fourth white piece movement. To do it, go
    to the method called `bestMovementWhite` and add a breakpoint on the line where
    we call the method `bestMovementSinglePieceWhite`. Right-click on this breakpoint
    and you will see a menu like the following one:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所知，我们必须调试第四个白棋的移动。要做到这一点，转到名为`bestMovementWhite`的方法，并在调用`bestMovementSinglePieceWhite`方法的行上添加一个断点。右键单击此断点，你会看到一个如下所示的菜单：
- en: '![How to do it…](img/00084.jpeg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00084.jpeg)'
- en: Choose **Edit breakpoint...**, as you know we don't want to check what happened
    with the first three pieces, so say that you want to ignore **3** times before
    stopping:![How to do it…](img/00085.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**编辑断点...**，正如你所知，我们不想检查前三个棋子的动作，所以说明你想要忽略**3**次然后停止：![如何操作…](img/00085.jpeg)
- en: Sometimes we know that we have to stop after a certain number of times, try
    to use it instead of clicking play lots of times. Add another breakpoint in this
    same method at the end (`return boardCandidate`) and edit it. Now we are going
    to add a condition to make it work and change the action to sound. Unfortunately
    most of the available sounds are too soft, I usually choose the glass one, but
    if you prefer you can choose another one. To finish this breakpoint, select the
    option **Automatically continue after evaluating actions**:![How to do it…](img/00086.jpeg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候我们知道在经过一定次数后必须停止，尝试使用它而不是多次点击播放。在这个相同的方法末尾（`return boardCandidate`）添加另一个断点并编辑它。现在我们将添加一个条件使其工作，并将动作更改为声音。不幸的是，大多数可用的声音都太弱了，我通常选择玻璃声，但如果你更喜欢，你可以选择另一个。要完成这个断点，选择**在评估动作后自动继续**选项：![如何操作…](img/00086.jpeg)
- en: 'Now press play and wait until Xcode stops, press the step into button (the
    one with an arrow pointing down) or press *F7*, you will get into the `bestMovementSinglePieceWhite`.
    Now click on step over (or press *F6*) three times, check the board with quick
    look, and have a look that we will return this board. Once this issue has been
    detected, we can replace our algorithm with this one:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按播放并等待Xcode停止，按步骤进入按钮（指向下的箭头按钮）或按*F7*，你将进入`bestMovementSinglePieceWhite`。现在点击步骤跳过（或按*F6*）三次，用快速查看检查棋盘，看看我们将返回这个棋盘。一旦这个问题被发现，我们可以用这个算法替换我们的算法：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now press play again but instead of pressing step into use step over, check
    the board with the quick look inspector, and see that you now have the right solution.
    So, problem solved, but don't celebrate too much, other issues are coming.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次按播放，但不要按步骤进入，而是使用步骤跳过，用快速查看检查器检查棋盘，看看你现在是否有了正确的解决方案。所以，问题解决了，但不要过于庆祝，其他问题还在路上。
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Xcode allows us to debug step by step. Using the method that we used to debug
    on our playground (`debugQuickLookObject`) can help us to visualize the current
    object state. In this case we could improve our method using the method `drawAtPoint`
    of the NSString, right now there is no equivalent method on Swift strings.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode允许我们逐步调试。使用我们在我们的游乐场中调试的方法（`debugQuickLookObject`）可以帮助我们可视化当前对象的状态。在这种情况下，我们可以使用NSString的`drawAtPoint`方法改进我们的方法，但目前Swift字符串上没有等效的方法。
- en: Another detail that you could see is that we created our own method to clone
    the board instead of using a struct. The reason is that structs can't inherit
    and in this case we need to do it due to our quick look method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，我们创建了自己的方法来克隆棋盘而不是使用结构体。原因是结构体不能继承，在这种情况下我们需要这样做，因为我们的快速查看方法。
- en: Breakpoints have some special features when using Xcode. You can ignore them
    a few times, which is very useful when you know that the issue happens after some
    repetitions. Imagine if you have to press continue 50 times, and then you have
    to repeat it again and again until you find the solution. You and your mouse would
    end the day exhausted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Xcode 时，断点有一些特殊功能。您可以忽略它们几次，这在您知道问题发生在某些重复之后非常有用。想象一下，如果您必须按 50 次继续，然后您必须一次又一次地重复它，直到找到解决方案。您和您的鼠标都会在一天结束时筋疲力尽。
- en: As you can see, you can also add an action to the breakpoint, such as adding
    a debugger command, playing a sound (that is very useful for knowing that something
    was done in the background, but you don't want to stop), or logging a message
    that helps us to analyze the program trajectory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您还可以向断点添加一个动作，例如添加一个调试器命令、播放一个声音（这对于知道后台已经完成了一些操作非常有用，但您不想停止），或者记录一条有助于我们分析程序轨迹的消息。
- en: There are some commands for debugging that a developer must know, such as step
    over, which executes the whole line of code and stops on the next one, step into,
    which goes inside the current function, step out (*F8*), which exits from the
    current function and stops on the same place where it was called, and continue
    (*control* + *command* + *Y*), which continues executing the program until the
    next breakpoint.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试，有一些命令是开发者必须知道的，例如 step over（跳过），它执行整个代码行并停止在下一行，step into（进入），它进入当前函数，step
    out（*F8*）（退出），它从当前函数退出并停在调用它的同一位置，以及 continue（*control* + *command* + *Y*）（继续），它继续执行程序直到下一个断点。
- en: Unfortunately there is no right or wrong procedure to find an issue, and sometimes
    you have to use your sixth sense to solve it. The only way is to collect as much
    information as you can and go step by step.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有正确或错误的方法来找到问题，有时您必须使用您的第六感来解决它。唯一的方法是收集尽可能多的信息，并一步一步地进行。
- en: There's more…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Actually Xcode isn't debugging by itself, the reality is that it uses another
    debugger to do this task; on the next recipe we are going to use the debugger
    from the command line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Xcode 并不是自己进行调试，现实是它使用另一个调试器来完成这项任务；在下一个菜谱中，我们将使用命令行调试器。
- en: Debugging with LLDB
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLDB 进行调试
- en: Debugging with Xcode is fine, but sometimes we are limited and we have to use
    the debugger with a lower level. To do it, we have to know that actually, Xcode
    is not debugging anything, it uses another program called LLDB.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Xcode 进行调试是不错的，但有时我们受到限制，必须使用更低级别的调试器。为了做到这一点，我们必须知道实际上，Xcode 并没有在调试任何东西，它使用另一个名为
    LLDB 的程序。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Old versions of Xcode used to debug with GDB instead of LLDB, don't try to use
    them with Swift because there is no support for Swift on GDB.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 Xcode 以前使用 GDB 而不是 LLDB 进行调试，不要尝试用 Swift 使用它们，因为 GDB 不支持 Swift。
- en: It is highly recommended knowing the LLDB commands if you want to debug big
    programs, there are also some cases where you have to connect with another machine
    (a continuous integration, for example), where you have to do everything through
    an SSH shell.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想调试大型程序，强烈建议您了解 LLDB 命令，还有一些情况下您必须连接到另一台机器（例如持续集成），在那里您必须通过 SSH shell 做所有事情。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the checkers board program and check whether you have any breakpoints and
    remove all of them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开检查棋盘程序，检查您是否有任何断点，并删除所有断点。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Press play and when the program starts, press the pause button using the combination
    *control* + *command* + *U*. After that you will see the LLDB console:![How to
    do it…](img/00087.jpeg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮，当程序开始时，使用组合键 *control* + *command* + *U* 按下暂停按钮。之后，您将看到 LLDB 控制台：![如何操作…](img/00087.jpeg)
- en: 'Now click on the LLDB console and write `break s -r bestMovement*`. You will
    see that the answer is `Breakpoint 1: 4 locations`. Then let''s list these breakpoints
    with a breakpoint list. Here you can see an ugly answer, but don''t be scared,
    this is simpler than you think.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击 LLDB 控制台，输入 `break s -r bestMovement*`。您将看到答案是 `Breakpoint 1: 4 locations`。然后让我们列出这些断点，使用断点列表。在这里，您可能会看到一个丑陋的答案，但不要害怕，这比您想象的要简单。'
- en: You can also write `thread info` to get some information about the current thread.
    Check that it specifies the language of each frame, with this information you
    can get a better idea about what happened with your code in case of crashing.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以输入 `thread info` 来获取一些关于当前线程的信息。检查它是否指定了每个帧的语言，有了这些信息，您可以在程序崩溃的情况下更好地了解您的代码发生了什么。
- en: List your threads with `thread list,` switch to thread 2 with `thread select
    2`, and write `thread info` again.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`thread list`列出你的线程，使用`thread select 2`切换到线程2，然后再次写入`thread info`。
- en: 'Now write `repl` and see that the prompt changes to `1>`. In this case, we
    are going to write a new function to test our REPL, so type the following code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入`repl`并查看提示符是否变为`1>`。在这种情况下，我们将编写一个新的函数来测试我们的REPL，所以输入以下代码：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once this function is done, let''s test it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这个函数完成，让我们来测试它：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, `repl` can help you write functions in runtime, like we did
    with the playground.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`repl`可以帮助你在运行时编写函数，就像我们在playground中做的那样。
- en: How it works…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: LLDB is the current Xcode debugger; you can set multiple breakpoints with regular
    expressions. Remember that what you do on LLDB isn't necessarily reflected on
    Xcode, the breakpoints we set are a good example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB是当前的Xcode调试器；你可以使用正则表达式设置多个断点。记住，你在LLDB上所做的操作不一定会在Xcode中反映出来，我们设置的断点是一个很好的例子。
- en: Have a look that three of our breakpoints have the filename and a line number,
    like `... at CheckersBoard.swift:158, …` it means your breakpoint is on the file
    `CheckersBoard.swift` at line 158.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的三个断点都有文件名和行号，例如`... at CheckersBoard.swift:158, …`这意味着你的断点在文件`CheckersBoard.swift`的第158行。
- en: We also used REPL, which is a Swift command line, here you can create functions
    and test some code. Of course you can also use playground, but sometimes it is
    faster using the current debugger.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了REPL，这是一个Swift命令行，在这里你可以创建函数并测试一些代码。当然，你也可以使用playground，但有时使用当前的调试器会更快。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Apple has some documentation about LLDB worth looking at. Check this URL: [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果有一些关于LLDB的文档值得一看。检查这个URL：[https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html)。
- en: What about features that users complain about but are hard to debug, such as
    memory, performance, or energy? For these kinds of problems you have to use another
    tool, we are going to learn about it in the next recipe.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户抱怨但难以调试的功能，例如内存、性能或能耗，该怎么办？对于这类问题，你必须使用另一个工具，我们将在下一个菜谱中学习它。
- en: Profiling an app
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析应用程序
- en: It's very common to hear about issues, but if an app doesn't have any important
    issue it doesn't mean that it is working fine. Imagine that you have a program
    that has a memory leak. Presumably you won't find any problem using it for 10
    minutes, however, a user may find it after using it for a few days. Don't think
    that this case is impossible, remember that iOS apps don't terminate, so if you
    have a memory leak it will be kept until your app blows up.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见听到问题，但如果一个应用程序没有任何重要的问题，并不意味着它运行良好。想象一下，你有一个有内存泄漏的程序。你可能在使用10分钟内不会发现任何问题，然而，用户可能在几天后就会发现问题。不要认为这种情况不可能发生，记住iOS应用程序不会终止，所以如果你有内存泄漏，它将一直保持到你的应用程序崩溃。
- en: Performance is another frequent topic, what if your app looks ok but it gets
    slower with the passage of time? We have to be aware of this problem. This kind
    of test is called **profiling** and Xcode comes with a very good tool for realizing
    this operation, which is called **Instruments**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是另一个常见的话题，如果你的应用程序看起来没问题，但随着时间的推移变得缓慢，该怎么办？我们必须意识到这个问题。这类测试被称为**性能分析**，Xcode提供了一个非常好的工具来实现这个操作，它被称为**Instruments**。
- en: In this case we are going to profile our app to visualize the amount of energy
    wasted by our app and of course let's try to reduce it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将分析我们的应用程序以可视化应用程序浪费的能量，当然，我们也要尝试减少它。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe you will need a physical device, and to install your app on
    the device you will need to be enrolled on the Apple Developer Program. If you
    have both requirements the next thing you have to do is create a new project called
    `Chapter 7 Energy`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要一个物理设备，并且为了在设备上安装你的应用程序，你需要注册Apple开发者计划。如果你满足这两个条件，下一步你要做的是创建一个名为`第7章
    能量`的新项目。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Before we start coding, we will need to add a framework to the project. Click
    on the tab **Build Phases** of your project and go to the section **Link Binaries
    with Libraries** and press the plus sign:![How to do it…](img/00088.jpeg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要将一个框架添加到项目中。点击项目中的**构建阶段**选项卡，转到**链接二进制与库**部分，然后按加号：![如何做…](img/00088.jpeg)
- en: Once Xcode opens a dialog window asking for the framework to add, choose **CoreLocation**
    and **MapKit**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Xcode打开一个对话框询问要添加的框架，请选择**CoreLocation**和**MapKit**。
- en: Now go to the storyboard, place a label and a MapKit view, you might have a
    layout similar to this one:![How to do it…](img/00089.jpeg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到故事板，放置一个标签和一个MapKit视图，你的布局可能类似于以下这个：![如何操作…](img/00089.jpeg)
- en: 'Link the MapKit view and call it just map, and the `UILabel` and call it just
    label:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MapKit视图链接并命名为map，将`UILabel`命名为label：
- en: '[PRE23]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Continuing with the view controller, let''s click at the beginning of the file
    to add the `CoreLocation` and `MapKit` imports:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在视图控制器中操作，让我们点击文件开头以添加`CoreLocation`和`MapKit`导入：
- en: '[PRE24]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that you have to initialize the location manager object on the `viewDidLoad`
    method:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你必须在`viewDidLoad`方法中初始化位置管理器对象：
- en: '[PRE25]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this moment you may get an error because your view controller doesn''t conform
    with the `CLLocationManagerDelegate`, so let''s go to the header of the view controller
    class and let''s specify that it implements this protocol. Another error we have
    is the `locationManager` variable, because it is not declared, therefore we have
    to create it as an attribute. And as we are declaring attributes, we are going
    to add the geocoder, which is going to be used later:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个时候，你可能遇到错误，因为你的视图控制器没有遵循`CLLocationManagerDelegate`协议，所以让我们转到视图控制器类的头文件，并指定它实现了这个协议。我们遇到的另一个错误是`locationManager`变量，因为它没有被声明，因此我们必须将其创建为一个属性。在我们声明属性的同时，我们将添加地理编码器，它将被稍后使用：
- en: '[PRE26]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we implement the method that receives the positioning, let''s create
    another method to detect whether there was any authorization error:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实现接收定位的方法之前，让我们创建另一个方法来检测是否有任何授权错误：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we can implement the method that will update our location:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以实现更新我们位置的方法：
- en: '[PRE28]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before you test the app there is still another step to do. On your project,
    navigate to or click expand on the supporting files and then click on **info.plist**.
    Add a row by right-clicking on the list and selecting **add row**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试应用程序之前，还有另一个步骤要做。在你的项目中，导航到或点击展开“支持文件”，然后点击**info.plist**。通过右键点击列表并选择**添加行**来添加一行。
- en: On this new row, type `NSLocationWhenInUseUsageDescription` as key, and on value
    Permission required, like the following screenshot:![How to do it…](img/00090.jpeg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一新行中，将`NSLocationWhenInUseUsageDescription`作为键，在值中输入“权限要求”，如下截图所示：![如何操作…](img/00090.jpeg)
- en: Select a device and install this app onto it, and test the application walking
    around your street (or walking around planet Earth if you want). Check that the
    label will change and also that the map will display your current position.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个设备并将此应用程序安装到该设备上，并在你街道周围（或者如果你想的话，在地球周围行走）测试应用程序。检查标签是否会改变，同时地图也会显示你的当前位置。
- en: Now go back to your computer and plug the device in again, now instead of pressing
    play you have to hold the play button until you see more options and then you
    have to select the profile option:![How to do it…](img/00091.jpeg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到你的电脑上，再次将设备连接上，现在不是按播放键，而是要按住播放键，直到你看到更多选项，然后你必须选择配置文件选项：![如何操作…](img/00091.jpeg)
- en: The next thing that will happen is that instruments is going to open, probably
    a dialog will pop up asking for an administrator account. That's due to instruments
    needing to use some special permissions to access some low-level information:![How
    to do it…](img/00092.jpeg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来会发生的事情是，将打开“仪器”，可能弹出一个对话框要求管理员账户。这是由于“仪器”需要使用一些特殊权限来访问一些底层信息：![如何操作…](img/00092.jpeg)
- en: On the next dialog you will see different kinds of instruments, some of them
    are OS X specific, some are iOS specific, and others are for both. If you choose
    the wrong platform instrument the record button will be disabled. For this recipe
    choose energy diagnostics:![How to do it…](img/00093.jpeg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，你会看到不同种类的仪器，其中一些是针对OS X的，一些是针对iOS的，还有一些是针对两者的。如果你选择了错误的平台仪器，记录按钮将会被禁用。对于这个菜谱，请选择能量诊断：![如何操作…](img/00093.jpeg)
- en: Once the **Energy Diagnostics** window is open you can press the record button,
    which is on the upper-left corner, and try to move around—yes, you need to keep
    the device connected to your computer so you have to move around with both elements
    together—and do some actions with your device, such as pressing the home button
    and turning off the screen. Now you may have a screen similar to this one:![How
    to do it…](img/00094.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开**能量诊断**窗口，您就可以按下记录按钮，它位于左上角，并尝试四处移动——是的，您需要保持设备与电脑连接，因此您必须同时移动这两个元素——并使用您的设备执行一些操作，例如按下主页按钮和关闭屏幕。现在您可能有一个类似于这样的屏幕：![如何操作…](img/00094.jpeg)
- en: Now you can analyze who is spending more energy on your app. To get a better
    idea about it, go to your code and replace the constant `kCLLocationAccuracyBest`
    with `kCLLocationAccuracyThreeKilometers` and check whether you have saved some
    energy.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用它来分析谁在您的应用上消耗了更多的能量。为了更好地了解这一点，请进入您的代码，将常量`kCLLocationAccuracyBest`替换为`kCLLocationAccuracyThreeKilometers`并检查您是否节省了一些能量。
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Instruments is a tool used for profiling your application. It gives you information
    about your app, which can't be retrieved by code, or at least can't be retrieved
    easily. You can check whether your app has memory leaks, whether it is losing
    performance, and as you can see, whether it is wasting much energy or not.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments是一个用于分析您应用程序的工具。它提供了有关您的应用程序的信息，这些信息无法通过代码获取，或者至少无法轻松获取。您可以检查您的应用程序是否有内存泄漏，是否正在失去性能，以及如您所见，是否正在浪费大量能量。
- en: In this recipe we used the GPS because it is a sensor that requires some energy,
    and also you can check on the table on the bottom of your instrument that Internet
    requests were done, which is something that if you do very frequently, will also
    empty your battery fast.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了GPS，因为它是一个需要一些能量的传感器，并且您还可以检查您的仪器底部的表格，以查看是否进行了网络请求，如果您非常频繁地这样做，这也会快速耗尽您的电池。
- en: 'Something you might be asking is: why did we have to change the `info.plist`?
    Since iOS 8, some sensors require user permissions; the GPS is one of them, so
    you need to report the message that is going to be shown to the user.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问的问题之一是：为什么我们必须更改`info.plist`？自iOS 8以来，一些传感器需要用户权限；GPS就是其中之一，因此您需要报告将要显示给用户的消息。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'It is recommended that you read about the way that instruments work, mainly
    those that you are going to use. Check the Apple documentation about instruments
    to get more details about it: [https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html](https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议您了解仪器的工作方式，主要是您将要使用的那部分。请查看Apple关于仪器的文档以获取更多详细信息：[https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html](https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html)。
- en: If you have experience with Objective-C you might be asking how could you recycle
    your code using Swift, in the next chapter we are going to see some recipes for
    this.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有Objective-C的经验，您可能会问如何使用Swift回收代码，在下一章中，我们将看到一些关于这个的食谱。
- en: Error handling in Swift 2.0
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2.0中的错误处理
- en: With the introduction of Swift 2.0, Apple has provided an entirely new way to
    perform error handling, similar to other programming languages. Not only can you
    take advantage of this in your own classes, Apple has also updated all of its
    classes to use the new error handling methods.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Swift 2.0的引入，Apple提供了一种全新的错误处理方式，类似于其他编程语言。您不仅可以在自己的类中利用这一点，Apple还更新了其所有类以使用新的错误处理方法。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new single view project and name it `Error Handling Chapter 7`. We
    will be using the boiler plate project setup for this recipe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的单视图项目，并将其命名为`Error Handling Chapter 7`。我们将为此食谱使用模板项目设置。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open `ViewController.swift` and add the following function:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewController.swift`并添加以下函数：
- en: '[PRE29]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Upon running this code, you should receive an error `Extra argument 'Error'
    in call`. With Swift 2.0, you are no longer required to pass the memory address
    of an error object, therefore the error argument is no longer needed and has been
    removed from the Apple standard library.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此代码后，您应该收到一个错误`调用中多余的参数 'Error'`。在Swift 2.0中，您不再需要传递错误对象的内存地址，因此错误参数不再需要，并且已从Apple标准库中删除。
- en: 'Update the code in the method call to the following:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新方法调用中的代码如下：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Similar to C++, Swift 2.0 now uses a do-try-catch method of error handling.
    Inside the do block we attempt to perform some task that can result in an error
    and prefix it with the try keyword. This lets Xcode know that this method can
    fail and to look for a catch block if a failure occurs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 类似，Swift 2.0 现在也使用 do-try-catch 方法进行错误处理。在 do 块中，我们尝试执行可能引发错误的某些任务，并在前面加上
    try 关键字。这会让 Xcode 知道这个方法可能会失败，并在发生失败时寻找 catch 块。
- en: You can tell what methods require this error handling by looking at the method
    declaration. All methods with error handling will include a throws keyword at
    the tail end of the declaration. We will learn in the next recipe how to define
    your own methods that incorporate error handling.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看方法声明来了解哪些方法需要这种错误处理。所有具有错误处理的方法将在声明末尾包含一个 throws 关键字。我们将在下一个食谱中学习如何定义自己的方法，这些方法包含错误处理。
- en: Additionally, the try keyword can be used with both ? and ! for additional functionality.
    Using try? for instance will result in the returned value wrapped in an optional.
    Rather than performing a do-while loop and catching the error to set a value to
    nil, you can simply substitute try? and the value will now function as an optional
    with standard nil handling. When using try!, you explicitly ignore the error handling.
    This is only used when you already know a value will not produce an error; for
    example, loading an image that was shipped with the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，try 关键字可以与 ? 和 ! 一起使用以提供额外的功能。例如，使用 try? 将返回值包装在可选值中。您不必执行 do-while 循环并捕获错误来将值设置为
    nil，只需简单地替换 try?，值现在将作为具有标准 nil 处理的可选值工作。当使用 try! 时，您明确忽略错误处理。这仅在您知道值不会产生错误时使用；例如，加载与应用程序一起分发的图像。
- en: There's more…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You will often require some code to run regardless of errors. Swift 2.0 adds
    a new feature that works great for just this scenario: the defer keyword. Any
    code provided inside of the defer block will automatically execute once it reaches
    the end of the containing scope. This feature works anywhere in code.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会需要一些代码在出现错误的情况下也能运行。Swift 2.0 添加了一个非常适合这种场景的新功能：defer 关键字。任何在 defer 块内提供的代码将在到达包含作用域的末尾时自动执行。这个功能可以在代码的任何地方工作。
- en: Custom error handling in Swift 2.0
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2.0 中的自定义错误处理
- en: The new error handling in Swift 2.0 is not limited to the Apple standard library.
    You can include this new syntax in your own classes and methods. Doing so allows
    you to build applications that handle all errors appropriately, often resulting
    in a better user experience and with fewer crashes. Additionally, this new error
    handling can be leveraged for more complex debugging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0 中的新错误处理不仅限于 Apple 标准库。您可以将此新语法包含在自己的类和方法中。这样做可以构建能够适当处理所有错误的应用程序，通常会导致更好的用户体验和更少的崩溃。此外，这种新的错误处理可以用于更复杂的调试。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new single view project and name it `Custom Error Handling Chapter
    7`. We will be using the boilerplate project setup for this recipe. If you followed
    the previous recipe in this chapter, you may continue using that project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的单视图项目，并将其命名为 `Custom Error Handling Chapter 7`。我们将为此食谱使用样板项目设置。如果您遵循了本章前面的食谱，您可以使用那个项目继续。
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Navigate to the `ViewController.swift` file and add the following code to the
    bottom of the file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `ViewController.swift` 文件，并将以下代码添加到文件底部：
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s implement a custom method that uses the `CustomError` enum we just created.
    Add the following code below our enum declaration:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个使用我们刚刚创建的 `CustomError` 枚举的自定义方法。在我们的枚举声明下方添加以下代码：
- en: '[PRE32]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We initially create a custom enum to store any required custom error types.
    These types can be explicit to your application or generic enough for a framework.
    Swift 2.0 uses the throws keyword placed before the return value of a method in
    order to identify methods with error handling.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建一个自定义枚举来存储任何所需的自定义错误类型。这些类型可以是特定于您的应用程序的，也可以足够通用以用于框架。Swift 2.0 使用 throws
    关键字放在方法返回值之前，以标识具有错误处理的方法。
- en: In our custom method, we want to perform any task that can possibly fail, such
    as a URL request. Next, we validate the possible errors and call `throw` with
    the error type. Everything after our checks will run as normal if no errors are
    thrown.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义方法中，我们想要执行任何可能失败的任务，例如 URL 请求。接下来，我们验证可能的错误，并使用错误类型调用 `throw`。如果没有抛出错误，我们的检查之后的所有内容都将正常运行。
- en: Availability checking in Swift 2.0
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2.0 中的可用性检查
- en: Swift 2.0 introduces a new method for checking OS availability in your code.
    This is done in the form of `@available` and allows us to check for OS support
    for both calling methods and creating our own. Using this new availability checking
    allows you to write backwards-compatible code without the worry of runtime errors.
    Xcode 7 has great integration with `@available` for a better programmer experience
    without many warnings. Additionally, you can more clearly define tasks based on
    the OS version without the hassle of macros.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0 引入了一种新的方法来检查代码中的操作系统可用性。这是通过 `@available` 形式实现的，并允许我们检查对调用方法和创建我们自己的方法的操作系统支持。使用这种新的可用性检查功能，您可以编写向后兼容的代码，而无需担心运行时错误。Xcode
    7 与 `@available` 集成良好，为程序员提供了更好的体验，而无需许多警告。此外，您可以根据操作系统版本更清晰地定义任务，而无需使用宏。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new single view project and name it `Availability Chapter 7`. We will
    be using the boiler plate project setup for this recipe. If you followed the previous
    recipe in this chapter, you may continue using that project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的单视图项目，并将其命名为 `Availability Chapter 7`。我们将为此食谱使用模板项目设置。如果您遵循了本章前面的食谱，您可以使用该项目继续操作。
- en: How to do it…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To test this functionality, we will be using an Apple standard library call
    for registering notifications. iOS 8 introduced a new method for this, so we want
    to target iOS 8 and up only.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试此功能，我们将使用苹果标准库中的注册通知的调用。iOS 8 引入了一种新的方法，因此我们只想针对 iOS 8 及以上版本。
- en: Navigate to the project settings and change the minimum deployment target to
    iOS 7.1 or below. Because the notification method is supported in 8.0 and above,
    we want to test with 7.1 as our target.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目设置，并将最低部署目标更改为 iOS 7.1 或以下。因为通知方法在 8.0 及以上版本中受支持，所以我们想使用 7.1 作为我们的目标。
- en: 'Navigate to the projects `AppDelegate.swift` file and add the following code
    to the `didFinishLaunchingWithOptions` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目的 `AppDelegate.swift` 文件，并在 `didFinishLaunchingWithOptions` 方法中添加以下代码：
- en: '[PRE33]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We use the new syntax `#available`(version number) to specify the version we
    require to run this block of code. The `*` simply indicates all versions above
    the stated version. Additionally, this syntax supports adding multiple platforms,
    such as OS X and watchOS.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的 `#available`(版本号) 语法来指定运行此代码块所需的版本。`*` 仅表示所有高于指定版本的版本。此外，此语法支持添加多个平台，例如
    OS X 和 watchOS。
- en: There's more…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Using the `@available`(version number) syntax, you can specify individual functions
    and classes as only available in a specific version. Simply include this line
    directly above the function or class declaration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@available`(版本号) 语法，您可以指定单个函数和类仅在特定版本中可用。只需在函数或类声明上方直接包含此行即可。
- en: See also…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容…
- en: 'Apple has supplied numerous attributes that can be used in conjunction with
    `@available`. Visit this link to the Apple documentation to learn more about attributes:
    [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果公司提供了许多可以与 `@available` 一起使用的属性。访问以下链接以了解有关属性的更多信息：[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html)
