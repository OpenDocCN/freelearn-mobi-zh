- en: Chapter 6. Using Protocols and Protocol Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 使用协议和协议扩展
- en: While watching the presentations from WWDC 2015 about protocol extensions and
    protocol-oriented programming, I will admit that I was very skeptical. I have
    worked with object-oriented programming for so long that I was unsure if this
    new programming paradigm would solve all of the problems that Apple was claiming
    it would. Since I am not one to let my skepticism get in the way of trying something
    new, I set up a new project that mirrored the one I was currently working on,
    but wrote the code using Apple's recommendations for protocol-oriented programming
    and used protocol extensions extensively in the code. I can honestly say that
    I was amazed with how much cleaner the new project was compared to the original
    one. I believe that protocol extensions is going to be one of those defining features
    that set one programming language apart from the rest. I also believe that many
    major languages will soon have similar features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在观看2015年WWDC关于协议扩展和面向协议编程的演讲时，我必须承认我非常怀疑。我从事面向对象编程已经很长时间了，以至于我不确定这种新的编程范式是否能够解决苹果所声称的所有问题。既然我不是那种让怀疑阻碍尝试新事物的人，我就设置了一个新的项目，这个项目与我现在正在工作的项目相似，但我使用了苹果面向协议编程的建议来编写代码，并在代码中广泛使用了协议扩展。我可以诚实地说我被这个新项目与原始项目相比的整洁程度所震惊。我相信协议扩展将是那些定义性特征之一，将一种编程语言与其它编程语言区分开来。我也相信许多主要语言很快就会拥有类似的功能。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How protocols are used as a type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议作为类型的使用
- en: How to implement polymorphism in Swift using protocols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中使用协议实现多态
- en: How to use protocol extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用协议扩展
- en: Why we would want to use protocol extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们想要使用协议扩展
- en: Protocol extensions are the backbone for Apple's new protocol-oriented programming
    paradigm and are arguably one of the most important additions to the Swift programming
    language. With protocol extensions, we are able to provide method and property
    implementations to any type that conforms to a protocol. To really understand
    how useful protocols and protocol extensions are, let's get a better understanding
    of protocols.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 协议扩展是苹果新面向协议编程范式的骨架，并且可以说是Swift编程语言最重要的补充之一。有了协议扩展，我们能够为符合协议的任何类型提供方法和属性实现。为了真正理解协议和协议扩展有多有用，让我们更好地理解协议。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While classes, structs, and enums can all conform to protocols in Swift, for
    this chapter, we will be focusing on classes and structs. Enums are used when
    we need to represent a finite number of cases and while there are valid use cases
    where we would have an enum conform to a protocol, they are very rare in my experience.
    Just remember that anywhere that we refer to a class or struct, we can also use
    an enum.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`class`、`struct`和`enum`都可以在Swift中符合协议，但在这个章节中，我们将专注于`class`和`struct`。当我们需要表示有限数量的情况时，我们会使用`enum`，虽然有一些有效的用例，其中枚举会符合协议，但在我个人的经验中，这种情况非常罕见。只需记住，在任何我们提到`class`或`struct`的地方，我们也可以使用`enum`。
- en: Let's begin exploring protocols by seeing how they are full-fledged types in
    Swift.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解它们在Swift中是如何作为完整的类型开始探索协议。
- en: Protocols as types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议作为类型
- en: 'Even though no functionality is implemented in a protocol, they are still considered
    a full-fledged type in the Swift programming language and can be used like any
    other type. What this means is we can use protocols as a parameter type or a return
    type in a function. We can also use them as the type for variables, constants,
    and collections. Let''s take a look at some examples. For these few examples,
    we will use the `PersonProtocol` protocol:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在协议中没有实现任何功能，但在Swift编程语言中，它们仍然被视为一个完整的类型，可以像任何其他类型一样使用。这意味着我们可以将协议用作函数中的参数类型或返回类型。我们还可以将它们用作变量、常量和集合的类型。让我们看看一些例子。对于这些例子，我们将使用`PersonProtocol`协议：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this first example, we will see how we would use protocols as a parameter
    type or return type in functions, methods, or initializers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将看到我们如何将协议用作函数、方法或初始化器中的参数类型或返回类型：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, the `updatePerson()` function accepts one parameter of the
    `PersonProtocol` protocol type and then returns a value of the `PersonProtocol`
    protocol type. Now let''s see how we can use protocols as a type for constants,
    variables, or properties:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`updatePerson()`函数接受一个`PersonProtocol`协议类型的参数，然后返回一个`PersonProtocol`协议类型的值。现在让我们看看我们如何可以将协议用作常量、变量或属性的类型：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we create a variable of the `PersonProtocol` protocol type
    that is named `myPerson`. We can also use protocols as the item type to store
    in collection such as arrays, dictionaries, or sets:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`myPerson`的`PersonProtocol`协议类型的变量。我们还可以将协议用作集合（如数组、字典或集合）中的项目类型来存储：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this final example, we create an array of `PersonProtocol` protocol types.
    As we can see from these three examples, even though the `PersonProtocol` protocol
    does not implement any functionality, we can still use protocols when we need
    to specify a type. We cannot, however, create an instance of a protocol. This
    is because no functionality is implemented in a protocol. As an example, if we
    tried to create an instance of the `PersonProtocol` protocol, we would be receiving
    the `error: protocol type ''PersonProtocol'' cannot be instantiated error`, as
    shown in the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个最后的例子中，我们创建了一个`PersonProtocol`协议类型的数组。从这三个例子中我们可以看到，尽管`PersonProtocol`协议没有实现任何功能，我们仍然可以在需要指定类型时使用协议。然而，我们无法创建协议的实例。这是因为协议中没有实现任何功能。例如，如果我们尝试创建`PersonProtocol`协议的实例，我们会收到`error:
    协议类型 ''PersonProtocol'' 不能实例化`错误，如下面的例子所示：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the instance of any class or struct that conforms to our protocol
    anywhere that the protocol type is required. As an example, if we defined a variable
    to be of the `PersonProtocol` protocol type, we could then populate that variable
    with any class or struct that conforms to the `PersonProtocol` protocol. For this
    example, let''s assume that we have two types named `SwiftProgrammer` and `FootballPlayer`,
    which conform to the `PersonProtocol` protocol:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要协议类型的地方使用任何符合我们协议的类或结构体的实例。例如，如果我们定义一个变量为`PersonProtocol`协议类型，那么我们可以用任何符合`PersonProtocol`协议的类或结构体来填充这个变量。为了这个例子，让我们假设我们有两个类型名为`SwiftProgrammer`和`FootballPlayer`，它们符合`PersonProtocol`协议：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we start off by creating the `myPerson` variable of the `PersonProtocol`
    protocol type. We then set the variable with an instance of the `SwiftProgrammer`
    type and print out the first and last names. Next, we set the `myPerson` variable
    to an instance of the `FootballPlayer` type and print out the first and last names
    again. One thing to note is that Swift does not care if the instance is a class
    or struct. It only matters that the type conforms to the `PersonProtocol` protocol
    type. Therefore, if our `SwiftProgrammer` type was a struct and the `FootballPlayer`
    type was a class, our previous example would be perfectly valid.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了一个`PersonProtocol`协议类型的`myPerson`变量。然后我们将变量设置为`SwiftProgrammer`类型的实例并打印出名字和姓氏。接下来，我们将`myPerson`变量设置为`FootballPlayer`类型的实例并再次打印出名字和姓氏。需要注意的是，Swift并不关心实例是类还是结构体。重要的是类型符合`PersonProtocol`协议类型。因此，如果我们的`SwiftProgrammer`类型是结构体，而`FootballPlayer`类型是类，我们之前的例子将完全有效。
- en: 'As we saw earlier, we can use our `PersonProtocol` protocol as the type for
    an array. This means that we can populate the array with instances of any type
    that conforms to the `PersonProtocol` protocol. Once again, it does not matter
    if the type is a class or a struct as long as it conforms to the `PersonProtocol`
    protocol. Here is an example of this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以将我们的`PersonProtocol`协议用作数组的类型。这意味着我们可以用符合`PersonProtocol`协议的任何类型的实例来填充数组。再次强调，只要类型符合`PersonProtocol`协议，类型是类还是结构体并不重要。以下是一个例子：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we create an instance of the `SwiftProgrammer` type and an
    instance of the `FootballPlayer` type. We then add both instances to the `people`
    array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`SwiftProgrammer`类型的实例和一个`FootballPlayer`类型的实例。然后我们将这两个实例添加到`people`数组中。
- en: Polymorphism with protocols
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议的多态性
- en: What we were seeing in the previous examples is a form of polymorphism. The
    word polymorphism comes from the Greek roots *Poly*, meaning many and *morphe*,
    meaning form. In programming languages, polymorphism is a single interface to
    multiple types (many forms). In the previous example, the single interface was
    the `PersonProtocol` protocol and the multiple types were any type that conforms
    to that protocol.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的例子中看到的是一种多态形式。多态这个词来源于希腊语根词*Poly*，意为许多，*morphe*，意为形式。在编程语言中，多态是单一接口对多种类型（许多形式）。在之前的例子中，单一接口是`PersonProtocol`协议，多种类型是符合该协议的任何类型。
- en: 'Polymorphism gives us the ability to interact with multiple types in a uniform
    manner. To illustrate this, we can extend our previous example where we created
    an array of the `PersonProtocol` types and loop through the array. We can then
    access each item in the array using the properties and methods define in the `PersonProtocol`
    protocol, regardless of the actual type. Let''s see an example of this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性使我们能够以统一的方式与多个类型交互。为了说明这一点，我们可以扩展我们之前的示例，其中我们创建了一个`PersonProtocol`类型的数组并遍历该数组。然后我们可以使用在`PersonProtocol`协议中定义的属性和方法来访问数组中的每个项目，而不管实际的类型是什么。让我们看看这个示例：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we ran this example, the output would look similar to this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此示例，输出将类似于以下内容：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have mentioned a few times in this chapter that when we define the type of
    a variable, constant, collection type, and so on to be a protocol type, we can
    then use the instance of any type that conforms to that protocol. This is a very
    important concept to understand and it is what makes protocols and protocol extensions
    so powerful.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到过几次，当我们定义变量、常量、集合类型等类型为协议类型时，我们就可以使用符合该协议的任何类型的实例。这是一个非常重要的概念，也是协议和协议扩展之所以强大的原因。
- en: When we use a protocol to access instances, as shown in the previous example,
    we are limited to using only properties and methods that are defined in the protocol.
    If we want to use properties or methods that are specific to the individual types,
    we would need to cast the instance to that type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用协议来访问实例时，如前一个示例所示，我们仅限于使用协议中定义的属性和方法。如果我们想使用特定于单个类型的属性或方法，我们需要将该实例转换为该类型。
- en: Type casting with protocols
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议进行类型转换
- en: Type casting is a way to check the type of the instance and/or to treat the
    instance as a specified type. In Swift, we use the `is` keyword to check if an
    instance is a specific type and the `as` keyword to treat the instance as a specific
    type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是一种检查实例类型的方法，并且/或者将实例视为指定的类型。在Swift中，我们使用`is`关键字来检查实例是否是特定类型，并使用`as`关键字将实例视为特定类型。
- en: 'To start with, let''s see how we would check the instance type using the `is`
    keyword. The following example shows how would we do this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用`is`关键字来检查实例类型。以下示例展示了如何进行此操作：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we use the `if` conditional statement to check whether each
    element in the people array is an instance of the `SwiftProgrammer` type and if
    so, we print that the person is a Swift programmer to the console. While this
    is a good method to check whether we have an instance of a specific class or struct,
    it is not very efficient if we wanted to check for multiple types. It is a lot
    more efficient to use the `switch` statement, as shown in the next example, if
    we want to check for multiple types:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`if`条件语句来检查`people`数组中的每个元素是否是`SwiftProgrammer`类型的实例，如果是，我们将打印出该人是Swift程序员到控制台。虽然这是一种检查我们是否具有特定类或结构体实例的好方法，但如果我们要检查多个类型，则效率不高。如果我们想要检查多个类型，使用`switch`语句会更高效，如下一个示例所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous example, we showed how to use the `switch` statement to check
    the instance type for each element of the array. To do this check, we use the
    `is` keyword in each of the `case` statements in an attempt to match the instance
    type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们展示了如何使用`switch`语句来检查数组中每个元素的实例类型。为此检查，我们在每个`case`语句中使用`is`关键字尝试匹配实例类型。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Control Flow and Functions"), *Control
    Flow and Functions*, we saw how to filter conditional statements with the `where`
    statement. We can also use the `where` statement with the `is` keyword to filter
    the array, as shown in the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。控制流和函数")中，*控制流和函数*，我们看到了如何使用`where`语句来过滤条件语句。我们还可以使用`where`语句与`is`关键字一起过滤数组，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s look at how we can cast an instance of a class or struct to a specific
    type. To do this, we can use the `as` keyword. Since the cast can fail if the
    instance is not of the specified type, the `as` keyword comes in two forms: `as?`
    and `as!`. With the `as?` form, if the casting fails, it returns a nil, and with
    the `as!` form, if the casting fails, we get a runtime error; therefore, it is
    recommended to use the `as?` form unless we are absolutely sure of the instance
    type or we perform a check of the instance type prior to doing the cast.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何将一个类或结构体的实例转换为特定类型。为此，我们可以使用 `as` 关键字。由于转换可能会失败，如果实例不是指定的类型，`as`
    关键字有两种形式：`as?` 和 `as!`。使用 `as?` 形式，如果转换失败，它返回 nil，而使用 `as!` 形式，如果转换失败，我们会得到一个运行时错误；因此，除非我们绝对确定实例类型，或者在我们进行转换之前对实例类型进行了检查，否则建议使用
    `as?` 形式。
- en: 'Let''s look at how we would use the `as?` keyword to cast an instance of a
    class or struct to a specified type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 `as?` 关键字将一个类或结构体的实例转换为指定的类型：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the `as?` keyword returns an optional, we can use optional binding to
    perform the cast, as shown in this example. If we are sure of the instance type,
    we can use the `as!` keyword. The following example shows how to use the `as!`
    keyword when we filter the results of the array to only return instances of the
    `SwiftProgrammer` type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `as?` 关键字返回一个可选值，我们可以使用可选绑定来执行转换，如下面的例子所示。如果我们确定实例类型，我们可以使用 `as!` 关键字。以下示例展示了如何使用
    `as!` 关键字在过滤数组结果时仅返回 `SwiftProgrammer` 类型的实例：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have covered the basics of protocols, that is, how polymorphism
    works and type casting, let's dive into one of the most exciting new features
    of Swift protocol extensions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了协议的基础知识，即多态工作和类型转换，让我们深入了解 Swift 协议扩展中最激动人心的一个新特性。
- en: Protocol extensions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议扩展
- en: Protocol extensions allow us to extend a protocol to provide method and property
    implementations to conforming types. They also allow us to provide common implementations
    to all the confirming types eliminating the need to provide an implementation
    in each individual type or the need to create a class hierarchy. While protocol
    extensions may not seem too exciting, once you see how powerful they really are,
    they will transform the way you think about and write code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 协议扩展允许我们扩展一个协议，为符合的类型提供方法和属性实现。它们还允许我们为所有符合的类型提供通用实现，从而消除了在每个单独的类型中提供实现或创建类层次结构的需要。虽然协议扩展可能看起来并不太吸引人，但一旦你看到它们真正的强大之处，它们将改变你思考和使用代码的方式。
- en: 'Let''s begin by looking at how we would use protocol extension with a very
    simplistic example. We will start off by defining a protocol called `DogProtocol`
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用一个非常简单的例子来看如何使用协议扩展开始。我们将从定义一个名为 `DogProtocol` 的协议开始，如下所示：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this protocol, we are saying that any type that conforms to the `DogProtocol`
    protocol, must have the two properties of the String type, namely, `name` and
    `color`. Now let''s define the three types that conform to this protocol. We will
    name these types `JackRussel`, `WhiteLab`, and `Mutt` as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个协议，我们是在说任何符合 `DogProtocol` 协议的类型，都必须有两个 String 类型的属性，即 `name` 和 `color`。现在让我们定义符合此协议的三个类型。我们将这些类型命名为
    `JackRussel`、`WhiteLab` 和 `Mutt`，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We purposely created the `JackRussel` and `Mutt` types as structs and the `WhiteLab`
    type as a class to show the differences between how the two types are set up and
    to illustrate how they are treated in the same way when it comes to protocols
    and protocol extensions. The biggest difference that we can see in this example
    is the struct types provide a default initiator, but in the class, we must provide
    the initiator to populate the properties.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将 `JackRussel` 和 `Mutt` 类型创建为结构体，将 `WhiteLab` 类型创建为类，以展示两种类型设置方式的不同，并说明当涉及到协议和协议扩展时，它们是如何以相同的方式被处理的。在这个例子中，我们可以看到的最大区别是结构体类型提供了一个默认的初始化器，但在类中，我们必须提供初始化器来填充属性。
- en: 'Now let''s say that we want to provide a method named `speak` to each type
    that conforms to the `DogProtocol` protocol. Prior to protocol extensions, we
    would start off by adding the method definition to the protocol, as shown in the
    following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要为符合 `DogProtocol` 协议的每个类型提供一个名为 `speak` 的方法。在协议扩展之前，我们会从向协议添加方法定义开始，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the method is defined in the protocol, we would then need to provide an
    implementation of the method in every type that conforms to the protocol. Depending
    on the number of types that conformed to this protocol, this could take a bit
    of time to implement. The following code sample shows how we might implement this
    method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在协议中定义了该方法，我们随后就需要为符合该协议的每个类型提供一个该方法的实现。根据符合此协议的类型数量，实现这一过程可能需要一些时间。以下代码示例展示了我们可能如何实现此方法：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While this method works, it is not very efficient because anytime we update
    the protocol, we would need to update all the types that conform to it and we
    may be duplicating a lot of code, as shown in this example. Another concern is,
    if we need to change the default behavior of the `speak()` method, we would have
    to go in each implementation and change the `speak()` method. This is where protocol
    extensions come in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此方法可行，但效率不高，因为每次我们更新协议时，都需要更新所有符合该协议的类型，并且我们可能会在代码中重复很多内容，如本例所示。另一个担忧是，如果我们需要更改`
    speak()`方法的默认行为，我们必须进入每个实现并更改` speak()`方法。这就是协议扩展发挥作用的地方。
- en: 'With protocol extensions, we could take the `speak()` method definition out
    of the protocol itself and define it with the default behavior, in protocol extension.
    The following code shows how we would define the protocol and the protocol extension:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议扩展，我们可以将` speak()`方法定义从协议本身中提取出来，并在协议扩展中定义它，带有默认行为。以下代码展示了我们将如何定义协议和协议扩展：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We begin by defining `DogProtocol` with the original two properties. We then
    create a protocol extension that extends `DogProtocol` and contains the default
    implementation of the `speak()` method. With this code, there is no need to provide
    an implementation of the `speak()` method in each of the types that conform to
    `DogProtocol` because they automatically receive the implementation as part of
    the protocol. Let''s see how this works by setting our three types that conform
    to `DogProtocol` back to their original implementations and they should receive
    the `speak()` method from the protocol extension:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用原始的两个属性定义`DogProtocol`。然后创建一个扩展`DogProtocol`的协议扩展，其中包含` speak()`方法的默认实现。使用此代码，我们无需在每个符合`DogProtocol`的类型的实现中提供`
    speak()`方法的实现，因为它们会自动作为协议的一部分接收实现。让我们通过将符合`DogProtocol`的三个类型恢复到它们的原始实现来查看这是如何工作的，它们应该会从协议扩展中接收`
    speak()`方法：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now use each of the types as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下代码所示的方式使用每个类型：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in this example, by adding the `speak()` method to the `DogProtocol`
    protocol extension, we are automatically adding that method to all the types that
    conform to `DogProtocol`. The `speak()` method in the `DogProtocol` protocol extension
    can be considered a default implementation of the `speak()` method because we
    are able to override it in the type implementations. As an example, we could override
    the `speak()` method in the `Mutt` struct, as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，通过将` speak()`方法添加到` DogProtocol`协议扩展中，我们自动将该方法添加到所有符合` DogProtocol`的类型中。`
    DogProtocol`协议扩展中的` speak()`方法可以被视为` speak()`方法的默认实现，因为我们能够在类型实现中覆盖它。例如，我们可以在以下代码中覆盖`
    Mutt`结构体中的` speak()`方法：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we call the `speak()` method for an instance of the `Mutt` type, it will
    return the string, `"I am hungry"`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`Mutt`类型的实例调用` speak()`方法时，它将返回字符串`"I am hungry"`。
- en: Now that we have seen how we would use protocols and protocol extensions, let's
    look at a more real-world example. In numerous apps across multiple platforms
    (iOS, Android, and Windows), I have had the requirement to validate user input
    as it is entered. This validation can be done very easily with regular expressions;
    however, we do not want various regular expressions littered throughout our code.
    It is very easy to solve this problem by creating different classes or structs
    that contains the validation code; however, we would have to organize these classes
    to make them easy to use and maintain. Prior to protocol extensions in Swift,
    I would use protocols to define the validation requirements and then create a
    struct that would conform to the protocol for each validation that I needed. Let's
    take a look at this preprotocol extension method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用协议和协议扩展，让我们看看一个更实际的例子。在多个平台（iOS、Android和Windows）的众多应用程序中，我需要验证用户输入。这种验证可以用正则表达式非常容易地完成；然而，我们不希望各种正则表达式散布在我们的代码中。通过创建包含验证代码的不同类或结构体来解决这个问题非常容易；然而，我们必须组织这些类，使它们易于使用和维护。在Swift的协议扩展之前，我会使用协议来定义验证要求，然后为每个需要的验证创建一个符合协议的结构体。让我们看看这个预协议扩展方法。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A regular expression is a sequence of characters that define a particular pattern.
    This pattern can then be used to search a string to see whether the string matches
    the pattern or contains a match of the pattern. Most major programming languages
    contain a regular expression parser, and if you are not familiar with regular
    expressions, it may be worthwhile to learn more about them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一系列字符，用于定义特定的模式。这个模式可以用来搜索字符串，以查看字符串是否匹配该模式或包含该模式的匹配项。大多数主要的编程语言都包含正则表达式解析器，如果你不熟悉正则表达式，了解它们可能是有益的。
- en: 'The following code shows the `TextValidationProtocol` protocol that defines
    the requirements for any type that we want to use for text validation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了定义任何我们想要用于文本验证的类型的要求的`TextValidationProtocol`协议：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this protocol, we define three properties and two methods that any type
    that conforms to `TextValidationProtocol` must implement. The three properties
    are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此协议中，我们定义了三个属性和两个方法，任何符合`TextValidationProtocol`的类型都必须实现。这三个属性是：
- en: '`regExMatchingString`: This is a regular expression string used to verify that
    the input string contains only valid characters.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regExMatchingString`：这是一个正则表达式字符串，用于验证输入字符串是否只包含有效字符。'
- en: '`regExFindMatchString`: This is a regular expression string used to retrieve
    a new string from the input string that contains only valid characters. This regular
    expression is generally used when we need to validate the input in real time,
    as the user enters information, because it will find the longest matching prefix
    of the input string.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regExFindMatchString`：这是一个正则表达式字符串，用于从输入字符串中检索只包含有效字符的新字符串。这个正则表达式通常在我们需要实时验证输入时使用，因为用户输入信息时，它会找到输入字符串的最长匹配前缀。'
- en: '`validationMessage`: This is the error message to display if the input string
    contains non-valid characters.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationMessage`：这是如果输入字符串包含非有效字符时显示的错误信息。'
- en: 'The two methods for this protocol are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议的两种方法如下：
- en: '`validateString`: This method will return `true` if the input string contains
    only valid characters. The `regExMatchingString` property will be used in this
    method to perform the match.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validateString`：如果输入字符串只包含有效字符，此方法将返回`true`。在这个方法中，将使用`regExMatchingString`属性来执行匹配。'
- en: '`getMatchingString`: This method will return a new string that contains only
    valid characters. This method is generally used when we need to validate the input
    real time as the user enters information because it will find the longest matching
    prefix of the input string. We will use the `regExFindMatchString` property in
    this method to retrieve the new string.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMatchingString`：此方法将返回一个只包含有效字符的新字符串。这个方法通常在我们需要实时验证用户输入时使用，因为它会找到输入字符串的最长匹配前缀。我们将使用`regExFindMatchString`属性来检索新字符串。'
- en: 'Now let''s see how we would create a struct that conforms to this protocol.
    The following struct would be used to verify that the input string contains only
    alpha characters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何创建一个符合此协议的结构体。以下结构体会被用来验证输入字符串是否只包含字母字符：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this implementation, the `regExFindMatchString` and `validationMessage` properties
    are stored properties, and the `regExMatchingString` property is a computed property.
    We also implement the `validateString()` and `getMatchingString()` methods within
    the struct.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，`regExFindMatchString`和`validationMessage`属性是存储属性，而`regExMatchingString`属性是一个计算属性。我们还在结构体内部实现了`validateString()`和`getMatchingString()`方法。
- en: Normally, we would have several different types that conform to `TextValidationProtocol`
    where each one would validate a different type of input. As we can see from the
    `AlphaValidation1` struct, there is a bit of code involved with each validation
    type. A lot of the code would also be duplicated in each type. The code for both
    methods (`validateString()` and `getMatchingString()`) and the `regExMatchingString`
    property would be duplicated in every validation class. This is not ideal, but
    if we wanted to avoid creating a class hierarchy with a super class that contains
    the duplicate code (I personally prefer using value types over classes), we would
    have no other choice. Now let's see how we would implement this using protocol
    extensions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会有几个不同的类型符合`TextValidationProtocol`，其中每个类型都会验证不同类型的输入。正如我们从`AlphaValidation1`结构体中可以看到的，每个验证类型都涉及一些代码。大量的代码也会在每个类型中重复。两个方法（`validateString()`和`getMatchingString()`）和`regExMatchingString`属性的代码会在每个验证类中重复。这并不理想，但如果我们想避免创建一个包含重复代码的超级类类层次结构（我个人更喜欢使用值类型而不是类），我们就别无选择。现在让我们看看我们如何使用协议扩展来实现这一点。
- en: 'With protocol extensions, we need to think about the code a little differently.
    The big difference is, we neither need, nor want to define everything in the protocol.
    With standard protocols or when we use class hierarchy, all the methods and properties
    that you would want to access using the generic superclass or protocol would have
    to be defined within the superclass or protocol. With protocol extensions, it
    is preferable for us not to define a property or method in the protocol if we
    are going to be defining it within the protocol extension. Therefore, when we
    rewrite our text validation types with protocol extensions, `TextValidationProtocol`
    would be greatly simplified to look similar to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议扩展时，我们需要稍微改变一下对代码的思考方式。最大的不同是，我们既不需要也不希望定义协议中的所有内容。使用标准协议或当我们使用类层次结构时，所有你想要通过通用超类或协议访问的方法和属性都必须在超类或协议中定义。使用协议扩展时，如果我们打算在协议扩展中定义它，我们更倾向于不在协议中定义属性或方法。因此，当我们用协议扩展重写我们的文本验证类型时，`TextValidationProtocol`将大大简化，看起来类似于这样：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In original `TextValidationProtocol`, we defined three properties and two methods.
    As we can see in this new protocol, we are only defining two properties. Now that
    we have our `TextValidationProtocol` defined, let''s create the protocol extension
    for it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的`TextValidationProtocol`中，我们定义了三个属性和两个方法。正如我们在这个新协议中可以看到的，我们只定义了两个属性。现在我们已经定义了`TextValidationProtocol`，让我们为它创建一个协议扩展：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `TextValidationProtocol` protocol extension, we define the two methods
    and the third property that were defined in original `TextValidationProtocol`,
    but were not defined in the new one. Now that we have created our protocol and
    protocol extension, we are able to define our text validation types. In the following
    code, we define three structs that we will use to validate text when a user types
    it in:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextValidationProtocol`协议扩展中，我们定义了原始`TextValidationProtocol`中定义的两个方法和第三个属性，但在新协议中没有定义。现在我们已经创建了我们的协议和协议扩展，我们能够定义我们的文本验证类型。在下面的代码中，我们定义了三个结构体，我们将使用这些结构体在用户输入文本时验证文本：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In each one of the text validation structs, we create a static constant and
    a private initiator so that we can use the struct as a singleton. For more information
    on the singleton pattern, please see the *The Singleton design pattern* section
    of [Chapter 17](ch17.html "Chapter 17. Adopting Design Patterns in Swift"), *Adopting
    Design Patterns in Swift*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文本验证结构体中，我们创建一个静态常量和私有初始化器，以便我们可以将结构体用作单例。有关单例模式的更多信息，请参阅[第17章](ch17.html
    "第17章。在Swift中使用设计模式")中的*单例设计模式*部分，*在Swift中使用设计模式*。
- en: After we define the singleton pattern, all we do in each type is set the values
    for the `regExFindMatchString` and `validationMessage` properties. Now, we have
    not duplicated the code virtually because even if we could, we would not want
    to define the singleton code in the protocol extension because we would not want
    to force that pattern on all the conforming types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了单例模式之后，在每种类型中我们只需设置 `regExFindMatchString` 和 `validationMessage` 属性的值。现在，我们实际上并没有复制代码，因为即使我们可以，我们也不希望在协议扩展中定义单例代码，因为我们不希望将该模式强加给所有符合的类型。
- en: 'To use the text validation classes, we would want to create a dictionary object
    that would map the `UITextField` objects to the validation class to use it like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用文本验证类，我们希望创建一个字典对象，将 `UITextField` 对象映射到要使用的验证类，如下所示：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could then populate the `validators` dictionary as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像下面这样填充 `validators` 字典：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now set the `EditingChanged` event of the text fields to a single method
    named `keyPressed()`. To set the edition changed event for each field, we would
    add the following code to the `viewDidLoad()` method of our view controller:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将文本字段的 `EditingChanged` 事件设置为名为 `keyPressed()` 的单个方法。要为每个字段设置编辑更改事件，我们将在视图控制器的
    `viewDidLoad()` 方法中添加以下代码：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s create the `keyPressed()` method that each text field calls when
    a user types a character into the field:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `keyPressed()` 方法，当用户在字段中输入字符时，每个文本字段都会调用此方法：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this method, we use the `if let validator = validators[textField]` statement
    to retrieve the validator for the particular text field and then we use the `where
    !validator.validateString(textField.text!)` statement to validate the string that
    the user has entered. If the string fails validation, we use the `getMatchingString()`
    method to update the text in the text field by removing all the characters from
    the input string, starting with the first invalid character and then displaying
    the error message from the text validation class. If the string passes validation,
    the text in the text field is left unchanged.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用 `if let validator = validators[textField]` 语句来检索特定文本字段的验证器，然后我们使用
    `where !validator.validateString(textField.text!)` 语句来验证用户输入的字符串。如果字符串验证失败，我们使用
    `getMatchingString()` 方法通过从输入字符串的第一个无效字符开始删除所有字符，并显示来自文本验证类的错误消息来更新文本字段中的文本。如果字符串通过验证，文本字段中的文本保持不变。
- en: In the downloadable code for this book, you will find a sample project that
    demonstrates how to use the text validation types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下载代码中，你可以找到一个示例项目，演示如何使用文本验证类型。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that protocols are treated as full-fledged types by
    Swift. We also saw how polymorphism can be implemented in Swift with protocols.
    We concluded this chapter with an in-depth look at protocol extensions and saw
    how we would use them in Swift.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 Swift 如何将协议视为完整的类型。我们还看到了如何在 Swift 中使用协议实现多态。我们通过深入了解协议扩展来结束本章，并看到了我们如何在
    Swift 中使用它们。
- en: Protocols and protocol extensions are the backbone of Apple's new protocol-oriented
    programming paradigm. This new model for programming has the potential to change
    the way we write and think about code. While we did not specifically cover protocol-oriented
    programming in this chapter, understanding the topics in this chapter gives us
    the solid understanding of protocols and protocol extensions needed to learn about
    this new programming model.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和协议扩展是苹果新协议导向编程范式的骨架。这种新的编程模型有可能改变我们编写和思考代码的方式。虽然我们在这章没有专门介绍协议导向编程，但理解本章的内容为我们提供了学习这种新编程模型所需的关于协议和协议扩展的坚实基础。
