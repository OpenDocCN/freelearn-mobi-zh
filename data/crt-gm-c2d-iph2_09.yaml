- en: Chapter 9. Running and Running and Running...
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。奔跑，奔跑，再奔跑...
- en: In this chapter we will be exploring randomly generated landscapes, how to create
    a lot of different enemies with very little code, parallax scrolling, and using
    particle effects for extra visual flair. We've covered a lot of the smaller housekeeping
    details several times, so for this project we will be focusing on the new, interesting
    code and not re-covering old ground.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨随机生成的景观，如何用很少的代码创建许多不同的敌人，透视滚动，以及使用粒子效果来增加视觉效果。我们已经多次涵盖了大量的细节，所以对于这个项目，我们将专注于新的、有趣的代码，而不是重新覆盖旧的内容。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Randomizing terrain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机化地形
- en: Endless scrolling parallax backgrounds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无尽滚动透视背景
- en: Using your own sensors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的传感器
- en: Animation made simple
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化动画
- en: Particle effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果
- en: The game is...
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这款游戏是...
- en: 'This time around we will be designing a side scrolling endless runner. The
    endless runner game style has really taken off in the mobile gaming world, and
    it is a fun game style to implement using Cocos2d. Basic gameplay will be a simple
    two-touch control method: touches on the left half of the screen make the hero
    jump and touches on the right half of the screen will make the hero shoot. The
    game will scroll continuously, leaving no time for the player to stop and rest.
    As the game progresses, it will steadily increase the scrolling speed, so it gets
    harder the longer you play. For all of our graphics (except for the background
    images), we will be using the Planet-X graphics created by James Macanufo at [http://tintanker.com](http://tintanker.com),
    used here with the creator''s permission. You can find his original images at
    [http://tintanker.com/makegameswithus](http://tintanker.com/makegameswithus).
    If you enjoy the graphics, James deserves full credit for this fun and whimsical
    set.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将设计一个侧滚动无尽跑酷游戏。无尽跑酷游戏风格在移动游戏世界中已经非常流行，并且使用Cocos2d实现这种游戏风格非常有趣。基本游戏玩法将是一个简单的双触控控制方法：屏幕左侧的触摸使英雄跳跃，屏幕右侧的触摸将使英雄射击。游戏将连续滚动，不给玩家停下来休息的时间。随着游戏的进行，它将逐渐增加滚动速度，所以玩得越久就越难。对于我们的所有图形（除了背景图像），我们将使用由James
    Macanufo在[http://tintanker.com](http://tintanker.com)创建的Planet-X图形，这里使用的是创作者的许可。您可以在[http://tintanker.com/makegameswithus](http://tintanker.com/makegameswithus)找到他的原始图像。如果您喜欢这些图形，James应得到全部的赞誉，因为这套图形既有趣又富有想象力。
- en: Design review
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计回顾
- en: 'When you are designing a side-scrolling endless runner, there are two primary
    design approaches. Some will use a physics engine like Box2D or Chipmunk to help
    control all of the object interactions. We will be taking the other approach by
    building our own lightweight physics engine for the game. All of our ground will
    use square tiles, so we can easily identify the surfaces our hero can walk on
    safely. We will build sensors on the top of all walkable surfaces, as well as
    building sensors underneath each of our walking characters (hero and enemies).
    The hero will be in a fixed x coordinate on the screen, and the world will scroll
    past the hero. We will have two types of enemies: flying and walking. Both will
    have similar behavior, but the walkers will have the sensors we mentioned to allow
    them to walk back and forth on their platforms. Enemies will not be allowed to
    walk off the platforms to their death. We will also implement a two level endless
    parallax background from scratch. Finally, we want some fun effects when enemies
    (or the hero) die. We will be using particle effects, built using Particle Designer.
    We will only measure the player''s success in the game with one metric: distance
    travelled. That about covers the basics of the design, so let''s take a peek at
    the finished game:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设计一个侧滚动无尽跑酷游戏时，有两种主要的设计方法。有些人会使用物理引擎，如Box2D或Chipmunk，来帮助控制所有对象之间的交互。我们将采取另一种方法，为游戏构建自己的轻量级物理引擎。我们所有的地面都将使用方形瓦片，这样我们就可以轻松地识别我们的英雄可以安全行走的表面。我们将在所有可通行表面的顶部构建传感器，以及在我们每个行走角色（英雄和敌人）的下方构建传感器。英雄将在屏幕上的固定x坐标处，而世界将滚动过英雄。我们将有两种类型的敌人：飞行和行走。两者都将有类似的行为，但行走的敌人将拥有我们提到的传感器，允许它们在其平台上来回行走。敌人不允许走出平台走向死亡。我们还将从头开始实现一个两级无尽透视背景。最后，我们希望在敌人（或英雄）死亡时有一些有趣的效果。我们将使用粒子效果，这些效果是通过Particle
    Designer构建的。我们只使用一个指标来衡量玩家在游戏中的成功：行走的距离。这基本上涵盖了设计的基本内容，所以让我们看看完成的游戏：
- en: '![Design review](img/9007_9_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![设计回顾](img/9007_9_01.jpg)'
- en: Building the ground
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建地面
- en: We will start by building the random ground tiles. For our game, we have three
    types of ground, with three ground images for each type, so we can build stacks
    with them. For organization, the image that has a gradient color (the bottom)
    will be identified as `1`, the middle as `2`, and the top (with the grassy surface)
    as `3`. Let's take a look at the code to build the ground, in two parts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建随机的地面瓦片。在我们的游戏中，我们有三种类型的地面，每种类型有三种地面图像，因此我们可以用它们构建堆叠。为了组织，具有渐变颜色（底部）的图像将被标识为`1`，中间的为`2`，顶部的（带有草地表面）为`3`。让我们看看构建地面的代码，分为两部分。
- en: '**Filename**: `ERPlayfieldLayer.m` (`addGround…`, part 1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m` (`addGround…`，第一部分)'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start this method by randomizing the width, the height, and the type (graphic
    set) for the platform. The width and height are both expressed in terms of how
    many tiles we will use for this platform. You will notice that the width adds
    `2` to the result of the `arc4random()` call. This is because we want the platform
    to be a minimum of 2 tiles wide. Anything smaller is too challenging to land on,
    once we add enemies into the mix. We then move into a big `switch` statement,
    passing it the `platformHeight` variable. We have designed "stacks" for the different
    elevations to be more playable. The tile type 3 is the only type of walkable tile,
    so we need to make sure there is a walkable tile on top. This predefined stack
    approach guarantees we will have something that looks more pleasant and is playable.
    You will notice that the case 4 has two uses of tile type 3 (the walkable tile)
    in the stack. This will give that "stack" two separate platforms for the hero
    to walk on. We do this for variety, but also to make sure we don't have an impossible
    arrangement, if the terrain goes directly from an elevation 1 to an elevation
    4\. The lower surface gives the hero something else to land on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个方法开始，随机化平台宽度、高度和类型（图形集）。宽度和高度都是以我们将为这个平台使用的瓦片数量来表示的。你会注意到宽度在`arc4random()`调用的结果上增加了`2`。这是因为我们希望平台至少有2个瓦片宽。任何更小的平台一旦加入敌人，就太难以着陆了。然后我们进入一个大的`switch`语句，传递给它`platformHeight`变量。我们为不同的海拔设计了“堆叠”，以便游戏性更好。瓦片类型3是唯一可走的瓦片类型，因此我们需要确保顶部有一个可走的瓦片。这种预定义的堆叠方法确保我们将有一个看起来更愉快且可玩的东西。你会注意到案例4在堆叠中使用了两种瓦片类型3（可走的瓦片）。这将给“堆叠”提供两个单独的平台供英雄行走。我们这样做是为了多样性，同时也是为了确保如果地形直接从海拔1到海拔4，我们不会有一个不可能的排列。较低的地表给英雄提供了另一种着陆的地方。
- en: '**Filename**: `ERPlayfieldLayer.m` (`addGround…`, part 2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m` (`addGround…`，第二部分)'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have a stack defined, we iterate through the number of tiles wide
    we need. The `maxTileX` variable is populated with the `x` position we need for
    the current stack of tiles. Once that is updated for the current stack, we enter
    another loop, based on the `platformHeight` variable. We get the next tile from
    the `platformStack` array, and build the sprite name in the `tileNm` variable.
    This is a case where the consistent naming convention of the files really helps
    out. We then create a new `ERTile` object. `ERTile` is a subclass of the `CCSprite`
    class, which we will look at in just a few moments. We set the anchor point to
    center bottom so we can easily build the tiles from the bottom of the screen,
    and we define the `y` value by multiplying times the `tileSize` variable we define
    in our `init` method (50, the size in points of the square tiles). We then check
    to see if the tile is type 3\. Remember, tile 3 is a walkable surface. If it is
    a walkable surface, we set the tile's `isTop` value to `YES`. (We also try to
    generate an enemy on the walkable surface some percentage of the time.) Finally,
    we set the position of the tile, add it to the `grndArray` array, and add the
    tile as a child of the `runnersheet` (our `CCSpriteBatchNode` which houses all
    of our foreground images). The last thing we do here is to remove all objects
    from the `platformStack` array, so it will be ready for the next time we add ground.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个栈，我们遍历所需的瓷砖宽度。`maxTileX`变量被填充了当前瓷砖栈所需的`x`位置。一旦更新了当前栈，我们就进入另一个基于`platformHeight`变量的循环。我们从`platformStack`数组中获取下一个瓷砖，并在`tileNm`变量中构建精灵名称。这是一个文件命名一致性
    conventions 真正帮了大忙的情况。然后我们创建一个新的`ERTile`对象。`ERTile`是`CCSprite`类的一个子类，我们将在接下来的几分钟内查看它。我们将锚点设置为底部中心，这样我们就可以轻松地从屏幕底部构建瓷砖，并通过乘以我们在`init`方法中定义的`tileSize`变量（50，正方形瓷砖的点大小）来定义`y`值。然后我们检查瓷砖是否为类型3。记住，瓷砖3是一个可通行表面。如果是可通行表面，我们将瓷砖的`isTop`值设置为`YES`。（我们也会尝试在可通行表面上生成一定比例的敌人。）最后，我们设置瓷砖的位置，将其添加到`grndArray`数组中，并将瓷砖作为`runnersheet`（我们包含所有前景图像的`CCSpriteBatchNode`）的子项。我们在这里做的最后一件事是从`platformStack`数组中移除所有对象，以便它为下一次添加地面做好准备。
- en: ERTile class
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ERTile`类'
- en: We said that `ERTile` is a subclass of the `CCSprite` class, but for most purposes
    it acts like a normal sprite. Let's take a look at the implementation file to
    see why we need it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到`ERTile`是`CCSprite`类的一个子类，但在大多数情况下它表现得像一个普通的精灵。让我们看一下实现文件，看看为什么我们需要它。
- en: '**Filename**: `ERTile.m`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERTile.m`'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two methods are the only methods included in the `ERTile` class. We define
    variables and properties for the `topSensor` and `isTop`, but that's it for this
    class. The main piece we need to understand is the sensor. The `topSensor` is
    a `CGRect` we define in relation to the bounding box of the tile. As you can see,
    this `topSensor` is the full width of the sprite and is `5` points high, a few
    points inside the top of the sprite. This is the level at which "ground" will
    be defined for this tile. To use this, we also override the `setPosition` method.
    When the `setPosition` method is called, it sends the same command to the `super`
    version of itself (that is, `CCSprite` class), and if the `isTop` value is `YES`,
    then it calls to the `defineSensors` method. We have to keep redefining it because
    the `CGRect` will otherwise stay exactly where you put it on screen, even if the
    sprite itself moves. By redefining it with every `setPosition` call, we guarantee
    it is exactly where we need it, relative to the tile.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法是`ERTile`类中包含的唯一方法。我们为`topSensor`和`isTop`定义变量和属性，但这个类就这些了。我们需要理解的主要部分是传感器。`topSensor`是我们相对于瓷砖的边界框定义的一个`CGRect`。正如你所见，这个`topSensor`是精灵的全宽，高5点，位于精灵顶部内部几点的位置。这是定义此瓷砖“地面”的水平。为了使用它，我们还重写了`setPosition`方法。当调用`setPosition`方法时，它向`super`版本的自身（即`CCSprite`类）发送相同的命令，如果`isTop`值为`YES`，则调用`defineSensors`方法。我们必须不断重新定义它，因为否则`CGRect`将保持在屏幕上你放置的位置，即使精灵本身移动。通过每次`setPosition`调用重新定义它，我们确保它正好位于我们需要的相对位置，相对于瓷砖。
- en: There are other ways we could have accomplished this same effect, including
    invisible child sprites under the `ERTile` class. We have chosen this approach
    because a `CGRect` is a lot less resource intensive than defining another sprite
    for every tile (and character). For our purposes, this `CGRect` implementation
    is fast, reliable, and because we tie it into the overridden `setPosition` method,
    it is invisible to any other methods that manipulate the sprite.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他方法可以实现相同的效果，包括在`ERTile`类下有不可见的子精灵。我们选择这种方法是因为`CGRect`比为每个瓷砖（和角色）定义另一个精灵要节省资源得多。就我们的目的而言，这种`CGRect`实现速度快、可靠，并且因为我们将其与重写的`setPosition`方法绑定，所以对任何操纵精灵的其他方法都是不可见的。
- en: Adding gap tiles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加间隙瓷砖
- en: We don't want end-to-end ground, since we need the ability for our hero to fall
    to his death. We build these gap tiles in much the same fashion as the ground
    tiles, except the gap tiles are only one tile high.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望地面是连续的，因为我们需要我们的英雄有掉落到死亡的能力。我们以与地面瓷砖相同的方式构建这些间隙瓷砖，只是间隙瓷砖只有一砖高。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The structure of this method is pretty similar to the ground tile method. We
    start by using a randomizer to determine if we need a gap or not. We have a three
    in five chance that we will build a gap (if the `gapRnd` value is greater than
    `1`). This lets us have some ground-to-ground passages for more variety. We control
    the width of the gaps a little differently. We take the `MIN` value of the `scrollSpeed`
    variable or `5`, so when the game is scrolling slower, the gaps will also be smaller.
    But as the game ramps up in speed, we don't want any tile gaps larger than 5\.
    The loop in this method is virtually identical to the one in the ground method,
    except these tiles are never walkable. We also randomize the creation of flying
    enemies over the gaps. The chance is lower than with walking enemies, and we randomize
    their starting elevation between `y` values of 250 and 289\. Finally, whenever
    we build a gap, we immediately call the method to build the ground tiles. This
    ensures that we don't have to worry about which method to call later on. We simply
    call the `addGapTiles` method, and it takes care of both of these methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的结构与地面瓷砖方法非常相似。我们首先使用随机化器来确定是否需要间隙。我们有五分之三的机会会构建一个间隙（如果`gapRnd`值大于`1`）。这让我们有一些地面到地面的通道，以增加多样性。我们以不同的方式控制间隙的宽度。我们取`scrollSpeed`变量的`MIN`值或`5`，所以当游戏滚动速度较慢时，间隙也会更小。但是当游戏速度加快时，我们不希望任何瓷砖间隙大于5。这个方法中的循环与地面方法中的循环几乎相同，只是这些瓷砖永远不会被行走。我们还随机化在间隙上创建飞行敌人的过程。这个概率低于行走敌人，并且我们随机化它们的起始高度在`y`值250到289之间。最后，每次我们构建一个间隙时，我们立即调用构建地面瓷砖的方法。这确保了我们不必担心稍后调用哪个方法。我们只需调用`addGapTiles`方法，它就会处理这两个方法。
- en: Scrolling the tiles
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动瓷砖
- en: In our game, there is a lot that needs to be updated, so we have broken out
    our `update` method into individual methods for each type of update. Let's take
    a look at how we update the tiles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，有很多需要更新的内容，因此我们将`update`方法分解为针对每种更新类型的独立方法。让我们看看我们是如何更新瓷砖的。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first callout here is that we have a variable in our layer called `isScrolling`
    that controls whether or not the world is scrolling. It is a simple Boolean variable,
    used to start or stop the scrolling as we see fit. We also have a `scrollSpeed`
    variable, which controls the speed of the scroll. In our `init` method we start
    this at a value of `2.5f`. In this method, we go through every tile in the `grndArray`
    array, and add the negative of the `scrollSpeed` value (to move everything left)
    to the current position of each tile. We then update our distance travelled, and
    call out to the HUD to update the display. (Note: we will not be discussing the
    HUD layer here. It is structurally the same as how we built the HUD in [Chapter
    8](ch08.html "Chapter 8. Shoot, Scroll, Shoot Again"), *Shoot, Scroll, Shoot Again*,
    so flip back there for a refresher, if needed). We also increase the scroll speed
    a little bit each time this method is called, so the speed will slowly increase
    as the game progresses.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第一个要注意的是，在我们的层中有一个名为`isScrolling`的变量，它控制世界是否滚动。它是一个简单的布尔变量，用于根据我们的需要开始或停止滚动。我们还有一个`scrollSpeed`变量，它控制滚动的速度。在我们的`init`方法中，我们将其初始化为`2.5f`。在这个方法中，我们遍历`grndArray`数组中的每个瓦片，并将`scrollSpeed`值的负数（为了将所有东西向左移动）加到每个瓦片的当前位置。然后我们更新我们的移动距离，并调用HUD来更新显示。（注意：我们在这里不会讨论HUD层。它的结构与我们如何在[第8章](ch08.html
    "第8章。射击，滚动，再射击")中构建HUD相同，即“射击，滚动，再射击”，如果需要，请翻回那里进行复习）。我们还每次调用这个方法时稍微增加滚动速度，所以随着游戏的进行，速度会逐渐增加。
- en: After we move everything, we need to do some tile maintenance. We look for any
    tiles whose `x` value is less than `-100`, and remove them. At the same time,
    we reset the `maxTileX` value to the `x` position of the rightmost tile we find.
    If that `maxTileX` value is less than `1.1` times the width of the screen, we
    call to the `addGapTiles` method to build some gaps and ground. That's all it
    takes to make a scrolling, randomly generated ground.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将所有东西移动之后，我们需要做一些瓦片维护。我们寻找任何`x`值小于`-100`的瓦片，并将它们移除。同时，我们将`maxTileX`值重置为我们找到的最右侧瓦片的`x`位置。如果这个`maxTileX`值小于屏幕宽度的`1.1`倍，我们就调用`addGapTiles`方法来构建一些空隙和地面。这就是制作一个滚动、随机生成的地面的全部过程。
- en: 'There is one slight issue, however. There will be visible seams between the
    tiles. Fortunately, this has a simple fix. In the cocos2d source files, there
    is a file called `ccConfig.h`. Open this file and find the line (line 85, in the
    2.0 version) that looks like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个小问题。瓦片之间会有可见的缝隙。幸运的是，这个问题有一个简单的解决办法。在cocos2d源文件中，有一个名为`ccConfig.h`的文件。打开这个文件，找到看起来像这样的行（2.0版本中的第85行）：
- en: '**Filename**: `ccConfig.h`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ccConfig.h`'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Change the value of `0` to `1`, and the seams disappear. How easy is that?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将`0`的值改为`1`，缝隙就消失了。这有多简单？
- en: Parallax background
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差背景
- en: 'Before we move on to our hero, let''s turn our attention to the other endless
    element of the game: the background. We want to have a two-layer parallax background
    that is endlessly scrolling. A parallax background is simply one that has multiple
    layers that scroll at different rates, to simulate the way that distant terrain
    looks like it is moving slower than closer terrain. We simulate this by throttling
    the scrolling speed of each layer of the background to a relative speed. Let''s
    look at our background class and see how it works.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向我们的英雄之前，让我们将注意力转向游戏的另一个无尽元素：背景。我们希望有一个两层视差背景，可以无限滚动。视差背景简单来说就是有多个层，以不同的速度滚动，以模拟远处地形看起来比近处地形移动得慢的现象。我们通过调整背景每一层的滚动速度到相对速度来模拟这一点。让我们看看我们的背景类，看看它是如何工作的。
- en: '**Filename**: `ERBackground.h`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERBackground.h`'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ERBackground` class is a subclass of the `CCLayer` class. Here we simply
    add two sprites to the layer using the `bg_mtns.png` image. You will notice we
    aren't using a sprite sheet here. Since it is a single image, there would be minimal
    performance gains using a sprite sheet here. We position one at (`0,0`) and the
    other at (`1001,0`). The image itself is 1000 points wide, so this will put them
    one after the other. We flip the second sprite to add some variety to the landscape,
    even though we are using the same image twice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ERBackground`类是`CCLayer`类的子类。在这里，我们只是使用`bg_mtns.png`图像在层中添加了两个精灵。你会注意到我们在这里没有使用精灵表。由于它是一个单独的图像，在这里使用精灵表几乎不会带来性能上的提升。我们将一个放在`(0,0)`，另一个放在`(1001,0)`。这个图像本身宽度为1000点，所以这将使它们一个接一个地放置。我们将第二个精灵翻转以增加景观的多样性，尽管我们在这里使用了相同的图像两次。'
- en: '**Filename**: `ERBackground.m`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERBackground.m`'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will be using the same image for both of the parallax layers, so we want
    to make one seem farther away. The `useDarkBG` method call will darken the image
    by about half when this method is called. Now we need to be able to move the background
    and make it endless.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的图像为两个透视层，所以我们要让一个看起来更远。当调用`useDarkBG`方法时，这个方法会将图像大约变暗一半。现在我们需要能够移动背景并使其无限循环。
- en: '**Filename**: `ERBackground.m`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERBackground.m`'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the `update` method is called, we move both images to the left by their
    designated `bgScrollSpeed` value. Then each background is checked to see if it
    is off-screen by 1000 points. If it is, then that sprite is repositioned to the
    right side of the other sprite. This means that every time one sprite is completely
    off-screen to the left, it is moved to the far right, so it will scroll through
    again. We obviously have a few parameters that need to be set from outside this
    class. Let's see how we set this up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`update`方法时，我们将两个图像向左移动它们指定的`bgScrollSpeed`值。然后检查每个背景是否偏离屏幕1000个点。如果是，那么那个精灵将被重新定位到另一个精灵的右侧。这意味着每次一个精灵完全偏离屏幕左侧时，它就会被移动到最右边，这样它就会再次滚动。显然，我们有一些参数需要从类外设置。让我们看看我们是如何设置这个的。
- en: '**Filename**: `ERPlayfieldLayer.m` (inside `init`)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`（在`init`内部）'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here you see that the `background1` object calls the `useDarkBG` method, and
    sets a `bgScrollSpeed` value of `0.025`, which is nice and slow. These are the
    mountains in the distance. The other layer, `background2`, sets its initial offset
    to be `200` to the right (and sets the corresponding position), so the mountains
    do not start exactly on top of each other. It also uses a faster scrolling rate
    of `0.1`. That is all it takes to establish the mountains. The one piece that
    is left to complete the parallax is how to call the `update` method. We do not
    set any schedules in the `ERBackground` class. Instead, we call this `update`
    method manually from the playfield''s `update` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`background1`对象调用了`useDarkBG`方法，并将`bgScrollSpeed`的值设置为`0.025`，这很好，速度很慢。这些是远处的山脉。另一层`background2`将其初始偏移设置为向右`200`（并设置了相应的位置），这样山脉就不会完全重叠。它还使用更快的滚动速度`0.1`。这就是建立山脉的全部内容。剩下要完成的是如何调用`update`方法。我们在`ERBackground`类中没有设置任何计划。相反，我们从游戏场的`update`方法中手动调用这个`update`方法：
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On each iteration of the playfield's `update` method, it calls out the background
    layers, and they take care of themselves with nothing else needed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏场的`update`方法的每次迭代中，它都会调用背景层，并且它们会自己处理，不需要其他操作。
- en: Our hero
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的英雄
- en: Now we can turn our attention to our hero, the little spaceman. Let's start
    by looking through the `ERHero` class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以把注意力转向我们的英雄，那个小太空人。让我们先看看`ERHero`类。
- en: '**Filename**: `ERHero.m`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERHero.m`'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ERHero` class is a subclass of `CCSprite` class. Because we need a custom
    `init` method for the sprite, we have overridden the `spriteWithSpriteFrameName`
    class method and the corresponding `init` method. As the `_state` variable might
    lead you to guess, the hero will be operating as a simple state machine. Let''s
    see what states are valid:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ERHero`类是`CCSprite`类的子类。因为我们需要一个定制的`init`方法来处理精灵，所以我们重写了`spriteWithSpriteFrameName`类方法和相应的`init`方法。正如你可能从`_state`变量猜到的，英雄将作为一个简单的状态机运行。让我们看看哪些状态是有效的：'
- en: '**Filename**: `ERDefinitions.m`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERDefinitions.m`'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we can look at how the states are changed for our hero.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看英雄的状态是如何改变的。
- en: '**Filename**: `ERHero.m`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERHero.m`'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We start by checking to make sure we are not trying to reassign to the same
    state. If we are, we exit. We then stop all actions, because most of the actions
    are related to animations, so we want to stop the prior ones before running the
    new animation. The `isFlashing` check relates to when the hero gets hit (he flashes
    red for a brief moment). We put this check in here to see if the hero was flashing
    when the state is changed. If he is flashing, then we force the hero back to normal
    color. We do this because the `stopAllActions` method will also stop all actions,
    including the "tint color" actions. The end result is that without this clause,
    the hero would get stuck with a red tint if his state changed when he got hit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查确保我们不是试图将相同的值重新分配给同一个状态。如果是这样，我们就退出。然后我们停止所有动作，因为大多数动作都与动画相关，所以我们希望在运行新动画之前停止之前的动画。`isFlashing`检查与英雄被击中时的动作有关（他会短暂地变红）。我们将这个检查放在这里是为了查看当状态改变时英雄是否在闪烁。如果他正在闪烁，那么我们将英雄强制恢复到正常颜色。我们这样做是因为`stopAllActions`方法也会停止所有动作，包括“着色颜色”动作。最终结果是，如果没有这个条款，当英雄被击中时状态改变，他可能会卡在一个红色的着色中。
- en: The core of the `stateChangeTo` method is the switch statement at the bottom.
    It evaluates the state and calls the appropriate animation method. Finally, it
    defines the sensors, to make sure we have current sensors in place.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`stateChangeTo`方法的核心是底部的switch语句。它评估状态并调用适当的动画方法。最后，它定义传感器，以确保我们有当前传感器就位。'
- en: '**Filename**: `ERHero.m`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERHero.m`'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here we see the same type of `defineSensors` method we saw in the `ERTile`
    class. The difference for the hero is that he has two sensors: one on his feet,
    and one below his feet. The `footSensor` variable will be used to identify state
    changes, and the `fallSensor` variable will be used to determine if the hero should
    be falling. We also use the same `setPosition` override method, for exactly the
    same reason: to keep the sensors in place during movement. Let''s see how the
    game looks with the sensors visible:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到与`ERTile`类中看到的相同类型的`defineSensors`方法。对于英雄来说，区别在于他有两个传感器：一个在他的脚下，一个在他的脚下方。`footSensor`变量将用于识别状态变化，而`fallSensor`变量将用于确定英雄是否应该坠落。我们也使用相同的`setPosition`覆盖方法，原因完全相同：在移动过程中保持传感器就位。让我们看看传感器可见时的游戏看起来如何：
- en: '![Our hero](img/9007_9_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![我们的英雄](img/9007_9_02.jpg)'
- en: Animation loading
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画加载
- en: We have talked about playing animations, but we haven't actually created any
    yet. We will be using a helper method to load our animations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了播放动画，但实际上我们还没有创建任何动画。我们将使用一个辅助方法来加载我们的动画。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we see our two helper methods. The first takes quite a few parameters to
    build the animation. We pass it the name we want the animation stored as, the
    root of the filename, the extensions of the filename, the number of frames for
    the animation, and the time delay between frames. This assumes that any animations
    loaded will have an incremental number in their filenames. It then goes through
    the process of loading each frame and adding it to the frames array. Finally,
    it builds the animation and stores it in the `CCAnimationCache` under the `AnimName`
    string specified. Once it is loaded, you can simply request the animation by name
    from the cache.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到我们的两个辅助方法。第一个方法需要传递很多参数来构建动画。我们传递给它我们想要存储动画的名称，文件名的根，文件名的扩展名，动画的帧数，以及帧之间的时间延迟。这假设任何加载的动画都将有一个递增的数字在它们的文件名中。然后它通过加载每一帧并将其添加到帧数组中的过程。最后，它构建动画并将其存储在`CCAnimationCache`中，存储在指定的`AnimName`字符串下。一旦加载，你只需简单地从缓存中按名称请求动画即可。
- en: The code needed to load an animation from the cache is a fairly long line of
    code, so we have also built a helper method to assist with retrieving the frames,
    `getAnim`. It returns a `CCAnimate` object to the caller. If we were not using
    this helper method, we would have to repeat the same line of code found inside
    that method every time we wanted an animation. Combined, these two methods save
    us from writing a lot of repetitive code. Now let's get back to our hero.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中加载动画所需的代码是一行相当长的代码，因此我们还构建了一个辅助方法来帮助检索帧，`getAnim`。它将一个`CCAnimate`对象返回给调用者。如果我们不使用这个辅助方法，每次我们需要动画时，我们都必须重复该方法内部找到的相同代码行。这两个方法结合起来，使我们免于编写大量重复的代码。现在让我们回到我们的英雄身上。
- en: '**Filename**: `ERHero.m`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERHero.m`'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method is all we need to load the hero's animations. We call this method
    from the playfield after we have created the hero, because we need to reference
    the playfield in order to call the helper method (which we assign to the variable
    `pf`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是我们加载英雄动画所需的所有内容。我们在创建英雄后从游戏场景中调用这个方法，因为我们需要引用游戏场景来调用辅助方法（我们将其分配给变量`pf`）。
- en: '**Filename**: `ERHero.m`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERHero.m`'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we see the fruits of our animation coding labor. When the state changes
    to `kHeroRunning`, this method is called. We use our helper method to get the
    animation, and set it up to repeat forever. This will keep him running until the
    state changes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了我们动画编码劳动的成果。当状态变为`kHeroRunning`时，这个方法会被调用。我们使用辅助方法来获取动画，并将其设置为无限重复。这将使他一直跑动，直到状态改变。
- en: '**Filename**: `ERHero.m`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERHero.m`'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The landing animation is similar, except we only play it once.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 着陆动画与此类似，只是我们只播放一次。
- en: '**Filename**: `ERHero.m`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERHero.m`'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The jumping animation is the most complex of the three. We play the animation
    once, and then state change the `kHeroInAir`, and play a jumping sound. The state
    `kHeroInAir` is used for the time the hero is airborne, but no special animation
    is playing. The sprite will remain as the last frame of the previous animation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃动画是三者中最复杂的。我们播放一次动画，然后状态改变`kHeroInAir`，并播放跳跃声音。状态`kHeroInAir`用于英雄在空中但没有任何特殊动画播放的时间。精灵将保持为上一动画的最后帧。
- en: That covers everything in the hero class except for methods related to shooting
    and getting hit. We will come back to those when we discuss bullets and collisions
    later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了英雄类中除与射击和被击中相关的方法之外的所有内容。当我们讨论子弹和碰撞时，我们将回到这些方法。
- en: Updating the hero
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新英雄
- en: As we saw earlier with the tile updates, we have also broken out the updates
    for the hero into a separate method in the playfield layer. Let's take a look
    at that method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在瓦片更新中看到的，我们还将英雄的更新操作拆分成了单独的方法，放置在游戏场景层中。让我们来看看这个方法。
- en: '**Filename**: `ERHero.m`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERHero.m`'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this method we parse through all the different states that we may need to
    trigger or react to. If the hero is jumping, we decrease the `jumpTimer` variable
    by the current delta value. The `jumpTimer` variable controls how long the hero
    can be in the air in a single jump. When the timer reaches zero, the hero's state
    changes to `kHeroIsFalling`. If the timer is still greater than zero, we increase
    the hero's `y` position by 3 points. (As you may recall, the hero is always at
    the same `x` position, so we only have to concern ourselves with the y axis).
    If the hero is falling, then we apply our gravity by decreasing his `y` position
    by 3 points.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们解析所有可能需要触发或响应的不同状态。如果英雄在跳跃，我们将`jumpTimer`变量减去当前的delta值。`jumpTimer`变量控制英雄在单次跳跃中可以在空中停留多长时间。当计时器达到零时，英雄的状态将变为`kHeroIsFalling`。如果计时器仍然大于零，我们将英雄的`y`位置增加3点。（如您所回忆的，英雄总是在相同的`x`位置，所以我们只需要关注y轴）。如果英雄在下落，那么我们通过减少他的`y`位置来应用重力。
- en: We then begin to make use of our sensors. We check to see if the hero's `footSensor`
    is touching any tile's `topSensor`. If it is, we push the hero up by 1 point,
    and change his state to `kHeroRunning`. We also check each tile to see if there
    is any contact between the hero's `fallSensor` and the tile's `topSensor`. If
    there is contact with any tile's sensor, then the `isFalling` local Boolean variable
    is set to `NO`. If there is no contact with any tile sensors, then the `isFalling`
    variable will still have the original `YES` we assigned to it, so we know the
    hero should be falling. We then check to see if the hero is currently running
    and if the `isFalling` variable is `YES`, then we change his state to `kHeroFalling`.
    After all of that, we actually set the new position to the hero. The last check
    is to see if the hero has fallen off the screen. If he has, we call the `gameOver`
    method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后开始使用我们的传感器。我们检查英雄的`footSensor`是否接触到了任何瓦片的`topSensor`。如果是，我们将英雄向上推1点，并将他的状态改为`kHeroRunning`。我们还会检查每个瓦片，看英雄的`fallSensor`是否与瓦片的`topSensor`有接触。如果有与任何瓦片传感器的接触，那么本地的布尔变量`isFalling`将被设置为`NO`。如果没有与任何瓦片传感器的接触，那么`isFalling`变量将仍然保持我们最初赋予它的`YES`，因此我们知道英雄应该是在下落。然后我们检查英雄是否正在奔跑，以及`isFalling`变量是否为`YES`，如果是，我们将他的状态改为`kHeroFalling`。完成所有这些后，我们实际上将新的位置设置给英雄。最后的检查是看英雄是否已经掉出屏幕。如果他已经掉出，我们将调用`gameOver`方法。
- en: Touch controls
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸控制
- en: Now that we have a hero to control, we need to look at the control methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以控制的角色，我们需要看看控制方法。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After checking whether touches should be prevented or whether game over conditions
    have been met, we compare the locations of the touch to the left or right half
    of the screen. If the touch is on the left and the hero is currently running,
    we change state to `kHeroJumping`. We set the `jumpTimer` variable to the value
    of the `maxJumpTimer` variable (defined in the `init` method as 0.85), and we
    also set the `allowDoubleJump` variable to `YES`. This state change will trigger
    the correct movement behavior (moving up) in the `updateHero` method we just saw.
    We set the `allowDoubleJump` variable to give the player a little extra help.
    As you can see, the `allowDoubleJump` variable is only evaluated if the hero is
    not currently in the `kHeroRunning` state. Most of the code is the same as the
    first clause of the `if` statement, except we reset the `allowDoubleJump` to `NO`.
    Combined, this will allow the player to double-jump in mid-air, but it will prevent
    air-jumping a third time. (If you allow unlimited jumps from mid-air, the hero
    can actually fly forever!)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查是否应该阻止触摸或是否满足游戏结束条件之后，我们将触摸的位置与屏幕的左侧或右侧进行比较。如果触摸在左侧且英雄当前正在奔跑，我们改变状态为 `kHeroJumping`。我们将
    `jumpTimer` 变量设置为 `maxJumpTimer` 变量的值（在 `init` 方法中定义为 0.85），并且我们还设置了 `allowDoubleJump`
    变量为 `YES`。这种状态改变将在我们刚才看到的 `updateHero` 方法中触发正确的移动行为（向上移动）。我们设置 `allowDoubleJump`
    变量是为了给玩家提供一些额外的帮助。正如你所见，`allowDoubleJump` 变量只有在英雄当前不在 `kHeroRunning` 状态时才会被评估。大部分代码与
    `if` 语句的第一个子句相同，只是我们将 `allowDoubleJump` 重置为 `NO`。结合这些，玩家可以在空中进行双跳，但会防止第三次空中跳跃。（如果你允许从空中无限跳跃，英雄实际上可以永远飞行！）
- en: The final `else` clause will catch any touches on the right-hand side of the
    screen, and send the message to the hero to shoot.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `else` 子句将捕获屏幕右侧的任何触摸，并将消息发送给英雄进行射击。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We wrap up the touch handler by looking at the `ccTouchEnded` method. Here we
    must first check to make sure we are not in a game over condition. Without this
    check, if the hero died while a touch was still occurring, the game would crash
    as soon as the finger was lifted (since the hero sprite would be dead and gone).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看 `ccTouchEnded` 方法来完成触摸处理。在这里，我们必须首先检查我们是否不在游戏结束的状态。如果没有这个检查，如果英雄在触摸发生时死亡，游戏会在手指抬起时立即崩溃（因为英雄精灵已经死亡并消失）。
- en: Most of this is concerned with jumping, as you could probably assume. If the
    touch was on the left-hand side (jumping side), then we change the state to `kHeroFalling`,
    so gravity can take over.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容都与跳跃有关，正如你可能想象的那样。如果触摸在左侧（跳跃侧），那么我们改变状态为 `kHeroFalling`，这样重力就可以接管了。
- en: Shooting bullets
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击子弹
- en: Now we turn our attention to the bullets and allowing our hero to shoot. Let's
    look at the simple `ERBullet` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向子弹和允许我们的英雄进行射击。让我们看看简单的 `ERBullet` 类。
- en: '**Filename**: `ERBullet.h`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERBullet.h`'
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `ERBullet` class is nothing more than a subclass of the `CCSprite` class
    with a couple of extra Boolean variables to track. The `isShootingRight` Boolean
    variable helps us keep track of direction of travel for the bullet. Since we are
    only designing the game to allow flat trajectories for the bullets, we really
    just need to know if it is going left or right. We also use the `isHeroBullet`
    variable so we can keep track of whose bullet it is, for collision detection purposes.
    We will not allow "friendly fire", so enemies won't kill other enemies in this
    game. Now we can look at what the hero does when instructed to shoot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ERBullet` 类不过是一个 `CCSprite` 类的子类，它包含一些额外的布尔变量用于跟踪。`isShootingRight` 布尔变量帮助我们跟踪子弹的移动方向。由于我们只为子弹设计平直的轨迹，我们实际上只需要知道它是向左还是向右移动。我们还使用
    `isHeroBullet` 变量来跟踪这是谁的子弹，以便进行碰撞检测。我们不允许“友军火力”，所以敌人不会在这个游戏中杀死其他敌人。现在我们可以看看当英雄被指示射击时会发生什么。
- en: '**Filename**: `ERHero.m`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERHero.m`'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We create a new bullet at the hero's position, give it a nice blue color, and
    set our two Boolean variables to `YES`. The hero is only travelling to the right,
    so that's the only direction his bullets will travel. We then call out to the
    playfield to the `addBullet` method. We wrap it up by playing a nice shooting
    sound. Let's turn to that `addBullet` method next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在英雄的位置创建一颗新的子弹，给它一个漂亮的蓝色，并将我们的两个布尔变量设置为 `YES`。英雄只向右移动，因此子弹也只会向右移动。然后我们调用游戏场的
    `addBullet` 方法。我们通过播放一个射击声音来结束这个过程。接下来让我们看看那个 `addBullet` 方法。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Not much here, either. We add the bullet to the batch node, and we add the bullet
    to the `bulletArray` array. So why did we do this here, and not in the hero's
    `shoot` method? For one, we will be using this same method when adding enemy bullets.
    The other reason is that we don't want to have the `bulletArray` array accessible
    outside of the playfield layer itself, so it is much easier to use this method
    to insert the bullet into that array.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也没有太多内容。我们将子弹添加到批处理节点中，并将子弹添加到`bulletArray`数组中。那么为什么我们在这里做这件事，而不是在英雄的`shoot`方法中做？一方面，我们将在添加敌人子弹时使用这个相同的方法。另一个原因是，我们不希望`bulletArray`数组在游戏场层外部可访问，因此使用这个方法将子弹插入数组要容易得多。
- en: As you might imagine, there is also a separate update method for the bullets.
    Let's go there now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，也有一个单独的子弹更新方法。我们现在就来看看。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method style should be familiar by now. We iterate through all the bullets
    in the `bulletArray` array, and move each bullet either left or right, depending
    on the value of `isShootingRight` variable. If the bullet goes off-screen, it
    is added to the `bulletsToDelete` array, which is then used after the loop to
    remove the bullets from the `bulletArray`. Of course, at this point the bullets
    won't interact with anything, but we need to have some enemies to shoot at before
    we deal with collisions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法风格现在应该很熟悉了。我们遍历`bulletArray`数组中的所有子弹，根据`isShootingRight`变量的值将每个子弹向左或向右移动。如果子弹飞出屏幕，它将被添加到`bulletsToDelete`数组中，然后在循环之后使用该数组从`bulletArray`中删除子弹。当然，在这个阶段，子弹不会与任何东西交互，但在处理碰撞之前，我们需要有一些敌人来射击。
- en: Enemies everywhere
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到处都是敌人
- en: We want to have enemies in our game. A lot of enemies. We need to have flying
    enemies as well as walking enemies. With the wonderful Planet-X graphics we are
    using, the designer created six types of creatures in six colors. We are using
    all but one type of creature (the swimming creature didn't fit this game), so
    we have 12 flying enemy types and 18 walking enemy types. In our game there is
    no difference in the behavior of the creatures, but it does give more of a visual
    flair to the game to have this much variety. Because we will be randomly creating
    enemies throughout the game, we don't want to be reloading the animations into
    the cache every time a new creature is spawned, so we build all of the enemy animations
    when the playfield is loaded.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在游戏中拥有敌人。很多敌人。我们需要有飞行敌人以及行走的敌人。使用我们使用的奇妙Planet-X图形，设计师创建了六种颜色中的六种生物。我们使用了除一种生物类型（游泳生物不适合这个游戏）之外的所有类型，因此我们有12种飞行敌人类型和18种行走敌人类型。在我们的游戏中，生物的行为没有区别，但这确实给游戏增添了更多的视觉魅力。因为我们将在整个游戏中随机创建敌人，所以我们不想每次生成新的生物时都重新加载动画到缓存中，因此我们在加载游戏场时构建所有敌人动画。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`'
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because we have kept our naming convention consistent (that is, `walk1_1.png`,
    `walk1_2.png`, and so on) we can easily construct our names in a loop. We first
    load the walking enemies in a loop, and we assemble two strings to help us. The
    `root` parameter is the first part of the file name before the incremental frame
    numbers. The `anim` variable will add the word "move" to the end of the `root`
    name, to load the animation under that name. So the fifth walker's animation will
    be named `walk5_move`. We then call the same helper method we used for the hero
    to load the animation frames for all of the walkers. The second half of the method
    repeats the same process, except it loads the flying creatures' animations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们保持了命名约定的一致性（即`walk1_1.png`、`walk1_2.png`等等），我们可以轻松地在循环中构建我们的名称。我们首先在循环中加载行走敌人，并使用两个字符串来帮助我们。`root`参数是文件名中增量帧号之前的第一部分。`anim`变量将在`root`名称的末尾添加单词"move"，以加载该名称下的动画。因此，第五个行走的动画将被命名为`walk5_move`。然后我们调用与英雄相同的辅助方法来加载所有行走的动画帧。方法的后半部分重复同样的过程，只是它加载的是飞行生物的动画。
- en: Now we can start to look at the `EREnemy` class, which will look very familiar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始查看`EREnemy`类了，它看起来非常熟悉。
- en: '**Filename**: `EREnemy.m`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`EREnemy.m`'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We define a `fallSensor` variable for the enemy, using the same structure as
    we did for the hero. We also override the `setPosition` method for this class
    to refresh the `fallSensor` every time it is repositioned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为敌人定义了一个`fallSensor`变量，使用与英雄相同的结构。我们还重写了这个类的`setPosition`方法，以便每次重新定位时都刷新`fallSensor`。
- en: '**Filename**: `EREnemy.m`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`EREnemy.m`'
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The enemy's `shoot` method is very similar to the hero's `shoot` method. Obviously,
    the `isHeroBullet` Boolean variable is set to `NO` here. Also, the `isShootingRight`
    variable sets itself to one of the new variables that is contained in the `EREnemy`
    class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的`shoot`方法与英雄的`shoot`方法非常相似。显然，这里的`isHeroBullet`布尔变量被设置为`NO`。此外，`isShootingRight`变量将自己设置为`EREnemy`类中包含的新变量之一。
- en: '**Filename**: `EREnemy.h`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `EREnemy.h`'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These variables help us keep better track of the enemies. The `isFlying` and
    `isMovingRight` Boolean variables are self-explanatory. The `shootTimer` for the
    enemies is kept in this class, where the hero's is kept as part of the playfield
    layer itself. Now that we have seen all of the `EREnemy` class (except for getting
    hit), we can look at how we create the enemies in the game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量帮助我们更好地跟踪敌人。`isFlying`和`isMovingRight`布尔变量是自解释的。敌人的`shootTimer`被保留在这个类中，而英雄的则作为游戏场层本身的一部分保留。现在我们已经看到了`EREnemy`类的所有内容（除了被击中），我们可以看看我们在游戏中是如何创建敌人的。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we did when we created the ground tiles, we randomize the selection of the
    `enemyNo`, and use that to build the correct initial frame name for the new `EREnemy`
    object. When we set the position, we add the requested position (`pos`) to half
    of the content size of the enemy itself. We do this because the enemy has a default
    center `anchorPoint`, and the position passed is the top of the tile we want the
    enemy to be standing on. So by adding half of the height, we position the enemy
    perfectly standing on the tile below. (We don't want to change the `anchorPoint`,
    because then we would have to do this type of adjustment for all bullets fired
    by the enemies.) All enemies will start by facing to the left, and since these
    are walking enemies, they will have `isFlying` set to `NO`. After adding the enemy
    to the batch node and to the `enemyArray` array, we get the animation we loaded
    for this particular enemy, and set it to repeat forever. That's all we need to
    create the walking enemies.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在创建地面瓦片时所做的，我们随机选择`enemyNo`，并使用它来构建新`EREnemy`对象的正确初始帧名称。当我们设置位置时，我们将请求的位置（`pos`）加到敌人本身的内容大小的一半。我们这样做是因为敌人有一个默认的中心`anchorPoint`，而传递的位置是我们希望敌人站立在上的瓦片的顶部。因此，通过添加一半的高度，我们使敌人完美地站在下面的瓦片上。（我们不希望改变`anchorPoint`，因为那样我们就必须为所有由敌人发射的子弹进行此类调整。）所有敌人都会开始面向左侧，由于这些是行走的敌人，它们将`isFlying`设置为`NO`。在将敌人添加到批节点和`enemyArray`数组后，我们获取为这个特定敌人加载的动画，并将其设置为无限重复。这就是我们创建行走的敌人所需的所有内容。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we look at how we add flying enemies, you will notice this is the same basic
    code structure as the walking enemy. The only real differences are that the names
    of the sprite frames begin with `fly` instead of `walk`, and we don't have to
    change the starting position for the flying enemies, because they will not interact
    with the ground at all. Now we can move to the enemy `update` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看如何添加飞行敌人时，你会注意到这与行走的敌人有相同的基本代码结构。唯一的真正区别是精灵帧的名称以`fly`开头而不是`walk`，并且我们不需要更改飞行敌人的起始位置，因为它们根本不会与地面互动。现在我们可以转向敌人的`update`方法。
- en: '**Filename**: `ERPlayfieldLayer.m`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `ERPlayfieldLayer.m`'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin the `updateEnemies` method by making sure the playfield is scrolling.
    If not we exit, because we don't want the enemies to move. Then we iterate through
    all the enemies in the `enemyArray` and move them left or right, according to
    how their `isMovingRight` Boolean variable is set. The middle section of the update
    is concerned only with walking enemies. For each walking enemy, we iterate through
    all tiles to see if their `fallSensor` is touching any tiles. This is exactly
    the same as what we did for the hero with the `isFalling` Boolean variable the
    `updateHero` method. If there is no ground, instead of making in the enemy fall,
    we flip the graphic to face the opposite direction, and change the `isMovingRight`
    Boolean to the opposite value. If an enemy reaches the edge of a ledge, this will
    make it turn around.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过确保游戏场正在滚动来开始`updateEnemies`方法。如果没有，我们就退出，因为我们不希望敌人移动。然后我们遍历`enemyArray`中的所有敌人，根据它们的`isMovingRight`布尔变量是设置为向左还是向右移动。更新过程的中段仅关注行走的敌人。对于每个行走的敌人，我们遍历所有瓦片以查看它们的`fallSensor`是否接触到了任何瓦片。这与我们在`updateHero`方法中对英雄使用`isFalling`布尔变量所做的是完全相同的。如果没有地面，我们不会让敌人掉落，而是翻转图形以面向相反方向，并将`isMovingRight`布尔值更改为相反值。如果敌人到达了悬崖的边缘，这将使它转身。
- en: We then have a simple `shootTimer` loop for the enemies. Each enemy will shoot
    every 2 seconds. Because we have non-intelligent enemies (they move back and forth,
    but never pursue the player), it makes sense to have this form of blind shooting
    for the enemies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为敌人有一个简单的`shootTimer`循环。每个敌人每2秒射击一次。因为我们有非智能敌人（它们来回移动，但从不追击玩家），所以对于敌人来说，这种盲射的形式是有意义的。
- en: Finally, we check to see if any enemies are off-screen to the left, and remove
    them in the usual fashion. Now our enemies can move and everybody can shoot, we
    need some collision detection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查是否有任何敌人出现在屏幕左侧之外，并按常规方式移除它们。现在我们的敌人可以移动，每个人都可以射击，我们需要一些碰撞检测。
- en: Collision handling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: We need to be able to check for three different types of collisions. We need
    to be able to have bullets hit the enemies. We need the hero to get hit. We also
    need to react when the hero runs into an enemy. Let's look at the method for this,
    which is in two parts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够检查三种不同类型的碰撞。我们需要能够让子弹击中敌人。我们需要英雄被击中。我们还需要在英雄遇到敌人时做出反应。让我们看看这个方法，它分为两部分。
- en: '**Filename**: `ERPlayfieldLayer.m` (`checkCollisions`, part 1)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`（`checkCollisions`，第一部分）'
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We start by iterating through all bullets in the array. If the bullet is an
    enemy bullet (`isHeroBullet == NO`), then we check the `boundingBox` of the bullet
    with the `boundingBox` of the hero. If they intersect, we add the bullet to the
    `bulletsToDelete` array, remove the bullet, and set the `isHeroHit` Boolean to
    `YES`. We use a Boolean variable for the hero hit here because we will be doing
    another hero collision check within this method. Since the hero's death causes
    the hero to be removed, the game would crash if the hero was shot and ran into
    an enemy at the same time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历数组中的所有子弹。如果子弹是敌人的子弹（`isHeroBullet == NO`），那么我们检查子弹的`boundingBox`与英雄的`boundingBox`是否相交。如果它们相交，我们将子弹添加到`bulletsToDelete`数组中，移除子弹，并将`isHeroHit`布尔值设置为`YES`。在这里我们使用布尔变量来表示英雄被击中，因为我们将在该方法内进行另一个英雄碰撞检查。由于英雄的死亡会导致英雄被移除，如果英雄被射击并在同一时间遇到敌人，游戏将会崩溃。
- en: If the bullet is a "hero bullet", we iterate through all enemies to determine
    if the bullet is intersecting with an enemy `boundingBox`. If it is, we add the
    bullet to the `bulletsToDelete` array, remove the bullet, add the enemy to the
    `enemiesToDelete` array, and send the message to the enemy that it got shot.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子弹是“英雄子弹”，我们遍历所有敌人以确定子弹是否与敌人的`boundingBox`相交。如果是，我们将子弹添加到`bulletsToDelete`数组中，移除子弹，将敌人添加到`enemiesToDelete`数组中，并发送消息给敌人，告知它被击中。
- en: '**Filename**: `ERPlayfieldLayer.m` (`checkCollisions`, part 2)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERPlayfieldLayer.m`（`checkCollisions`，第二部分）'
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the second half of this method, we start by iterating through all the enemies.
    For each enemy, we check to see if the enemy's `boundingBox` intersects with the
    hero's `boundingBox`. If they intersect, we register a collision for both hero
    and enemy in the same manner as we did with the bullets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法的第二部分，我们首先遍历所有敌人。对于每个敌人，我们检查敌人的`boundingBox`是否与英雄的`boundingBox`相交。如果它们相交，我们以与子弹相同的方式为英雄和敌人注册碰撞。
- en: 'After we have resolved the collisions, we check the `isHeroHit` variable to
    see if he got shot. If he got shot, we send the `gotShot` message to the hero.
    As the final bit of cleanup, we handle the `bulletsToDelete` and `enemiesToDelete`
    arrays the same as usual: we use them to remove the deleted objects from the `bulletArray`
    and `EnemyArray`, and then use the `removeAllObjects` method to empty the deletion
    arrays.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决碰撞后，我们检查`isHeroHit`变量以查看英雄是否被击中。如果他被击中，我们向英雄发送`gotShot`消息。作为最后的清理工作，我们像往常一样处理`bulletsToDelete`和`enemiesToDelete`数组：我们使用它们从`bulletArray`和`EnemyArray`中移除被删除的对象，然后使用`removeAllObjects`方法清空删除数组。
- en: Getting shot with particles
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被粒子击中
- en: The last unresolved bits of code that we need to look at are the `gotShot` routines
    for both the enemy and the hero. The enemies die after a single hit, so their
    method is a simpler place to start.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的最后未解决的代码片段是敌人和英雄的`gotShot`例程。敌人被击中一次后就会死亡，所以他们的方法是一个更简单的起点。
- en: '**Filename**: `EREnemy.m`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`EREnemy.m`'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When an enemy gets shot, the first thing we do is to create a particle system.
    Particles can be coded in one of two ways. The first would be to manually set
    all of the parameters regarding the particle system by hand, and test and retest
    until you achieve the desired effect. The alternate approach (one that is more
    widely used) is to use a commercially available tool, Particle Designer, available
    at [http://particledesigner.71squared.com](http://particledesigner.71squared.com).
    Particle Designer allows you to see the results of changing every parameter in
    real time, so you can experiment until you achieve the desired result. Once you
    have what you want, you can save it as a `.plist` file, and use it as we have
    done here. We created a `CCParticleSystemQuad` object using the plist file, set
    the position, and added it to the layer. That's all we needed to do for this one-shot
    particle. (If you want to know how much manual coding we are avoiding by using
    Particle Designer, open the `enemydie.plist` file in Xcode and see all the values
    stored in it.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人被击中时，我们首先创建一个粒子系统。粒子可以通过两种方式编码。第一种是手动设置粒子系统的所有参数，并通过测试和重试直到达到期望的效果。另一种方法（更广泛使用的方法）是使用一个商业工具，粒子设计师，可在[http://particledesigner.71squared.com](http://particledesigner.71squared.com)找到。粒子设计师允许您实时查看更改每个参数的结果，因此您可以实验直到达到期望的结果。一旦您得到想要的效果，您可以将其保存为`.plist`文件，并像我们这样使用它。我们使用plist文件创建了一个`CCParticleSystemQuad`对象，设置了位置，并将其添加到层中。这就是我们为这个一次性粒子需要做的所有事情。（如果您想知道使用粒子设计师避免了多少手动编码，请打开Xcode中的`enemydie.plist`文件，并查看其中存储的所有值。）
- en: 'After we trigger the particle, we simply remove the enemy from its parent and
    play a nice death sound. Let''s see the aftermath when an enemy is shot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发粒子后，我们只需从其父节点中移除敌人，并播放一个美妙的死亡音效。让我们看看敌人被击中的后果：
- en: '![Getting shot with particles](img/9007_9_03.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![被粒子击中](img/9007_9_03.jpg)'
- en: Death of hero
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄死亡
- en: The hero getting hit adds a little complexity, because the hero can take five
    hits before he dies. If he doesn't die, we want him to flash red briefly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 英雄被击中增加了复杂性，因为英雄在被击中五次之前才会死亡。如果他没死，我们希望他短暂地闪烁红色。
- en: '**Filename**: `ERHero.m`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`ERHero.m`'
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We first reduce the hero's health by one. Then we check if the hero should be
    dead or not. If his health is zero, we spawn a new particle system centered on
    the hero, remove the hero, play a death sound, and then call the `gameOver` method.
    It should be noted that the `ExplodingRing.plist` file we use here is actually
    a particle that ships with Cocos2d, and is used as part of the Particle test.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先减少英雄的生命值一个单位。然后检查英雄是否应该死亡。如果他的生命值为零，我们在英雄中心生成一个新的粒子系统，移除英雄，播放死亡音效，然后调用`gameOver`方法。需要注意的是，我们这里使用的`ExplodingRing.plist`文件实际上是Cocos2d附带的一个粒子，用作粒子测试的一部分。
- en: If the hero is not dead, then we check the value of the hero's `isFlashing`
    variable. If he isn't currently flashing, we build a small action sequence that
    will tint the hero red for a duration of 0.05, then tint it back to normal (all
    max values return the sprite color to its original color). Then we play a sound
    effect, and call it done.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果英雄没有死亡，我们就检查英雄的`isFlashing`变量的值。如果他没有正在闪烁，我们就构建一个小的动作序列，将英雄染成红色，持续时间为0.05秒，然后恢复到正常颜色（所有最大值将精灵颜色恢复到原始颜色）。然后我们播放一个音效，并完成操作。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have put a lot of interesting pieces together in this game. We have dynamic
    terrain, randomized enemies, shooting, jumping, endless backgrounds, and (hopefully)
    some fun while building and playing it. You will notice that there are a few less
    interesting bits we have not covered in depth. Please, consult the code bundle
    to explore the other pieces of the game, like the "Dramatic Entrance" when the
    hero starts the game by being dropped off by a space ship. There is also some
    helpful debugging code we used for the sensors (commented out) in the bottom of
    the `ERPlayfieldLayer.m` file. By enabling that code, you can see the sensor boxes
    drawn while the game is playing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个游戏中组合了许多有趣的元素。我们有动态地形、随机敌人、射击、跳跃、无限背景，并且在构建和游玩过程中（希望）有一些乐趣。您会注意到，还有一些不太有趣的细节我们没有深入探讨。请查阅代码包以探索游戏的其他部分，例如当英雄被飞船放下开始游戏时的“戏剧性入场”。在`ERPlayfieldLayer.m`文件的底部还有一些用于传感器的有用调试代码（已注释）。通过启用该代码，您可以在游戏播放时看到绘制的传感器框。
- en: It is our sincere hope that these projects have instructed, entertained, and
    perhaps even inspired you in your own pursuits. Each of the games, designed with
    a "bare bones" approach, gives plenty of room for exploration and expansion. If
    you create something wonderful as a result of having been inspired by these projects,
    please let us know! We look forward to hearing from you.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们衷心希望这些项目能在您的追求中起到指导、娱乐，甚至可能激发灵感的作用。每一款游戏都采用了“骨架式”设计，为探索和扩展提供了充足的空间。如果您因为这些项目而受到启发，创作出了令人惊叹的作品，请告诉我们！我们期待着您的反馈。
