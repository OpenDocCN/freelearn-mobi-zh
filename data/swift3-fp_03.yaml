- en: Chapter 3. Types and Type casting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 类型与类型转换
- en: This chapter starts with explaining types, touching on the concept of type in
    the category theory very briefly. Then, it explains value and reference types
    and compares them in detail. Finally, it talks about equality, identity, and type
    casting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先解释类型，非常简短地触及范畴论中的类型概念。然后，它解释值类型和引用类型，并详细比较它们。最后，它讨论了相等性、身份和类型转换。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过代码示例涵盖以下主题：
- en: Types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Value versus reference types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: Value and reference type constants
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型和引用类型常量
- en: Mixing value and reference types
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合值类型和引用类型
- en: Copying
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Value type characteristics
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型特性
- en: Equality, identity, and comparing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性、身份和比较
- en: Type checking and casting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查和转换
- en: 'You may have heard that functional programming uses concepts of the category
    theory. This link is the reason why some people find functional programming closer
    to mathematics. In an upcoming chapter, we will talk briefly about the category
    theory so we are not going to dive into those concepts now. At this point, it
    is good to know that theoretically category refers to a collection that contains
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过函数式编程使用范畴论的概念。这个链接是为什么有些人觉得函数式编程更接近数学的原因。在下一章中，我们将简要介绍范畴论，所以我们现在不会深入探讨这些概念。在此阶段，重要的是要知道，从理论上讲，范畴指的是包含以下内容的集合：
- en: A collection of objects (types in Swift)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组对象（Swift中的类型）
- en: A collection of morphisms, each of which ties two objects together (functions
    in Swift)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组将两个对象联系在一起的形态（Swift中的函数）
- en: A notion of composition of the morphisms (function composition in Swift)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴的形态组合（Swift中的函数组合）
- en: We have already discussed functions and function composition and now we are
    going to explore types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了函数和函数组合，现在我们将探索类型。
- en: It is possible to categorize types in two different ways. The first is the concept
    of named types and compound types in Swift. The second is the categorization of
    types based on value versus reference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方式来对类型进行分类。第一种是Swift中命名的类型和复合类型的概念。第二种是基于值与引用的类型分类。
- en: Any type that we can give a name to while we define it is a named type. For
    instance, if we create a class named `OurClass`, any instance of `OurClass` will
    be of the `OurClass` type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义时可以为其命名的任何类型都是命名类型。例如，如果我们创建一个名为`OurClass`的类，`OurClass`的任何实例都将具有`OurClass`类型。
- en: Function types and tuple types are compound types. A compound type may contain
    named types and other compound types. For instance, `(String, (Double, Double))`
    is a compound type and in fact is a tuple of `String` and another tuple of the
    `(Double, Double)` type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型和元组类型是复合类型。复合类型可以包含命名类型和其他复合类型。例如，`(String, (Double, Double))`是一个复合类型，实际上是一个`String`和另一个`(Double,
    Double)`类型元组的元组。
- en: We can use named types and compound types in type annotation, identification,
    and aliasing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类型注释、标识和别名中使用命名类型和复合类型。
- en: In previous chapters, we have seen that we can use Swift inference that infers
    the types unless we want to specify the type explicitly. We annotate the type
    in case we need to specify the type explicitly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到我们可以使用Swift的推断来推断类型，除非我们想要显式地指定类型。如果我们需要显式地指定类型，我们会注释类型。
- en: Also, we did not talk a lot about reference versus value types and type casting.
    In the following sections of this chapter, we will explore these concepts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们并没有过多地讨论引用类型与值类型以及类型转换。在本章的后续部分，我们将探讨这些概念。
- en: Value versus reference types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: 'In Swift, there are two kinds of types: value and reference.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，有两种类型的类型：值类型和引用类型。
- en: 'Value type instances keep a copy of their data. Each type has its own data
    and is not referenced by another variable. `Structures`, `enums`, and `tuples`
    are value types; therefore, they do not share data between their instances. Assignments
    copy the data of an instance to the other and there is no reference counting involved.
    The following example presents a `struct` with copying:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例保留其数据的一个副本。每种类型都有自己的数据，并且不被其他变量引用。`Structures`、`enums`和`tuples`是值类型；因此，它们不会在其实例之间共享数据。赋值会复制实例的数据到另一个实例，并且没有引用计数。以下示例展示了具有复制的`struct`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As seen from the preceding example, changing `valueA.data` does not change `valueB.data`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，改变`valueA.data`不会改变`valueB.data`。
- en: In Swift, arrays, dictionaries, strings, and sets are all value types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，数组、字典、字符串和集合都是值类型。
- en: 'On the other hand, reference type instances share the same copy of the data.
    Classes and closures are reference types so assignment only adds a reference but
    does not copy the data. In fact, initialization of a reference type creates a
    shared instance that will be used by different instances of a reference type such
    as class or closure. Two variables of the same class type will refer to a single
    instance of the data, so if we modify the data in one of the variables, it will
    also affect the other variable. The following example presents a class with referencing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，引用类型实例共享相同的数据副本。类和闭包是引用类型，所以赋值只添加一个引用，而不复制数据。实际上，引用类型的初始化创建了一个共享实例，该实例将被引用类型的不同实例（如类或闭包）使用。同一类类型的两个变量将引用数据的一个单一实例，因此如果我们修改其中一个变量的数据，它也会影响另一个变量。以下示例展示了具有引用的类：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen from the preceding example, changing `referenceA.data` also changes
    `referenceB.data` as they refer to the same shared instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，更改 `referenceA.data` 也会更改 `referenceB.data`，因为它们引用了相同的共享实例。
- en: This fundamental difference between value and reference types can have a huge
    impact on our system architecture. In functional programming, it is recommended
    to prefer value types over reference types as it is easier to trace and reason
    about value types. As we always get a unique copy of data and the data is not
    shared among instances, we can reason that no other part of our program is going
    to change the data. This feature of value types makes them especially helpful
    in multithreaded environments where a different thread will be able to change
    our data without informing us. This can create bugs that are very hard to debug
    and fix.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的这种基本差异可能对我们的系统架构产生巨大影响。在函数式编程中，建议优先使用值类型而不是引用类型，因为值类型更容易追踪和推理。由于我们总是得到数据的一个唯一副本，并且数据在实例之间不共享，我们可以推断出程序的其他部分不会更改数据。值类型的这一特性使它们在多线程环境中特别有用，因为在不同的线程中可以更改我们的数据而无需通知我们。这可能会创建非常难以调试和修复的错误。
- en: To be able to use this feature in Swift with classes, we can develop immutable
    classes using only immutable stored properties and avoiding exposing any APIs
    that can alter state. However, Swift does not provide any language mechanism to
    enforce class immutability the way it enforces immutability for `struct` and `enum`.
    Any API user can subclass our provided class and make it mutable unless we define
    them as **final**. This is not the case with `struct`, `enum`, and `tuples` as
    basically we cannot subclass them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在 Swift 中使用类实现此功能，我们可以仅使用不可变存储属性开发不可变类，并避免公开任何可以更改状态的 API。然而，Swift 并没有提供任何语言机制来强制执行类不可变性，就像它强制执行
    `struct` 和 `enum` 的不可变性一样。任何 API 用户都可以子类化我们提供的类并将其变为可变的，除非我们将其定义为 **final**。这与
    `struct`、`enum` 和元组不同，因为我们基本上不能对它们进行子类化。
- en: Value and reference type constants
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型和引用类型常量
- en: Constants behave differently if they are value or reference types. We will be
    able to change the variables in a constant class but we cannot change them for
    structs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的行为取决于它们是值类型还是引用类型。我们可以在常量类中更改变量，但不能在结构体中更改。
- en: 'Let''s examine the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下示例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we have a class named `User` and two constants that point to
    the instance of the class. Also, we have a `Student` `struct` that has a variable
    of the `User` type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `User` 的类和两个指向该类实例的常量。此外，我们还有一个具有 `User` 类型变量的 `Student` 结构体。
- en: We create `student` using the `Student` structure. If we try to change the `user`
    variable in `student`, the compiler gives us an error telling that `student` is
    a constant even though we defined `user` as a variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Student` 结构体创建 `student`。如果我们尝试更改 `student` 中的 `user` 变量，编译器会给出错误，指出 `student`
    是一个常量，尽管我们定义 `user` 为一个变量。
- en: 'So we cannot change any variable in `struct` if we instantiate it as a constant.
    In other words, `let student = Student(user: julie)` makes the whole `struct`
    immutable.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，如果我们将 `struct` 实例化为一个常量，我们无法更改其中的任何变量。换句话说，`let student = Student(user:
    julie)` 使得整个 `struct` 都是不可变的。'
- en: Let's try the same operation with classes. In the following code, we change
    the name of `steve`, which is defined as a constant. The compiler does not give
    us an error and accepts this assignment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用类来尝试相同的操作。在下面的代码中，我们更改了名为 `steve` 的常量名称。编译器没有给出错误并接受这个赋值。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though we defined `steve` as a constant, we could change the `name` variable
    as it was a `class`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将 `steve` 定义为常量，但我们仍然可以更改 `name` 变量，因为它是一个 `class`。
- en: From the preceding examples, we have seen that we can change the value of a
    variable on a constant that is an instance of a `class` (reference type), but
    we cannot change the value of a variable on a constant that is an instance of
    a `struct` (value type).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们已经看到我们可以改变一个常量实例的 `class`（引用类型）变量的值，但不能改变一个常量实例的 `struct`（值类型）变量的值。
- en: As `steve` is an instance of a reference type, it refers to the instance of
    `User`. When we change `name`, we are not actually changing what `steve` is, which
    is a reference to `User`. We change the name that we made mutable by defining
    it as a variable. This is not the case for our `student` constant as it is a value
    type. Defining it as a constant makes its variables constant too.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `steve` 是引用类型的实例，它引用了 `User` 的实例。当我们更改 `name` 时，我们实际上并没有改变 `steve` 是什么，`steve`
    是对 `User` 的引用。我们改变的是我们通过将其定义为变量而使其可变的名称。这并不适用于我们的 `student` 常量，因为它是一个值类型。将其定义为常量也使其变量成为常量。
- en: This property of reference types makes them hard to track and since we are defining
    them as constants, it is not going to make them immune to changes. To be able
    to make them immutable, we will need to define their properties as constants.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的这种特性使得它们难以追踪，并且由于我们将它们定义为常量，这并不会使它们免受更改的影响。为了使它们不可变，我们需要将它们的属性定义为常量。
- en: Mixing value and reference types
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合值类型和引用类型
- en: In real-world problems, we may need to mix reference types with value types.
    For instance, we may need to have a reference to `class` in `struct` like our
    previous example or we may need to have a `struct` variable in `class`. How would
    we reason about the assignments and copying in these circumstances?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的问题中，我们可能需要混合引用类型和值类型。例如，我们可能需要在 `struct` 中有对 `class` 的引用，就像我们之前的例子一样，或者我们可能需要在
    `class` 中有 `struct` 变量。在这种情况下，我们如何推理赋值和复制呢？
- en: 'Let''s examine the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we have a `User` class, a `Student` struct that has the user
    variable. We define a constant, `student` with `julie`, which is of the `class`
    type. If we print `student.user.name`, the result will be `julie`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个 `User` 类，一个包含用户变量的 `Student` 结构体。我们定义一个常量 `student`，其值为 `julie`，它是
    `class` 类型。如果我们打印 `student.user.name`，结果将是 `julie`。
- en: Now if we define `anotherStudent` and copy `student` to it by assignment, changing
    the name of Julie will change the name of `anotherStudent` too.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们定义 `anotherStudent` 并通过赋值将其复制到 `student`，更改朱莉的名字也会更改 `anotherStudent`
    的名字。
- en: We would expect `anotherStudent` to have a copy of `student` but `name` has
    been changed. It is changed because the `user` variable is of the `User` type,
    which is `class` and therefore a reference type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计 `anotherStudent` 将有 `student` 的一个副本，但 `name` 已经更改了。这是因为 `user` 变量是 `User`
    类型，它是 `class` 类型，因此是引用类型。
- en: This example presents the complexity of using reference types in value types.
    To avoid these complications, it is recommended to avoid using reference type
    variables inside value types. If we need to use reference types in our value types,
    as we have stated before, we should define them as constants.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在值类型中使用引用类型的复杂性。为了避免这些复杂性，建议避免在值类型内部使用引用类型变量。如果我们需要在我们的值类型中使用引用类型，正如我们之前所述，我们应该将它们定义为常量。
- en: Copying
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: Assignment operations on value types copy values from one value type to another
    value type. There are two types of copying in different programming languages,
    shallow and deep copying.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型上的赋值操作将值从一个值类型复制到另一个值类型。在不同的编程语言中，有两种复制类型，浅度复制和深度复制。
- en: Shallow copying duplicates as little as possible. For instance, a shallow copy
    of a collection is a copy of the collection structure, not its elements. With
    a shallow copy, two collections share the same individual elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 浅度复制尽可能少地复制。例如，集合的浅度复制是集合结构的副本，而不是其元素。在浅度复制中，两个集合共享相同的单个元素。
- en: Deep copying duplicates everything. For instance, a deep copy of a collection
    results in another collection with all of the elements in the original collection
    duplicated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 深度复制会复制一切。例如，一个集合的深度复制将导致另一个集合，其中包含原始集合中所有元素的副本。
- en: 'Swift does the shallow copying and does not provide a mechanism for deep copying.
    Let''s examine an example to understand shallow copying:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 进行浅度复制，并且不提供深度复制的机制。让我们通过以下示例来了解浅度复制：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we created a new `User` named `alain` and added three
    users to a new array named `users`. In the following example, we copy the `users`
    array to a new array named `copyOfUsers`. Then we change the name of one of our
    users in the `users` array as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个名为 `alain` 的新 `User` 对象，并将三个用户添加到了一个名为 `users` 的新数组中。在下面的示例中，我们将
    `users` 数组复制到了一个名为 `copyOfUsers` 的新数组中。然后我们按照以下方式更改 `users` 数组中一个用户的名称：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Printing `users` and `copyOfUsers` will show us that changing `name` of `Alain`
    to `Jean-Marc` in the `users` array has changed the name of `Alain` in `copyOfUsers`
    to `Jean-Marc` too. The `users` and `copyOfUsers` are arrays, and we would expect
    assignment expression to copy the values from `users` to `copyOfUsers` as arrays
    are value types but, as we have seen from the preceding example, changing the
    name of `user` in one array changed the username in the copied array. There are
    two reasons for this behavior. First of all, `User` is a type of `class`. So it
    is a reference type. Secondly, Swift does the shallow copying.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `users` 和 `copyOfUsers` 将显示，在 `users` 数组中将 `Alain` 的 `name` 更改为 `Jean-Marc`
    也会将 `copyOfUsers` 中的 `Alain` 的名称更改为 `Jean-Marc`。`users` 和 `copyOfUsers` 都是数组，我们预计赋值表达式会像数组是值类型一样从
    `users` 复制值到 `copyOfUsers`，但正如前一个示例所示，在一个数组中更改 `user` 的名称也会更改复制数组中的用户名。这种行为有两个原因。首先，`User`
    是 `class` 类型的一种。因此，它是一个引用类型。其次，Swift 进行浅拷贝。
- en: Shallow copying does not provide a distinct copy of an instance as we have seen
    in this example. Shallow copying duplicates the references to the same elements
    of the instance. So again, this example presents complications with using reference
    types in value types as Swift does not provide deep copying to overcome these
    complications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝并不提供与示例中看到的不同实例的副本，浅拷贝只是复制了实例相同元素的引用。因此，这个示例再次展示了在 Swift 中使用引用类型作为值类型时的复杂性，因为
    Swift 不提供深拷贝来克服这些复杂性。
- en: Copying reference types
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制引用类型
- en: 'Two variables can point to the same object so changing one variable changes
    the other too. Having lots of objects point to the same data can be useful in
    some circumstances, but mostly we will want to modify copies so that modifying
    one object doesn''t have an effect on the others. To make this work, we need to
    do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量可以指向同一个对象，因此更改一个变量也会更改另一个变量。在某些情况下，让许多对象指向相同的数据可能是有用的，但大多数情况下，我们希望修改副本，以便修改一个对象不会影响其他对象。为了实现这一点，我们需要做以下事情：
- en: Our class should be of the `NSObject` type
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的类应该是 `NSObject` 类型
- en: Our class should conform to the `NSCopying` protocol (which is not mandatory
    but makes our intent clear for our API user)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的类应该遵守 `NSCopying` 协议（这不是强制性的，但可以使我们的 API 用户意图更明确）
- en: 'Our class should implement the `copy(with: NSZone)` method'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们的类应该实现 `copy(with: NSZone)` 方法'
- en: To copy the object, we will need to call the `copy()` method on the object
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要复制对象，我们需要在对象上调用 `copy()` 方法
- en: 'Here''s an example of a `Manager` class that conforms fully to the `NSCopying`
    protocol:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个完全符合 `NSCopying` 协议的 `Manager` 类的示例：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `copyWithZone()` function is implemented by creating a new `Manager` object
    using the information of current `Manager`. To test our class, we create two instances
    and copy one instance over the other as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithZone()` 函数通过使用当前 `Manager` 的信息创建一个新的 `Manager` 对象来实现。为了测试我们的类，我们创建了两个实例，并将一个实例复制到另一个实例上，如下所示：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result will be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Value type characteristics
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型特性
- en: We have examined the notion of value types and reference types. We have looked
    into simple scenarios of value type versus reference type usage. We understand
    that using value types makes our code simpler and easier to trace and reason.
    Now let's look into the characteristics of value types in more detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了值类型和引用类型的观念。我们探讨了值类型与引用类型使用的简单场景。我们理解使用值类型可以使我们的代码更简单，更容易追踪和推理。现在让我们更详细地看看值类型的特性。
- en: Behavior
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为
- en: Value types do not behave. A value type stores data and provides methods to
    use its data. A value type can only have a single owner and it does not have deinitializers
    as there are no references involved. Some of the value type methods may cause
    the value type to mutate itself, but control flow is rigidly controlled by the
    single owner of the instance. As the code will only execute when directly invoked
    by a single owner and not from many sources, it is easy to reason about the value
    type code execution flow.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型不具有行为。值类型存储数据并提供使用其数据的方法。值类型只能有一个所有者，并且由于没有引用，它没有析构器。一些值类型的方法可能会使值类型自身发生突变，但控制流严格由实例的单个所有者控制。由于代码仅在直接由单个所有者调用时执行，而不是来自多个来源，因此很容易推理值类型代码的执行流程。
- en: On the other hand, a reference type might subscribe itself as a target of other
    systems. It might receive notifications from other systems. This sort of interactions
    require reference types as they can have multiple owners. It's unnecessarily difficult
    to develop value types that perform side effects on their own in most of the cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，引用类型可能会将自己订阅为其他系统的目标。它可能会从其他系统接收通知。这种类型的交互需要引用类型，因为它们可以有多个所有者。在大多数情况下，开发能够自行执行副作用的价值类型是不必要的困难。
- en: Isolation
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离
- en: A typical value type has no implicit dependencies on the behavior of any external
    system. Therefore, a value type is isolated. It interacts only with its owner
    and it is easy to understand how it interacts in comparison to a reference type's
    interactions with multiple number of owners.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的值类型对外部系统的行为没有隐式依赖。因此，值类型是隔离的。它只与其所有者交互，与引用类型与多个所有者交互相比，其交互方式更容易理解。
- en: If we access a reference to a mutable instance, we have an implicit dependency
    on all its other owners and they could change the instance at any time without
    notifying us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问一个可变实例的引用，我们隐式地依赖于所有其他所有者，并且他们可以在不通知我们的情况下随时更改实例。
- en: Interchangeability
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可互换性
- en: As a value type is copied when it is assigned to a new variable, all of those
    copies are completely interchangeable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值类型在分配给新变量时被复制，因此所有这些副本都是完全可互换的。
- en: We can safely store a value that is passed to us, then later utilize this value
    as if it were a new value. It will not be possible to compare the instance with
    another instance using anything but its data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地存储传递给我们的值，然后稍后将其用作新值。不可能使用除其数据之外的其他任何方式来比较实例。
- en: Interchangeability also means that it does not matter how a given value was
    defined. Two value types are equal by all means if comparing them via `==` results
    in equality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可互换性还意味着给定值的定义方式并不重要。如果通过 `==` 比较结果为相等，则两个值类型在所有意义上都是相等的。
- en: Testability
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可测试性
- en: There is no need for a mocking framework to write unit tests that deal with
    value types. We can directly define values indistinguishable from the instances
    in our applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理值类型的单元测试，没有必要使用模拟框架。我们可以直接定义与我们的应用程序中的实例不可区分的值。
- en: If we use reference types that behave, we have to test the interactions between
    the reference type that we will test and the rest of the system. This typically
    means a lot of mocking or extensive setup code to establish the required relationships.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用具有行为的行为类型，我们必须测试我们将要测试的行为类型与系统其余部分之间的交互。这通常意味着大量的模拟或大量的设置代码来建立所需的关系。
- en: In contrast, value types are isolated and interchangeable, so we can directly
    define a value, call a method, and examine the result. Simpler tests with greater
    coverage yield a code that is easier to change and maintain.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，值类型是隔离和可互换的，因此我们可以直接定义一个值，调用一个方法，并检查结果。更简单的测试具有更大的覆盖率，从而产生更容易更改和维护的代码。
- en: Threats
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 威胁
- en: While the structure of value types encourages testability, isolation, and interchangeability,
    one can define value types that diminish these advantages. Value types containing
    code that executes without being called by its owner are generally hard to track
    and reason about, and should often be avoided.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然值类型的结构鼓励可测试性、隔离性和可互换性，但可以定义减少这些优势的值类型。包含在所有者未调用的情况下执行代码的值类型通常难以跟踪和推理，通常应避免。
- en: Also, value types containing reference types are not necessarily isolated. Using
    reference types in value types should generally be avoided as they are dependent
    on all other owners of that referent. These kinds of value types are also not
    easily interchangeable as the external reference might interact with the rest
    of the system and cause some complications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，包含引用类型的值类型并不一定是隔离的。在值类型中使用引用类型通常应避免，因为它们依赖于该引用的所有其他所有者。这类值类型也不容易互换，因为外部引用可能会与系统的其余部分交互并引起一些复杂问题。
- en: Using value and reference types
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用值类型和引用类型
- en: '*The Swift Programming Language (Swift 3.0)* by*Apple Inc.* has a section on
    comparing structs (value type) and classes (reference type) and how to prefer
    one over the other. It is highly recommended to read that section to understand
    why we prefer one over the other. Although we touched on the topic briefly in
    *[Chapter 1](ch01.html "Chapter 1. Getting Started with Functional Programming
    in Swift")* , *Getting Started With Functional Programming in Swift*, we will
    explore this topic further as the distinction between reference and value types
    is very important in functional programming.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Swift编程语言（Swift 3.0）》* 由 *苹果公司* 出版，其中有一节介绍了如何比较结构体（值类型）和类（引用类型），以及如何选择其中一种类型而舍弃另一种。强烈建议阅读该部分内容，以了解我们为什么选择其中一种类型而舍弃另一种。尽管我们在
    *[第1章](ch01.html "第1章. Swift中的函数式编程入门")* ，*Swift中的函数式编程入门* 中简要地提到了这个话题，但我们仍将进一步探讨这个话题，因为在函数式编程中，引用类型和值类型的区别非常重要。'
- en: In object-oriented programming, we model real-world objects as classes and interfaces.
    For instance, to model an Italian restaurant with different types of pizzas, we
    may have a pizza object and subclasses of it such as margherita, napoletana, or
    romana. Each of these pizzas will have different ingredients. Different restaurants
    may make them slightly differently, and whenever we read their recipes in different
    books or websites, we may understand it differently. This level of abstraction
    enables us to refer to a specific pizza without caring about how other people
    really imagine that pizza. Whenever we talk about that pizza, we do not transfer
    it, we just refer to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们将现实世界中的对象建模为类和接口。例如，为了模拟一家提供不同类型披萨的意大利餐厅，我们可能有一个披萨对象及其子类，如玛格丽塔、那不勒斯或罗马披萨。每种披萨都会有不同的配料。不同的餐厅可能制作得略有不同，而且每当我们在不同的书籍或网站上阅读它们的食谱时，我们可能会有不同的理解。这种抽象级别使我们能够引用特定的披萨，而不必关心其他人真正想象的那种披萨。当我们谈论那种披萨时，我们并不是转移它，我们只是引用它。
- en: On the other hand, in our Italian restaurant, we will need to provide bills
    to our customers. Whenever they ask for the bill, we are going to provide real
    information about quantity and prices. Anyone has the same perception about quantities,
    prices in dollars, and in fact values. Our customers can calculate the invoice
    total. If our customers modify the bill, it is not going to modify the source
    that we used to provide the bill. No matter if they write something on the bill
    or spill wine on it, the value and bill total amount is not going to change. The
    preceding example presents a simple real-world usage of reference versus value
    types. Value types and reference types have their own usages in the Swift programming
    language and in web, mobile, or desktop application programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在我们的意大利餐厅中，我们需要向顾客提供账单。每当他们要求账单时，我们将提供有关数量和价格的真实信息。任何人对于数量、美元价格以及实际上价值的感知都是相同的。我们的顾客可以计算发票总额。如果我们的顾客修改账单，它不会修改我们用来提供账单的原始数据。无论他们在账单上写什么，或者洒上酒，账单的价值和总额都不会改变。前面的例子展示了引用类型与值类型在现实世界中的简单应用。在Swift编程语言以及网络、移动或桌面应用程序编程中，值类型和引用类型都有它们自己的用途。
- en: Value types enable us to make architectures clearer, simpler, and more testable.
    Value types typically have fewer or no dependencies on the outside state, so there's
    less that we have to consider when reasoning about them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型使我们能够使架构更清晰、更简单、更易于测试。值类型通常对外部状态有较少或没有依赖，因此在推理它们时考虑的因素更少。
- en: Also, value types are essentially more reusable because they are interchangeable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值类型因其可互换性而本质上更具可重用性。
- en: As we use more value types and immutable entities, our system will become easier
    to test and maintain over time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们使用更多的值类型和不可变实体，我们的系统将随着时间的推移变得更加易于测试和维护。
- en: In contrast, reference types are acting entities in the system. They have identity.
    They can behave. Their behavior is often complex and hard to reason about, but
    some of the details can usually be represented by simple values and isolated functions
    involving those values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，引用类型是系统中的行为实体。它们有身份。它们可以表现。它们的行为通常是复杂且难以推理的，但其中的一些细节通常可以用简单的值和涉及这些值的隔离函数来表示。
- en: Reference types maintain state defined by values, but these values can be considered
    independently of the reference type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型维护由值定义的状态，但这些值可以独立于引用类型来考虑。
- en: Reference types perform side effects such as I/O, file and database operations,
    and networking.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型会执行副作用，例如 I/O、文件和数据库操作，以及网络操作。
- en: Reference types can interact with other reference types, but they generally
    send values, not references, unless they truly plan to create a persistent connection
    with the external system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型可以与其他引用类型交互，但它们通常发送值，而不是引用，除非它们真正计划与外部系统创建持久连接。
- en: It is important to use value types (`enums`, `tuples`, or `structs`) as much
    as possible unless we need to create a shared mutable state. There are cases where
    we have to use classes. For instance, when we work with **Cocoa**, many APIs expect
    subclasses of `NSObject` so we have to use classes in these cases. Whenever we
    need to use classes, we avoid variables; we define our properties as constants
    and avoid exposing any APIs that can alter states.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要创建共享可变状态的情况下，尽可能多地使用值类型（`enums`、`tuples` 或 `structs`）。有些情况下我们必须使用类。例如，当我们使用
    **Cocoa** 时，许多 API 期望 `NSObject` 的子类，因此在这些情况下我们必须使用类。每次我们需要使用类时，我们避免使用变量；我们将我们的属性定义为常量，并避免暴露任何可以改变状态的
    API。
- en: Equality versus identity
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相等性与同一性
- en: 'Two instances are equal if they have the same value. Equality is used to determine
    the equality of two value types. For instance, two `Strings` are equal if they
    have the same text value. The `==` operator is used to check for equality. The
    following example presents equality checking for two `Int` numbers (`Int` is a
    value type):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个实例具有相同的值，则它们是相等的。相等性用于确定两个值类型的相等性。例如，如果两个 `String` 具有相同的文本值，则它们是相等的。`==`
    运算符用于检查相等性。以下示例展示了两个 `Int` 数字（`Int` 是值类型）的相等性检查：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the other hand, two instances are identical if they refer to the same instance
    of memory. Identity is used to determine if two reference types are identical.
    The `===` operator is used to check for identity. The following example presents
    identity checking for two instances of the `User` class that we have defined earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果两个实例引用了相同的内存实例，则它们是相同的。同一性用于确定两个引用类型是否相同。`===` 运算符用于检查同一性。以下示例展示了我们之前定义的
    `User` 类的两个实例的同一性检查：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The identity checking operator is available only for reference types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 标识检查运算符仅适用于引用类型。
- en: Equatable and Comparable
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Equatable 和 Comparable
- en: 'We are able to compare two value types such as `String`, `Int`, and `Double`,
    but we cannot compare two value types that we have developed. To make our custom
    value types comparable, we need to implement Equatable and Comparable protocols.
    Let''s first examine an example of equality checking without conforming to protocols:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够比较两种值类型，例如 `String`、`Int` 和 `Double`，但我们不能比较我们自己开发的两种值类型。为了使我们的自定义值类型可比较，我们需要实现
    Equatable 和 Comparable 协议。让我们首先检查一个不遵守协议的相等性检查的例子：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, the compiler will complain that **Binary operator ''=='' cannot
    be applied to two ''Point'' operands**. Let''s fix this problem by conforming
    to the `Equatable` protocol:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器会抱怨 **二进制运算符 '==' 不能应用于两个 'Point' 操作数**。让我们通过遵守 `Equatable` 协议来解决这个问题：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The value for `isEqual` is going to be false as they are not equal. To be able
    to compare two points, we need to conform to the `Comparable` protocol. Our example
    becomes as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEqual` 的值将会是 `false`，因为它们并不相等。为了能够比较两个点，我们需要遵守 `Comparable` 协议。我们的例子如下：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result of the comparison will be true.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的结果将是 `true`。
- en: Type checking and casting
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查和类型转换
- en: 'Swift provides type checking and type casting. We can check the type of a variable
    with the `is` keyword. It is most commonly used in `if` statements, as shown in
    the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供类型检查和类型转换。我们可以使用 `is` 关键字检查变量的类型。它最常用于 `if` 语句中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As `String` is a value type and the compiler can infer the type, the Swift
    compiler will issue a warning because it already knows that `aConstant` is `String`.
    Another example can be the following, where we check whether `anyString` is `String`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `String` 是值类型，编译器可以推断类型，因此 Swift 编译器会发出警告，因为它已经知道 `aConstant` 是 `String`
    类型。另一个例子如下，我们检查 `anyString` 是否是 `String` 类型：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the `is` operator is useful to check the type of a class instance, specifically,
    the ones that have subclasses. We can use the `is` operator to determine if an
    object is an instance of a specific class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is` 操作符有助于检查类实例的类型，特别是具有子类的实例。我们可以使用 `is` 操作符来确定一个对象是否是特定类的实例。
- en: 'Similarly, we can use the `as` operator to actually coerce an object to another
    type than what the compiler has inferred it to be. The `as` operator comes in
    two flavors: the plain `as` operator and `as?`. The former casts the object into
    the desired type without asking. If the object cannot be cast to that type, a
    runtime error is thrown. The `as?` operator asks an object if it can be cast to
    a given type. If the object can be cast, then *some* value is returned; otherwise,
    `nil` is returned. The `as?` operator is most often used as part of an `if` statement.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `as` 操作符将对象强制转换为编译器推断的类型之外的类型。`as` 操作符有两种形式：普通的 `as` 操作符和 `as?`。前者在不需要询问的情况下将对象转换为所需的类型。如果对象无法转换为该类型，则会抛出运行时错误。`as?`
    操作符询问对象是否可以转换为给定的类型。如果对象可以转换，则返回 *some* 值；否则，返回 `nil`。`as?` 操作符通常用作 `if` 语句的一部分。
- en: Obviously, it's best to use `as?` whenever possible. We should use `as` only
    if we know it will not result in a runtime error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在可能的情况下最好使用 `as?`。我们应该只在知道它不会导致运行时错误的情况下使用 `as`。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked into types in general and explored reference versus
    value types in detail. We covered topics such as value and reference type constants,
    mixing value and reference types, and copying. Then we learned the characteristics
    of value types, key differences between value and reference types, and how we
    should decide which one to use. We continued by exploring equality, identity,
    type checking, and casting topics. Even though we explored the topic of value
    types, we did not explore a related topic—immutability—in this chapter. [Chapter
    9](ch09.html "Chapter 9. Importance of Immutability") , *Importance of Immutability* will
    cover the importance of immutability.Furthermore, for in depth coverage of these
    concepts it is recommended to watch the following videos from: WWDC 2015 - Session
    414, WWDC 2016 - Session 418, and WWDC 2016 - Session 419.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了类型的一般概念，并详细探讨了引用类型和值类型。我们涵盖了值类型和引用类型常量、值类型和引用类型的混合以及复制等内容。然后我们学习了值类型的特征、值类型和引用类型之间的关键区别以及我们应该如何决定使用哪一个。我们继续探讨了相等性、身份、类型检查和类型转换等主题。尽管我们探讨了值类型的话题，但我们没有在本章中探讨一个相关的话题——不可变性。[第9章](ch09.html
    "第9章。不可变性的重要性")，*不可变性的重要性*将涵盖不可变性的重要性。此外，为了深入了解这些概念，建议观看以下视频：WWDC 2015 - Session
    414，WWDC 2016 - Session 418，和 WWDC 2016 - Session 419。
- en: In the following chapter, we will explore the enumeration and pattern matching
    topics. We will familiarize ourselves with associated and raw values. We will
    be introduced to algebraic data types and finally, we will cover patterns and
    pattern matching.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨枚举和模式匹配主题。我们将熟悉关联值和原始值。我们将介绍代数数据类型，最后，我们将涵盖模式和模式匹配。
