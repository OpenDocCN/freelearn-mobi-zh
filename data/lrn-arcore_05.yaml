- en: Real-World Motion Tracking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际世界运动跟踪
- en: 'Now that we have all the fun stuff set up and ready to go, we can begin building
    some real-world AR apps. In order to do this, we will be picking and choosing
    various pieces we need from the samples. The samples are great examples, but,
    for the most part, they are nothing more than boilerplate code. This means that
    we have no reason to rewrite code sections that already work well. Instead, we
    will focus on adding new code to tackle AR problems. In this chapter, we will
    dive in and learn in depth how ARCore motion tracking works. We will learn the
    current limitations of motion tracking with ARCore and develop a technique for
    overcoming those limitations. Here are the main topics that we will cover in this
    chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置并准备好了所有有趣的东西，我们可以开始构建一些实际的AR应用。为了做到这一点，我们将从样本中挑选和选择我们需要的各种组件。样本是很好的例子，但大部分只是样板代码。这意味着我们没有理由重写已经运行良好的代码部分。相反，我们将专注于添加新的代码来解决AR问题。在本章中，我们将深入了解ARCore运动跟踪的工作原理。我们将学习ARCore运动跟踪的当前局限性，并开发一种克服这些局限性的技术。以下是本章我们将涵盖的主要主题：
- en: Motion tracking in depth
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度运动跟踪
- en: 3D sound
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D声音
- en: Resonance Audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Resonance Audio
- en: A tracking service with Firebase
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Firebase的跟踪服务
- en: Visualize tracked motion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化跟踪运动
- en: In order to successfully complete the exercises in this chapter, the reader
    will need to complete the setup till [Chapter 4](9739deb2-69a5-4756-aa54-946ba15eb405.xhtml),
    *ARCore on the Web*. It may be helpful to review some of the exercises from that
    chapter as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成本章的练习，读者需要完成到[第4章](9739deb2-69a5-4756-aa54-946ba15eb405.xhtml)，*ARCore
    on the Web*的设置。回顾该章节的一些练习可能会有所帮助。
- en: Motion tracking in depth
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度运动跟踪
- en: 'ARCore implements motion tracking using an algorithm known as **visual-inertial
    odometry** (**VIO**). VIO combines the identification of image features from the
    device''s camera with internal motion sensors to track the device''s orientation
    and position relative to where it started. By tracking orientation and position,
    we have the ability to understand where a device is in 6 degrees of freedom, or
    what we will often refer to as the device''s/object''s **pose**. Let''s take a
    look at what a pose looks like in the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore使用称为**视觉惯性里程计**（**VIO**）的算法来实现运动跟踪。VIO结合了从设备摄像头识别图像特征与内部运动传感器，以跟踪设备相对于起始点的方向和位置。通过跟踪方向和位置，我们能够理解设备在6个自由度中的位置，或者我们经常所说的设备/物体的**姿态**。让我们看看以下图中姿态的样子：
- en: '![](img/63cc29fa-8877-4442-ade8-3a65019042b2.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63cc29fa-8877-4442-ade8-3a65019042b2.png)'
- en: 6 Degrees of Freedom, Pose
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 6自由度，姿态
- en: We will use the term pose frequently when identifying an object's position and
    orientation in 3D. If you recall from [Chapter 4](9739deb2-69a5-4756-aa54-946ba15eb405.xhtml),
    *ARCore on the Web*, a pose can also be expressed in a mathematical notation called
    a matrix. We can also refer to rotation in a special form of complex math called
    a **quaternion**. Quaternions allow us to define all aspects of 3D rotation in
    a simple form. Again, we won't worry about the specific math here; we will just
    mention how it is used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在识别物体在3D空间中的位置和方向时，会频繁使用术语“姿态”。如果你还记得[第4章](9739deb2-69a5-4756-aa54-946ba15eb405.xhtml)，*ARCore
    on the Web*，姿态也可以用一种称为矩阵的数学符号来表示。我们还可以提到一种特殊形式的复数数学中的旋转，称为**四元数**。四元数允许我们以简单形式定义3D旋转的所有方面。再次强调，我们不会担心这里的特定数学；我们只是提及它的用法。
- en: 'Perhaps it will be more helpful if we can see how this works in a modified
    ARCore sample. Open up the `spawn-at-surface.html` example from the `Android/three.ar.js/examples`
    folder in a text editor and follow the given steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能通过修改后的ARCore样本看到它是如何工作的，可能会更有帮助。在文本编辑器中打开`Android/three.ar.js/examples`文件夹中的`spawn-at-surface.html`示例，并按照给定的步骤进行操作：
- en: Scroll down or search for the `update` function.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动或搜索`update`函数。
- en: 'Locate the following line of code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位以下代码行：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following lines of code right after the highlighted line:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高亮显示的行之后添加以下代码行：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the file. The code we added just extracts the camera's position and orientation
    (rotation) into some helper variables: `pos` and `rot`. Then, it outputs the values
    to the console with the `console.log` function. As it happens, the camera also
    represents the device's view.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。我们添加的代码只是将摄像头的位置和方向（旋转）提取到一些辅助变量中：`pos`和`rot`。然后，使用`console.log`函数将这些值输出到控制台。碰巧的是，摄像头也代表了设备的视图。
- en: Open Command Prompt or shell window.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符或shell窗口。
- en: 'Launch the `http-server` in your `android` folder by entering this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`android`文件夹中通过输入以下命令启动`http-server`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Launch the Chrome debugging tools and connect remotely to your device.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Chrome调试工具并远程连接到你的设备。
- en: Open the `spawn-at-surface.html` file using the WebARCore browser app on your
    device.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设备上的WebARCore浏览器应用打开`spawn-at-surface.html`文件。
- en: Switch back to the Chrome tools and click on Inspect.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回Chrome工具并点击检查。
- en: 'Wait for the new window to open and click on Console. Move your device around
    while running the AR app (`spawn-at-surface.html`), and you should see the Console
    tab updated with messages about the device''s position and orientation. Here''s
    an example of how this should look:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待新窗口打开并点击控制台。在运行AR应用（`spawn-at-surface.html`）的同时移动你的设备，你应该会看到控制台标签更新，显示有关设备位置和方向的消息。以下是如何显示的示例：
- en: '![](img/0c42ea9a-646c-4dda-bb38-cfb0f89fe7c9.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c42ea9a-646c-4dda-bb38-cfb0f89fe7c9.png)'
- en: Console output showing device position and orientation being tracked
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显示设备位置和方向跟踪的输出控制台
- en: 'The code we added in this example tracks the camera, which, as it so happens,
    represents the view projected through the device in an AR app. We refer to a camera
    as the view of a scene in 3D. A 3D scene can have multiple cameras, but, typically,
    we only use one in AR. The following is a diagram of how we define a camera or
    view projection in 3D:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中添加的代码跟踪摄像机，它恰好代表了AR应用中通过设备投影的视图。我们称摄像机为3D场景的视图。一个3D场景可以有多台摄像机，但在AR中，我们通常只使用一台。以下是我们如何定义3D中的摄像机或视图投影的示意图：
- en: '![](img/9b8e5644-539d-48a4-ad41-41e09850b6bb.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b8e5644-539d-48a4-ad41-41e09850b6bb.png)'
- en: Viewing frustum of a 3D camera
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 3D摄像机的视图视锥体
- en: 'The main task of a camera is to project or flatten the 3D virtual objects into
    a 2D image, which is then displayed on the device. If you scroll near the middle
    of the `spawn-at-surface.html` file, you will see the following code, which creates
    the camera for the scene:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机的主要任务是投影或展平3D虚拟对象到2D图像中，然后该图像在设备上显示。如果你在`spawn-at-surface.html`文件的中间附近滚动，你会看到以下代码，它为场景创建摄像机：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `vrDisplay` is the device's actual camera, `60` represents the field of
    view, `window.innerWidth / window.innerHeight` represents the **aspect ratio**,
    and `vrDisplay.depthNear` and `vrDisplay.depthFar` represent the near and far
    plane depth distances. The near and far, along with the field of view, represent
    the view frustum. All objects in the view frustum will be rendered. Feel free
    to try and change those parameters to see what effect they have on the scene view
    when running the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`vrDisplay`是设备的实际摄像机，`60`代表视野，`window.innerWidth / window.innerHeight`代表**宽高比**，`vrDisplay.depthNear`和`vrDisplay.depthFar`代表近平面和远平面的深度距离。近、远平面以及视野共同构成了视图视锥体。视锥体内的所有对象都将被渲染。你可以自由尝试更改这些参数，看看它们在运行应用时对场景视图有什么影响。
- en: We use a field of view of 60 degrees in this setting to give a more natural
    perspective to the objects in the scene. Feel free to experiment with larger and
    smaller angles to see the visual effect this has on the scene objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，我们使用60度的视野来给场景中的对象提供更自然的视角。你可以自由地尝试更大的和更小的角度，看看这对场景对象有什么视觉效果。
- en: Now that we have a better understanding of how we can track our device around
    a scene, we will extend our example. In the next section, we will introduce 3D
    spatial sound.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何在场景周围跟踪我们的设备有了更好的理解，我们将扩展我们的例子。在下一节中，我们将介绍3D空间声音。
- en: 3D sound
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D声音
- en: '3D sound is another illusion we cast at the listener in order to further trick
    them into believing that our virtually generated world is real. In fact, 3D sound
    has been used extensively for years in movies, TV, and of course, video games
    in order to trick the listener into a more immersive experience. In a movie, for
    instance, the listener is stationary, so 3D sound can be mimicked by setting up
    multiple speakers. However, in an AR or VR mobile app, the sound needs to come
    from a single (mono) or double (stereo, headphones) source. Fortunately, numerous
    smart people figured out how our human ears hear using a technique called **binaural
    sound** to map out sounds in 3D. The next diagram goes into a little more detail
    on how binaural audio works:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 3D声音是我们向听众施加的另一种错觉，以进一步欺骗他们相信我们的虚拟生成世界是真实的。实际上，3D声音多年来在电影、电视和当然，视频游戏中被广泛使用，以欺骗听众获得更沉浸式的体验。例如，在电影中，听众是静止的，因此可以通过设置多个扬声器来模仿3D声音。然而，在AR或VR移动应用中，声音需要来自单个（单声道）或双声道（立体声，耳机）源。幸运的是，许多聪明的人通过使用称为**双耳声音**的技术来了解我们人类耳朵的听觉方式，从而在3D中绘制声音。下一张图将更详细地介绍双耳音频的工作原理：
- en: '![](img/8dae6f4d-343a-4209-b724-293e4762cd9b.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dae6f4d-343a-4209-b724-293e4762cd9b.jpg)'
- en: 3D sound visualized
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 3D声音可视化
- en: Since then, we have figured out not only how to record binaural audio, but also
    how to play it back, thus giving us the ability to play sounds that fool the brain
    into thinking that their source is different from reality. However, most of the
    current technology assumes that the user is stationary, but, of course, that is
    far from the case in an AR app. In an AR app, our user (listener) is moving in
    our virtual world, which means that the 3D sounds around the listener also need
    to adjust. Fortunately, Google has again come to the rescue and developed a 3D
    sound API for AR and VR, called **Resonance Audio**. We will explore more about
    Resonance Audio and how to use it in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自那以后，我们不仅弄清楚了如何录制双耳音频，还弄清楚了如何回放它，从而让我们能够播放让大脑误以为声音来源与现实不同的声音。然而，目前的大多数技术都假设用户是静止的，但在AR应用中，当然并非如此。在AR应用中，我们的用户（听众）在我们的虚拟世界中移动，这意味着听众周围的3D声音也需要调整。幸运的是，谷歌再次伸出援手，为AR和VR开发了一个3D声音API，称为**Resonance
    Audio**。我们将在下一节中更深入地探讨Resonance Audio及其使用方法。
- en: Resonance Audio
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Resonance Audio
- en: 'Google developed Resonance Audio as a tool for developers who need to include
    3D spatial audio in their AR and VR applications. We will use this tool to put
    3D sound in our demo app. Let''s get started by opening up the `spawn-at-surface.html`
    file in your favorite text editor and then follow the given steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌开发了Resonance Audio作为开发者工具，用于在他们的AR和VR应用中包含3D空间音频。我们将使用这个工具在我们的演示应用中添加3D声音。让我们开始吧，首先在您喜欢的文本编辑器中打开`spawn-at-surface.html`文件，然后按照给定的步骤进行：
- en: 'Locate the beginning of the JavaScript and add the following lines in the variable
    declarations:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到JavaScript的开始部分，并在变量声明中添加以下行：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, scroll down to just before the `update` function and start a new function
    called `initAudio`, like this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向下滚动到`update`函数之前，开始一个新的函数，称为`initAudio`，如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to initialize an `AudioContext`, which represents the device''s
    stereo sound. Inside the `initAudio` function, enter the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化一个`AudioContext`，它代表设备的立体声音。在`initAudio`函数中，输入以下内容：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we set up the audio scene in `Resonance` and output the binaural audio
    to the device''s stereo output by adding this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`Resonance`中设置音频场景，并通过添加以下内容将双耳音频输出到设备的立体声音频输出：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this, we define some properties for the virtual space around the user
    by adding the given code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们通过添加以下代码为用户周围的虚拟空间定义一些属性：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, there is plenty of flexibility here to define any `room` you
    want. We are describing a room in this example, but that room can also be described
    as an outdoor space. There's an example of this for the **up** direction at the
    bottom where the **transparent** option is used. Transparent means sound will
    pass through the virtual wall in that direction, and you can represent the outdoors
    by setting all directions to transparent.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，这里有很多灵活性来定义任何您想要的`room`。在这个例子中，我们描述了一个房间，但那个房间也可以描述为一个户外空间。底部有一个关于**向上**方向的例子，其中使用了**透明**选项。透明意味着声音会穿过虚拟墙的那个方向，您可以通过将所有方向设置为透明来表示户外。
- en: 'Now, we add the `room` to the audio scene by writing this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过写入以下内容将`room`添加到音频场景中：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that `room` is done, let''s add the audio source by entering the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`room`已经完成，让我们通过输入以下内容添加音频源：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `audioElement` is a connection to an HTML `audio` tag. Essentially, what
    we are doing here is replacing the default audio of HTML with the audio routed
    through resonance to provide us with spatial sound.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`audioElement`是与HTML `audio`标签的连接。本质上，我们在这里所做的就是用通过共振路由的音频替换HTML的默认音频，为我们提供空间声音。'
- en: 'Finally, we need to add our `audio` object when we spawn our box and play the
    sound. Enter the given code just following the function call to `THREE.ARUtils.placeObjectAtHit`inside
    the `onClick` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们生成盒子并播放声音时，我们需要添加我们的`audio`对象。在`onClick`函数中`THREE.ARUtils.placeObjectAtHit`函数调用之后输入给定的代码：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before we run our sample, we need to download the `cube-sound.wav` file and
    put it in our sample folder. Open the folder where you downloaded the book's source
    code and copy the file from `Chapter_5/Resources/cube-sound.wav` to your `Android/three.ar.js/examples`
    folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行示例之前，我们需要下载`cube-sound.wav`文件并将其放入我们的示例文件夹中。打开你下载本书源代码的文件夹，并将文件从`Chapter_5/Resources/cube-sound.wav`复制到你的`Android/three.ar.js/examples`文件夹中。
- en: Binaural is so named because we hear sound with both the ears. In order to get
    the most from the audio examples in this chapter, ensure that you wear stereo
    headphones. You will be able to hear some differences with your device's mono
    speaker, but it won't be the same without headphones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 双耳立体声之所以得名，是因为我们用两只耳朵听声音。为了从本章的音频示例中获得最大收益，请确保你戴上立体声耳机。你将能够用你设备的单声道扬声器听到一些差异，但没有耳机就不会一样。
- en: Now when you are ready to run the app, save the `spawn-at-surface.html` page,
    start your device, and close and reopen the WebARCore app. Play around with the
    app and spawn a box by tapping a surface. Now when the box spawns, you will hear
    the cube sound. Move around the scene and see how the sound moves.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好运行应用程序时，保存`spawn-at-surface.html`页面，启动你的设备，关闭并重新打开WebARCore应用程序。在应用程序中玩耍，并通过轻触表面生成一个盒子。现在当盒子生成时，你会听到立方体声音。在场景中四处移动，看看声音是如何移动的。
- en: 'Not what you expected? That''s right, the sound still moves with the user.
    So what''s wrong? The problem is that our audio scene and 3D object scene are
    in two different virtual spaces or dimensions. Here''s a diagram that hopefully
    explains this further:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不是你预期的结果？没错，声音仍然随着用户移动。那么问题是什么？问题是我们的音频场景和3D对象场景在两个不同的虚拟空间或维度中。以下是一个希望进一步解释这一点的图表：
- en: '![](img/8a2e4d4f-4f2e-43a1-95c9-cbeb057d3334.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a2e4d4f-4f2e-43a1-95c9-cbeb057d3334.jpg)'
- en: Difference in audio and virtual 3D object space
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 音频和虚拟3D对象空间中的差异
- en: 'The problem we have is that our audio space moves with the user. What we want
    is to align the audio space with the same reference as our camera and then move
    the listener. Now, this may sound like a lot of work, and it likely would be,
    if not for ARCore. So thankfully, we can do this by adding one line right after
    those couple of console lines we put in earlier, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题是我们的音频空间随着用户移动。我们想要做的是将音频空间与我们的相机相同的参考系对齐，然后移动听众。现在，这听起来可能像是一项大量工作，如果不是因为ARCore，那么很可能就是这样。所以，幸运的是，我们可以在之前放入的那几个控制台行之后添加一行代码来实现这一点，就像这样：
- en: 'Find the two `console.log` lines we added in the previous section and comment
    them out like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到我们在上一节中添加的两个`console.log`行，并像这样注释掉：
- en: If you omitted the previous section, you will need to go back and complete it.
    The code we use in this section requires it*.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了前面的部分，你需要回去完成它。本节中使用的代码需要它*。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add our new line of code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们新的代码行：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All this line does is to adjust the audio position relative to the user (camera).
    It does this by subtracting the `X`, `Y`, and `Z` values of the position vectors.
    We could have also just as easily subtracted the vectors.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码所做的只是调整音频位置相对于用户（相机）。它是通过减去位置向量的`X`、`Y`和`Z`值来实现的。我们也可以同样容易地减去向量。
- en: Run the sample again. Spawn some boxes and move around.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行示例。生成一些盒子并四处移动。
- en: Note that when you place a box and move around, the sound changes, as you expect
    it to. This is due to our ability to track the user in 3D space relative to where
    a virtual sound is. In the next section, we will look at extending our ability
    to track users by setting up a tracking service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你放置一个盒子并四处移动时，声音会改变，正如你所期望的那样。这是由于我们能够跟踪用户在相对于虚拟声音的3D空间中的位置。在下一节中，我们将探讨通过设置跟踪服务来扩展我们跟踪用户的能力。
- en: A tracking service with Firebase
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase的跟踪服务
- en: Now, being able to track a user's motion is all well and good, but what if we
    wanted to track a user across applications or even multiple users at the same
    time? This will require us to write a server, set up a database, make a schema,
    and so on, which is certainly not an easy task and cannot be easily explained
    in just a chapter. However, what if there was an easier way? Well, there is, and
    again, Google comes to our rescue with Firebase.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，能够跟踪用户的动作固然很好，但如果我们想要跨应用或同时跟踪多个用户呢？这将需要我们编写服务器，设置数据库，创建模式等等，这当然不是一件容易的事情，也不能在仅仅一章中轻易解释。然而，如果有一个更简单的方法呢？好吧，确实有，而且，又是Google带着Firebase来帮助我们。
- en: 'Firebase is an excellent collection of app tools and storage services that
    are dead simple to use and cross-platform. We will use Firebase database, a real-time
    database service, to track our user''s position. Open up a web browser and follow
    the given steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个使用简单且跨平台的优秀应用工具和存储服务集合。我们将使用Firebase数据库，一个实时数据库服务，来跟踪用户的位置。打开一个网络浏览器并按照以下步骤操作：
- en: Browse to [firebase.google.com](https://firebase.google.com/).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 [firebase.google.com](https://firebase.google.com/)。
- en: Click on the GET STARTED button.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 GET STARTED 按钮。
- en: Log in with your Google (Gmail) account. If you don't have one, yes, you will
    need to create one to continue.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的Google（Gmail）账户登录。如果你没有，是的，你需要创建一个账户才能继续。
- en: Click on the Add project button.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Add project 按钮。
- en: 'Name your project `ARCore` and select your own Country/Region, as shown in
    the following excerpt:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的项目命名为`ARCore`并选择你自己的国家/地区，如以下摘录所示：
- en: '![](img/7e5dfefe-4619-40ff-87d4-cc7708626781.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e5dfefe-4619-40ff-87d4-cc7708626781.png)'
- en: Setting up the ARCore project
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置ARCore项目
- en: Click on CREATE PROJECT. This will create your project and open up the Firebase
    Console.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 CREATE PROJECT。这将创建你的项目并打开Firebase控制台。
- en: 'Click on Add Firebase to your web app, which can be found at the top of the
    Project Overview page. This will open up a dialog similar to the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Add Firebase to your web app，它可以在项目概览页面的顶部找到。这将打开一个类似于以下对话框：
- en: '![](img/fa2c34a8-c817-4361-a43f-db671318adc6.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa2c34a8-c817-4361-a43f-db671318adc6.png)'
- en: Copy the setup code for your project
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 复制你项目的设置代码
- en: Click on COPY. This should copy the two script tags and contents to your clipboard.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 COPY。这应该会将两个脚本标签及其内容复制到你的剪贴板中。
- en: Don't worry if the keys and URLs you see are different; they should be different.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到的密钥和URL不同，不用担心；它们应该是不同的。
- en: Open up the `spawn-at-surface.html` file in your favorite text editor. Scroll
    down to just before the last `<script>` tag, the one with the big block of code.
    Paste the code (*Ctrl* + *V* and*command* + *V* on Mac) you copied earlier.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`spawn-at-surface.html`文件。滚动到最后一行`<script>`标签之前，即带有大块代码的那一行。粘贴你之前复制的代码（*Ctrl*
    + *V* 和*command* + *V* 在Mac上）。
- en: Setting up the database
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'With that, we have set up the ARCore Firebase project. Now we want to create
    our real-time database and set it up for us to connect to. Go back to the Firebase
    Console and follow the given steps to set up a database:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已经设置了ARCore Firebase项目。现在我们想要创建我们的实时数据库并为我们设置连接。返回Firebase控制台并按照以下步骤设置数据库：
- en: Close the configuration dialog that we left open from the last exercise.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭我们之前留下的配置对话框。
- en: Click on Database on the left-hand side menu.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单中的 Database。
- en: Click on GET STARTED. This will create a Firebase Realtime Database with default
    security turned on. We don't really need authentication at this point, so let's
    just turn it off.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 GET STARTED。这将创建一个带有默认安全设置开启的Firebase实时数据库。在这个阶段，我们实际上不需要身份验证，所以让我们将其关闭。
- en: 'Click on the RULES tab. The default security rule is defined with JSON. We
    want to change this so that our database has public access. Replace the JSON with
    the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 RULES 标签页。默认的安全规则是用JSON定义的。我们想要更改它，以便我们的数据库具有公开访问权限。将JSON替换为以下内容：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Click on PUBLISH. You should now see the following security warning:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 PUBLISH。你现在应该会看到一个以下安全警告：
- en: '![](img/2053873a-2786-4adc-a044-9d4c4dea139d.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2053873a-2786-4adc-a044-9d4c4dea139d.png)'
- en: The security warning after turning on public access
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开公共访问后的安全警告
- en: Click on the DATA tab. Leave this tab and the browser window open.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 DATA 标签页。保持这个标签页和浏览器窗口打开。
- en: Turning off security is okay for development prototyping. However, as soon as
    you go past a prototype, you need to turn security back on. Failure to do this
    can cost you all manner of heartache, pain, and things you probably can't imagine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭安全设置适用于开发原型。然而，一旦您超出原型，您需要重新启用安全设置。未能这样做可能会给您带来各种痛苦和您可能无法想象的事情。
- en: Time to test the connection
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试连接时间
- en: 'Believe it or not, our real-time database service is up and running; now we
    just want to test our connection by writing a single value to the database from
    our AR Web app. Open up `spawn-at-surface.html` in a text editor and follow along:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们的实时数据库服务正在运行；现在我们只想通过从我们的AR Web应用向数据库写入单个值来测试我们的连接。在文本编辑器中打开`spawn-at-surface.html`，并按照以下步骤操作：
- en: 'Scroll down to the Firebase script we added earlier. Add the following code
    after the last line:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到我们之前添加的Firebase脚本。在最后一行之后添加以下代码：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding line creates a reference to the database. Now, let''s set some
    data using the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一行代码创建了对数据库的引用。现在，让我们使用以下代码设置一些数据：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Various versions of the `spawn-at-surface.html` page can be found in the book's
    downloaded source code at `Chapter_5/Examples`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书下载的源代码中的`Chapter_5/Examples`部分找到`spawn-at-surface.html`页面的各种版本。
- en: Run the page on your desktop using the [**http://localhost:9999/three.ar.js/examples/spawn-at-surface.html**](http://localhost:9999/three.ar.js/examples/spawn-at-surface.html)
    URL. At this stage, we are just setting a single point of data when the page starts,
    as a test, so we don't need AR. Of course, ensure that you start `http-server`
    before running any tests.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [**http://localhost:9999/three.ar.js/examples/spawn-at-surface.html**](http://localhost:9999/three.ar.js/examples/spawn-at-surface.html)
    URL在您的桌面浏览器上运行页面。在这个阶段，我们只是在页面开始时设置一个数据点作为测试，因此我们不需要AR。当然，确保在运行任何测试之前启动`http-server`。
- en: After the page loads, you will see the ARCore warning message, but not to worry,
    this is just a test of the real-time database service.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载后，您将看到ARCore警告信息，但不必担心，这只是一个对实时数据库服务的测试。
- en: 'Go back to the Firebase Console ****([https://console.firebase.google.com/u/0/?pli=1](https://console.firebase.google.com/u/0/?pli=1)**)******
    window we left open. Ensure that you are looking at the Database page and DATA
    tab, as shown:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回我们之前留下的Firebase控制台 ****([https://console.firebase.google.com/u/0/?pli=1](https://console.firebase.google.com/u/0/?pli=1)**)******
    窗口。确保您正在查看数据库页面和DATA选项卡，如下所示：
- en: '![](img/0beed976-b5a3-4217-ab4a-69574d4e8306.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0beed976-b5a3-4217-ab4a-69574d4e8306.png)'
- en: Checking the data that was set on the Firebase database
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检查在Firebase数据库上设置的数据
- en: Expand the pose and its child objects, as shown in the preceding excerpt. If
    everything is working correctly, you should see the values we set for a simulated
    pose (position).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开姿态及其子对象，如前文摘录所示。如果一切正常，您应该看到我们为模拟姿态（位置）设置的值。
- en: We now have a service in place, with the ability to track any data we want.
    Firebase allows us to model our data and schema on the fly, which is very useful
    in prototyping. It also has the extra benefit of being free, public, and accessible
    from the other platforms we will work with later. In the next section, we will
    put our tracking service to use by tracking the user in real time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个服务在位，能够跟踪我们想要跟踪的任何数据。Firebase允许我们在实时中对我们的数据和模式进行建模，这在原型设计中非常有用。它还有额外的优势，即免费、公开，并且可以从我们稍后将要工作的其他平台访问。在下一节中，我们将通过实时跟踪用户来使用我们的跟踪服务。
- en: Visualizing tracked motion
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化跟踪运动
- en: 'Now that we understand how to track motion and have a service in place, let''s
    see how we can put this service to use and visualize the tracked data in our AR
    app. Open up the `spawn-at-surface.html` page in a text editor and follow the
    given steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何跟踪运动并且有一个服务在位，让我们看看我们如何使用这个服务并在我们的AR应用中可视化跟踪数据。在文本编辑器中打开`spawn-at-surface.html`页面，并按照以下步骤操作：
- en: 'Find that last line of code we added in the last exercise and delete it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到我们上次练习中添加的最后一行代码并将其删除：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace that line with the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该行替换为以下代码：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line in the preceding snippet is setting an index or count variable.
    Then, we use the `setInterval` function to set up a repeating timer that calls
    the anonymous function every second (1000 milliseconds). We do this so that we
    only track movement every second. We could certainly track movement every frame
    like in a multiplayer game, but for now, one second will work. The rest of the
    code, you have seen earlier in the previous exercises.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个代码片段中的第一行是设置索引或计数变量。然后，我们使用`setInterval`函数设置一个每秒（1000毫秒）调用匿名函数的重复计时器。我们这样做是为了确保我们每秒只追踪一次移动。我们当然可以在像多人游戏那样的每一帧追踪移动，但现阶段，一秒就足够了。其余的代码，你已经在之前的练习中见过。
- en: Save the file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the sample in your browser's device. Now, move around with the device.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器设备上运行示例。现在，用设备移动。
- en: Go to the Firebase Console. You should now see a stream of data getting fed
    into the database. Feel free to expand the data points and see the values being
    captured.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Firebase控制台。你现在应该会看到一个数据流被输入到数据库中。你可以自由地扩展数据点，并查看捕获的值。
- en: 'Great, we can now see our data being collected. Of course, it is a little difficult
    for us humans to easily make sense of the data unless we can visualize it in 2D
    or 3D, which means that we have a few options. We can build a separate web page
    to just track the users on a map. Yet, that sounds more like a standard web exercise,
    so let''s leave that to readers who are so inclined. Instead, what we will do
    is draw a 3D path of where the user has traveled, using the same data that we
    are sending to our database. Open up that text editor again and load up `spawn-at-camera.html`
    to follow along:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在可以看到我们的数据正在被收集。当然，除非我们能将其在2D或3D中可视化，否则对我们人类来说，要轻松理解这些数据是有点困难的，这意味着我们有几种选择。我们可以构建一个单独的网页来跟踪地图上的用户。但这听起来更像是一个标准的网络练习，所以我们把它留给有此兴趣的读者。相反，我们将使用发送到我们数据库的相同数据来绘制用户旅行的3D路径。再次打开那个文本编辑器并加载`spawn-at-camera.html`以继续：
- en: Locate that call to the `setInterval` function we added in the last exercise.
    We need to change some code in order to create a line from the points.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到我们在上一个练习中添加的`setInterval`函数调用。我们需要更改一些代码来创建从点到线的线条。
- en: 'Enter the following code after the identified line:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在识别的行之后输入以下代码：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code first checks whether `lastPos` is defined. On the first run through
    the `setInterval` timer loop, `lastPos` will be undefined; it then gets set right
    after the `if` statement. Then, after `lastPos` is defined, we create a basic
    line `material` with the call to `THREE.LineBasicMaterial`, passing in a hexadecimal
    color value. Next, we create our `geometry`, a `line`, using the current `pos` and
    `lastPos` variables with the `material`. We do this by first constructing a `Vector3`
    object with the `x`, `y`, and `z` values of each position. Finally, we add the
    `line` to the scene with `scene.add(line)`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码首先检查`lastPos`是否已定义。在`setInterval`计时器循环的第一次运行中，`lastPos`将是未定义的；它随后在`if`语句之后被设置。然后，在`lastPos`被定义后，我们通过调用`THREE.LineBasicMaterial`并传入十六进制颜色值来创建一个基本的`material`线条。接下来，我们使用当前的`pos`和`lastPos`变量以及`material`创建我们的`geometry`，即一条线。我们这样做是通过首先使用每个位置`x`、`y`和`z`的值构造一个`Vector3`对象。最后，我们通过调用`scene.add(line)`将`line`添加到场景中。
- en: A vector is nothing more than an ordered set of numbers, where each number represents
    a dimension. There are a number of cool mathematical properties about vectors
    that are useful to know. However, for now, think of a `Vector3` as representing
    a point in 3D space at the `x`, `y`, and `z` coordinates. We use the term vertex
    to refer to a vector or point on a line, surface, or mesh.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 向量不过是有序数字的集合，其中每个数字代表一个维度。向量有许多有趣的数学特性，了解这些特性是有用的。然而，现在，我们可以将`Vector3`视为在`x`、`y`和`z`坐标上表示3D空间中的一个点。我们使用术语顶点来指代线、表面或网格上的向量或点。
- en: 'Save the file and run it in the WebARCore browser on your device. Now when
    you move around, you will see a trail of blue lines follow you, as shown in the
    following picture:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在你的设备上的WebARCore浏览器中运行它。现在当你移动时，你会看到一条蓝色线条的轨迹跟随你，如下面的图片所示：
- en: '![](img/76425f6b-dd40-4dc1-b5a2-ad3ab343a3b9.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76425f6b-dd40-4dc1-b5a2-ad3ab343a3b9.png)'
- en: Sample showing tracked path as blue lines
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示追踪路径为蓝色线条
- en: Feel free to continue playing with the app. The development cycle (build, deploy,
    and run) is quick when developing a simple single page web app, which gives you
    plenty of opportunities to make quick changes, run them, and then debug easily.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随意继续使用这个应用。当开发一个简单的单页网页应用时，开发周期（构建、部署和运行）非常快，这为你提供了很多快速更改、运行并轻松调试的机会。
- en: Exercises
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'At the end or near the end of every chapter, an exercise section will be available
    to test your knowledge and give you more experience with ARCore. Complete the
    following exercises on your own:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章的结尾或接近结尾的地方，将有一个练习部分来测试你的知识，并让你在ARCore上获得更多经验。请独立完成以下练习：
- en: Change the color of the tracking line from blue to red, or another color.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将追踪线的颜色从蓝色改为红色，或另一种颜色。
- en: Replace the straight line segments with a `SplineCurve`. Hint—you will need
    to track more than one previous position.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将直线段替换为`SplineCurve`。提示——你需要跟踪多个之前的位置。
- en: Make the cube and/or audio follow the user along the tracked path. Hint—you
    can use another `setInterval` timer function to move the box every 1.1 seconds
    (1100 milliseconds) along the path.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让立方体和/或音频沿着追踪路径跟随用户。提示——你可以使用另一个`setInterval`定时器函数，每1.1秒（1100毫秒）沿着路径移动盒子。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we complete our look at motion tracking with ARCore. As we learned,
    ARCore gives us the ability to track position and rotation or the pose of a device
    using feature identification correlated with the device's motion sensors. We then
    learned why it is important to track the position of a user when building AR apps
    with 3D sound. This taught us the difference between our audio and virtual (3D)
    scene and how to convert between references. We then extended our ability to track
    a user by setting up a Firebase Realtime Database and connected that to our AR
    app. By doing this, we could now track a single user or multiple users globally.
    Of course, we didn't have enough time here to build on this further. For now,
    we finished the app by drawing the user's travel path while the device moves around
    an area.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们完成了对ARCore运动追踪的探讨。正如我们所学的，ARCore通过使用与设备运动传感器相关的特征识别来给我们提供跟踪位置和旋转或设备姿态的能力。然后我们学习了为什么在构建带有3D声音的AR应用时跟踪用户的位置很重要。这教会了我们我们的音频和虚拟（3D）场景之间的区别以及如何进行转换。然后我们通过设置Firebase实时数据库并连接到我们的AR应用来扩展跟踪用户的能力。通过这样做，我们现在可以全球范围内跟踪单个用户或多个用户。当然，我们没有足够的时间在这里进一步构建。现在，我们通过在设备在区域内移动时绘制用户的旅行路径来完成应用。
- en: In the next chapter, we will jump back to working with Android (Java) and learn
    more about environmental understanding and various related 3D concepts, which
    is the next topic on the fundamental AR topics' list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到使用Android（Java）的工作，学习更多关于环境理解和各种相关3D概念，这是基础AR主题列表中的下一个主题。
