- en: Chapter 4. Data Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 数据管理
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件
- en: Creating an SQLite database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建SQLite数据库
- en: Inserting and updating data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入和更新数据
- en: Querying an SQLite database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询SQLite数据库
- en: Using an already existing SQLite database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的SQLite数据库
- en: Storing data with serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用序列化存储数据
- en: Storing data with XML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML存储数据
- en: Managing XML data with LINQ to XML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ to XML管理XML数据
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Almost every application needs to have permanent data storage on the filesystem.
    In this chapter, we will discuss different ways of storing data. We will see how
    to create an SQLite database and manage data with it from within an iPhone application.
    Also, we will learn how to use an already existing database in a project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都需要在文件系统中具有永久数据存储。在本章中，我们将讨论不同的数据存储方式。我们将了解如何在iPhone应用程序中创建SQLite数据库并使用它来管理数据。此外，我们还将学习如何在项目中使用现有的数据库。
- en: SQLite ([http://www.sqlite.org](http://www.sqlite.org) ) is a self-contained
    transactional database system. Each database is saved in a standalone file, and
    there is no database server. In iOS, SQLite support is native.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite ([http://www.sqlite.org](http://www.sqlite.org) ) 是一个自包含的事务型数据库系统。每个数据库都保存在一个独立的文件中，没有数据库服务器。在iOS中，SQLite支持是原生的。
- en: Next, we will see how to serialize and save objects to the filesystem and how
    to use XML files with LINQ to XML.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何序列化和将对象保存到文件系统中，以及如何使用LINQ to XML与XML文件一起使用。
- en: Creating files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件
- en: In this recipe, we will learn how to create files on the filesystem of iOS devices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在iOS设备的文件系统中创建文件。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **iPhone Single View Application** project in MonoDevelop. Name
    it `FileCreationApp`. Open the `FileCreationAppViewController.xib` file, and add
    a `UILabel` and a `UIButton` on its view.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的**iPhone单视图应用程序**项目，命名为`FileCreationApp`。打开`FileCreationAppViewController.xib`文件，并在其视图中添加一个`UILabel`和一个`UIButton`。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enter the following code in the `FileCreationAppViewController` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileCreationAppViewController`类中输入以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As one can see from this code, we can use standard classes from the `System.IO`
    namespace, just like in desktop applications. The first thing we do is to set
    a path for the file we will save. We do this in the following line:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，我们可以像在桌面应用程序中一样使用`System.IO`命名空间中的标准类。我们首先做的事情是为我们将要保存的文件设置一个路径。我们在以下行中这样做：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In iOS, we do not have access to the whole filesystem, not even inside the application
    bundle. An exception will occur if we try to write inside a folder we do not have
    access to. So, we use the static `Environment.GetFolderPath(SpecialFolder)` method
    and retrieve the `Personal` special folder, which corresponds to our application's
    `Documents` folder. Note the use of `Path.Combine(string, string)`, which combines
    two strings and returns a path. After that, we create a new instance of the `StreamWriter`
    class and write some text in the file with its `WriteLine(string)` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中，我们无法访问整个文件系统，甚至在应用程序包内部也不行。如果我们尝试在无法访问的文件夹中写入，将会发生异常。因此，我们使用静态的`Environment.GetFolderPath(SpecialFolder)`方法来检索`Personal`特殊文件夹，这对应于我们的应用程序的`Documents`文件夹。注意`Path.Combine(string,
    string)`的使用，它将两个字符串组合并返回一个路径。之后，我们创建`StreamWriter`类的新实例，并使用其`WriteLine(string)`方法在文件中写入一些文本。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To retrieve the text from the file, we create a new instance of the `StreamReader`
    class and read the text with its `ReadLine` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中检索文本，我们创建`StreamReader`类的新实例，并使用其`ReadLine`方法读取文本：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If we want to write or read binary data, we can use the `FileStream` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要写入或读取二进制数据，我们可以使用`FileStream`类。
- en: Documents Folder
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档文件夹
- en: An application's `Documents` folder is relevant to the application alone. If
    the application is uninstalled from the device, its contents are also removed.
    We have both read and write access in this folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的`Documents`文件夹仅与该应用程序相关。如果从设备中卸载应用程序，其内容也会被删除。我们在这个文件夹中既有读又有写权限。
- en: See also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Storing data with serialization*'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用序列化存储数据*'
- en: Creating an SQLite database
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SQLite数据库
- en: In this recipe, we will learn how to create an SQLite database file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何创建SQLite数据库文件。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **iPhone Single View Application** in MonoDevelop, and name it
    `CreateSQLiteApp`. Add a `UILabel` and a `UIButton` on its view.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的**iPhone单视图应用程序**，命名为`CreateSQLiteApp`。在其视图中添加一个`UILabel`和一个`UIButton`。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a reference to the project to the assembly `Mono.Data.Sqlite` and the corresponding
    `using` directive on the namespace:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目引用添加到`Mono.Data.Sqlite`程序集，并在命名空间上添加相应的`using`指令：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Enter the following method in the `CreateSQLiteAppViewController` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateSQLiteAppViewController`类中输入以下方法：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And add the following code in the `ViewDidLoad` method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: iOS provides native support for SQLite databases.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: iOS为SQLite数据库提供了原生支持。
- en: 'We can access SQLite databases with Mono''s `Mono.Data.Sqlite` namespace, as
    follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Mono的`Mono.Data.Sqlite`命名空间来访问SQLite数据库，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `CreateSQLiteDatabase` method, we first check if the file already
    exists:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateSQLiteDatabase`方法内部，我们首先检查文件是否已存在：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can continue with the creation of the database. We first create the
    file with the `SqliteConnection.CreateFile(string)` static method, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以继续创建数据库。我们首先使用`SqliteConnection.CreateFile(string)`静态方法创建文件，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We connect to the newly created file by initializing an `SqliteConnection`
    object and calling its `Open()` method. The connection string for an SQLite database
    is `Data Source =`, followed by the filename of the database:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过初始化一个`SqliteConnection`对象并调用其`Open()`方法来连接新创建的文件。SQLite数据库的连接字符串为`Data Source
    =`，后跟数据库的文件名：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create a table in the database, an `SqliteCommand` object is initialized.
    We pass a standard SQL string to its `CommandText` property, and call the `ExecuteNonQuery()`
    method to execute the SQL:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中创建一个表时，会初始化一个`SqliteCommand`对象。我们将一个标准的SQL字符串传递给其`CommandText`属性，并调用`ExecuteNonQuery()`方法来执行SQL：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Note the usage of a try-catch block. It is provided to display a message to
    the user if something goes wrong with the creation of the database.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意try-catch块的使用。它用于在数据库创建过程中出现错误时向用户显示消息。
- en: SQL table creation
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SQL表创建
- en: In this task, we have created a simple table for our database, with the name
    `Customers`. It contains three fields. `FirstName` and `LastName` are of type
    `VARCHAR(20)`, while `ID` is of type `INTEGER` and is also the `PRIMARY KEY` of
    the table.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们为我们的数据库创建了一个简单的表，名为`Customers`。它包含三个字段。`FirstName`和`LastName`字段类型为`VARCHAR(20)`，而`ID`字段类型为`INTEGER`，同时也是表的`PRIMARY
    KEY`。
- en: Apart from using SQL commands for creating tables, we can create an SQLite database
    with various commercial or free GUI tools. A simple search on the Internet will
    yield various results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用SQL命令创建表之外，我们还可以使用各种商业或免费的GUI工具创建SQLite数据库。在互联网上简单搜索就会得到各种结果。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Querying an SQLite database*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询SQLite数据库*'
- en: '*Inserting and updating data*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入和更新数据*'
- en: '*Using an already existing database*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用现有的数据库*'
- en: Inserting and updating data
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和更新数据
- en: In this recipe, we will learn how to write data to the database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将数据写入数据库。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this task, we will extend the project `CreateSQLiteApp` that we created
    in the previous task.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将扩展我们在上一个任务中创建的`CreateSQLiteApp`项目。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add two more buttons on the view.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加两个额外的按钮。
- en: 'Inside the `CreateSQLiteAppViewController` class, create two methods that will
    connect to the database file using the code from the previous task. The difference
    here lies in the usage of the `SqliteCommand` object:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateSQLiteAppViewController`类内部，创建两个方法，这些方法将使用上一个任务中的代码连接到数据库文件。这里的区别在于`SqliteCommand`对象的使用：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To insert and update data in an SQLite table, we use the common `INSERT` and
    `UPDATE` statements respectively. The highlighted parts of the code indicate the
    usage of SQLite parameters. Both statements are executed on the database at the
    `sqlCom.ExecuteNonQuery()`; line. The `ExecuteNonQuery` has a return value of
    type `int` that indicates the number of rows in the table that were affected.
    So, if we called the method like the following in our example, we would get the
    output `1`, indicating that one row was affected:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SQLite表中插入和更新数据，我们分别使用常见的`INSERT`和`UPDATE`语句。代码中高亮的部分表示了SQLite参数的使用。这两个语句都在`sqlCom.ExecuteNonQuery()`行上对数据库进行执行。`ExecuteNonQuery`的返回值类型为`int`，表示受影响的表中的行数。所以，如果我们像以下示例中那样调用该方法，我们会得到输出`1`，表示影响了一行：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Since we have used the project from the previous task, where we provided code
    for creating the database file, we should add the following code on the beginning
    of each of our methods that perform the data operations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用了上一个任务中的项目，其中我们提供了创建数据库文件的代码，因此我们应该在我们的每个执行数据操作的方法的开始处添加以下代码：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is to make sure that we will not have an exception if the user taps on
    the **insert** or **update** button while there is no database file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保当用户在没有任何数据库文件的情况下点击 **插入** 或 **更新** 按钮时，不会出现异常。
- en: SQLite performance
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQLite 性能
- en: Although SQLite offers great performance and portability, it relies to a great
    extent on its host filesystem, regardless of which platform it is stored on. If
    you want to perform multiple concurrent `INSERT` or `UPDATE` statements, consider
    using an `SqliteTransaction`. Apart from the benefit in performance, by batching
    multiple statements together, a transaction provides a way of rolling back the
    operation if a problem occurs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite提供了出色的性能和可移植性，但它在很大程度上依赖于其宿主文件系统，无论它存储在哪个平台上。如果您想执行多个并发 `INSERT` 或 `UPDATE`
    语句，请考虑使用 `SqliteTransaction`。除了性能上的好处外，通过将多个语句批处理在一起，事务提供了一种在出现问题时回滚操作的方法。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating files*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建文件*'
- en: '*Creating an SQLite database*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 SQLite 数据库*'
- en: '*Querying an SQLite database*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询 SQLite 数据库*'
- en: Querying an SQLite database
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 SQLite 数据库
- en: In this recipe, we will learn how to retrieve data from an SQLite database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何从 SQLite 数据库中检索数据。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we will use the `CreateSQLiteApp` project. Upon completion of this
    task, the project will be a full SQLite management application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `CreateSQLiteApp` 项目。完成此任务后，该项目将是一个完整的 SQLite 管理应用程序。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add another button on the view.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加另一个按钮。
- en: 'Inside the `CreateSQLiteAppViewController` class, add a method that will handle
    the query. The part that performs the query is the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreateSQLiteAppViewController` 类内部，添加一个处理查询的方法。执行查询的部分如下：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To perform a query on an SQLite database, we create a simple `SELECT` statement
    and assign it to the `CommandText` property of the `SqliteCommand` object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SQLite 数据库上执行查询，我们创建一个简单的 `SELECT` 语句并将其分配给 `SqliteCommand` 对象的 `CommandText`
    属性：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The asterisk (*) after the `SELECT` word indicates that we want to retrieve
    all the fields of the table. The simplest way to execute the SQL query is by using
    the `SqliteDataReader` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 关键字后面的星号 (*) 表示我们想要检索表中的所有字段。执行 SQL 查询的最简单方法是通过使用 `SqliteDataReader`
    类：'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `SqliteCommand.ExecuteReader()` method performs the query on the table
    and creates an `SqliteDataReader` object. Now that we have our object, we first
    check if the table contains any rows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqliteCommand.ExecuteReader()` 方法在表上执行查询并创建一个 `SqliteDataReader` 对象。现在我们有了对象，我们首先检查表是否包含任何行：'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the above returns `true`, we begin advancing through each row by passing
    the `SqliteDataReader.Read()` method in a `while` loop:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述返回 `true`，我们开始通过传递 `SqliteDataReader.Read()` 方法在 `while` 循环中逐行前进：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now retrieve each field''s value by passing the name of each field as
    an index on the `SqliteDataReader` instance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过传递每个字段的名称作为 `SqliteDataReader` 实例的索引来检索每个字段的值：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since the indexed `dbReader` variable returns an object of the type `System.Object`,
    we use the `Convert.ToString(object)` static method to convert it to a string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于索引的 `dbReader` 变量返回的是 `System.Object` 类型的对象，我们使用 `Convert.ToString(object)`
    静态方法将其转换为字符串。
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The SQLite database is not thread-safe. If we want to perform queries on a database
    while another thread might be executing `INSERT` or `UPDATE` statements, it would
    be better to provide some sort of synchronization mechanism.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库不是线程安全的。如果我们想在执行查询的同时，另一个线程可能正在执行 `INSERT` 或 `UPDATE` 语句，那么提供某种同步机制会更好。
- en: Query performance
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询性能
- en: Although devices running the iOS platform are performing better than some older
    desktop computers, their resources are still limited in comparison. When querying
    data from large databases, consider narrowing the results to the data that is
    needed at that particular time with the SQL `WHERE` statement. Also, if no sorting
    is required, avoid using `ORDER BY` statements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行 iOS 平台的设备在性能上优于一些较老的桌面计算机，但它们的资源仍然有限。在查询大型数据库中的数据时，请考虑使用 SQL `WHERE` 语句缩小结果，以获取特定时间所需的数据。此外，如果不需要排序，请避免使用
    `ORDER BY` 语句。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating an SQLite database*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 SQLite 数据库*'
- en: '*Inserting and updating data*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插入和更新数据*'
- en: '*Using an already existing SQLite database*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用现有的 SQLite 数据库*'
- en: Using an already existing SQLite database
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有的 SQLite 数据库
- en: In this recipe, we will discuss how to include an already existing SQLite database
    file in our project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何将现有的 SQLite 数据库文件包含到我们的项目中。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is always easier to create databases with some kind of frontend. In this
    task, we will see how to integrate an existing SQLite database with an iPhone
    project. Create a new **iPhone Single View Application** project, and name it
    `SqliteIntegrationApp`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用某种前端创建数据库总是更容易。在这个任务中，我们将了解如何将现有的 SQLite 数据库与 iPhone 项目集成。创建一个新的 **iPhone
    单视图应用程序** 项目，并将其命名为 `SqliteIntegrationApp`。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add a `UIButton` and a `UILabel` on the view in Interface Builder. Connect them
    with the appropriate outlets. Make sure the label is tall enough for six lines,
    and set its **# Lines** field in the **Inspector** tab.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中的视图上添加一个 `UIButton` 和一个 `UILabel`。将它们与适当的出口连接起来。确保标签足够高，可以显示六行，并在
    **检查器** 选项卡中设置其 **# Lines** 字段。
- en: In MonoDevelop, right-click on the project in the **Solution** pad, and click
    **Add Files...**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中，在 **解决方案** 面板中右键单击项目，然后点击 **添加文件...**。
- en: On the dialog box that will be shown, navigate to the path where the database
    file resides and select it. The file will be added in the project.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示的对话框中，导航到数据库文件所在的路径并选择它。文件将被添加到项目中。
- en: Right-click on it and select **Build Action | Content**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它，然后选择 **构建操作 | 内容**。
- en: 'Enter the following methods in the `SqliteIntegrationAppViewController` class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SqliteIntegrationAppViewController` 类中输入以下方法：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The functionality of the `QueryData` method is the same as the method that performs
    the query in the previous task. The main difference is that in this project, it
    will act as the button's TouchUpInside event handler.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QueryData` 方法的功能与之前任务中执行查询的方法相同。主要区别在于，在这个项目中，它将作为按钮的 TouchUpInside 事件处理程序。'
- en: 'Add a field of type `string` that will hold the database path:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为 `string` 的字段，用于存储数据库路径：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And, finally, in the `ViewDidLoad` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `ViewDidLoad` 方法中：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and run the application. Tap on the button, and watch the contents of
    the database being displayed in the label.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。点击按钮，并观察数据库内容在标签中显示。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'What we have done here is a combination of various practices discussed in previous
    tasks. When we want to add various files in a project, it is important that we
    set their **Build Action** to **Content**. Any file that is marked as **Content**
    is being copied as-is in the application bundle. In this case, the file is an
    SQLite database, hence we will need write access to it at runtime. We need to
    copy it in the application''s **Documents** folder. This is what the `CopyDatabase()`
    method does, at this point:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将之前任务中讨论的各种实践相结合。当我们想在项目中添加各种文件时，我们设置它们的 **构建操作** 为 **内容** 非常重要。任何标记为
    **内容** 的文件都会在应用程序包中按原样复制。在这种情况下，文件是一个 SQLite 数据库，因此我们需要在运行时对它有写入权限。我们需要将其复制到应用程序的
    **Documents** 文件夹中。这就是 `CopyDatabase()` 方法在这一点上所做的事情：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is important to check if the file already exists so that it will not be overwritten
    the next time the application is executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否已经存在非常重要，这样它就不会在应用程序下次执行时被覆盖。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you get an `SqliteException`, the first thing to check is if for some reason
    the database file was not copied to the correct folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到 `SqliteException`，首先检查是否由于某种原因数据库文件没有被复制到正确的文件夹。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating files*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建文件*'
- en: '*Creating an SQLite database*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 SQLite 数据库*'
- en: Storing data with serialization
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用序列化存储数据
- en: In this recipe, we will discuss using .NET serialization to store C# objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论使用 .NET 序列化来存储 C# 对象。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **iPhone Single View Application** project in MonoDevelop. Name
    it `SerializationApp`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的 **iPhone 单视图应用程序** 项目。将其命名为 `SerializationApp`。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add two buttons and a label on the view in Interface Builder. Add the following
    using directives in the `SerializationAppViewController.cs` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图上添加两个按钮和一个标签，在 Interface Builder 中。在 `SerializationAppViewController.cs`
    文件中添加以下使用指令：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following methods in the `AppDelegate` class:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中添加以下方法：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The complete code can be found in the `SerializationApp` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在 `SerializationApp` 项目中找到。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Serialization with MonoTouch works the same as in desktop C# applications. The
    `CustomerData` class indicated in the highlighted code is a simple object that
    contains one integer and two string properties.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MonoTouch进行序列化与桌面C#应用程序中的操作相同。在突出显示的代码中指示的`CustomerData`类是一个简单的对象，它包含一个整数和两个字符串属性。
- en: To serialize the object, we first initialize a `MemoryStream:`
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要序列化对象，我们首先初始化一个`MemoryStream`：
- en: '[PRE27]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then use the `BinaryFormatter` class to serialize the object and store it
    into the stream:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`BinaryFormatter`类来序列化对象并将其存储到流中：
- en: '[PRE28]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the serialization, we reset the stream''s position to its beginning,
    and read the data from it into a byte array:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化后，我们将流的位置重置为其开始处，并将数据从流中读取到字节数组中：
- en: '[PRE29]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To deserialize the object from the buffer, the process is similar, but in the
    reverse order. After the `MemoryStream` initialization, we reset the stream''s
    position to its beginning and use the `Deserialize` method of the `BinaryFormatter`.
    It returns an object of type `System.Object`, so we need to cast it to the type
    of our object:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从缓冲区反序列化对象，过程类似，但顺序相反。在`MemoryStream`初始化后，我们将流的位置重置为其开始处，并使用`BinaryFormatter`的`Deserialize`方法。它返回一个`System.Object`类型的对象，因此我们需要将其转换为我们的对象类型：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One important thing to remember when serializing objects with MonoTouch is
    to decorate the objects that will be serialized with the `PreserveAttribute`.
    This attribute instructs the linker to avoid stripping the object of unused members,
    keeping it intact. The `CustomerData` class in this task is declared as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MonoTouch序列化对象时，有一件重要的事情要记住，那就是用`PreserveAttribute`装饰将要序列化的对象。此属性指示链接器避免删除未使用的成员，保持对象完整。在这个任务中声明的`CustomerData`类如下：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Serializable objects
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可序列化对象
- en: This is a simple example to display the use of binary serialization in an iOS
    application. Objects can be customized for serialization by inheriting the `ISerializable`
    C# interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，用于展示在iOS应用程序中使用二进制序列化的用法。可以通过继承`ISerializable` C#接口来定制用于序列化的对象。
- en: When creating an object that will be used for serialization, do not forget to
    mark it with the `SerializableAttribute`. An exception will occur when trying
    to serialize objects that are not marked with this attribute.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建用于序列化的对象时，不要忘记用`SerializableAttribute`标记它。如果尝试序列化未标记此属性的对象，将会发生异常。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Storing data with XML*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用XML存储数据*'
- en: 'In this book:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。开发工具"),开发工具：'
- en: '*Compiling*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译*'
- en: Storing data with XML
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XML存储数据
- en: In this recipe, we will discuss how to store data with XML serialization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何使用XML序列化存储数据。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **iPhone Single View Application** project in MonoDevelop, and
    name it `XMLDataApp`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的**iPhone单视图应用程序**项目，并将其命名为`XMLDataApp`。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a `UIButton` and a `UILabel` on the view. Add the class `CustomerData`
    from the previous task to the project. Add the following `using` directives in
    the `XMLDataAppViewController.cs` file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加一个`UIButton`和一个`UILabel`。将上一个任务中的`CustomerData`类添加到项目中。在`XMLDataAppViewController.cs`文件中添加以下`using`指令：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following method in the `XMLDataAppViewController` class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`XMLDataAppViewController`类中添加以下方法：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The complete solution can be found in the `XMLDataApp` project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的解决方案可以在`XMLDataApp`项目中找到。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this example, we are using the `XmlSerializer` class to serialize an object
    to XML. The `StringBuilder` object will hold the XML data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`XmlSerializer`类将对象序列化为XML。`StringBuilder`对象将保存XML数据：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To initialize the `XmlSerializer`, we use its `XmlSerializer(System.Type)`
    constructor, passing as a parameter the type of the object we want to serialize:
    `(typeof(CustomerData))`. We than call its `Serialize(XmlWriter, object)` method,
    which will perform the actual serialization and store the output XML to the `StringBuilder`,
    through the `XmlWriter` class, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化`XmlSerializer`，我们使用它的`XmlSerializer(System.Type)`构造函数，将我们想要序列化的对象的类型作为参数传递：`(typeof(CustomerData))`。然后我们调用它的`Serialize(XmlWriter,
    object)`方法，该方法将执行实际的序列化并将输出XML存储到`StringBuilder`中，通过`XmlWriter`类，如下所示：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you compile and run the application, you will see the output XML in the
    label.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行应用程序时，你将在标签中看到输出XML。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are two main advantages in using XML to store data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XML存储数据有两个主要优势：
- en: The output is pure text, as opposed to binary serialization, which makes it
    human readable.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出是纯文本，与二进制序列化不同，这使得它易于阅读。
- en: Data can be transmitted or received to and from different types of applications,
    websites, and so on that are not necessarily written in C#.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据可以传输或接收来自不同类型的应用程序、网站等，这些应用程序和网站不一定是用C#编写的。
- en: Deserialization
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反序列化
- en: 'To deserialize our object from XML, we would use the following line:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要从XML反序列化我们的对象，我们将使用以下行：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Storing data with serialization*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用序列化存储数据*'
- en: '*Managing XML data with LINQ to XML*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用LINQ to XML管理XML数据*'
- en: Managing XML data with LINQ to XML
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LINQ to XML管理XML数据
- en: In this recipe, we will learn how to manage XML data using **Language INtegrated
    Query (LINQ)** .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用**语言集成查询（LINQ）**来管理XML数据。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we are going to use the project `XMLDataApp` from the previous
    task. Open it in MonoDevelop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将使用上一个任务中的项目`XMLDataApp`。在MonoDevelop中打开它。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add another `UIButton` on the view. Add a reference to the `System.Xml.Linq`
    assembly and the following `using` directive in the `XMLDataAppViewController.cs`
    file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加另一个`UIButton`。在`XMLDataAppViewController.cs`文件中添加对`System.Xml.Linq`程序集的引用和以下`using`指令：
- en: '[PRE37]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Enter the following method in the `XMLDataAppViewController` class:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`XMLDataAppViewController`类中输入以下方法：
- en: '[PRE38]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: LINQ is very versatile and straightforward in querying XML data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ在查询XML数据方面非常灵活且直观。
- en: 'The first thing we do is create an `XDocument` from our XML data:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从我们的XML数据创建一个`XDocument`：
- en: '[PRE39]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After this, we create a query on its `Descendants()` method, which returns an
    `IEnumerable<XElement>` object. Each `XElement` object corresponds to an XML element.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们对其`Descendants()`方法创建一个查询，该方法返回一个`IEnumerable<XElement>`对象。每个`XElement`对象对应一个XML元素。
- en: 'Using the information of each `XElement` returned, we construct our `CustomerData`
    object in the `select` statement:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回的每个`XElement`的信息，我们在`select`语句中构建我们的`CustomerData`对象：
- en: '[PRE40]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To retrieve the created object, we call the extension method `FirstOrDefault()`
    on the query:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索创建的对象，我们在查询上调用扩展方法`FirstOrDefault()`：
- en: '[PRE41]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The XML in this example contains only one object of the type `CustomerData`.
    If there were more, we could narrow down the results, providing a `where` statement:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，XML只包含一个类型为`CustomerData`的对象。如果有更多，我们可以通过提供一个`where`语句来缩小结果：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Anonymous types in LINQ
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: LINQ中的匿名类型
- en: In MonoTouch, we can also use C#'s powerful feature of anonymous types in queries,
    for example, `select new { ID = … }`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoTouch中，我们还可以在查询中使用C#的强大功能——匿名类型，例如，`select new { ID = … }`
- en: See also
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Storing data with serialization*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用序列化存储数据*'
- en: '*Storing data*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储数据*'
