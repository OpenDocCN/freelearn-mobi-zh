- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Classes, Structures, and Protocols
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、结构体和协议
- en: 'The first programming language that I learned was BASIC. It was a good language
    to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr
    (yes, I had a PCjr and I really enjoyed it), I realized that there were other,
    more advanced languages out there, and I spent a lot of time learning Pascal and
    C. It wasn''t until I started college that I heard the term **object-oriented
    programming language**. At that time, object-oriented programming languages were
    so new that there were no real courses on them, but I was able to experiment a
    little with C++. After I graduated, I left object-oriented programming behind,
    and it really wasn''t until several years later, when I started to experiment
    with C++ again, that I really discovered the power and flexibility of object-oriented
    programming. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初学习的编程语言是 BASIC。这是一个开始编程的好语言，但当我用 Commodore Vic-20 交换了 PCjr（是的，我有一台 PCjr，我真的很喜欢它）后，我意识到还有其他更高级的语言，我花了很多时间学习
    Pascal 和 C。直到我开始上大学，我才听到**面向对象编程语言**这个术语。当时，面向对象编程语言还非常新，没有真正的课程，但我能够用 C++ 进行一些实验。毕业后，我放弃了面向对象编程，直到几年后，当我再次开始尝试
    C++ 时，我才真正发现了面向对象编程的强大和灵活性。在本章中，我们将涵盖以下主题：
- en: What are classes and structures?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类和结构体？
- en: How to add properties and property observers to classes and structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向类和结构体添加属性和属性观察器
- en: How to add methods to classes and structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向类和结构体添加方法
- en: How to add initializers to classes and structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向类和结构体添加初始化器
- en: How and when to use access controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时使用访问控制
- en: How to create a class hierarchy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建类层次结构
- en: How to extend a class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展类
- en: What are classes and structures?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类和结构体？
- en: 'In Swift, classes and structures are very similar. If we really want to master
    Swift, it is very important to not only understand what makes classes and structures
    so similar, but to also understand what sets them apart, because they are the
    building blocks of our applications. Apple describes them as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，类和结构体非常相似。如果我们真的想精通 Swift，不仅理解使类和结构体如此相似的原因非常重要，而且理解使它们区别开来的原因也非常重要，因为它们是我们应用程序的构建块。苹果公司是这样描述它们的：
- en: Classes and structures are general-purpose, flexible constructs that become
    the building blocks of your program's code. You define properties and methods
    to add functionality to your classes and structures by using the already familiar
    syntax of constants, variables, and functions.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类和结构体是通用、灵活的构造，它们成为你程序代码的构建块。你可以通过使用已经熟悉的常量、变量和函数的语法来定义属性和方法，为你的类和结构体添加功能。
- en: Let's begin by taking a quick look at some of the similarities between classes
    and structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速看一下类和结构体之间的一些相似之处。
- en: Similarities between classes and structures
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和结构体之间的相似之处
- en: 'In Swift, classes and structures are more similar than they are in other languages,
    such as Objective-C. The following is a list of some of the features that classes
    and structures share:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，类和结构体比在其他语言（如 Objective-C）中更相似。以下是类和结构体共享的一些功能列表：
- en: '**Properties**: These are used to store information in our classes and structures'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**: 这些用于在类和结构体中存储信息'
- en: '**Methods**: These provide functionality for our classes and structures'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**: 这些为我们的类和结构体提供功能'
- en: '**Initializers**: These are used when initializing instances of our classes
    and structures'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化器**: 这些用于初始化我们的类和结构体实例'
- en: '**Subscripts**: These provide access to values using the subscript syntax'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下标**: 这些通过下标语法提供对值的访问'
- en: '**Extensions**: These help extend both classes and structures'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**: 这些有助于扩展类和结构体'
- en: Now, let's take a quick look at some of the differences between classes and
    structures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下类和结构体之间的一些区别。
- en: Differences between classes and structures
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和结构体之间的区别
- en: 'While classes and structures are very similar, there are also several very
    important differences. The following is a list of some of the differences between
    classes and structures in Swift:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类和结构体非常相似，但也有几个非常重要的区别。以下是 Swift 中类和结构体之间的一些区别列表：
- en: '**Type**: A structure is a value type, while a class is a reference type'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**: 结构体是一个值类型，而类是一个引用类型'
- en: '**Inheritance**: A structure cannot inherit from other types, while a class
    can'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**: 结构体不能从其他类型继承，而类可以'
- en: '**Deinitializers**: Structures cannot have custom deinitializers, while a class
    can'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**析构器**：结构体不能有自定义析构器，而类可以'
- en: Throughout this chapter, we will be emphasizing the differences between classes
    and structures to help us understand when to use each. Before we really dive into
    classes and structures, let's look at the difference between value types (structures)
    and reference types (classes). To fully understand when to use classes and structures
    and how to properly use them, it is important to understand the difference between
    value and reference types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将强调类和结构体之间的区别，以帮助我们了解何时使用每个。在我们真正深入类和结构体之前，让我们看看值类型（结构体）和引用类型（类）之间的区别。为了完全理解何时使用类和结构体以及如何正确使用它们，理解值类型和引用类型之间的区别非常重要。
- en: Value versus reference types
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: 'Structures are value types. When we pass instances of a structure within our
    application, we pass a copy of the structure and not the original structure. Classes
    are reference types; therefore, when we pass an instance of a class within our
    application, a reference to the original instance is passed. It is very important
    to understand this difference. We will give a very high-level view here and will
    provide additional details in *Chapter 18*, *Memory Management*. When we pass
    structures within our application, we are passing copies of the structures and
    not the original structures. Since the function gets its own copy of the structure,
    it can change it as needed without affecting the original instance of the structure.
    When we pass an instance of a class within our application, we are passing a reference
    to the original instance of the class. Since we''re passing the instance of the
    class to the function, the function is getting a reference to the original instance;
    therefore, any changes made within the function will remain once the function
    exits. To illustrate the difference between value and reference types, let''s
    look at a real-world object: a book. If we have a friend who wants to read *Mastering
    Swift 5.3*, we could either buy them their own copy or share ours. If we bought
    our friend their own copy of the book, any notes they made within the book would
    remain in their copy of the book and would not be reflected in our copy. This
    is how passing by value works with structures and variables. Any changes that
    are made to the structure or variable within the function are not reflected in
    the original instance of the structure or variable. If we share our copy of the
    book, any notes they made within the book would stay in the book when they return
    it to us. This is how passing by reference works. Any changes that are made to
    the instance of the class remain when the function exits.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是值类型。当我们在我们应用程序中传递结构体的实例时，我们传递的是结构体的一个副本，而不是原始的结构体。类是引用类型；因此，当我们在我们应用程序中传递类的实例时，传递的是原始实例的引用。理解这种区别非常重要。在这里，我们将提供一个非常高级的概述，并在*第18章*，*内存管理*中提供更多细节。当我们在我们应用程序中传递结构体时，我们传递的是结构体的副本，而不是原始的结构体。由于函数会得到结构体自己的副本，因此它可以按需更改它，而不会影响结构体的原始实例。当我们在我们应用程序中传递类的实例时，我们传递的是类的原始实例的引用。由于我们将类的实例传递给函数，函数得到的是原始实例的引用；因此，在函数退出后，函数内所做的任何更改都将保留。为了说明值类型和引用类型之间的区别，让我们看看一个现实世界的对象：一本书。如果我们有一个朋友想阅读*精通Swift
    5.3*，我们要么可以为他们买一本自己的书，要么分享我们的书。如果我们为我们朋友买了一本自己的书，他们在书中做的任何笔记都会保留在他们自己的书里，而不会反映在我们的副本中。这就是结构体和变量按值传递的方式。在函数中对结构体或变量所做的任何更改都不会反映在结构体或变量的原始实例中。如果我们分享我们的书，他们在还书时在书中做的任何笔记都会保留在书中。这就是按引用传递的方式。对类的实例所做的任何更改在函数退出后都将保留。
- en: Creating a class or structure
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类或结构体
- en: We use the same syntax to define classes and structures. The only difference
    is that we define a class using the `class` keyword and a structure using the
    `struct` keyword.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的语法来定义类和结构体。唯一的区别是我们使用`class`关键字定义类，使用`struct`关键字定义结构体。
- en: 'Let''s look at the syntax that''s used to create both classes and structures:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于创建类和结构体的语法：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we define a new class named `MyClass` and a new structure
    named `MyStruct`. This effectively creates two new Swift types, named `MyClass`
    and `MyStruct`. When we name a new type, we want to use the standard naming convention
    set by Swift, where the name is in camel case, with the first letter being uppercase.
    This is also known as `PascalCase`. Any method or property defined within the
    class or structure should also be named using camel case, with the first letter
    being uppercase. Empty classes and structures are not that useful, so let's look
    at how we can add properties to our classes and structures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`MyClass`的新类和一个名为`MyStruct`的新结构体。这实际上创建了两个新的Swift类型，分别命名为`MyClass`和`MyStruct`。当我们命名一个新类型时，我们希望使用Swift设定的标准命名约定，即名称采用驼峰式，首字母大写。这也被称为`PascalCase`。在类或结构体内部定义的任何方法或属性也应使用驼峰式命名，首字母大写。空类和结构体并不那么有用，因此让我们看看我们如何向我们的类和结构体添加属性。
- en: Properties
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties associate values with a class or a structure. There are two types
    of properties:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 属性将值与类或结构体关联。属性有两种类型：
- en: '**Stored properties**: These will store variable or constant values as part
    of an instance of a class or structure. Stored properties can also have property
    observers that can monitor the property for changes and respond with custom actions
    when the value of the property changes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储属性**: 这些属性将变量或常量值作为类或结构体实例的一部分进行存储。存储属性还可以有属性观察器，可以监视属性的变化，并在属性值发生变化时执行自定义操作。'
- en: '**Computed properties**: These do not store a value themselves but instead
    retrieve and possibly set other properties. The value returned by a computed property
    can also be calculated when it is requested.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算属性**: 这些属性本身不存储值，而是检索并可能设置其他属性。计算属性的返回值也可以在请求时计算。'
- en: Stored properties
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储属性
- en: 'A stored property is a variable or constant that is stored as part of an instance
    of a class or structure. These are defined with the `var` and `let` keywords,
    just like normal variables and constants. In the following code, we will create
    a structure named `MyStruct` and a class named `MyClass`. The structure and the
    class both contain two stored properties, `c` and `v`. The stored property, `c`,
    is a constant because it is defined with the `let` keyword, and `v` is a variable
    because it is defined with the `var` keyword. Let''s look at the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存储属性是作为类或结构体实例的一部分存储的变量或常量。这些属性使用`var`和`let`关键字定义，就像普通变量和常量一样。在以下代码中，我们将创建一个名为`MyStruct`的结构体和一个名为`MyClass`的类。该结构体和类都包含两个存储属性`c`和`v`。存储属性`c`是一个常量，因为它使用`let`关键字定义，而`v`是一个变量，因为它使用`var`关键字定义。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see from the preceding example, the syntax to define a stored property
    is the same for both classes and structures. Let''s look at how we would create
    an instance of both the structure and class. The following code creates an instance
    of the `MyStruct` structure, named `myStruct`, and an instance of the `MyClass`
    class, named `myClass`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，定义存储属性的语法对类和结构体都是相同的。让我们看看我们将如何创建结构体和类的实例。以下代码创建了一个名为`myStruct`的`MyStruct`结构体实例和一个名为`myClass`的`MyClass`类实例：
- en: 'One of the differences between structures and classes is that, by default,
    a structure creates an initializer that lets us populate the stored properties
    when we create an instance of the structure. Therefore, we could also create an
    instance of `MyStruct` like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体和类之间的一种区别是，默认情况下，结构体会创建一个初始化器，允许我们在创建结构体实例时填充存储属性。因此，我们也可以像这样创建`MyStruct`的实例：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, the initializer is used to set the `v` variable,
    and the `c` constant will still contain the number `5`, which is defined in the
    structures. If we did not give the constant an initial value, as shown in the
    following example, the default initializer would be used to set the constant as
    well:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，初始化器用于设置`v`变量，而`c`常量仍然包含在结构体中定义的数字`5`。如果我们没有为常量提供一个初始值，如以下示例所示，则默认初始化器也会用于设置常量：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following example shows how the initializer for this new structure would
    work:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了此新结构体的初始化器将如何工作：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This allows us to define a constant where we set the value when we initialize
    the class or structure at runtime, rather than hardcoding the value of the constant
    within the type. The order in which the parameters appear in the initializer is
    the order in which we defined them. In the previous example, we defined the `c`
    constant first, therefore, it is the first parameter in the initializer. We defined
    the `v` parameter next, therefore, it is the second parameter in the initializer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在运行时初始化类或结构体时设置值，而不是在类型内硬编码常量的值。参数在初始化器中出现的顺序是我们定义它们的顺序。在先前的例子中，我们首先定义了
    `c` 常量，因此它是初始化器中的第一个参数。接下来我们定义了 `v` 参数，因此它是初始化器中的第二个参数。
- en: 'Starting in Swift 5.1 with SE-0242, the initializer for structures has been
    enhanced so that default values can be added to any parameter, making the parameter
    optional in the initializer. Let''s create a new structure that illustrates this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swift 5.1 开始，随着 SE-0242 的引入，结构体的初始化器得到了增强，可以给任何参数添加默认值，使得参数在初始化器中是可选的。让我们创建一个新的结构体来说明这一点：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we define three parameters, a, b, and c, where both the b and
    c parameters have default values. We are now able to initialize the `MyStruct`
    structure in any of the following ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了三个参数，a、b 和 c，其中 b 和 c 参数都有默认值。现在我们可以以下任何一种方式初始化 `MyStruct` 结构体：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are able to leave the c parameter or the b and c parameters undefined within
    the initializer because we set default values when we defined the parameters.
    One thing to note is the following code will throw an error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在初始化器中省略 c 参数或 b 和 c 参数，因为我们定义参数时设置了默认值。需要注意的是以下代码将抛出错误：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we defined the parameters within the structure, we defined parameter a
    first, followed by b, and then c, which means the order within the initializer
    is also a followed by b, and then c. When we make multiple parameters that are
    optional, we cannot leave off one of the parameters but still include others that
    come after it, therefore we cannot leave off parameter a and still include parameters
    `b` and c.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在结构体中定义参数时，我们首先定义参数 a，然后是 b，最后是 c，这意味着初始化器中的顺序也是 a，然后是 b，最后是 c。当我们使多个参数成为可选时，我们不能省略其中一个参数但仍包括其后的其他参数，因此我们不能省略参数
    a 而仍然包括参数 `b` 和 `c`。
- en: 'To set or read a stored property, we use the standard dot syntax. Let''s look
    at how we would set and read stored properties in Swift:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置或读取存储属性，我们使用标准的点语法。让我们看看在 Swift 中如何设置和读取存储属性：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the first line of code, we read the `c` property and store it into a variable
    named `x`. In the second line of code, we set the `v` property to the `Howdy`
    string. Before we move on to computed properties, let''s create both a structure
    and a class that will represent an employee. We will be using and expanding these
    throughout this chapter to show how classes and structures are similar, and how
    they differ:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行中，我们读取 `c` 属性并将其存储在一个名为 `x` 的变量中。在第二行代码中，我们将 `v` 属性设置为 `Howdy` 字符串。在我们继续到计算属性之前，让我们创建一个表示员工的结构体和类。我们将在此章中使用并扩展这些内容，以展示类和结构体的相似之处以及它们的不同之处：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The employee structure is named `EmployeeStruct`, and the employee class is
    named `EmployeeClass`. Both the class and structure have three stored properties:
    `firstName`, `lastName`, and `salaryYear`. Within the structure and class, we
    can access these properties by using the name of the property and the `self` keyword.
    Every instance of a structure or class has a property named `self`. This property
    refers to the instance itself; therefore, we can use it to access the properties
    within the instance. The following examples show how we can access the properties
    with the `self` keyword within the instance of the structure or class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 员工结构体的名称为 `EmployeeStruct`，员工类的名称为 `EmployeeClass`。类和结构体都有三个存储属性：`firstName`、`lastName`
    和 `salaryYear`。在结构体和类中，我们可以通过使用属性名和 `self` 关键字来访问这些属性。每个结构体或类的实例都有一个名为 `self`
    的属性。这个属性指向实例本身；因此，我们可以用它来访问实例内的属性。以下示例展示了如何在结构体或类的实例中使用 `self` 关键字来访问属性：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Computed properties
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'Computed properties are properties that do not have backend variables, which
    are used to store the values associated with the property but are hidden from
    the external code. The values of a computed property are usually computed when
    code requests it. You can think of a computed property as a function disguised
    as a property. Let''s look at how we would define a read-only computed property:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是没有后端变量的属性，这些变量用于存储与属性相关的值，但对外部代码是隐藏的。计算属性的值通常在代码请求时计算。你可以将计算属性视为一个伪装成属性的函数。让我们看看如何定义一个只读计算属性：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To create a read-only computed property, we begin by defining it as if it were
    a normal variable with the `var` keyword, followed by the variable name, a colon,
    and the variable type. What comes next is different; we add a curly bracket at
    the end of the declaration and then define a getter method, which is called when
    the value of our computed property is requested. In this example, the getter method
    divides the current value of the `salaryYear` property by 52 to get the employee's
    weekly salary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个只读计算属性，我们首先使用`var`关键字定义它，就像定义一个普通变量一样，然后是变量名，一个冒号，以及变量类型。接下来的是不同的；我们在声明末尾添加一个花括号，然后定义一个getter方法，当请求计算属性的值时会被调用。在这个例子中，getter方法将`salaryYear`属性的当前值除以52，以获取员工的周薪。
- en: 'We can simplify the definition of the read-only computed property by removing
    the `get` keyword, as shown in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除`get`关键字来简化只读计算属性的定义，如下例所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Computed properties are not limited to being read-only; we can also write to
    them. To enable the `salaryWeek` property to be writeable, we will add a setter
    method. The following example shows how we add a setter method that will set the
    `salaryYear` property, based on the value being passed into the `salaryWeek` property:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性不仅限于只读；我们也可以向它们写入。为了使`salaryWeek`属性可写，我们将添加一个setter方法。以下示例展示了我们如何添加一个setter方法，该方法将根据传递给`salaryWeek`属性的值设置`salaryYear`属性：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can simplify the setter definition by not defining a name for the new value.
    In this case, the value will be assigned to a default variable named `newValue`,
    as shown in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不定义新值的名称来简化setter定义。在这种情况下，值将被分配给默认变量`newValue`，如下例所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `salaryWeek` computed property, as written in the preceding examples, could
    be added to either the `EmployeeClass` class or the `EmployeeStruct` structure
    without any modifications. Let''s see how we can do this by adding the `salaryWeek`
    property to our `EmployeeClass` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例中所示，`salaryWeek`计算属性可以添加到`EmployeeClass`类或`EmployeeStruct`结构体中，无需任何修改。让我们看看如何通过将`salaryWeek`属性添加到我们的`EmployeeClass`类中来实现这一点：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s look at how we can add the `salaryWeek` computed property to the
    `EmployeeStruct` structure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将`salaryWeek`计算属性添加到`EmployeeStruct`结构体中：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, the class and structure definitions are the same so far, except
    for the initial `class` or `struct` keywords that are used to define them. We
    read and write to a computed property exactly as we would to a stored property.
    Code that is external to the class or structure should not be aware that the property
    is a computed property. Let''s see this in action by creating an instance of the
    `EmployeeStruct` structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，类和结构定义到目前为止是相同的，只是用于定义它们的初始`class`或`struct`关键字不同。我们读写计算属性的方式与读写存储属性的方式完全相同。类或结构体外部的代码不应知道该属性是计算属性。让我们通过创建`EmployeeStruct`结构体的实例来观察这一点：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example starts off by creating an instance of the `EmployStruct`
    structure with the `salaryYear` value being set to 39,000\. Next, we print the
    value of the `salaryWeek` property to the console. This value is currently 750.00\.
    We then set the `salaryWeek` property to 1,000.00 and print out both the `salaryWeek`
    and `salaryYear` properties to the console. The values of the `salaryWeek` and
    `salaryYear` properties are now 1,000.00 and 52,000, respectively. As we can see,
    in this example, setting either the `salaryWeek` or `salaryYear` properties changes
    the values returned by both. Computed properties can be very useful for offering
    different views of the same data. For example, if we had a value that represented
    the length of something, we could store the length in centimeters and then use
    computed properties that calculate the values for meters, millimeters, and kilometers.
    Now, let's look at property observers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上一示例首先创建了一个`EmployStruct`结构的实例，并将`salaryYear`的值设置为39,000。接下来，我们将`salaryWeek`属性的值打印到控制台。这个值目前是750.00。然后我们将`salaryWeek`属性设置为1,000.00，并将`salaryWeek`和`salaryYear`属性的值都打印到控制台。现在`salaryWeek`和`salaryYear`属性的值分别是1,000.00和52,000。正如我们所看到的，在这个例子中，设置`salaryWeek`或`salaryYear`属性中的任何一个都会改变两个属性返回的值。计算属性可以非常有用，可以提供相同数据的不同视图。例如，如果我们有一个表示某物长度的值，我们可以将长度存储为厘米，然后使用计算属性来计算米、毫米和千米的值。现在，让我们看看属性观察者。
- en: Property observers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性观察者
- en: 'Property observers are called every time the value of the property is set.
    We can add property observers to any non-lazy stored property. We can also add
    property observers to any inherited stored or computed property by overriding
    the property in the subclass, which we will look at in the *Overriding properties*
    section. There are two property observers that we can set in Swift: `willSet`
    and `didSet`. The `willSet` observer is called right before the property is set,
    and the `didSet` observer is called right after the property is set. One thing
    to note about property observers is that they are not called when the value is
    set during initialization. Let''s look at how we can add a property observer to
    the salary property of our `EmployeeClass` class and `EmployeeStruct` structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每当属性的值被设置时，都会调用属性观察者。我们可以将属性观察者添加到任何非延迟存储属性。我们还可以通过在子类中重写属性来将属性观察者添加到任何继承的存储或计算属性，我们将在*重写属性*部分讨论这一点。Swift中有两种可以设置的属性观察者：`willSet`和`didSet`。`willSet`观察者在属性被设置之前被调用，而`didSet`观察者在属性被设置之后被调用。关于属性观察者需要注意的一点是，它们在初始化过程中设置值时不会被调用。让我们看看如何将属性观察者添加到我们的`EmployeeClass`类和`EmployeeStruct`结构中的工资属性：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we add a property observer to a stored property, we need to include the
    type of the value being stored within the definition of the property. In the preceding
    example, we did not need to define our `salaryYear` property as a `Double` type;
    however, when we add property observers, the definition is required. After the
    property definition, we define the `willSet` observer, which simply prints out
    the new value that the `salaryYear` property will be set to. We also define a
    `didSet` observer, which will check whether the new value is greater than the
    old value, and if so, it will print out that the employee got a raise; otherwise,
    it will print out that the employee did not get a raise. As with the getter method
    with computed properties, we do not need to define the name for the new value
    of the `willSet` observer. If we do not define a name, the new value is put in
    a constant named `newValue`. The following example shows how we can rewrite the
    previous `willSet` observer without defining a name for the new value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向一个存储属性添加属性观察者时，我们需要在属性的定义中包含要存储的值的类型。在上一示例中，我们不需要将我们的`salaryYear`属性定义为`Double`类型；然而，当我们添加属性观察者时，定义是必需的。在属性定义之后，我们定义了`willSet`观察者，它简单地打印出`salaryYear`属性将被设置为的新值。我们还定义了一个`didSet`观察者，它将检查新值是否大于旧值，如果是，它将打印出员工得到了加薪；否则，它将打印出员工没有得到加薪。与计算属性的getter方法一样，我们不需要为新值定义名称。如果我们不定义名称，新值将被放入一个名为`newValue`的常量中。以下示例显示了如何在不为新值定义名称的情况下重写之前的`willSet`观察者：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we have seen, properties are mainly used to store information associated
    with a class or structure. Methods are mainly used to add the business logic to
    a class or structure. Let's look at how we can add methods to a class or structure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，属性主要用于存储与类或结构体相关联的信息。方法主要用于向类或结构体添加业务逻辑。让我们看看我们如何向类或结构体添加方法。
- en: Methods
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'Methods are functions that are associated with an instance of a class or structure.
    A method, like a function, will encapsulate the code for a specific task or functionality
    that is associated with the class or structure. Let''s look at how we can define
    methods for classes and structures. The following code will return the full name
    of the employee by using the `firstName` and `lastName` properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与类或结构体实例相关联的函数。与函数一样，方法将封装与类或结构体相关联的特定任务或功能的相关代码。让我们看看我们如何为类和结构体定义方法。以下代码将使用`firstName`和`lastName`属性返回员工的完整姓名：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define this method exactly as we would define any function. A method is simply
    a function that is associated with a specific class or structure, and everything
    that we learned about functions in the previous chapters applies to methods. The
    `fullName()` function can be added directly to the `EmployeeClass` class or `EmployeeStruct`
    structure without any modification. To access a method, we use the same dot syntax
    we used to access properties.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义这个方法就像定义任何函数一样。方法只是一个与特定类或结构体相关联的函数，我们在前几章中学到的关于函数的所有内容都适用于方法。`fullName()`函数可以直接添加到`EmployeeClass`类或`EmployeeStruct`结构体中，无需任何修改。要访问方法，我们使用与访问属性相同的点语法。
- en: 'The following code shows how we access the `fullName()` method of a class and
    a structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何访问类和结构体的`fullName()`方法：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding example, we initialize an instance of both the `EmployeeClass`
    class and the `EmployeeStruct` structure. We populate the structure and class
    with the same information and then use the `fullName()` method to print the full
    name of the employee to the console. In both cases, `Jon Hoffman` is printed to
    the console. There is a difference in how we define methods for classes and structures
    that need to update property values. Let''s look at how we define a method that
    gives an employee a raise within the `EmployeeClass` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们初始化了`EmployeeClass`类和`EmployeeStruct`结构体的实例。我们用相同的信息填充结构和类，然后使用`fullName()`方法将员工的完整姓名打印到控制台。在两种情况下，都会打印出“Jon
    Hoffman”。在定义需要更新属性值的类和结构体的方法时，存在差异。让我们看看我们如何在`EmployeeClass`类中定义一个给员工加薪的方法：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we add the preceding code to our `EmployeeClass`, it works as expected,
    and when we call the method with an amount, the employee gets a raise. However,
    if we try to add this method as it is written to the `EmployeeStruct` structure,
    we receive a `mark` method and a `mutating to make self mutable` error. By default,
    we are not allowed to update property values within a method of a structure. If
    we want to modify a property, we can mutate the behavior for that method by adding
    the `mutating` keyword before the `func` keyword of the method declaration. Therefore,
    the following code would be the correct way to define the `giveRaise(amount:)`
    method for the `EmployeeStruct` structure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码添加到我们的`EmployeeClass`中，它将按预期工作，当我们用金额调用该方法时，员工会得到加薪。然而，如果我们尝试将此方法以当前形式添加到`EmployeeStruct`结构体中，我们会收到一个`mark`方法和一个`mutating
    to make self mutable`错误。默认情况下，我们不允许在结构体的方法中更新属性值。如果我们想修改一个属性，我们可以通过在方法声明的`func`关键字之前添加`mutating`关键字来修改该方法的`mutating`行为。因此，以下代码将是为`EmployeeStruct`结构体定义`giveRaise(amount:)`方法的正确方式：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding examples, we use the `self` property to refer to the current
    instance of the type within the instance itself, so when we write `self.salaryYear`,
    we ask for the value of the `salaryYear` property for the current instance of
    the type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`self`属性来引用实例本身内部的当前类型实例，因此当我们写`self.salaryYear`时，我们要求当前类型实例的`salaryYear`属性的值。
- en: The `self` property should only be used when necessary. We are using it in these
    examples to illustrate what it is and how to use it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`属性仅在必要时使用。我们在这些示例中使用它来展示它是什么以及如何使用它。'
- en: 'The `self` property is mainly used to distinguish between local and instance
    variables that have the same name. Let''s look at an example that illustrates
    this. We can add this function to either the `EmployeeClass` or `EmployeeStruct`
    type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 属性主要用于区分具有相同名称的局部变量和实例变量。让我们通过一个示例来解释这一点。我们可以将此函数添加到 `EmployeeClass`
    或 `EmployeeStruct` 类型中：'
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the method accepts an argument named `firstName`.
    There is also a property within the type that has the same name. We use the `self`
    property to specify that we want the instance property with the `firstName` name,
    and not the local variable with this name. Other than the `mutating` keyword being
    required for methods that change the value of the structure's properties, methods
    can be defined and used exactly as functions are defined and used. Therefore,
    everything we learned about functions in *Chapter 6*, *Functions*, can be applied
    to methods. There are times when we want to initialize properties or perform some
    business logic when a class or structure is first initialized. For this, we will
    use an initializer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该方法接受一个名为 `firstName` 的参数。在该类型中还有一个具有相同名称的属性。我们使用 `self` 属性来指定我们想要具有
    `firstName` 名称的实例属性，而不是具有此名称的局部变量。除了对于需要更改结构属性值的 `mutating` 关键字是必需的外，方法可以像函数定义和使用一样定义和使用。因此，我们在
    *第6章*，*函数* 中学到的所有关于函数的知识都可以应用到方法上。有时我们希望在类或结构首次初始化时初始化属性或执行一些业务逻辑。为此，我们将使用初始化器。
- en: Custom initializers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义初始化器
- en: 'Initializers are called when we initialize a new instance of a type (class
    or structure). Initialization is the process of preparing an instance for use.
    The initialization process can include setting initial values for stored properties,
    verifying that external resources are available, or setting up the UI properly.
    Initializers are generally used to ensure that the instance of the class or structure
    is properly initialized prior to first use. Initializers are special methods that
    are used to create a new instance of a type. We define an initializer similarly
    to defining other methods, but we must use the `init` keyword as the name of the
    initializer to tell the compiler that this method is an initializer. In its simplest
    form, the initializer does not accept any arguments. Let''s look at the syntax
    that''s used to write a simple initializer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化一个类型（类或结构）的新实例时，会调用初始化器。初始化是准备实例以供使用的进程。初始化过程可能包括设置存储属性的初始值、验证外部资源是否可用，或正确设置用户界面。初始化器通常用于确保类或结构的实例在使用前得到适当的初始化。初始化器是用于创建类型新实例的特殊方法。我们定义初始化器的方式与定义其他方法类似，但我们必须使用
    `init` 关键字作为初始化器的名称，以告知编译器此方法是一个初始化器。在其最简单形式中，初始化器不接受任何参数。让我们看看用于编写简单初始化器的语法：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This format works for both classes and structures. By default, all classes
    and structures have an empty default initializer that can be overridden. We used
    these default initializers when we initialized the `EmployeeClass` class and `EmployeeStruct`
    structure in the previous section. Structures also have an additional default
    initializer, which we saw with the `EmployeeStruct` structure, which accepts a
    value for each stored property and initializes them with those values. Let''s
    look at how we add custom initializers to the `EmployeeClass` class and the `EmployeeStruct`
    structure. In the following code, we create three custom initializers that will
    work for both the `EmployeeClass` class and the `EmployeeStruct` structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式适用于类和结构。默认情况下，所有类和结构都有一个空的默认初始化器，可以重写。我们在上一节中初始化 `EmployeeClass` 类和 `EmployeeStruct`
    结构时使用了这些默认初始化器。结构还有另一个默认初始化器，我们在 `EmployeeStruct` 结构中看到了它，它接受每个存储属性的值并将它们初始化为这些值。让我们看看如何向
    `EmployeeClass` 类和 `EmployeeStruct` 结构添加自定义初始化器。在以下代码中，我们创建了三个自定义初始化器，它们将适用于 `EmployeeClass`
    类和 `EmployeeStruct` 结构：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first initializer, `init()`, will set all of the stored properties to their
    default values. The second initializer, `init(firstName: String, lastName: String)`,
    will populate the `firstName` and `lastName` properties with the values of the
    arguments. The third initializer, `init(firstName: String, lastName: String, salaryYear:
    Double)`, will populate all the properties with the values of the arguments. In
    the previous example, we can see that in Swift, an initializer does not have an
    explicit return value, but it does return an instance of the type. This means
    that we do not define a return type for the initializer or have a return statement
    within the initializer. Let''s look at how we could use these initializers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个初始化器 `init()` 将将所有存储属性设置为它们的默认值。第二个初始化器 `init(firstName: String, lastName:
    String)` 将使用参数的值填充 `firstName` 和 `lastName` 属性。第三个初始化器 `init(firstName: String,
    lastName: String, salaryYear: Double)` 将使用参数的值填充所有属性。在之前的示例中，我们可以看到在 Swift 中，初始化器没有显式的返回值，但它确实返回该类型的实例。这意味着我们不需要为初始化器定义返回类型或在初始化器中包含返回语句。让我们看看我们如何使用这些初始化器：'
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `g` instance of `EmployeeClass` uses the `init()` initializer to create
    an instance of the `EmployeeClass` class; therefore, all the properties of this
    instance contain their default values. The `h` instance of `EmployeeStruct` uses
    the `init(firstName: String, lastName: String)` initializer to create an instance
    of the `EmployeeStruct` structure; therefore, the `firstName` property is set
    to `Me` and the `lastName` property is set to `Moe`, which are the two arguments
    passed into the initializer. The `salaryYear` property is still set to the default
    value of `0.0`. The `i` instance of `EmployeeClass` uses the `init(firstName:
    String, lastName: String, salaryYear: Double0)` initializer to create an instance
    of the `EmployeeClass` class; therefore, the `firstName` property is set to `Me`,
    the `lastName` property is set to `Moe`, and the `salaryYear` property is set
    to `45_000`. Since all the initializers are identified with the `init` keyword,
    the parameters and parameter types are used to identify which initializer to use.
    A class, unlike a structure, can have a deinitializer. A deinitializer is called
    just before an instance of the class is destroyed and removed from memory. In
    *Chapter 18*, *Memory Management*, we will show examples of the deinitializer
    and see when it is called. Let''s look at internal and external parameter names
    with initializers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeClass` 类的 `g` 实例使用 `init()` 初始化器创建 `EmployeeClass` 类的一个实例；因此，这个实例的所有属性都包含它们的默认值。`EmployeeStruct`
    结构的 `h` 实例使用 `init(firstName: String, lastName: String)` 初始化器创建 `EmployeeStruct`
    结构的一个实例；因此，`firstName` 属性被设置为 `Me`，`lastName` 属性被设置为 `Moe`，这两个参数被传递到初始化器中。`salaryYear`
    属性仍然设置为默认值 `0.0`。`EmployeeClass` 类的 `i` 实例使用 `init(firstName: String, lastName:
    String, salaryYear: Double)` 初始化器创建 `EmployeeClass` 类的一个实例；因此，`firstName` 属性被设置为
    `Me`，`lastName` 属性被设置为 `Moe`，`salaryYear` 属性被设置为 `45_000`。由于所有初始化器都与 `init` 关键字相关联，参数和参数类型被用来识别使用哪个初始化器。与结构不同，类可以有析构器。析构器在类的实例被销毁并从内存中移除之前被调用。在
    *第 18 章*，*内存管理* 中，我们将展示析构器的示例并看到它在何时被调用。让我们看看带有初始化器的内部和外部参数名称。'
- en: Internal and external parameter names
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部和外部参数名称
- en: 'Just like functions, the parameters associated with an initializer can have
    separate internal and external names. If we do not supply external parameter names
    for our parameters, Swift will automatically generate them for us. In the previous
    examples, we did not include external parameter names in the definition of the
    initializers, so Swift created them for us using the internal parameter name as
    the external parameter name. If we wanted to supply our own parameter names, we
    would do so by putting the external parameter name before the internal parameter
    name, exactly as we do with any normal function. Let''s look at how we can define
    our own external parameter names by redefining one of the initializers within
    our `EmployeeClass` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，与初始化器关联的参数可以有独立的内部和外部名称。如果我们没有为我们的参数提供外部参数名称，Swift 会自动为我们生成它们。在之前的示例中，我们没有在初始化器的定义中包含外部参数名称，因此
    Swift 使用内部参数名称作为外部参数名称为我们创建了它们。如果我们想提供自己的参数名称，我们可以在内部参数名称之前放置外部参数名称，这与我们对任何正常函数的做法完全一样。让我们看看我们如何通过重新定义
    `EmployeeClass` 类中的一个初始化器来定义我们自己的外部参数名称：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, we created the `init(employeeWithFirstName firstName:
    String, lastName lastName: String, andSalary salaryYear: Double)` initializer.
    This initializer will create an instance of the `EmployeeClass` class and populate
    the instance properties with the value of the arguments. In this example, each
    of the parameters has both external and internal property names. Let''s look at
    how we would use this initializer, with the external property names:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我们创建了`init(employeeWithFirstName firstName: String, lastName lastName:
    String, andSalary salaryYear: Double)`初始化器。这个初始化器将创建`EmployeeClass`类的一个实例，并用参数的值填充实例属性。在这个例子中，每个参数都有外部和内部属性名。让我们看看我们如何使用这个初始化器，使用外部属性名：'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we are now using the external parameter names as defined in the
    initializer. Using external parameter names can help make our code more readable
    and help differentiate between different initializers. So, what will happen if
    our initializer fails? For example, what if our class relies on a specific resource,
    such as a web service that is not currently available? This is where failable
    initializers come in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在正在使用初始化器中定义的外部参数名。使用外部参数名可以帮助使我们的代码更易读，并有助于区分不同的初始化器。那么，如果我们的初始化器失败会怎样呢？例如，如果我们的类依赖于特定的资源，比如当前不可用的网络服务，会发生什么？这就是failable初始化器发挥作用的地方。
- en: Failable initializers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Failable初始化器
- en: 'A failable initializer is an initializer that may fail to initialize the resources
    needed for a class or a structure, thereby rendering the instance unusable. When
    using a failable initializer, the result of the initializer is an optional type,
    containing either a valid instance of the type or nil. An initializer can be made
    failable by adding a question mark (`?`) after the `init` keyword. Let''s look
    at how we can create a failable initializer that will not allow a new employee
    to be initialized with a salary of less than $20,000 a year:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Failable初始化器是一种可能无法初始化类或结构所需资源的初始化器，从而使实例无法使用。当使用failable初始化器时，初始化器的结果是可选类型，包含该类型的有效实例或nil。可以通过在`init`关键字后添加一个问号（`?`）来使初始化器成为failable。让我们看看我们如何创建一个不允许用年薪低于每年20,000美元初始化新员工的failable初始化器：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous examples, we did not include a `return` statement within the
    initializer because Swift does not need to return the initialized instance; however,
    in a failable initializer, if the initialization fails, it must return nil. If
    the initializer successfully initializes the instance, we do not need to return
    anything. Therefore, in our example, if the yearly salary that is passed in is
    less than $20,000 a year, we return `nil`, indicating that the initialization
    failed, otherwise nothing will be returned. Let''s look at how we would use a
    failable initializer to create an instance of a class or structure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有在初始化器中包含`return`语句，因为Swift不需要返回初始化的实例；然而，在failable初始化器中，如果初始化失败，它必须返回nil。如果初始化器成功初始化了实例，我们不需要返回任何内容。因此，在我们的例子中，如果传入的年薪低于每年20,000美元，我们返回`nil`，表示初始化失败，否则不返回任何内容。让我们看看我们如何使用failable初始化器来创建类或结构的实例：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous example, we initialize the instance of the `EmployeeClass`
    class with a yearly salary of greater than $20,000; therefore, the instance gets
    initialized correctly and the full name of `Jon Hoffman` is printed to the console.
    Now, let''s try to initialize an instance of the `EmployeeClass` class with a
    yearly salary of less than $20,000 to see how it fails:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们用超过20,000美元的年薪初始化了`EmployeeClass`类的实例；因此，实例被正确初始化，并且`Jon Hoffman`的全名被打印到控制台。现在，让我们尝试用低于20,000美元的年薪初始化`EmployeeClass`类的实例，看看它会如何失败：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the yearly salary that we are attempting to initialize
    for our employee is less than $20,000, therefore the initialization fails and
    a `Failed to initialize` messageis printed to the console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试为我们的员工初始化的年薪低于20,000美元，因此初始化失败，并在控制台打印出“Failed to initialize”消息。
- en: There are times when we want to restrict access to certain parts of our code.
    For this, we use access controls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要限制对代码某些部分的访问。为此，我们使用访问控制。
- en: Access controls
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制
- en: 'Access controls enable us to hide implementation details and only expose the
    interfaces we want to expose. This feature is handled with access controls. We
    can assign specific access levels to both classes and structures. We can also
    assign specific access levels to properties, methods, and initializers that belong
    to our classes and structures. In Swift, there are five access levels:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制使我们能够隐藏实现细节，仅暴露我们想要暴露的接口。这个功能是通过访问控制来处理的。我们可以为类和结构体分配特定的访问级别。我们还可以为属于我们的类和结构体的属性、方法和初始化器分配特定的访问级别。在
    Swift 中，有五个访问级别：
- en: '**Open**: This is the most visible access control level. It allows us to use
    the property, method, class, and so on anywhere we want to import the module.
    Basically, anything can use an item that has an access-control level of open.
    Anything that is marked open can be subclassed or overridden by any item within
    the module they are defined in and any module that imports the module it is defined
    in. This level is primarily used by frameworks to expose the framework''s public
    API. The open-access control is only available to classes and members of a class.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开（Open）**：这是最可见的访问控制级别。它允许我们在任何想要导入模块的地方使用属性、方法、类等。基本上，任何具有公开访问级别项都可以被任何模块使用。任何标记为公开的项可以由定义它们的模块内的任何项以及导入该模块的任何模块进行子类化或重写。这个级别主要用于框架，以暴露框架的公共
    API。公开访问控制仅适用于类及其成员。'
- en: '**Public**: This access level allows us to use the property, method, class,
    and so on anywhere we want to import the module. Basically, anything can use an
    item that has an access-control level of public. Anything that is marked public
    can be subclassed or overridden only by any item within the module they are defined
    in. This level is primarily used by frameworks to expose the framework''s public
    API.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共（Public）**：这个访问级别允许我们在任何想要导入模块的地方使用属性、方法、类等。基本上，任何具有公共访问级别项都可以被任何模块使用。任何标记为公共的项只能由定义它们的模块内的任何项进行子类化或重写。这个级别主要用于框架，以暴露框架的公共
    API。'
- en: '**Internal**: This is the default access level. This access level allows us
    to use the property, method, class, and so on in the module the item is defined
    in. If this level is used in a framework, it lets other parts of the framework
    use the item but code outside the framework will be unable to access it.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部（Internal）**：这是默认的访问级别。这个访问级别允许我们在定义项的模块中使用属性、方法、类等。如果在框架中使用此级别，它允许框架的其他部分使用该项，但框架外部的代码将无法访问它。'
- en: '**Fileprivate**: This access control allows access to the properties and methods
    from any code within the same source file that the item is defined in.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件私有（Fileprivate）**：这种访问控制允许从定义项的同一源文件中的任何代码访问属性和方法。'
- en: '**Private**: This is the least visible access-control level. It only allows
    us to use the property, method, class, and so on, within extensions of the declaration
    defined in the source file that defines it.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有（Private）**：这是最不可见的访问控制级别。它只允许我们在定义它的源文件中声明的扩展内使用属性、方法、类等。'
- en: 'When we are developing frameworks, the access controls really become useful.
    We will need to mark the public-facing interfaces as public or open so that other
    modules, such as applications that import the framework, can use them. We will
    then use the internal and private access-control levels to mark the interfaces
    that we want to use internally to the framework and the source file, respectively.
    To define access levels, we place the name of the level before the definition
    of the entity. The following code shows examples of how we can add access levels
    to several entities:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发框架时，访问控制变得非常有用。我们需要将面向公众的接口标记为公共或公开，以便其他模块，如导入框架的应用程序，可以使用它们。然后，我们将使用内部和私有访问控制级别来标记我们希望在框架和源文件内部使用的接口。要定义访问级别，我们在实体的定义之前放置级别的名称。以下代码显示了我们可以如何向多个实体添加访问级别的示例：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are some limitations with access controls, but these limitations are
    there to ensure that access levels in Swift follow a simple guiding principle:
    no entity can be defined in terms of another entity that has a lower (more restrictive)
    access level. This means that we cannot assign a higher (less restrictive) access
    level to an entity when it relies on another entity that has a lower (more restrictive)
    access level. The following examples demonstrate this principle:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问控制方面存在一些限制，但这些限制是为了确保 Swift 中的访问级别遵循一个简单的指导原则：不能以具有较低（更限制性）访问级别的另一个实体来定义实体。这意味着当实体依赖于具有较低（更限制性）访问级别的另一个实体时，我们不能将其访问级别设置为较高（较少限制性）。以下示例演示了这一原则：
- en: We cannot mark a method as being public when one of the arguments or the return
    type has an access level of private, because external code would not have access
    to the private type
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其中一个参数或返回类型的访问级别为 private 时，我们不能将方法标记为 public，因为外部代码无法访问私有类型。
- en: We cannot set the access level of a method or property to public when the class
    or structure has an access level of private, because external code would not be
    able to access the constructor when the class is private
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类或结构的访问级别为 private 时，我们不能将方法或属性的访问级别设置为 public，因为外部代码在类为 private 时无法访问构造函数。
- en: Now let's look at a new feature in Swift 5.2, key-path expressions as functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 Swift 5.2 中的一个新特性，即作为函数的关键路径表达式。
- en: Key-path expressions as functions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为函数的关键路径表达式
- en: 'SE-0249 in Swift 5.2 introduced a great shortcut which enables us to easily
    access the properties of objects in a particular collection. What this means is
    if we iterate over a collection using the `map` algorithm, we are able to use
    key-path expressions `(\Root.value`) to access the properties of the items in
    the collection. Let''s look at an example using the employee structure we created
    earlier. We will start by creating three employees and adding them to an array:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 5.2 中的 SE-0249 引入了一个非常方便的快捷方式，使我们能够轻松访问特定集合中对象的属性。这意味着如果我们使用 `map` 算法遍历一个集合，我们能够使用关键路径表达式
    `(\Root.value)` 来访问集合中项的属性。让我们看看一个使用我们之前创建的员工结构的示例。我们将从创建三个员工并将它们添加到数组中开始：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have an array of employees, let''s retrieve all of the first names
    of our employees. We could loop through our array and pull out the names one by
    one, but if we combine the map algorithm that we saw in *Chapter 5*, *Using Swift
    Collections*, with this new feature, we could retrieve all first names like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个员工数组，让我们检索我们员工的全部姓名。我们可以通过遍历数组并逐个提取名称，但如果我们结合我们在第 5 章“使用 Swift 集合”中看到的
    map 算法以及这个新特性，我们可以这样检索所有姓名：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this code, the firstName array will contain the first name for each employee
    in our employeeCollection array.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，firstName 数组将包含 employeeCollection 数组中每个员工的姓名。
- en: Let's look at another new feature with Swift 5.2, calling a type as a function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Swift 5.2 中的另一个新特性，即作为函数的类型调用。
- en: Calling a type as a function
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型作为函数调用
- en: 'With SE-0253 in Swift 5.2, we are able to call a type as a function. To explain
    it a little better, instances of types that have a method whose name is `callAsFunction`
    can be called as if they were a function. Let''s look at an example of this. We
    will start off by creating a `Dice` type that can be used to create an instance
    of any size dice:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 5.2 的 SE-0253 中，我们能够将类型作为函数调用。为了更好地解释，具有名为 `callAsFunction` 的方法的类型的实例可以像函数一样被调用。让我们看看这个示例。我们将从创建一个
    `Dice` 类型开始，它可以用来创建任何大小的骰子实例：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice the method within the function called callAsFunction(). This function
    generates a random number using the `lowValue` and `highValue` properties. Since
    we named this method `callAsFunction`, we are able to call it using the instance''s
    name as if it were a function. Let''s see how this works by creating a six-sided
    dice and generating a random value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在函数中调用的方法 callAsFunction()。这个函数使用 `lowValue` 和 `highValue` 属性生成随机数。由于我们把这个方法命名为
    `callAsFunction`，所以我们能够使用实例的名称来调用它，就像它是一个函数一样。让我们通过创建一个六面骰子并生成一个随机值来查看这是如何工作的：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `roll` variable will contain a random value generated from the `callAsFunction()`
    method. This enables us to simplify how we call certain functions. In the previous
    example, we are able to generate the roll of the dice by simply calling `d6()`
    rather than calling the instance with a function name like `d6.generateRoll()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll` 变量将包含由 `callAsFunction()` 方法生成的随机值。这使得我们可以简化调用某些函数的方式。在先前的例子中，我们能够通过简单地调用
    `d6()` 来生成骰子的点数，而不是通过像 `d6.generateRoll()` 这样的函数名来调用实例。'
- en: Now let's look at what inheritance is.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看什么是继承。
- en: Inheritance
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: The concept of inheritance is a basic object-oriented development concept. Inheritance
    allows a class to be defined as having a certain set of characteristics, and then
    other classes can be derived from that class. The derived class inherits all of
    the features of the class it is inheriting from (unless the derived class overrides
    those characteristics) and then usually adds additional characteristics of its
    own.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的概念是面向对象开发的基本概念。继承允许一个类被定义为具有某些特性，然后其他类可以从该类派生。派生类继承了它所继承的类的所有特性（除非派生类覆盖了这些特性），然后通常还会添加它自己的额外特性。
- en: Inheritance is one of the fundamental differences that separates classes from
    structures. Classes can be derived from a parent or superclass, but a structure
    cannot.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是区分类和结构体的基本差异之一。类可以从父类或超类派生，但结构体不能。
- en: With inheritance, we can create what is known as a class hierarchy. In a class
    hierarchy, the class at the top of the hierarchy is known as the base class, and
    the derived classes are known as subclasses. We are not limited to only creating
    subclasses from a base class, we can also create subclasses from other subclasses.
    The class that a subclass is derived from is known as the parent or superclass.
    In Swift, a class can have only one parent class. This is known as single inheritance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，我们可以创建所谓的类层次结构。在类层次结构中，位于层次结构顶部的类被称为基类，而派生类被称为子类。我们不仅限于仅从基类创建子类，我们还可以从其他子类创建子类。一个子类派生自的类被称为父类或超类。在Swift中，一个类只能有一个父类。这被称为单继承。
- en: Subclasses can call and access the properties, methods, and subscripts of their
    superclass. They can also override the properties, methods, and subscripts of
    their superclass.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以调用和访问它们从超类继承的属性、方法和下标。它们还可以覆盖它们从超类继承的属性、方法和下标。
- en: 'Subclasses can add property observers to properties that they inherit from
    a superclass so that they can be notified when the values of the properties change.
    Let''s look at an example that illustrates how inheritance works in Swift. We
    will start off by defining a base class named `Plant`. The `Plant` class will
    have two properties: `height` and `age`. It will also have one method: `growHeight()`.
    The `height` property will represent the height of the plant, the `age` property
    will represent the age of the plant, and the `growHeight()` method will be used
    to increase the height of the plant. Here is how we would define the `Plant` class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以给它们从超类继承的属性添加属性观察者，以便在属性值发生变化时得到通知。让我们看看一个示例，说明Swift中继承是如何工作的。我们将从定义一个名为
    `Plant` 的基类开始。`Plant` 类将有两个属性：`height` 和 `age`。它还将有一个方法：`growHeight()`。`height`
    属性将表示植物的高度，`age` 属性将表示植物的年龄，`growHeight()` 方法将用于增加植物的高度。以下是定义 `Plant` 类的方法：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have our `Plant` base class, let''s see how we would define a subclass
    of it. We will name this subclass `Tree`. The `Tree` class will inherit the `age`
    and `height` properties of the `Plant` class and add one more property, named
    `limbs`. It will also inherit the `growHeight()` method of the `Plant` class and
    add two more methods: `limbGrow()`, where new limbs are grown, and `limbFall()`,
    where limbs fall off the tree. Let''s have a look at the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的 `Plant` 基类，让我们看看我们如何定义它的子类。我们将把这个子类命名为 `Tree`。`Tree` 类将继承 `Plant`
    类的 `age` 和 `height` 属性，并添加一个额外的属性，命名为 `limbs`。它还将继承 `Plant` 类的 `growHeight()`
    方法，并添加两个额外的方法：`limbGrow()`，用于生长新的枝条，和 `limbFall()`，用于枝条从树上掉落。让我们看看以下代码：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We indicate that a class has a superclass by adding a colon and the name of
    the superclass to the end of the class definition. In this example, we indicated
    that the `Tree` class has a superclass named `Plant`. Now, let''s look at how
    we could use the `Tree` class that inherited the `age` and `height` properties
    from the `Plant` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类定义的末尾添加一个冒号和超类的名称来表示一个类有一个超类。在这个例子中，我们指明`Tree`类有一个名为`Plant`的超类。现在，让我们看看我们如何使用从`Plant`类继承来的`age`和`height`属性的`Tree`类：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding example begins by creating an instance of the `Tree` class. We
    then set the `Age` and `height` properties to `5` and `4`, respectively, and added
    two limbs to the tree by calling the `limbGrow()` method twice. We now have a
    base class named `Plant` that has a subclass named `Tree`. This means that the
    super (or parent) class of `Tree` is the `Plant` class. This also means that one
    of the subclasses (or child classes) of `Plant` is named `Tree`. There are, however,
    lots of different kinds of trees in the world. Let''s create two subclasses from
    the `Tree` class. These subclasses will be the `PineTree` class and the `OakTree`
    class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例首先创建了一个`Tree`类的实例。然后我们将`Age`和`height`属性分别设置为`5`和`4`，并通过调用`limbGrow()`方法两次为树添加了两条枝条。现在我们有一个名为`Plant`的基类，它有一个名为`Tree`的子类。这意味着`Tree`的超类（或父类）是`Plant`类。这也意味着`Plant`的一个子类（或子类）被命名为`Tree`。然而，世界上有各种各样的树木。让我们从`Tree`类创建两个子类。这些子类将是`PineTree`类和`OakTree`类：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The class hierarchy now looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当前类的层次结构看起来是这样的：
- en: '![](img/B16683_08_01.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16683_08_01.png)'
- en: 'Figure 8.1: Inheritance class hierarchy'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：继承类层次结构
- en: It is important to keep in mind that, in Swift, a class can have multiple subclasses;
    however, a class can have only one superclass. There are times when a subclass
    needs to provide its own implementation of a method or property that it inherited
    from its superclass. This is known as **overriding**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，一个类可以有多个子类；然而，一个类只能有一个超类。有时，子类需要提供它从超类继承来的方法或属性的自己的实现。这被称为**重写**。
- en: Overriding methods and properties
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重写和属性重写
- en: To override a method, property, or subscript, we need to prefix the definition
    with the `override` keyword. This tells the compiler that we intend to override
    something in the superclass, and that we did not make a duplicate definition by
    mistake. The `override` keyword prompts the Swift compiler to verify that the
    superclass (or one of its parents) has a matching declaration that can be overridden.
    If it cannot find a matching declaration in one of the superclasses, an error
    will be thrown.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写一个方法、属性或下标，我们需要在定义前加上`override`关键字。这告诉编译器我们打算重写超类中的某个东西，并且我们没有错误地创建了重复的定义。`override`关键字会提示Swift编译器验证超类（或其父类之一）是否有可以重写的匹配声明。如果它在一个超类中找不到匹配的声明，将会抛出一个错误。
- en: Overriding methods
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重写
- en: 'Let''s look at how we can override a method. We will start by adding a `getDetails()`
    method to the `Plant` class that we will then override in the child classes. The
    following code shows the code for the new `Plant` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何重写一个方法。我们将首先向`Plant`类添加一个`getDetails()`方法，然后在其子类中重写它。以下代码显示了新`Plant`类的代码：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s see how we can override the `getDetails()` method in the `Tree`
    class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在`Tree`类中重写`getDetails()`方法：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The thing to note here is that we do not use the `override` keyword in the
    `Plant` class because it is the first class to implement this method; however,
    we do include it in the `Tree` class since we are overriding the `getDetails()`
    method from the `Plant` class. Now, let''s see what happens if we call the `getDetails()`
    method from an instance of the `Plant` and `Tree` classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们不在`Plant`类中使用`override`关键字，因为它是最先实现这个方法的类；然而，我们在`Tree`类中包含它，因为我们正在重写从`Plant`类继承来的`getDetails()`方法。现在，让我们看看如果我们从`Plant`和`Tree`类的实例中调用`getDetails()`方法会发生什么：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous example will print the following two lines to the console:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将在控制台打印以下两行：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we can see, the `getDetails()` method in the `Tree` subclass overrides the
    `getDetails()` of its parent `Plant` class. Inside the `Tree` class, we can still
    call the `getDetails()` method (or any overridden method, property, or subscript)
    of its superclass by using the `super` prefix. We will begin by replacing the
    `getDetails()` method in the `Plant` class with the following method, which will
    generate a string that contains the values of the `height` and `age` properties:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Tree`子类中的`getDetails()`方法覆盖了其父类`Plant`的`getDetails()`方法。在`Tree`类内部，我们仍然可以通过使用`super`前缀来调用其超类（或任何覆盖的方法、属性或下标）的`getDetails()`方法（或任何覆盖的方法、属性或下标）。我们将首先用以下方法替换`Plant`类中的`getDetails()`方法，该方法将生成包含`height`和`age`属性值的字符串：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we will replace the `getDetails()` method for the `Tree` class with the
    following method, which will call the `getDetails()` method of the superclass:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用以下方法替换`Tree`类的`getDetails()`方法，该方法将调用超类的`getDetails()`方法：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding example, we begin by calling the `getDetails()` method of
    the superclass (the `Plant` class in this case) to get a string that contains
    the tree''s height and age. We then build a new string object that combines the
    results of the `getDetails()` method and a new string that contains the number
    of limbs from the `Tree` class. This new string is then returned. Let''s look
    at what happens if we call this new method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先调用超类（在本例中为`Plant`类）的`getDetails()`方法来获取一个包含树木高度和年龄的字符串。然后我们构建一个新的字符串对象，该对象结合了`getDetails()`方法的输出和一个包含来自`Tree`类肢体数量的新字符串。然后返回这个新字符串。让我们看看如果我们调用这个新方法会发生什么：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we run the preceding code, the following line will be printed to the console:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，以下行将被打印到控制台：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, the string that is returned contains the `height` and `age` information
    from the `Plant` class and the `limbs` information from the `Tree` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，返回的字符串包含了来自`Plant`类的`height`和`age`信息以及来自`Tree`类的`limbs`信息。
- en: Overriding properties
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖属性
- en: 'We can provide custom getters and setters to override any inherited property.
    When we override a property, we must provide the name and the type of property
    we are overriding so that the compiler can verify that one of the classes in the
    class hierarchy has a matching property to override. Let''s see how we can override
    a property by adding the following property to our `Plant` class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供自定义的getter和setter来覆盖任何继承的属性。当我们覆盖一个属性时，我们必须提供我们正在覆盖的属性名称和类型，以便编译器可以验证类层次结构中的某个类是否有一个匹配的属性可以覆盖。让我们看看我们如何通过向我们的`Plant`类添加以下属性来覆盖一个属性：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `description` property is a basic read-only property. This property returns
    the `Base class is Plant` string. Now, let''s override this property by adding
    the following property to the `Tree` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`属性是一个基本的只读属性。该属性返回`Base class is Plant`字符串。现在，让我们通过向`Tree`类添加以下属性来覆盖这个属性：'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The same `override` keyword is used when overriding both properties and methods.
    This keyword tells the compiler that we want to override a property so that the
    compiler can verify that another class in the class hierarchy contains a matching
    property to override. We then implement the property as we would any other property.
    Calling the `description` property for an instance of the `Tree` class will result
    in the `Base class is Plant. I am a Tree class` string being returned. There are
    times when we want to prevent a subclass from overriding the properties and methods.
    There are also times when we want to prevent an entire class from being subclassed.
    Let's see how we can do this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖属性和方法时，也使用相同的`override`关键字。此关键字告诉编译器我们想要覆盖一个属性，以便编译器可以验证类层次结构中的另一个类是否包含一个可以覆盖的匹配属性。然后我们像其他任何属性一样实现该属性。调用`Tree`类实例的`description`属性将返回`Base
    class is Plant. I am a Tree class`字符串。有时我们希望防止子类覆盖属性和方法。也有时候我们希望防止整个类被子类化。让我们看看我们如何做到这一点。
- en: Preventing overrides
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止覆盖
- en: To prevent overrides or subclassing, we can use the `final` keyword. To use
    the `final` keyword, we add it before the item's definition. Examples are `final
    func`, `final var`, and `final class`. Any attempt to override an item marked
    with this keyword will result in a compile-time error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止覆盖或子类化，我们可以使用`final`关键字。要使用`final`关键字，我们在项目定义之前添加它。例如，`final func`、`final
    var`和`final class`。任何尝试覆盖带有此关键字的项都将导致编译时错误。
- en: Protocols
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议
- en: There are times when we would like to describe the implementations (methods,
    properties, and other requirements) of a type without actually providing any implementation.
    For this, we can use protocols. Protocols define a blueprint of methods, properties,
    and other requirements for a class or a structure. A class or a structure can
    then provide an implementation that conforms to those requirements. The class
    or structure that provides the implementation is said to conform to the protocol.
    Protocols are very important to the Swift language. The entire Swift standard
    library is based on them, and we will be looking at protocols and how to use them
    in *Chapter 9*, *Protocols and Protocol Extensions*, and *Chapter 10*, *Protocol
    Oriented Design*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能希望在实际上不提供任何实现的情况下描述类型的实现（方法、属性和其他要求）。为此，我们可以使用协议。协议定义了类或结构体的方法、属性和其他要求的蓝图。然后，类或结构体可以提供一个符合这些要求的实现。提供实现的类或结构体被称为符合协议。协议对
    Swift 语言非常重要。整个 Swift 标准库都是基于它们构建的，我们将在第 9 章“协议和协议扩展”和第 10 章“面向协议设计”中探讨协议及其使用。
- en: Protocol syntax
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议语法
- en: 'The syntax to define a protocol is very similar to how we define a class or
    a structure. The following example shows the syntax that''s used to define a protocol:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义协议的语法与我们定义类或结构体的语法非常相似。以下示例显示了用于定义协议的语法：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We state that a class or structure conforms to a protocol by placing the name
    of the protocol after the type''s name, separated by a colon. Here is an example
    of how we would state that a structure conforms to the `MyProtocol` protocol:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类型名称之后放置协议名称，并用冒号分隔来声明一个类或结构体符合一个协议。以下是一个示例，说明我们如何声明一个结构体符合 `MyProtocol`
    协议：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A type can conform to multiple protocols. We list the protocols that the type
    conforms to by separating them with commas. The following example shows how we
    would state that our structure conforms to multiple protocols:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型可以符合多个协议。我们通过逗号分隔来列出类型符合的协议。以下示例显示了如何说明我们的结构体符合多个协议：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we need a class to both inherit from a superclass and implement a protocol,
    we would list the superclass first, followed by the protocols. The following example
    illustrates this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个类同时继承自一个超类并实现一个协议，我们应该首先列出超类，然后是协议。以下示例说明了这一点：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Property requirements
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性要求
- en: 'A protocol can require that the conforming type provides certain properties
    with a specified name and type. The protocol does not say whether the property
    should be a stored or computed property because the implementation details are
    left up to the conforming type. When defining a property within a protocol, we
    must specify whether the property is a read-only or read-write property by using
    the `get` and `set` keywords. Let''s look at how we would define properties within
    a protocol by creating a protocol named `FullName`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以要求符合协议的类型提供具有指定名称和类型的某些属性。协议不指定属性应该是存储属性还是计算属性，因为实现细节留给符合协议的类型。在协议中定义属性时，我们必须使用
    `get` 和 `set` 关键字来指定属性是只读的还是可读写的。让我们通过创建一个名为 `FullName` 的协议来看看如何在协议中定义属性：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `FullName` protocol defines two properties, which any type that conforms
    to the protocol must implement. These are the `firstName` and `lastName` properties,
    and both are read-write properties. If we wanted to specify that the property
    is read-only, we would define it with only the `get` keyword, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullName` 协议定义了两个属性，任何符合该协议的类型都必须实现。这两个属性是 `firstName` 和 `lastName` 属性，它们都是可读写属性。如果我们想指定属性为只读，我们只需使用
    `get` 关键字来定义它，如下所示：'
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s see how we can create a `Scientist` class that conforms to this protocol:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建一个符合此协议的 `Scientist` 类：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we had forgotten to include either of the required properties, we would have
    received an error message letting us know the property we forgot. We also need
    to make sure that the type of the property is the same. For example, if we change
    the definition of the `lastName` property in the `Scientist` class to `var lastName
    = 42`, we will also receive an error message because the protocol specifies that
    we must have a `lastName` property of the string type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记包含任何一个必需的属性，我们会收到一个错误消息，告知我们忘记的属性。我们还需要确保属性的类型相同。例如，如果我们将 `Scientist`
    类中 `lastName` 属性的定义更改为 `var lastName = 42`，我们也会收到一个错误消息，因为协议指定我们必须有一个字符串类型的 `lastName`
    属性。
- en: Method requirements
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法要求
- en: 'A protocol can require that the conforming class or structure provides certain
    methods. We define a method within a protocol exactly as we do within a class
    or structure, except without the method body. Let''s add a `fullName()` method
    to our `FullName` protocol and `Scientist` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以要求符合的类或结构体提供某些方法。我们可以在协议中定义一个方法，就像在类或结构体中定义一样，只是不需要方法体。让我们向我们的 `FullName`
    协议和 `Scientist` 类添加一个 `fullName()` 方法：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we need to add a `fullName()` method to our `Scientist` class so that
    it will conform to the protocol:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向我们的 `Scientist` 类添加一个 `fullName()` 方法，以便它符合协议：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Structures can conform to Swift protocols exactly as classes do. In fact, the
    majority of the Swift standard library are structures that implement the various
    protocols that make up the standard library. The following example shows how we
    can create a `FootballPlayer` structure that also conforms to the `FullName` protocol:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体可以像类一样完全符合 Swift 协议。实际上，Swift 标准库的大多数内容都是实现了组成标准库的各种协议的结构体。以下示例展示了我们如何创建一个同时符合
    `FullName` 协议的 `FootballPlayer` 结构体：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When a class or structure conforms to a Swift protocol, we can be sure that
    it has implemented the required properties and methods. This can be very useful
    when we want to ensure that certain properties or methods are implemented over
    various classes, as our preceding examples show. Protocols are also very useful
    when we want to decouple our code from requiring specific types. The following
    code shows how we would decouple our code using the `FullName` protocol, the `Scientist`
    class, and the `FootballPlayer` structure that we have already built:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类或结构体符合 Swift 协议时，我们可以确信它已经实现了所需属性和方法。当我们需要确保在多个类中实现某些属性或方法时，这非常有用，就像我们前面的示例所展示的那样。当我们想要解耦代码，使其不依赖于特定类型时，协议也非常有用。以下代码展示了我们如何使用
    `FullName` 协议、`Scientist` 类和我们已经构建的 `FootballPlayer` 结构体来解耦代码：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding code, we begin by creating an instance of the `Scientist` class
    and the `FootballPlayer` structure. We then create a `person` variable that is
    of the `FullName (protocol)` type and set it to the `scientist` instance that
    we just created. We then call the `fullName()` method to retrieve our description.
    This will print out the `Kara Hoffman studies Physics` message to the console.
    We then set the `person` variable equal to the `player` instance and call the
    `fullName()` method again. This will print out the `Dan Marino has the number
    13` message to the console. As we can see, the `person` variable does not care
    what the actual implementation type is. Since we defined the `person` variable
    to be of the `FullName` type, we can set the variable to an instance of any type
    that conforms to the `FullName` protocol. This is called polymorphism. We will
    cover polymorphism and protocols more in *Chapter 9*, *Protocols and Protocol
    Extensions*, and *Chapter 10*, *Protocol Oriented Design*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个 `Scientist` 类的实例和一个 `FootballPlayer` 结构体的实例。然后我们创建了一个 `person`
    变量，其类型为 `FullName (protocol)`，并将其设置为刚才创建的 `scientist` 实例。然后我们调用 `fullName()` 方法来获取我们的描述。这将打印出
    `Kara Hoffman 研究物理学` 消息到控制台。然后我们将 `person` 变量设置为 `player` 实例，并再次调用 `fullName()`
    方法。这将打印出 `Dan Marino 穿着 13 号球衣` 消息到控制台。正如我们所看到的，`person` 变量并不关心实际的实现类型。由于我们定义了
    `person` 变量为 `FullName` 类型，我们可以将变量设置为任何符合 `FullName` 协议的类型的实例。这被称为多态。我们将在第 9 章
    *协议和协议扩展* 和第 10 章 *面向协议设计* 中更详细地介绍多态和协议。
- en: Extensions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: With extensions, we can add new properties, methods, initializers, and subscripts,
    or make an existing type conform to a protocol without modifying the source code
    for the type. One thing to note is that extensions cannot override the existing
    functionality. To define an extension, we use the `extension` keyword, followed
    by the type that we are extending.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展，我们可以添加新的属性、方法、构造函数和下标，或者使现有的类型符合协议，而无需修改该类型的源代码。需要注意的是，扩展不能覆盖现有的功能。要定义一个扩展，我们使用
    `extension` 关键字，后跟我们要扩展的类型。
- en: 'The following example shows how we would create an extension that extends the
    `string` class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何创建一个扩展来扩展 `string` 类：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s see how extensions work by adding a `reverse()` method and a `firstLetter`
    property to Swift''s standard `string` class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 Swift 的标准 `string` 类添加一个 `reverse()` 方法和 `firstLetter` 属性来查看扩展是如何工作的：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When we extend an existing type, we define properties, methods, initializers,
    subscripts, and protocols in exactly the same way as we would normally define
    them in a standard class or structure. In the string extension example, we can
    see that we define the `reverse()` method and the `firstLetter` property exactly
    as we would define them in a normal type. We can then use these methods exactly
    as we would use any other method, as the following example shows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展现有类型时，我们定义属性、方法、初始化器、下标和协议的方式与我们在标准类或结构体中通常定义它们的方式完全相同。在字符串扩展的例子中，我们可以看到我们定义
    `reverse()` 方法和 `firstLetter` 属性的方式，就像我们在正常类型中定义它们一样。然后我们可以像使用任何其他方法一样使用这些方法，如下面的例子所示：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Swift 4 did add the `reversed()` method to the string type, which should be
    preferred over the one we created here. This example just illustrates how to use
    extensions. Extensions are very useful for adding extra functionality to an existing
    type from external frameworks, even for Apple's frameworks, as demonstrated in
    this example. It is preferred to use extensions to add extra functionality to
    types from external frameworks rather than subclassing, because it allows us to
    continue to use the type throughout our code rather than changing the type to
    the subclass. Before we finish this chapter, let's take another look at optional
    chaining now that we have an understanding of classes and structures.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 4 为字符串类型添加了 `reversed()` 方法，这应该比我们在这里创建的方法更受欢迎。这个例子只是说明了如何使用扩展。扩展对于从外部框架添加额外功能到现有类型非常有用，就像在这个例子中演示的那样。我们更倾向于使用扩展来向外部框架的类型添加额外功能，而不是子类化，因为这允许我们在整个代码中继续使用该类型，而不是将其更改为子类。在我们完成本章之前，现在我们已经理解了类和结构体，让我们再次看看可选链。
- en: Property wrappers
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性包装器
- en: 'Property wrappers were introduced in Swift 5.1 with SE-0258 and they enable
    property values to be wrapped using a custom type. In order to perform this wrapping,
    we must create a custom attribute and a type that will handle the attribute. To
    see an example of this, let''s say that we want to trim all of the whitespace
    characters from the beginning and the ending of our string values. We could do
    this by using the getter and setter methods of our properties to trim the whitespace
    characters; however, we would have to put this logic in for each property that
    we wanted to trim. With property wrappers, we would do this much more easily.
    We will start off by creating our custom type that will be used as a wrapper;
    we will name it Trimmed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 属性包装器是在 Swift 5.1 中通过 SE-0258 引入的，它们允许使用自定义类型来包装属性值。为了执行这种包装，我们必须创建一个自定义属性和一个将处理该属性的类型。为了看看这个例子，假设我们想要从字符串值的开始和结束处删除所有空白字符。我们可以通过使用属性的获取器和设置器方法来删除空白字符；然而，我们必须为每个想要删除空白的属性放入这种逻辑。使用属性包装器，我们会更容易做到这一点。我们将从创建用作包装器的自定义类型开始；我们将它命名为
    Trimmed：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The previous code starts off by using the @propertyWrapper attribute to define
    that this type can be used as a property wrapper. Any type that is defined as
    a property wrapper must have a non-static property named wrappedValue, which we
    define as a `String` type within our Trimmed type. Finally, we create an initializer
    that is used to set the wrappedValue property.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码首先使用 @propertyWrapper 属性来定义这个类型可以用作属性包装器。任何被定义为属性包装器的类型都必须有一个非静态属性名为 wrappedValue，我们在
    Trimmed 类型内将其定义为 `String` 类型。最后，我们创建一个初始化器，用于设置 wrappedValue 属性。
- en: 'If we look back at the `EmployeeStruct` structure that we created earlier in
    the chapter, we defined two `String` properties like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下本章早期创建的 `EmployeeStruct` 结构体，我们定义了两个类似这样的 `String` 属性：
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we wanted to trim all of the whitespaces from the beginning and ending of
    these properties, all we would need to do now is to add an @Trimmed attribute
    to them like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从这些属性的起始和结束处删除所有空白字符，我们现在只需要给它们添加一个 @Trimmed 属性，如下所示：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now if we created new instances of the `EmployeeStruct` structure like this
    (notice the spaces in the initializer):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们像这样创建了 `EmployeeStruct` 结构体的新实例（注意初始化器中的空格）：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `firstName` and `lastName` properties will contain the values with the whitespace
    characters automatically removed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstName` 和 `lastName` 属性将包含自动删除空白字符的值。'
- en: Optional chaining
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选链
- en: 'Optional binding allows us to unwrap one optional at a time, but what would
    happen if we had optional types embedded within other optional types? This would
    force us to have optional binding statements embedded within other optional binding
    statements. There is a better way to handle this: by using optional chaining.
    Before we look at optional chaining, let''s see how this would work with optional
    binding. We will start off by defining three types that we will be using for our
    examples in this section:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定允许我们一次解包一个可选值，但如果我们在其他可选类型中嵌入了可选类型会怎样呢？这将迫使我们必须在其他可选绑定语句中嵌入可选绑定语句。有一种更好的处理方法：使用可选链。在我们查看可选链之前，让我们看看这是如何与可选绑定一起工作的。我们将从定义三个我们将在本节示例中使用的类型开始：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this example, we begin by defining a `Collar` class, which has one property
    defined. This property is named `color`, which is of the string type. We can see
    that the `color` property is not an optional; therefore, we can safely assume
    that it will always have a valid value. Next, we define a `Pet` class that has
    two properties defined. These properties are named `name` and `collar`. The `name`
    property is of the string type and the `collar` property is an optional that may
    contain an instance of the `Collar` type or may contain no value. Finally, we
    define a `Person` class, which also has two properties. These properties are named
    `name` and `pet`. The `name` property is of the string type and the `pet` property
    is an optional that may contain an instance of the `Pet` type or may contain no
    value. For the examples that follow, let''s use the following code to initialize
    the classes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个名为 `Collar` 的类，它有一个属性被定义。这个属性名为 `color`，其类型为字符串。我们可以看到 `color`
    属性不是可选的；因此，我们可以安全地假设它总是会有一个有效的值。接下来，我们定义了一个名为 `Pet` 的类，它有两个属性被定义。这些属性分别命名为 `name`
    和 `collar`。`name` 属性的类型为字符串，而 `collar` 属性是可选的，可能包含 `Collar` 类型的实例，或者可能不包含任何值。最后，我们定义了一个名为
    `Person` 的类，它也有两个属性。这些属性分别命名为 `name` 和 `pet`。`name` 属性的类型为字符串，而 `pet` 属性是可选的，可能包含
    `Pet` 类型的实例，或者可能不包含任何值。对于接下来的示例，让我们使用以下代码来初始化这些类：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s say that we want to get the color of the collar for a person''s
    pet; however, the person may not have a pet (the `pet` property may be `nil`)
    or the pet may not have a collar (the `collar` property may be `nil`). We could
    use optional binding to drill down through each layer, as shown in the following
    example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要获取一个人的宠物的颜色；然而，这个人可能没有宠物（`pet` 属性可能为 `nil`）或者宠物可能没有项圈（`collar` 属性可能为
    `nil`）。我们可以使用可选绑定来逐层深入，如下面的示例所示：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'While this example is perfectly valid and would print out a `The color of the
    collar is red` message, the code is rather messy and hard to follow because we
    have multiple optional binding statements on the same line, where the second optional
    binding statement is dependent on the first one. Optional chaining allows us to
    drill down through multiple optional type layers of properties, methods, and subscripts
    in one line of code. These layers can be chained together and if any layer returns
    `nil`, the entire chain gracefully fails and returns `nil`. If none of the values
    returns `nil`, the last value of the chain is returned. Since the results of optional
    chaining may be a `nil` value, the results are always returned as an optional
    type, even if the final value we are retrieving is a non-optional type. To specify
    optional chaining, we place a question mark (`?`) after each of the optional values
    within the chain. The following example shows how to use optional chaining to
    make the preceding example much cleaner and easier to read:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子完全有效，并且会打印出 `The color of the collar is red` 的消息，但代码相当混乱且难以理解，因为我们有多个可选绑定语句在同一行上，其中第二个可选绑定语句依赖于第一个。可选链允许我们在一行代码中深入多个属性、方法和子脚本的多个可选类型层。这些层可以链接在一起，如果任何层返回
    `nil`，整个链优雅地失败并返回 `nil`。如果链中的所有值都没有返回 `nil`，则返回链的最后一个值。由于可选链的结果可能是一个 `nil` 值，结果始终以可选类型返回，即使我们检索的最终值不是可选类型。为了指定可选链，我们在链中的每个可选值后面放置一个问号
    (`?`)。以下示例展示了如何使用可选链使前面的示例更加简洁和易于阅读：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, we put a question mark after the `pet` and `collar` properties
    to signify that they are of the optional type and that, if either value is `nil`,
    the whole chain will return `nil`. This code would also print out the `The color
    of the collar is red` message; however, it is much easier to read than the preceding
    example because it clearly shows us what optionals we are dependent on.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`pet`和`collar`属性后面加上一个问号，以表示它们是可选类型，并且如果任一值是`nil`，整个链将返回`nil`。此代码还会打印出`The
    color of the collar is red`消息；然而，它比前面的例子更容易阅读，因为它清楚地显示了我们所依赖的可选类型。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took an in-depth look at classes and structures. We saw
    what makes them so similar and also what makes them so different. In the upcoming
    chapters, it will be important to remember that classes are reference types while
    structures are value types. We also looked at protocols and extensions. As this
    chapter ends, we end the introduction to the Swift programming language. At this
    point, we have enough knowledge of the Swift language to begin writing our own
    applications; however, there is still much to learn. In the following chapters,
    we will look in more depth at some of the concepts that we've already discussed,
    such as protocols and subscripts. We will also see how we can use protocol-oriented
    programming techniques to write easy-to-manage code. Finally, we will have chapters
    that will help us write better code, such as a sample Swift style guide, and a
    chapter on design patterns.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了类和结构体。我们看到了它们如此相似的原因，也看到了它们如此不同的原因。在接下来的章节中，记住类是引用类型而结构体是值类型是很重要的。我们还探讨了协议和扩展。随着本章的结束，我们结束了Swift编程语言的介绍。到目前为止，我们对Swift语言的知识已经足够开始编写自己的应用程序；然而，还有很多东西要学习。在接下来的章节中，我们将更深入地探讨我们已经讨论的一些概念，例如协议和下标。我们还将看到如何使用面向协议的编程技术来编写易于管理的代码。最后，我们将有一些章节帮助我们编写更好的代码，例如一个Swift风格指南的示例，以及一个关于设计模式的章节。
