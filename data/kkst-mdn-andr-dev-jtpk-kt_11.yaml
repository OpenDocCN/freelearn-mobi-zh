- en: '*Chapter 9*: Implementing Dependency Injection with Jetpack Hilt'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：使用 Jetpack Hilt 实现依赖注入'
- en: In this chapter, we're continuing our journey of improving the architectural
    design of the Restaurants app. More precisely, we will be incorporating **dependency
    injection** (**DI**) in our project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续改进 Restaurants 应用的架构设计。更确切地说，我们将把 **依赖注入**（**DI**）融入到我们的项目中。
- en: In the first section, *What is DI?*, we will start by defining DI and understanding
    its basic concepts, from what a dependency is, the types of dependencies, and
    what injection represents, through to concepts such as dependency containers and
    manual injection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*什么是 DI？*，我们将从定义 DI 并理解其基本概念开始，从依赖项是什么，依赖项的类型，以及注入代表什么，到依赖容器和手动注入等概念。
- en: Afterward, in the *Why is DI needed?* section, we will focus in more detail
    on the benefits that DI brings to our projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 *为什么需要 DI？* 这一部分，我们将更详细地关注 DI 为我们的项目带来的好处。
- en: In the last section, *Implementing DI with Hilt*, we will first understand how
    the Jetpack Hilt DI library works, and how to use it, and finally, with its help,
    we will incorporate DI in our Restaurants app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，*使用 Hilt 实现依赖注入*，我们将首先了解 Jetpack Hilt DI 库的工作原理以及如何使用它，最后，借助它的帮助，我们将把依赖注入融入到我们的
    Restaurants 应用程序中。
- en: 'To summarize, in this chapter we will be covering the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下内容：
- en: What is DI?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 DI？
- en: Why is DI needed?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要 DI？
- en: Implementing DI with Hilt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hilt 实现依赖注入
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter would usually require
    your day-to-day tools; however, to follow along smoothly, make sure you have the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本章的基于 Compose 的 Android 项目通常需要您日常使用的工具；然而，为了顺利跟进，请确保您拥有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。您也可以使用更新的 Android Studio 版本，甚至可以尝试 Canary
    版本，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer plugin installed in Android Studio
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中安装了 Kotlin 1.6.10 或更高版本的插件
- en: The Restaurants app code from the previous chapter
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的 Restaurants 应用程序代码
- en: The starting point for this chapter is represented by the Restaurants app developed
    in the previous chapter. If you haven't followed the implementation from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_08`
    directory of the repository and importing the Android project entitled `chapter_8_restaurants_app`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的 Restaurants 应用程序。如果您没有跟随上一章的实现，可以通过导航到存储库中的 `Chapter_08` 目录并导入名为
    `chapter_8_restaurants_app` 的 Android 项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_09`
    directory: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_09` 目录：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app)。
- en: What is DI?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 DI？
- en: In simple terms, **DI** represents the concept of providing the instances of
    the dependencies that a class needs, instead of having it construct them itself.
    But, what are dependencies?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**DI** 代表了提供类所需依赖实例的概念，而不是让它自己构建。但，什么是依赖项？
- en: '`ExampleViewModel` class could contain a `repository` variable of type `Repository`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExampleViewModel` 类可能包含一个类型为 `Repository` 的 `repository` 变量：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s why `ExampleViewModel` depends on `Repository`, or `Repository` is
    a dependency for `ExampleViewModel`. Most of the time, classes have many more
    dependencies, but we''ll stick with only one for the sake of simplicity. In this
    case, the `ExampleViewModel` provides its own dependencies so it''s very easy
    to create an instance of it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ExampleViewModel` 依赖于 `Repository`，或者 `Repository` 是 `ExampleViewModel`
    的依赖项。大多数情况下，类有更多的依赖项，但为了简单起见，我们将只关注一个。在这种情况下，`ExampleViewModel` 提供了自己的依赖项，因此创建其实例非常简单：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the previous example doesn't incorporate DI, mainly because `ExampleViewModel`
    provides instances for its own dependencies. It does that by instantiating a `Repository`
    instance (through the `Repository()` constructor) and by passing it to the `repository`
    variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的例子没有实现DI，主要是因为`ExampleViewModel`为其自己的依赖项提供实例。它是通过实例化一个`Repository`实例（通过`Repository()`构造函数）并将其传递给`repository`变量来做到这一点的。
- en: 'To incorporate DI, we must create a component that provides `ExampleViewModel`
    with its dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DI，我们必须创建一个提供`ExampleViewModel`依赖项的组件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `DependencyContainer` class will act, as the name suggests, as a **dependency
    container**, as it will provide instances for all the dependencies our classes
    need. When a class needs an instance for its dependency, this container will provide
    it. This way, we centralize the creation of the instances of dependencies so we
    can handle this process (which can become elaborate for complex projects where
    each dependency has other dependencies, for example) within a single place in
    our project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`DependencyContainer`类将充当**依赖项容器**，因为它将为我们的类提供所有所需的依赖项实例。当一个类需要其依赖项的实例时，这个容器将提供它。这样，我们可以在项目的单个位置集中处理依赖项实例的创建过程（这对于具有其他依赖项的复杂项目来说可能会变得复杂）。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from the DI technique, you can also use the `ServiceLocator` component.
    Both DI and the service locator pattern are useful; however, we will only cover
    DI in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了DI技术，您还可以使用`ServiceLocator`组件。DI和服务定位器模式都很有用；然而，在本章中我们只会介绍DI。
- en: 'Getting back to incorporating DI, we then must allow `DependencyContainer`
    to provide a `Repository` instance to `ExampleViewModel`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实现DI，我们接下来必须允许`DependencyContainer`为`ExampleViewModel`提供一个`Repository`实例：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This technique of having dependencies declared as variables (for example, `ExampleViewModel`
    contains a `repository` variable) and then providing their instances through a
    container is a form of DI called **field injection**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将依赖项声明为变量（例如，`ExampleViewModel`包含一个`repository`变量）然后通过容器提供其实例的技术，是一种称为**字段注入**的DI形式。
- en: 'There are several issues with this approach, mainly caused by the fact that
    we have declared dependencies as field variables. The most notable ones are as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个问题，主要是由我们将依赖项声明为字段变量的事实引起的。最显著的问题如下：
- en: The `ExampleViewModel` class is tightly coupled to our `DependencyContainer`
    and we cannot use the `ViewModel` without it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExampleViewModel`类与我们的`DependencyContainer`紧密耦合，我们不能在没有它的情况下使用`ViewModel`。'
- en: The dependencies are `ExampleViewModel` doesn't know about the `ViewModel` class's
    dependencies or their creation.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项是`ExampleViewModel`不知道`ViewModel`类的依赖项或它们的创建。
- en: This won't allow us to reuse the same `ExampleViewModel` with other implementations
    of its dependencies (given its dependencies, such as `Repository`, are interfaces
    that can be implemented by different classes).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不允许我们使用相同的`ExampleViewModel`与其他依赖项的实现（考虑到其依赖项，如`Repository`，是可以通过不同类实现的接口）一起重用。
- en: Since `ExampleViewModel` has hidden dependencies, it becomes hard for us to
    test it. As we will instantiate the `ExampleViewModel` and put it under test,
    it will create its own `Repository` instance that will probably make real I/O
    requests for every test. We want our tests to be fast and reliable and not dependent
    on real third-party APIs.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`ExampleViewModel`有隐藏的依赖项，这使得我们很难对其进行测试。当我们实例化`ExampleViewModel`并将其置于测试之下时，它将创建自己的`Repository`实例，这可能会为每个测试进行真实的I/O请求。我们希望我们的测试快速且可靠，并且不依赖于真实的第三方API。
- en: 'To alleviate these issues, we must first refactor `ExampleViewModel` to expose
    its dependencies through its public API to the outside world. The most appropriate
    way to do that is through its public `constructor`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些问题，我们首先必须重构`ExampleViewModel`，使其通过其公共API向外界暴露其依赖项。最合适的方法是通过其公共`构造函数`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, `ExampleViewModel` exposes its dependencies to the outside world through
    its constructor, making those dependencies **explicit**. Yet, who's going to provide
    the dependencies from outside?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ExampleViewModel`通过其构造函数向外界暴露其依赖项，使这些依赖项**明确化**。然而，谁将提供外部的依赖项呢？
- en: 'When we need to instantiate `ExampleViewModel`, `DependencyContainer` will
    provide it with the necessary dependencies from the outside:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要实例化`ExampleViewModel`时，`DependencyContainer`将提供它所需的依赖项：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous example, instead of field injection, we have used `ExampleViewModel`
    from the outside world through its constructor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不是使用字段注入，而是通过其构造函数从外部世界使用`ExampleViewModel`。
- en: 'As opposed to field injection, constructor injection allows us to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与字段注入相比，构造函数注入允许我们做以下事情：
- en: Decouple our classes from the DI container, just like `ExampleViewModel` no
    longer depends on `DependencyContainer`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的类与DI容器解耦，就像`ExampleViewModel`不再依赖于`DependencyContainer`一样。
- en: The dependencies are exposed to the outside world, so we can reuse the same
    `ExampleViewModel` with other implementations of `Repository` (given `Repository`
    is an interface).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项暴露给外部世界，因此我们可以使用相同的`ExampleViewModel`与其他`Repository`实现（假设`Repository`是一个接口）一起重用。
- en: The `ExampleViewModel` class can no longer decide which dependency implementation
    to get and use as was the case with field injection, so we have now inverted this
    responsibility from `ExampleViewModel` to the outside world.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExampleViewModel`类不能再决定获取并使用哪种依赖实现，就像字段注入那样，所以我们现在将这个责任从`ExampleViewModel`反转给了外部世界。'
- en: '`ExampleViewModel` is easier to test, as we can easily pass a mock or a fake
    `Repository` implementation (given `Repository` is an interface) that will behave
    the way we''re expecting it to in a test.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExampleViewModel`更容易测试，因为我们可以轻松传递一个模拟或伪造的`Repository`实现（假设`Repository`是一个接口），它将在测试中以我们期望的方式表现。'
- en: So far, with the help of a dependency container, we have incorporated DI by
    ourselves by allowing `DependencyContainer` to provide instances of dependencies
    to our classes (that is, an instance of `ExampleViewModel`). This technique is
    called **manual DI**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，借助依赖容器，我们通过允许`DependencyContainer`为我们提供依赖项的实例（即`ExampleViewModel`的实例）来自己实现DI。这种技术被称为**手动DI**。
- en: 'Apart from manual DI, you can have DI done automatically through frameworks
    that relieve you from the burden of the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动DI之外，你还可以通过框架自动完成DI，这些框架可以减轻你以下负担：
- en: Providing instances of dependencies to the classes that need them. More specifically,
    frameworks help you wire up complex object relationships for the required dependencies,
    so you don't have to write boilerplate code to generate instances and pass them
    to appropriate objects. This infrastructure code is often cumbersome for large-sized
    apps, so a framework that automates that for you can be quite handy.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为需要它们的类提供依赖项的实例。更具体地说，框架帮助您为所需的依赖项配置复杂的对象关系，因此您不必编写样板代码来生成实例并将它们传递给适当的对象。这种基础设施代码对于大型应用程序来说通常很繁琐，因此一个为您自动完成这项工作的框架可以非常方便。
- en: Scoping dependencies to certain lifetime scopes, such as the `Application` scope
    or `Activity` scope. For example, if you want a certain dependency to be a singleton
    (to be scoped to the lifetime of the application), you must manually make sure
    that only one instance is created in memory while also avoiding concurrency issues
    due to concurrent access. A framework can do that for you behind the scenes.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项的范围限制在特定的生命周期范围内，例如`Application`范围或`Activity`范围。例如，如果你想某个依赖项是单例（即与应用程序的生命周期相关联），你必须手动确保在内存中只创建一个实例，同时避免由于并发访问而导致的并发问题。框架可以在幕后为你完成这项工作。
- en: In Android, a very simple DI library is **Hilt**, and we will explore it in
    the *Implementing DI with Hilt* section. But until then, let's better understand
    why DI is needed in the first place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，一个非常简单的DI库是**Hilt**，我们将在*使用Hilt实现DI*部分中探讨它。但在此之前，让我们更好地理解为什么DI最初是必要的。
- en: Why is DI needed?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要DI？
- en: 'DI is not a must for all projects. Until now, our Restaurants app worked just
    fine without any DI incorporated. Yet, while not including DI might not seem like
    a big issue, by incorporating it you bring a lot of benefits to your project;
    the most notable advantages are that you can do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DI并非所有项目都必须使用。到目前为止，我们的餐厅应用在没有集成DI的情况下运行得很好。然而，虽然不包含DI可能看起来不是一个大问题，但通过引入它，你可以给你的项目带来很多好处；最显著的优势是你可以做以下事情：
- en: Write less boilerplate code.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更少的样板代码。
- en: Write testable classes.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试的类。
- en: Let's cover these two next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论这两点。
- en: Write less boilerplate code
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更少的样板代码
- en: 'Let''s circle back to our Restaurants app, and let''s have a look at how we
    instantiate the Retrofit interface within the `RestaurantsRepository` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的餐厅应用，看看我们如何在`RestaurantsRepository`类中实例化Retrofit接口：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s have a look at how we similarly instantiate the Retrofit interface
    within the `RestaurantsDetailsViewModel` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在`RestaurantsDetailsViewModel`类中类似地实例化Retrofit接口：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While the code seems different, in essence, it's the same code needed to instantiate
    a concrete instance of `RestaurantsApiService`. Unfortunately, we have duplicated
    this instantiation code in two places, both in the `RestaurantsRepository` class
    and in the `RestaurantsDetailsViewModel` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码看起来不同，但本质上，它需要实例化`RestaurantsApiService`具体实例的相同代码。不幸的是，我们在两个地方重复了此实例化代码，即在`RestaurantsRepository`类和`RestaurantsDetailsViewModel`类中。
- en: In medium to large-sized production apps, the relationship between objects is
    often much more complex, making such infrastructure code plague every class, mostly
    because, without any DI, every class builds the instances of the dependencies
    it needs. Such code is often duplicated throughout the project and ultimately
    becomes difficult to manage.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在中等或大型生产应用中，对象之间的关系通常要复杂得多，这使得此类基础设施代码成为每个类的常见问题，主要是因为，在没有任何依赖注入（DI）的情况下，每个类都会构建它所需的依赖项的实例。此类代码通常在整个项目中重复出现，最终变得难以管理。
- en: DI will help us centralize this infrastructure code and will eliminate all the
    duplicated code needed to provide instances of dependencies, wherever we need
    them throughout the project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DI将帮助我们集中管理此类基础设施代码，并将消除在整个项目中提供依赖项实例所需的所有重复代码。
- en: Going back to our Restaurants app, if we were to use manual DI, all this instantiation
    code could be extracted into a `DependencyContainer` class that would provide
    us with a `RestaurantsApiService` instance wherever we need it, so we would have
    no more duplicated code! Don't worry, we will incorporate DI soon, in the upcoming
    *Implementing DI with Hilt* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的餐厅应用，如果我们使用手动DI，所有这些实例化代码都可以提取到一个`DependencyContainer`类中，该类会在我们需要的地方提供`RestaurantsApiService`实例，这样我们就没有更多的重复代码了！别担心，我们将在即将到来的*使用Hilt实现DI*部分中引入DI。
- en: Now that we touched upon how DI helps us with containing and organizing the
    code related to building instances of classes, it's time to check out another
    essential advantage of DI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了DI如何帮助我们包含和组织与构建类实例相关的代码，现在是时候检查DI的另一个基本优势了。
- en: Write testable classes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可测试的类
- en: 'Let''s suppose that we want to test the behavior of `RestaurantsRepository`
    to make sure that it performs as expected. But first, let''s have a quick look
    at the existing implementation of `RestaurantsRepository`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试`RestaurantsRepository`的行为，以确保它按预期执行。但首先，让我们快速查看`RestaurantsRepository`的现有实现：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that no DI is currently incorporated, as `RestaurantsRepository`
    has two implicit dependencies: an instance of `RestaurantsApiService` and an instance
    of `RestaurantsDao`. The `RestaurantsRepository` provides instances to its own
    dependencies, first by constructing a `Retrofit.Builder()` object and creating
    the concrete instance by calling `.create(…)`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，目前还没有引入DI，因为`RestaurantsRepository`有两个隐式依赖项：一个`RestaurantsApiService`实例和一个`RestaurantsDao`实例。`RestaurantsRepository`通过构造一个`Retrofit.Builder()`对象并调用`.create(…)`来创建具体实例，首先为它的依赖项提供实例。
- en: 'Now, let''s say we want to test this `RestaurantsRepository` class, and make
    sure that it behaves correctly by running different verifications. Let''s imagine
    how such a test class would look:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要测试这个`RestaurantsRepository`类，并通过运行不同的验证来确保它表现正确。让我们想象这样一个测试类会是什么样子：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous test structure is simple: we created a `RestaurantsRepository`
    instance by using its constructor and then we saved it inside a `repo` variable.
    We then asserted that the instance of the `Repository` is not `null`, so we can
    proceed with testing its behavior.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试结构很简单：我们通过其构造函数创建了一个`RestaurantsRepository`实例，并将其保存在`repo`变量中。然后我们断言`Repository`实例不是`null`，这样我们就可以继续测试其行为。
- en: 'This is optional, yet if you''re trying to write the previous test class and
    follow this process, make sure that the `RestaurantsRepositoryTest` class is placed
    inside the `test` directory of the application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然是可选的，但如果你正在尝试编写前面的测试类并遵循此流程，请确保`RestaurantsRepositoryTest`类放置在应用程序的`test`目录中：
- en: '![Figure 9.1 – Placement of test classes in the project structure'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 测试类在项目结构中的位置'
- en: '](img/B17788_09_1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_09_1.jpg)'
- en: Figure 9.1 – Placement of test classes in the project structure
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 测试类在项目结构中的位置
- en: 'Now, if we would to run this test, it will throw an exception before having
    the chance to verify anything. The stack trace would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试运行这个测试，它将在有机会验证任何内容之前抛出异常。堆栈跟踪将如下所示：
- en: '![Figure 9.2 – Stack trace of running invalid test'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.2 – Stack trace of running invalid test](img/B17788_09_2.jpg)'
- en: '](img/B17788_09_2.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_09_2.jpg](img/B17788_09_2.jpg)'
- en: Figure 9.2 – Stack trace of running invalid test
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 运行无效测试的堆栈跟踪
- en: This happens because we're trying to write a small test for `RestaurantsRepository`
    but this class is not yet testable (in fact, we're trying to perform a Unit test
    – we will tackle this in more detail in [*Chapter 10*](B17788_10_ePub.xhtml#_idTextAnchor305),
    *Test Your App with UI and Unit Tests*).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们试图为`RestaurantsRepository`编写一个小测试，但这个类目前还不能进行测试（实际上，我们正在尝试执行单元测试——我们将在[*第10章*](B17788_10_ePub.xhtml#_idTextAnchor305)，*使用UI和单元测试测试您的应用程序*)中更详细地讨论这个问题）。
- en: But, why is our simple test throwing `UninitializedPropertyAccessException`?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么我们的简单测试会抛出`UninitializedPropertyAccessException`？
- en: If we have a look at the stack trace, we can see that the crash is caused because
    our test is trying to obtain the application context through `getAppContext()`
    from the `RestaurantsApplication` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看堆栈跟踪，我们可以看到崩溃是由于我们的测试尝试通过`RestaurantsApplication`类中的`getAppContext()`方法获取应用程序上下文而引起的。
- en: 'It makes sense because, if we have another look at `RestaurantsRepository`,
    we can see that to obtain the `restaurantsDao` instance, the `Repository` calls
    `RestaurantsDb.getDaoInstance()` that initializes the Room database, and it needs
    an instance of `Context` to do that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的，因为如果我们再次查看`RestaurantsRepository`，我们可以看到为了获取`restaurantsDao`实例，`Repository`调用`RestaurantsDb.getDaoInstance()`来初始化Room数据库，而这需要`Context`实例来完成：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our small test shouldn't need a `Context` object, simply because it should neither
    try to create a Room database nor to create a Retrofit client instance; it shouldn't
    even depend on these concrete implementations. This is not efficient for small
    tests simply because such operations are memory-expensive and will do nothing
    but slow down our tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小测试不需要`Context`对象，仅仅是因为它不应该尝试创建Room数据库，也不应该创建Retrofit客户端实例；它甚至不应该依赖于这些具体实现。这对于小测试来说并不高效，因为这些操作内存开销大，只会使我们的测试变慢。
- en: Moreover, we don't want our small test (that should run with much ease and very
    fast, several times in a short time frame) to make Room queries or, even worse,
    network requests through Retrofit, simply because the tests are dependent on the
    external world and so they become expensive and difficult to automate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不想让我们的小测试（应该轻松运行，非常快，在短时间内多次运行）通过Room查询，或者更糟糕的是，通过Retrofit进行网络请求，仅仅是因为测试依赖于外部世界，因此它们变得昂贵且难以自动化。
- en: If, however, we would have had DI in place with constructor injection, we could
    have created our own classes that *fake* the behavior, ultimately making our `Repository`
    class easy to test and independent of concrete implementations that perform heavy
    I/O operations. We'll cover more about tests and *faking* in [*Chapter 10*](B17788_10_ePub.xhtml#_idTextAnchor305),
    *Test Your App with UI and Unit Tests*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们已经实现了构造函数注入的依赖注入，我们就可以创建自己的类来*模拟*行为，最终使我们的`Repository`类易于测试，并且独立于执行重I/O操作的具体实现。我们将在[*第10章*](B17788_10_ePub.xhtml#_idTextAnchor305)，*使用UI和单元测试测试您的应用程序*)中更详细地介绍关于测试和*模拟*的内容。
- en: Going back to our app, we're not yet ready to write tests, because as you could
    see, we're lacking DI in our project. Now that we've seen that, without DI, life
    is somehow tough, let's learn how we can incorporate DI in the Restaurants app
    with the help of the Hilt library!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序，我们还没有准备好编写测试，因为正如你所看到的，我们在项目中缺少DI。现在我们已经看到，没有DI，生活似乎有些艰难，让我们学习如何使用Hilt库将DI集成到Restaurants应用程序中！
- en: Implementing DI with Hilt
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hilt实现DI
- en: DI libraries are often used to simplify and accelerate the incorporation of
    DI in our projects, especially when the infrastructure code required by manual
    DI gets difficult to manage in large projects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: DI库通常用于简化并加速我们在项目中集成DI，尤其是在手动DI所需的基础设施代码在大型项目中难以管理时。
- en: '**Hilt** is a DI library that is part of Jetpack, and it removes the unnecessary
    boilerplate involved in manual dependency injection in Android apps by generating
    the code and the infrastructure that you otherwise would have had to develop manually.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hilt**是Jetpack的一部分的DI库，它通过生成您否则必须手动开发的代码和基础设施，消除了Android应用程序中手动依赖注入的冗余代码。'
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hilt is a DI library based on another popular DI framework called **Dagger**,
    meaning that they are strongly related, so we will often refer to Hilt as *Dagger
    Hilt* in this chapter. Due to the steep learning curve of the Dagger APIs, Hilt
    was developed as an abstraction layer over Dagger to allow easier adoption of
    automated DI in Android projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Hilt 是一个基于另一个流行的依赖注入框架 **Dagger** 的 DI 库，这意味着它们之间有很强的关联，因此在本章中我们经常将 Hilt 称为
    *Dagger Hilt*。由于 Dagger API 的学习曲线陡峭，Hilt 被开发为一个抽象层，以允许在 Android 项目中更容易地采用自动 DI。
- en: Dagger Hilt relies on annotation processors to automatically generate code at
    build time, making it able to create and optimize the process of managing and
    providing dependencies throughout your project. Because of that, its core concepts
    are strongly connected to the use of annotations, so before we start adding and
    implementing Hilt in our Restaurants app, we must first cover a few concepts to
    better understand how Dagger Hilt works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger Hilt 依赖于注解处理器在构建时自动生成代码，这使得它能够创建和优化在整个项目中管理和提供依赖项的过程。正因为如此，其核心概念与注解的使用紧密相连，因此在我们开始向我们的餐馆应用中添加和实现
    Hilt 之前，我们必须首先了解一些概念，以便更好地理解 Dagger Hilt 的工作原理。
- en: 'To summarize, in this section we will be doing the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本节中我们将进行以下操作：
- en: Understanding the basics of Dagger Hilt
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Dagger Hilt 的基础知识
- en: Setting up Hilt
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Hilt
- en: Using Hilt for DI
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hilt 进行依赖注入
- en: Let's begin!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding the basics of Dagger Hilt
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Dagger Hilt 的基础知识
- en: 'Let''s analyze the three most important concepts and their corresponding annotations
    that we''re required to work with to enable automatic DI in our project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析三个最重要的概念及其对应的注解，这些注解是我们为了在项目中启用自动 DI 所必须与之合作的：
- en: Injection
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Modules
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Components
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Let's start with injection!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始注入吧！
- en: Injection
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入
- en: Dagger Hilt needs to know the type of instances we want it to provide us with.
    When we discussed manual constructor injection, we initially wanted `ExampleViewModel`
    to be injected wherever we needed it, and we used a `DependencyContainer` class
    for that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger Hilt 需要知道我们希望它为我们提供的实例类型。当我们讨论手动构造函数注入时，我们最初希望 `ExampleViewModel` 在需要的地方被注入，为此我们使用了
    `DependencyContainer` 类。
- en: If we want Dagger Hilt to inject instances of a class somewhere, we must first
    declare a variable of that type and annotate it with the `@Inject` annotation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 Dagger Hilt 在某个地方注入类的实例，我们必须首先声明一个该类型的变量，并用 `@Inject` 注解它。
- en: 'Let''s say that inside the `main()` function used for the manual DI example,
    we no longer want to use manual DI to get an instance of `ExampleViewModel`. Instead,
    we want Dagger to instantiate this class. That''s why we will annotate the `ExampleViewModel`
    variable with the Java `@Inject` annotation and refrain from instantiating the
    `ViewModel` class by ourselves. Dagger Hilt should do that for us now:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们用于手动 DI 示例的 `main()` 函数中，我们不再想使用手动 DI 来获取 `ExampleViewModel` 的实例。相反，我们希望
    Dagger 实例化这个类。这就是为什么我们将 `ExampleViewModel` 变量用 Java 的 `@Inject` 注解，并避免自己实例化 `ViewModel`
    类。现在，Dagger Hilt 应该为我们做这件事：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, for Dagger Hilt to know how to provide us with an instance of the `ExampleViewModel`
    class, we must also add the `@Inject` annotation to the dependencies of `ExampleViewModel`
    so that Dagger knows how to instantiate the `ViewModel` class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使 Dagger Hilt 知道如何为我们提供 `ExampleViewModel` 类的实例，我们还必须将 `@Inject` 注解添加到
    `ExampleViewModel` 的依赖项上，这样 Dagger 就知道如何实例化 `ViewModel` 类。
- en: 'Since the dependencies of `ExampleViewModel` are inside the constructor (from
    when we used manual constructor injection), we can directly add the `@Inject`
    annotation to `constructor`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ExampleViewModel` 的依赖项位于构造函数中（从我们使用手动构造函数注入时开始），我们可以直接在 `constructor` 上添加
    `@Inject` 注解：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, Dagger Hilt also needs to know how to inject the dependencies of `ExampleViewModel`,
    more precisely the `Repository` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Dagger Hilt 还需要知道如何注入 `ExampleViewModel` 的依赖项，更确切地说，是 `Repository` 类。
- en: 'Let''s consider that `Repository` has only one dependency, a `Retrofit` constructor
    variable. For Dagger to know how to inject a `Repository` class, we must annotate
    its constructor with `@Inject` as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 `Repository` 只有一个依赖项，一个 `Retrofit` 构造函数变量。为了使 Dagger 知道如何注入 `Repository`
    类，我们必须用 `@Inject` 注解其构造函数：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Until now, we got away with `@Inject` annotations because we had access to the
    classes and dependencies that we were trying to inject, but now, how can Dagger
    know how to provide us with a `Retrofit` instance? We have no way of tapping inside
    the `Retrofit` class and annotating its constructor with `@Inject`, since it's
    in an external library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过`@Inject`注解得以幸免，因为我们有访问我们试图注入的类和依赖项，但现在，Dagger如何知道如何为我们提供`Retrofit`实例呢？我们没有方法进入`Retrofit`类并注解其构造函数为`@Inject`，因为它位于外部库中。
- en: To instruct Dagger on how to provide us with specific dependencies, let's learn
    a bit about modules!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要指导Dagger如何为我们提供特定的依赖项，让我们了解一下模块吧！
- en: Modules
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: '`@Module` that allow us to instruct Dagger Hilt on how to provide dependencies.
    For example, we need Dagger Hilt to provide us with a `Retrofit` instance in our
    `Repository`, so we could define a `DataModule` class that tells Dagger Hilt how
    to do so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Module`允许我们指导Dagger Hilt如何提供依赖。例如，我们需要Dagger Hilt为我们提供`Repository`中的`Retrofit`实例，因此我们可以定义一个`DataModule`类，告诉Dagger
    Hilt如何这样做：'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To tell the library how to provide us with a dependency, we must create a method
    inside the `@Module` annotated class where we manually build that class instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉库如何为我们提供依赖项，我们必须在`@Module`注解的类内部创建一个方法，手动构建该类的实例。
- en: Since we don't have access to the `Retrofit` class and we need it injected,
    we've created a `provideRetrofit()` method (you can call it any way you want)
    annotated with the `@Provides` annotation, and that returns a `Retrofit` object.
    Inside the method, we manually created the `Retrofit` instance the way we needed
    it to be built.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有访问`Retrofit`类，并且需要将其注入，因此我们创建了一个带有`@Provides`注解的`provideRetrofit()`方法（你可以按任何你想要的方式调用它），它返回一个`Retrofit`对象。在方法内部，我们手动创建了`Retrofit`实例，按照我们需要的构建方式。
- en: Now, Dagger Hilt knows how to provide us with all the dependencies our `ExampleViewModel`
    needs (its direct `Repository` dependency and `Repository` `Retrofit` dependency).
    Yet, Dagger will complain that it needs a component class in which the module
    we've created must be installed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Dagger Hilt知道如何为我们提供`ExampleViewModel`需要的所有依赖（它的直接`Repository`依赖和`Repository`
    `Retrofit`依赖）。然而，Dagger会抱怨它需要一个组件类，其中我们必须安装我们创建的模块。
- en: Let's have a brief look at components next!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看组件吧！
- en: Components
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: '**Components** are interfaces that represent the container for a certain set
    of dependencies. A component takes in modules and makes sure that the injection
    of its dependencies happens with respect to a certain lifecycle.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是表示一组特定依赖项的接口。组件接受模块并确保其依赖项的注入与特定的生命周期相符合。'
- en: For our example with the `ExampleViewModel`, `Repository`, and `Retrofit` dependencies,
    let's say that we create a component that manages the creation for these dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`ExampleViewModel`、`Repository`和`Retrofit`依赖项的示例，假设我们创建一个管理这些依赖项创建的组件。
- en: 'With Dagger Hilt, you can define a component with the `@DefineComponent` annotation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dagger Hilt，你可以使用`@DefineComponent`注解定义一个组件：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Afterward, we could install our `DataModule` in this component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在该组件中安装我们的`DataModule`：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In practice though, the process of defining and building a component is more
    complex than that. This is because a component must scope its dependencies to
    a certain lifetime scope (such as the lifetime of the application) and have a
    pre-existent parent component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，定义和构建组件的过程比这更复杂。这是因为组件必须将其依赖项范围到某个生命周期范围内（例如应用程序的生命周期）并且有一个预存在的父组件。
- en: Luckily, Hilt provides components for us out of the box. Such predefined components
    allow us to install modules in them and to scope dependencies to their corresponding
    lifetime scope.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Hilt为我们提供了现成的组件。这些预定义的组件允许我们在其中安装模块，并将依赖项范围到它们对应的生命周期范围内。
- en: 'Some of the most important predefined components are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些最重要的预定义组件如下：
- en: '`SingletonComponent`: Allows us to scope dependencies to the lifetime of the
    application, as singletons, by annotating them with the `@Singleton` annotation.
    Every time a dependency annotated with `@Singleton` is requested, Dagger will
    provide the same instance.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingletonComponent`：允许我们通过使用`@Singleton`注解将依赖项范围到应用程序的生命周期，作为单例。每次请求带有`@Singleton`注解的依赖项时，Dagger都会提供相同的实例。'
- en: '`ActivityComponent`: Allows us to scope dependencies to the lifetime of an
    `Activity`, with the `@ActivityScoped` annotation. If the `Activity` is recreated,
    a new instance of the dependency will be provided.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityComponent`：允许我们使用 `@ActivityScoped` 注解将依赖项的范围限定为 `Activity` 的生命周期。如果
    `Activity` 被重建，将提供一个新的依赖项实例。'
- en: '`ActivityRetainedComponent`: Allows us to scope dependencies to the lifetime
    of an `Activity`, surpassing its recreation upon orientation change, with the
    `@ActivityRetainedScoped` annotation. If the `Activity` is recreated upon orientation
    change, the same instance of the dependency is provided.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityRetainedComponent`：允许我们使用 `@ActivityRetainedScoped` 注解将依赖项的范围限定为 `Activity`
    的生命周期，超越其方向改变后的重建。如果 `Activity` 在方向改变时被重建，将提供相同的依赖项实例。'
- en: '`ViewModelComponent`: Allows us to scope dependencies to the lifetime of a
    `ViewModel`, with the `@ViewModelScoped` annotation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModelComponent`：允许我们使用 `@ViewModelScoped` 注解将依赖项的范围限定为 `ViewModel` 的生命周期。'
- en: 'As the lifetime scope of these components varies, this also translates into
    the fact that each component derives its lifetime scope from each other, from
    the widest `@Singleton` lifetime scope (of the application) to narrower scopes
    such as `@ActivityScoped` (of an `Activity`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些组件的生命周期范围不同，这也转化为每个组件从彼此那里推导出其生命周期范围，从最宽的 `@Singleton` 生命周期范围（应用）到更窄的范围，如
    `@ActivityScoped`（活动）：
- en: '![Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their
    corresponding components'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – Dagger Hilt 范围注解及其对应组件的简化版本'
- en: '](img/B17788_09_3.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_09_3.jpg](img/B17788_09_3.jpg)'
- en: Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their corresponding
    components
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Dagger Hilt 范围注解及其对应组件的简化版本
- en: 'While in our Restaurants app, we will mostly be using `SingletonComponent`
    and its `@Singleton` scope annotation; it''s important to note that Dagger Hilt
    exposes a broader variety of predefined components and scopes. Check them out
    in the documentation here: [https://dagger.dev/hilt/components.html](https://dagger.dev/hilt/components.html).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的餐厅应用中，我们将主要使用 `SingletonComponent` 和其 `@Singleton` 范围注解；重要的是要注意，Dagger Hilt
    提供了更广泛预定义的组件和范围。您可以在以下文档中查看它们：[https://dagger.dev/hilt/components.html](https://dagger.dev/hilt/components.html)。
- en: Now that we've briefly covered components, it's time to add Hilt to our Restaurants
    app!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了组件，是时候将 Hilt 添加到我们的餐厅应用中了！
- en: Setting up Hilt
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Hilt
- en: Before injecting dependencies with Hilt, we must first set up Hilt. Let's begin!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Hilt 注入依赖项之前，我们必须首先设置 Hilt。让我们开始吧！
- en: 'In the project-level `build.gradle` file, inside the `dependencies` block,
    add the Hilt-Android Gradle dependency:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目级别的 `build.gradle` 文件中，在 `dependencies` 块内，添加 Hilt-Android Gradle 依赖项：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Moving inside the application-level `build.gradle` file, add the Dagger Hilt
    plugin inside the `plugins` block:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用级别的 `build.gradle` 文件中移动，在 `plugins` 块内添加 Dagger Hilt 插件：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Still inside the application-level `build.gradle`, inside the `dependencies`
    block, add the Android-Hilt dependencies:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在应用级别的 `build.gradle` 中，在 `dependencies` 块内，添加 Android-Hilt 依赖项：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `kapt` keyword stands for **Kotlin Annotation Processor Tool** and is required
    by Dagger Hilt to generate code based on the annotations we will be using.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`kapt` 关键字代表 **Kotlin 注解处理器工具**，它是 Dagger Hilt 生成基于我们将使用的注解的代码所必需的。'
- en: After updating the `build.gradle` files, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **与 Gradle
    文件同步项目** 来完成此操作。
- en: 'Annotate the `RestaurantsApplication` class with the `@HiltAndroidApp` annotation:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@HiltAndroidApp` 注解标注 `RestaurantsApplication` 类：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To make use of automated DI with Hilt, we must annotate our `Application` class
    with the `HiltAndroidApp` annotation. This annotation allows Hilt to generate
    DI-related boilerplate code, starting with the application-level dependency container.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Hilt 的自动化依赖注入，我们必须使用 `HiltAndroidApp` 注解来标注我们的 `Application` 类。这个注解允许 Hilt
    生成与依赖注入相关的样板代码，从应用级别的依赖容器开始。
- en: Build the project to trigger Hilt's code generation.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以触发 Hilt 的代码生成。
- en: 'Optionally, if you want to check out the generated classes, first, expand the
    **Project** tab on the left, and then expand the package for the generated code.
    These classes are the proof that Hilt generates a lot of code behind the scenes
    so we can incorporate DI much easier:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，如果您想查看生成的类，首先，展开左侧的 **项目** 选项卡，然后展开生成代码的包。这些类是 Hilt 在幕后生成大量代码的证明，这样我们可以更容易地实现依赖注入：
- en: '![Figure 9.4 – Automatically generated classes by Hilt'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.4 – Automatically generated classes by Hilt]'
- en: '](img/B17788_09_4.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_09_4.jpg]'
- en: Figure 9.4 – Automatically generated classes by Hilt
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Hilt 自动生成的类
- en: Let's move on to the actual implementation!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实际的实现！
- en: Using Hilt for DI
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hilt 进行依赖注入
- en: In this sub-section, we will implement DI with Hilt for the first screen of
    our app where the list of restaurants is displayed. In other words, we want to
    inject all the dependencies that `RestaurantsScreen()` needs or depends on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将使用 Hilt 在应用的第一屏中实现依赖注入，该屏显示餐厅列表。换句话说，我们希望注入 `RestaurantsScreen()` 所需或依赖的所有依赖项。
- en: 'To have a starting point, let''s have a look inside the `RestaurantsApp()`
    composable for the `RestaurantsScreen()` destination and see what we have to inject
    first:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个起点，让我们看看 `RestaurantsScreen()` 目的地中的 `RestaurantsApp()` 组合函数，看看我们首先需要注入什么：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's clear that `RestaurantsScreen()` depends on `RestaurantsViewModel` to obtain
    its state and consume it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`RestaurantsScreen()` 依赖于 `RestaurantsViewModel` 来获取其状态并消费它。
- en: 'This means that we must first inject an instance of `RestaurantsViewModel`
    inside the `composable()` destination where the `RestaurantsScreen()` resides:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须首先在 `RestaurantsScreen()` 所在的 `composable()` 目的地中注入一个 `RestaurantsViewModel`
    实例：
- en: 'Since we cannot add the `@Inject` annotation inside a composable function,
    we must use a special composable function to inject a `ViewModel`. To do that,
    first, add the `hilt-navigation-compose` dependency inside the `dependencies`
    block of the app-level `build.gradle` file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们无法在组合函数内部添加 `@Inject` 注解，我们必须使用一个特殊的组合函数来注入 `ViewModel`。为此，首先，在应用级别的 `build.gradle`
    文件的 `dependencies` 块中添加 `hilt-navigation-compose` 依赖项：
- en: '[PRE22]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **与 Gradle
    文件同步项目** 来完成此操作。
- en: 'Then, going back inside the `RestaurantsApp()` composable, in the DSL `composable()`
    destination for our `RestaurantsScreen()` composable, replace the `viewModel()`
    constructor of `RestaurantsViewModel` with the `hiltViewModel()` composable:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到 `RestaurantsApp()` 组合函数内部，在我们的 `RestaurantsScreen()` 组合函数的 DSL `composable()`
    目标中，将 `RestaurantsViewModel` 的 `viewModel()` 构造函数替换为 `hiltViewModel()` 组合函数：
- en: '[PRE23]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `hiltViewModel()` function injects an instance of `RestaurantsViewModel`
    scoped to the lifetime of the `RestaurantsScreen()` navigation component destination.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`hiltViewModel()` 函数注入一个 `RestaurantsViewModel` 实例，其作用域与 `RestaurantsScreen()`
    导航组件目标的生命周期相同。'
- en: 'Since now our composable hierarchy injects a `ViewModel` at some point with
    the help of Hilt, we must annotate the Android component that is the host of the
    `RestaurantsApp()` root composable with the `@AndroidEntryPoint` annotation. In
    our case, the `RestaurantsApp()` composable is hosted by the `MainActivity` class,
    so we must annotate it with the `@AndroidEntryPoint` annotation:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在我们的组合层次结构在 Hilt 的帮助下在某个点注入了一个 `ViewModel`，我们必须使用 `@AndroidEntryPoint` 注解来注释
    `RestaurantsApp()` 根组合函数的宿主 Android 组件。在我们的例子中，`RestaurantsApp()` 组合函数由 `MainActivity`
    类托管，因此我们必须使用 `@AndroidEntryPoint` 注解来注释它：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `@AndroidEntryPoint` annotation generates another component for our `Activity`
    with a lifetime narrower than the lifetime of the application. More precisely,
    this component allows us to scope dependencies to the lifetime of our `Activity`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AndroidEntryPoint` 注解为我们的 `Activity` 生成另一个组件，其生命周期比应用程序的生命周期更短。更确切地说，这个组件允许我们将依赖项的作用域限定到我们的
    `Activity` 的生命周期。'
- en: 'In the `RestaurantsViewModel` class, first refactor it to explicitly declare
    its dependencies by moving them inside its constructor so that testability is
    promoted through constructor injection:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 类中，首先将其重构为通过将其移动到其构造函数中来显式声明其依赖项，从而通过构造函数注入提高可测试性：
- en: '[PRE25]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that, while we extracted the two Use Case variables into the constructor,
    we're no longer instantiating them – we will leave that to Hilt.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们将两个 Use Case 变量提取到构造函数中，但我们不再实例化它们——我们将留给 Hilt 来完成。
- en: 'To get Hilt to inject `RestaurantsViewModel` for us, mark the `ViewModel` with
    the `@HiltViewModel` annotation, while also annotating its constructor with the
    `@Inject` annotation so that Hilt understands which dependencies of the `ViewModel`
    must be provided:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 Hilt 帮我们注入 `RestaurantsViewModel`，用 `@HiltViewModel` 注解标记 `ViewModel`，同时用
    `@Inject` 注解其构造函数，以便 Hilt 理解 `ViewModel` 的哪些依赖项必须由 Hilt 提供：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that our `ViewModel` is annotated with `@HiltViewModel`, instances of `RestaurantsViewModel`
    will be provided by `ViewModelComponent` that respects the lifecycle of a `ViewModel`
    (bound to the lifetime of the composable destination while also surviving configuration
    changes).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们的 `ViewModel` 被标记为 `@HiltViewModel`，`RestaurantsViewModel` 的实例将由尊重 `ViewModel`
    生命周期的 `ViewModelComponent` 提供（绑定到可组合目的地的生命周期，同时也能在配置更改中存活）。
- en: 'Now that we instructed Hilt how to provide `RestaurantsViewModel`, we might
    think we''re done; yet, if we build the application, we will get this exception:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经指导 Hilt 如何提供 `RestaurantsViewModel`，我们可能会认为我们已经完成了；然而，如果我们构建应用程序，我们将得到这个异常：
- en: '![Figure 9.5 – Hilt compilation error'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – Hilt 编译错误'
- en: '](img/B17788_09_5.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_09_5.jpg)'
- en: Figure 9.5 – Hilt compilation error
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Hilt 编译错误
- en: 'The issue lies in the fact that, while we instructed Hilt to inject `RestaurantsViewModel`
    and its dependencies, we never made sure that Hilt knows how to provide those
    dependencies: neither the `GetInitialRestaurantsUseCase` dependency nor the `ToggleRestaurantsUseCase`
    dependency.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然我们指示 Hilt 注入 `RestaurantsViewModel` 及其依赖项，但我们从未确保 Hilt 知道如何提供这些依赖项：既没有
    `GetInitialRestaurantsUseCase` 依赖项，也没有 `ToggleRestaurantsUseCase` 依赖项。
- en: In other words, if we want `RestaurantsViewModel` to be injected, we need to
    make sure that its dependencies can be provided by Hilt, and their dependencies
    too, and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们想注入 `RestaurantsViewModel`，我们需要确保其依赖项可以由 Hilt 提供，以及它们的依赖项，依此类推。
- en: 'Let''s first make sure that Hilt knows how to provide `GetInitialRestaurantsUseCase`
    to `RestaurantsViewModel`. Inside the `GetInitialRestaurantsUseCase` class, move
    its dependencies inside the constructor and mark it with `@Inject`, just like
    we did with `RestaurantsViewModel`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先确保 Hilt 知道如何将 `GetInitialRestaurantsUseCase` 注入到 `RestaurantsViewModel`
    中。在 `GetInitialRestaurantsUseCase` 类中，将其依赖项移动到构造函数中，并用 `@Inject` 标记，就像我们对 `RestaurantsViewModel`
    做的那样：
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After you add the `repository` and `getSortedRestaurantsUseCase` variables inside
    the constructor, remember to remove the old member variables as well as their
    instantiation code from the body of `GetInitialRestaurantsUseCase`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中添加 `repository` 和 `getSortedRestaurantsUseCase` 变量后，请记住从 `GetInitialRestaurantsUseCase`
    的主体中删除旧成员变量以及它们的实例化代码。
- en: Note that we aren't annotating the `GetInitialRestaurantsUseCase` class with
    any Hilt scope annotations, simply because we don't want it to be tied to a certain
    lifetime scope.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在 `GetInitialRestaurantsUseCase` 类上使用任何 Hilt 作用域注解，仅仅是因为我们不希望它与某个生命周期作用域绑定。
- en: 'Now, Hilt knows how to inject the `GetInitialRestaurantsUseCase` class, yet
    we must also instruct Hilt how to provide its dependencies as well: `RestaurantsRepository`
    and `GetSortedRestaurantsUseCase`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Hilt 知道如何注入 `GetInitialRestaurantsUseCase` 类，但我们也必须指导 Hilt 如何提供其依赖项：`RestaurantsRepository`
    和 `GetSortedRestaurantsUseCase`。
- en: 'We need to make sure that Hilt knows how to provide instances of `RestaurantsRepository`.
    We can see that its dependencies are `RestaurantsApiService` (the Retrofit interface)
    and `RestaurantsDao` (the Room Data Access Object interface):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保 Hilt 知道如何提供 `RestaurantsRepository` 的实例。我们可以看到，它的依赖项是 `RestaurantsApiService`（Retrofit
    接口）和 `RestaurantsDao`（Room 数据访问对象接口）：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The issue here is that once we place these dependencies inside the constructor
    and inject them, Hilt will have no idea how to provide them – simply because we
    cannot tap into the internal workings of Room or Retrofit and inject their dependencies
    too, like we did with `RestaurantsViewModel`, `GetInitialRestaurantsUseCase`,
    and now with `RestaurantsRepository`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，一旦我们将这些依赖项放入构造函数并注入它们，Hilt 就将无法知道如何提供它们——仅仅是因为我们无法像对 `RestaurantsViewModel`、`GetInitialRestaurantsUseCase`
    和现在的 `RestaurantsRepository` 那样，深入 Room 或 Retrofit 的内部工作并注入它们的依赖项。
- en: 'For Hilt to know how to provide dependencies out of our reach, we must create
    a `module` class where we will instruct Hilt on how to provide us with instances
    of `RestaurantsApiService` and `RestaurantsDao`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Hilt 知道如何提供我们无法触及的依赖项，我们必须创建一个 `module` 类，在其中我们将指导 Hilt 如何提供 `RestaurantsApiService`
    和 `RestaurantsDao` 的实例：
- en: 'Expand the `restaurants` package, then right click on the `data` package, and
    create a new package called `di` (short for dependency injection). Inside this
    package, create a new `object` class called `RestaurantsModule` and add the following
    code inside:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `restaurants` 包，然后在 `data` 包上右键单击，创建一个名为 `di`（代表依赖注入）的新包。在这个包内部，创建一个名为 `RestaurantsModule`
    的新 `object` 类，并在其中添加以下代码：
- en: '[PRE29]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`RestaurantsModule` will allow us to instruct Hilt on how to provide Room and
    Retrofit dependencies to `RestaurantsRepository`. Since this is a Hilt module,
    we have done the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantsModule` 将允许我们指导 Hilt 如何向 `RestaurantsRepository` 提供Room和Retrofit依赖项。由于这是一个
    Hilt 模块，我们做了以下操作：'
- en: Annotated it with `@Module` so that Hilt recognizes it as a module that provides
    instances of dependencies.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@Module` 注解，以便 Hilt 识别它为一个提供依赖项实例的模块。
- en: Annotated it with `@InstallIn()` and passed the predefined `SingletonComponent`
    component provided by Hilt. Since our module is installed in this component, the
    dependencies that are contained can be provided anywhere throughout the application
    since `SingletonComponent` is an application-level dependency container.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@InstallIn()` 注解，并传递了 Hilt 提供的预定义 `SingletonComponent` 组件。由于我们的模块安装在这个组件中，包含的依赖项可以在应用程序的任何地方提供，因为
    `SingletonComponent` 是一个应用程序级别的依赖项容器。
- en: Next up, inside `RestaurantsModule`, we need to tell Hilt how to provide our
    dependencies, so we will start with `RestaurantsDao`. For us to obtain an instance
    to `RestaurantsDao`, we must first instruct Hilt on how to instantiate a `RestaurantsDb`
    class.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `RestaurantsModule` 中，我们需要告诉 Hilt 如何提供我们的依赖项，因此我们将从 `RestaurantsDao` 开始。为了获取
    `RestaurantsDao` 的实例，我们必须首先指导 Hilt 如何实例化 `RestaurantsDb` 类。
- en: 'Add a `provideRoomDatabase` method annotated with `@Provides` that will instruct
    Hilt how to provide an `RestaurantsDb` object by borrowing part of the instantiation
    code of the `database` class from the `companion object` of the `RestaurantsDb`
    class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有 `@Provides` 注解的 `provideRoomDatabase` 方法，该方法将指导 Hilt 如何通过从 `RestaurantsDb`
    类的 `companion object` 中借用部分 `database` 类的实例化代码来提供一个 `RestaurantsDb` 对象：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First off, we've annotated the `provideRoomDatabase()` method with the `@Singleton`
    instance so that Hilt will create only one instance of `RestaurantsDb` for the
    whole application, allowing us to save memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `@Singleton` 实例注解了 `provideRoomDatabase()` 方法，这样 Hilt 就会为整个应用程序创建一个
    `RestaurantsDb` 实例，从而节省内存。
- en: Then, we can see that the `provideRoomDatabase()` method builds a `RestaurantsDb`
    instance, yet for this to work, we needed to provide the application-wide context
    to the `Room.databaseBuilder()` method. To achieve this, we have passed a `Context`
    object as a parameter of `provideRoomDatabase()` and annotated it with `@ApplicationContext`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到 `provideRoomDatabase()` 方法构建了一个 `RestaurantsDb` 实例，但为了使其工作，我们需要向 `Room.databaseBuilder()`
    方法提供应用程序级别的上下文。为此，我们通过将 `Context` 对象作为 `provideRoomDatabase()` 方法的参数传递，并使用 `@ApplicationContext`
    注解来实现这一点。
- en: To understand how Hilt provides us with the application `Context` object, we
    must first note that each Hilt container comes with a set of default bindings
    that we can inject as dependencies. The `SingletonComponent` container provides
    us with the application-wide `Context` object wherever we need it by defining
    the `@ApplicationContext` annotation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Hilt 如何为我们提供应用程序 `Context` 对象，我们必须首先注意，每个 Hilt 容器都附带一组默认绑定，我们可以将其作为依赖项注入。`SingletonComponent`
    容器通过定义 `@ApplicationContext` 注解，在需要的地方为我们提供应用程序级别的 `Context` 对象。
- en: 'Now that Hilt knows to provide us with `RestaurantsDb`, we can create another
    `@Provides` method that takes in a `RestaurantsDb` variable (which Hilt will now
    know how to provide) and return a `RestaurantsDao` instance:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Hilt 知道为我们提供 `RestaurantsDb`，我们可以创建另一个 `@Provides` 方法，该方法接受一个 `RestaurantsDb`
    变量（Hilt 将知道如何提供）并返回一个 `RestaurantsDao` 实例：
- en: '[PRE31]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Still inside `RestaurantsModule`, we now have to tell Hilt how to provide us
    with an instance of `RestaurantsApiService`. Do the same as before, but this time
    add a `@Provides` method for an instance of `Retrofit`, and one for an instance
    of `RestaurantsApiService`. Now, `RestaurantsModule` should look like this:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RestaurantsModule` 中，我们现在必须告诉 Hilt 如何为我们提供一个 `RestaurantsApiService` 的实例。像之前一样操作，但这次添加一个为
    `Retrofit` 实例的 `@Provides` 方法，以及一个为 `RestaurantsApiService` 实例的 `@Provides` 方法。现在，`RestaurantsModule`
    应该看起来像这样：
- en: '[PRE32]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember that all this instantiation code resides in `RestaurantsRepository`,
    so you can get it from there.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 记住所有这些实例化代码都位于 `RestaurantsRepository` 中，因此你可以从那里获取。
- en: 'Now that Hilt knows how to provide both dependencies of `RestaurantsRepository`,
    head back in the `RestaurantsRepository` class and apply constructor injection
    with Hilt by adding the `@Inject` annotation to the constructor while moving its
    `RestaurantsApiService` and `RestaurantsDao` dependencies inside the constructor:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Hilt 知道如何提供 `RestaurantsRepository` 的两个依赖项，让我们回到 `RestaurantsRepository`
    类，并使用 Hilt 应用构造函数注入，通过在构造函数上添加 `@Inject` 注解，并将其 `RestaurantsApiService` 和 `RestaurantsDao`
    依赖项移动到构造函数中：
- en: '[PRE33]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Usually, `Repository` classes have a static instance so that only one instance
    is re-used throughout the app. This is useful when different data is stored in
    memory globally in `Repository` classes (be cautious with system-initiated process
    death because that will wipe anything in memory!).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Repository` 类有一个静态实例，这样在整个应用程序中只有一个实例被重用。当在 `Repository` 类中全局存储不同的数据时，这很有用（在使用系统启动的进程死亡时要小心，因为这会清除内存中的所有内容！）。
- en: Finally, to have only one instance of `RestaurantsRepository` that can then
    be reused across the app, we have annotated the class with the `@Singleton` annotation.
    This annotation is provided by the Hilt `SingletonComponent` container and allows
    us to scope instances of classes to the lifetime of the application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了有一个可以在整个应用程序中重用的 `RestaurantsRepository` 实例，我们使用 `@Singleton` 注解了这个类。这个注解由
    Hilt 的 `SingletonComponent` 容器提供，允许我们将类的实例范围限定在应用程序的生命周期内。
- en: 'Now that Hilt knows how to inject `RestaurantsRepository`, let''s get back
    to the other remaining dependency of `GetInitialRestaurantsUseCase`: the `GetSortedRestaurantsUseCase`
    class. Head inside this class and make sure to inject its dependencies by moving
    the `repository` variable inside the constructor as we did before with other classes:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Hilt 知道如何注入 `RestaurantsRepository`，让我们回到 `GetInitialRestaurantsUseCase`
    的其他剩余依赖项：`GetSortedRestaurantsUseCase` 类。进入这个类，并确保通过将 `repository` 变量移动到构造函数中（就像我们之前对其他类所做的那样）来注入其依赖项：
- en: '[PRE34]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While we have annotated `RestaurantsRepository` with a scope annotation, we
    haven't added any scope annotation for this Use Case class simply because we don't
    want the instance to be preserved across a specific lifetime.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经用范围注解注解了 `RestaurantsRepository`，但我们没有为这个 Use Case 类添加任何范围注解，仅仅是因为我们不希望实例在特定的生命周期内被保留。
- en: Now, we have instructed Hilt how to provide all the dependencies for the first
    dependency of `RestaurantsViewModel`, which is `GetInitialRestaurantsUseCase`!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经指导 Hilt 如何为 `RestaurantsViewModel` 的第一个依赖项提供所有依赖项，即 `GetInitialRestaurantsUseCase`！
- en: 'Next up, let''s tell Hilt how to provide the dependencies for the second and
    last dependency of `RestaurantsViewModel`, the `ToggleRestaurantUseCase` class.
    Head inside this class and make sure to inject its dependencies by moving the
    `repository` and `getSortedRestaurantsUseCase` variables inside the constructor
    as we did before with other classes:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们告诉 Hilt 如何为 `RestaurantsViewModel` 的第二个和最后一个依赖项 `ToggleRestaurantUseCase`
    类提供依赖项。进入这个类，并确保通过将 `repository` 和 `getSortedRestaurantsUseCase` 变量移动到构造函数中（就像我们之前对其他类所做的那样）来注入其依赖项：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Optionally, you can head inside the `RestaurantsDb` class and delete the entire
    `companion object` that was in charge of providing a singleton instance for our
    `RestaurantsDao`. The `RestaurantsDb` class should now be much slimmer and look
    like this:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以进入 `RestaurantsDb` 类并删除负责为我们 `RestaurantsDao` 提供单例实例的整个 `companion object`。现在，`RestaurantsDb`
    类应该更加精简，看起来应该是这样的：
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It's safe to delete this instantiation code because from now on, Hilt will do
    that for us out of the box.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以安全地删除这个实例化代码，因为从现在开始，Hilt 会为我们自动完成这项工作。
- en: Also, if you followed the previous step of cleaning up the `RestaurantsDb` class,
    inside `RestaurantsApplication`, you can also remove all the logic inside this
    class that was related to obtaining the application-wide `Context` object. From
    now on, Hilt will do that for us out of the box.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果你遵循了清理 `RestaurantsDb` 类的上一步骤，在 `RestaurantsApplication` 中，你也可以删除这个类中与获取应用程序级
    `Context` 对象相关的所有逻辑。从现在开始，Hilt 会为我们自动完成这项工作。
- en: 'The `RestaurantsApplication` class should be much slimmer and look like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantsApplication` 类应该更加精简，看起来应该是这样的：'
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Build and run the application. Now, the build should be successful because Hilt
    is in charge of providing the dependencies that we required it to provide.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。现在，构建应该成功，因为 Hilt 负责提供我们需要的依赖项。
- en: With the help of DI, we have now promoted testability while also extracting
    the boilerplate associated with building class instances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DI 的帮助下，我们现在提高了测试性，同时也提取了与构建类实例相关的样板代码。
- en: Assignment
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作业
- en: We have integrated DI with Hilt for the first screen of `RestaurantsApplication`.
    However, the project is still not incorporating DI entirely because the second
    destination of our app (represented by the `RestaurantDetailsScreen()` composable)
    has neither its `RestaurantDetailsViewModel` injected nor this `ViewModel` class's
    dependencies injected. As a take-home assignment, incorporate DI in this second
    screen. This will allow you to get rid of the redundant Retrofit client instantiation
    inside `RestaurantDetailsViewModel` – remember that you can now inject a `RestaurantsApiService`
    instance directly with Hilt!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 DI 与 Hilt 集成到 `RestaurantsApplication` 的第一个屏幕中。然而，项目还没有完全采用 DI，因为我们的应用第二个目的地（由
    `RestaurantDetailsScreen()` 组合表示）既没有注入其 `RestaurantDetailsViewModel`，也没有注入这个 `ViewModel`
    类的依赖项。作为课后作业，将 DI 集成到这个第二个屏幕中。这将允许你从 `RestaurantDetailsViewModel` 中移除冗余的 Retrofit
    客户端实例化 – 记住，你现在可以直接使用 Hilt 注入 `RestaurantsApiService` 实例！
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved the architecture of the Restaurants App by incorporating
    DI.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过引入 DI 改进了“餐厅应用”的架构。
- en: 'We discussed what DI is and covered its basic concepts: dependency with its
    implicit or explicit types, injection, dependency containers, and manual injection.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了什么是 DI，并涵盖了其基本概念：具有隐式或显式类型的依赖项、注入、依赖容器和手动注入。
- en: 'We then examined the main benefits that DI brings to our projects: testable
    classes and less boilerplate code.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查了 DI 为我们的项目带来的主要好处：可测试的类和更少的样板代码。
- en: Finally, we covered how DI frameworks can help us with the injection of dependencies,
    and explored the Jetpack Hilt library as a viable solution for DI on Android.
    Afterward, we practiced what we learned as we incorporated DI with Hilt in our
    Restaurants app.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 DI 框架如何帮助我们进行依赖项注入，并探讨了 Jetpack Hilt 库作为 Android 上 DI 的可行解决方案。之后，我们在“餐厅应用”中结合
    Hilt 实施了我们所学的知识。
- en: Since we incorporated DI, it's a bit clearer that our classes can be easily
    tested, so it's time we start writing some tests in the next chapter!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们引入了依赖注入（DI）后，我们的类可以更容易地进行测试这一点变得更加清晰，因此是时候在下一章开始编写一些测试了！
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Knowing how to work with the basics of Hilt is usually enough for most projects.
    However, sometimes you might need to use more advanced features of Hilt or Dagger.
    To learn more about Dagger and how the framework automatically creates the dependencies
    for you by building a dependency graph, check this article: [https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82](https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，了解如何使用 Hilt 的基础知识就足够应对大多数项目。然而，有时你可能需要使用 Hilt 或 Dagger 的更高级功能。要了解更多关于
    Dagger 以及框架如何通过构建依赖图自动为你创建依赖项的信息，请查看这篇文章：[https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82](https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82)。
- en: 'On the same note, apart from the `@Singleton` scope that was the most used
    scope throughout our app, Dagger Hilt exposes a broader variety of predefined
    components and scopes that allow you to scope different classes to various lifecycles.
    Check out more about components and their scopes in the official documentation:
    [https://dagger.dev/hilt/components.html](https://dagger.dev/hilt/components.html).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，除了我们应用中最常用的 `@Singleton` 作用域之外，Dagger Hilt 还公开了更广泛预定义的组件和作用域，允许你将不同的类范围到各种生命周期。更多关于组件及其作用域的信息，请查看官方文档：[https://dagger.dev/hilt/components.html](https://dagger.dev/hilt/components.html)。
- en: 'Leaving components and their scopes aside, in some projects, you might need
    to allow injection of dependencies in other Android classes than `Activity`. To
    see which Android classes can be annotated with `@AndroidEntryPoint`, check out
    the documentation: https://dagger.dev/hilt/android-entry-point.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了组件及其作用域之外，在某些项目中，你可能需要允许在除了 `Activity` 之外的其他 Android 类中进行依赖项的注入。要查看哪些 Android
    类可以被标注为 `@AndroidEntryPoint`，请查阅文档：https://dagger.dev/hilt/android-entry-point。
