- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Learning about Variables, Constants, Strings, and Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于变量、常量、字符串和操作符的知识
- en: The first program I ever wrote was written in BASIC and was the typical Hello
    World application. This application was exciting at first, but the excitement
    of printing static text wore off pretty quickly. For my second application, I
    used BASIC's input command to ask the user for a name and then printed out a custom
    "hello" message with the name they entered. At the age of 12, it was pretty cool
    to display `Hello Han Solo`. This application led me to create numerous Mad Libs-style
    applications that prompted the user for various words, and then put those words
    into a story that was displayed after the user had entered all the required words.
    These applications introduced me to, and taught me, the importance of variables.
    Every useful application I've created since then has used variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我写的第一个程序是用 BASIC 编写的，是一个典型的 Hello World 应用程序。这个应用程序一开始很令人兴奋，但打印静态文本的兴奋感很快就消失了。对于我的第二个应用程序，我使用了
    BASIC 的输入命令来询问用户的名字，然后打印出带有他们输入的名字的自定义“hello”消息。12岁的时候，显示“Hello Han Solo”还是挺酷的。这个应用程序让我创建了大量的
    Mad Libs 风格的应用程序，这些应用程序会提示用户输入各种单词，然后在用户输入所有必需的单词后显示一个故事。这些应用程序让我了解到，并教会了我变量的重要性。从那时起，我创建的每个有用的应用程序都使用了变量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are variables and constants?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和常量是什么？
- en: What is the difference between explicit and inferred typing?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型和推断类型有什么区别？
- en: What are numeric, string, and Boolean types?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字、字符串和布尔类型是什么？
- en: Explaining how enumerations work in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 Swift 中枚举的工作原理
- en: Explaining how Swift's operators work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 Swift 操作符的工作原理
- en: We recognize that Swift is becoming very popular on platforms outside of the
    Apple eco-system. Therefore, starting with this chapter, in the downloadable code
    samples, we will be including both a Swift playground and a `.swift` code file
    for all the sample code. This will enable you to easily try the samples on whichever
    platform you wish. This is a new feature starting with the *Mastering Swift 5.3*,
    *Sixth Edition* book. Let's start our tour of the Swift language by understanding
    what constants and variables are.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到 Swift 正在成为苹果生态系统之外的平台上的非常流行的语言。因此，从本章开始，在可下载的代码示例中，我们将包括 Swift playground
    和所有示例代码的 `.swift` 代码文件。这将使您能够轻松地在您选择的任何平台上尝试这些示例。这是从 *Mastering Swift 5.3*，*第六版*
    书籍开始的一个新特性。让我们通过了解常量和变量来开始我们的 Swift 语言之旅。
- en: Constants and variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Constants and variables associate an identifier (such as `myName` or `currentTemperature`)
    with a value of a particular type (such as the `String` or `Integer` type), where
    the identifier can be used to retrieve the value. The difference between a constant
    and a variable is that a variable can be updated or changed, while a constant
    cannot be changed once a value is assigned to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量将一个标识符（如 `myName` 或 `currentTemperature`）与特定类型的值（如 `String` 或 `Integer`
    类型）关联起来，其中标识符可以用来检索值。常量和变量之间的区别在于，变量可以被更新或更改，而一旦为常量分配了值，它就不能被更改。
- en: Constants are good for defining values that you know will never change, like
    the temperature that water freezes at or the speed of light. Constants are also
    good for defining a value that we use many times throughout our application, such
    as a standard font size or the maximum number of characters in a buffer. There
    will be numerous examples of constants throughout this book, and it is recommended
    that we use constants rather than variables whenever possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 常量适用于定义那些你知道永远不会改变的值，比如水结冰的温度或光速。常量也适用于定义我们在整个应用程序中多次使用的值，例如标准字体大小或缓冲区中字符的最大数量。本书中会有许多关于常量的例子，建议尽可能使用常量而不是变量。
- en: Variables tend to be more common in software development than constants. This
    is mainly because developers tend to prefer variables over constants. In Swift,
    the compiler will warn us if we declare a variable whose value never changes.
    We can make useful applications without using constants (although it is good practice
    to use them); however, it is almost impossible to create a useful application
    without variables.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在软件开发中比常量更常见。这主要是因为开发者倾向于更喜欢变量。在 Swift 中，如果声明了一个值永远不会改变的变量，编译器会警告我们。我们可以不使用常量（尽管使用它们是良好的实践）来创建有用的应用程序；然而，没有变量几乎不可能创建一个有用的应用程序。
- en: The use of constants is encouraged in Swift. If we do not expect or want a value
    to change, we should declare it as a constant. This adds a very important safety
    constraint to our code that ensures that the value never changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中鼓励使用常量。如果我们不期望或不想一个值发生变化，我们应该将其声明为常量。这为我们代码添加了一个非常重要的安全约束，确保该值永远不会改变。
- en: 'You can use almost any character in the naming/identifier of a variable or
    constant (even Unicode characters); however, there are a few rules that you must
    follow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在变量或常量的命名/标识符中使用几乎任何字符（甚至 Unicode 字符）；然而，您必须遵循一些规则：
- en: An identifier must not contain any whitespace.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不得包含任何空白字符。
- en: It must not contain any mathematical symbols or arrows.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能包含任何数学符号或箭头。
- en: An identifier must not contain private-use or invalid Unicode characters.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不得包含私有用途或无效的 Unicode 字符。
- en: It must not contain line or box-drawing characters.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能包含行或框绘制字符。
- en: It must not start with a number, but it can contain numbers.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能以数字开头，但它可以包含数字。
- en: Using a Swift keyword as an identifier is strongly discouraged but if you do,
    surround it with backticks.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈不建议使用 Swift 关键字作为标识符，但如果您确实这样做，请用反引号包围它。
- en: Keywords are words that are used by the Swift programming language. Some examples
    of keywords that you will see in this chapter are `var` and `let`. You should
    avoid using Swift keywords as identifiers to avoid confusion when reading your
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是 Swift 编程语言使用的单词。本章中您将看到的几个关键字示例是 `var` 和 `let`。您应该避免使用 Swift 关键字作为标识符，以避免在阅读代码时产生混淆。
- en: Defining constants and variables
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义常量和变量
- en: 'Constants and variables must be defined prior to using them. To define a constant,
    you use the `let` keyword, and to define a variable, you use the `var` keyword.
    The following code shows how to define both constants and variables:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量在使用之前必须定义。要定义一个常量，您使用 `let` 关键字，要定义一个变量，您使用 `var` 关键字。以下代码显示了如何定义常量和变量：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can declare multiple constants or variables in a single line by separating
    them with a comma. For example, we could shrink the preceding four lines of code
    down to two lines, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一行中声明多个常量或变量，通过逗号分隔它们。例如，我们可以将前面的四行代码缩减为两行，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can change the value of a variable to another value of a compatible type;
    however, as we noted earlier, we cannot change the value of a constant. Let's
    look at the following playground. Can you tell what is wrong with the code from
    the error message?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量的值更改为兼容类型的另一个值；然而，正如我们之前提到的，我们无法更改常量的值。让我们看看以下游乐场。你能从错误信息中看出代码哪里有问题吗？
- en: '![](img/B16683_03_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16683_03_01.png)'
- en: 'Figure 3.1: Error thrown as a constant cannot be changed'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：尝试更改常量时抛出的错误
- en: Did you figure out what was wrong with the code? Any physicist can tell you
    that we cannot change the speed of light, and in our code, `speedOfLightKmSec`
    is a constant, so we cannot change it here either. When we attempted to change
    the `speedOfLightKmSec` constant, an error was thrown. We can change the value
    of `highTemperature` without an error because it is a variable. We have mentioned
    the difference between variables and constants a couple of times because it is
    a very important concept to grasp, especially when we move on to define mutable
    and immutable collection types in *Chapter 5*, *Using Swift Collections*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你弄清楚代码哪里出问题了吗？任何物理学家都可以告诉你，我们无法改变光速，在我们的代码中，`speedOfLightKmSec` 是一个常量，因此我们在这里也无法改变它。当我们尝试更改
    `speedOfLightKmSec` 常量时，会抛出一个错误。我们可以不产生错误地更改 `highTemperature` 的值，因为它是一个变量。我们已经多次提到变量和常量的区别，因为它是一个非常重要的概念，尤其是在我们进入定义可变和不可变集合类型时，尤其是在第
    5 章 *使用 Swift 集合* 中。
- en: When something is mutable, that means we are able to change it, and when we
    say something is immutable, that means we are unable to change it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当某物是可变的时，这意味着我们能够改变它，当我们说某物是不可变的时，这意味着我们无法改变它。
- en: Type safety
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全
- en: 'Swift is a type-safe language, which means we are required to define the types
    of the values we are going to store in a variable. We will get an error if we
    attempt to assign a value to a variable that is of the wrong type. The following
    playground shows what happens if we attempt to put a string value into a variable
    that expects integer values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种类型安全的语言，这意味着我们被要求定义将要存储在变量中的值的类型。如果我们尝试将一个错误类型的值分配给变量，我们会得到一个错误。以下游乐场显示了如果我们尝试将字符串值放入期望整数值的变量中会发生什么：
- en: We will go over the most popular types later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论最流行的类型。
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_03_02.png)'
- en: 'Figure 3.2: Type-safety error in a Swift playground'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Swift 游乐场中的类型安全错误
- en: Swift performs a type check when it compiles code, and so it will flag any mismatched
    types with an error. The error message in this playground explains quite clearly
    that we are trying to insert a string value into an integer variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 在编译代码时会执行类型检查，因此它会用错误标记任何不匹配的类型。在这个游乐场中的错误信息清楚地解释了我们试图将字符串值插入到整数变量中。
- en: How does Swift know that the constant `integerVar` is of the integer type? Swift
    uses type inference to figure out the appropriate type. Let's look at what type
    inference is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 如何知道常量 `integerVar` 是整数类型？Swift 使用类型推断来确定合适的类型。让我们看看什么是类型推断。
- en: Type inference
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Type inference allows us to omit the variable type when the variable is defined
    with an initial value. The compiler will infer the type based on that initial
    value. For example, in Objective-C, we would define an integer like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断允许我们在变量定义时省略变量类型，如果变量有初始值。编译器将根据该初始值推断类型。例如，在 Objective-C 中，我们会这样定义一个整数：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This tells the compiler that the `myInt` variable is of the `Int` type, and
    that the initial value is the number `1`. In Swift, we would define the same integer
    as this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器 `myInt` 变量是 `Int` 类型，初始值是数字 `1`。在 Swift 中，我们会这样定义相同的整数：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift infers that the variable type is an integer because the initial value
    is an integer. Let''s look at a couple more examples:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 推断变量类型是整数，因为初始值是整数。让我们看看更多例子：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the compiler will correctly infer that variable `x`
    is a `Double`, variable `y` is a `String`, and variable `z` is a `Boolean`, based
    on their initial values. We are able to explicitly define a variable type. However,
    it is recommended that we only do this if we are not assigning an initial value
    to a variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，编译器将正确推断变量 `x` 是 `Double` 类型，变量 `y` 是 `String` 类型，变量 `z` 是 `Boolean`
    类型，基于它们的初始值。我们能够显式地定义变量类型。然而，建议我们只在未为变量分配初始值时这样做。
- en: Explicit types
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式类型
- en: 'Type inference is a very nice feature in Swift and is one that you will probably
    get used to very quickly. However, there are times when we would like to explicitly
    define a variable''s type. For example, in the preceding example, the variable
    `x` is inferred to be `Double`, but what if we wanted the variable type to be
    `Float`? We can explicitly define a variable type like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是 Swift 中一个非常棒的功能，你可能会很快习惯它。然而，有时我们可能希望显式地定义一个变量的类型。例如，在上一个例子中，变量 `x` 被推断为
    `Double` 类型，但如果我们想将变量类型定义为 `Float` 呢？我们可以这样显式地定义变量类型：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the `Float` declaration (the colon and the word `Float`) after the variable
    identifier. This tells the compiler to define this variable to be of the `Float`
    type and gives it an initial value of `3.14`. When we define a variable in this
    manner, we need to make sure that the initial value is the same type as what we
    defined the variable to be. If we try to give a variable an initial value that
    is a different type than what we defined the variable as, then we receive an error.
    As an example, the following line will throw an error because we are explicitly
    defining the variable to be that of the `Float` type, while we are trying to put
    a `String` value in it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量标识符后面的 `Float` 声明（冒号和 `Float` 这个词）。这告诉编译器将这个变量定义为 `Float` 类型，并给它一个初始值 `3.14`。当我们以这种方式定义变量时，我们需要确保初始值与定义的变量类型相同。如果我们尝试给变量一个与定义的变量类型不同的初始值，那么我们会收到一个错误。例如，以下行将引发错误，因为我们显式地将变量定义为
    `Float` 类型，而我们在尝试放入一个 `String` 值：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will need to explicitly define the variable type if we are not setting an
    initial value. For example, the following line of code is invalid because the
    compiler does not know what type to set the variable `x` to:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置初始值，我们需要显式地定义变量类型。例如，以下代码行是无效的，因为编译器不知道将变量 `x` 设置为什么类型：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we use this code in our application, we will receive a **Type annotation
    missing in pattern** error. If we are not setting an initial value for a variable,
    we are required to define the variable type, as shown in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序中使用此代码，我们将收到一个 **模式中缺少类型注解** 错误。如果我们没有为变量设置初始值，我们必须定义变量类型，如下例所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have seen how to explicitly define a variable type, let's look at
    some of the most commonly used types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何显式定义变量类型，让我们看看一些最常用的类型。
- en: Numeric types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型
- en: Swift contains many of the standard numeric types that are suitable for storing
    various integer and floating-point values. Let's start by looking at the integer
    type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 包含许多适合存储各种整数和浮点值的标准数值类型。让我们首先看看整数类型。
- en: Integer types
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'An integer is a whole number and can be either signed (positive, negative,
    or zero) or unsigned (positive or zero). Swift provides several **Integer** types
    of different sizes. *Table 3.1* shows the value ranges for the different integer
    types on a 64-bit system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是一个完整的数字，可以是带符号的（正数、负数或零）或无符号的（正数或零）。Swift 提供了多种不同大小的 **整数** 类型。*表 3.1* 展示了
    64 位系统上不同整数类型的值范围：
- en: '| Type | Minimum | Maximum |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 最小值 | 最大值 |'
- en: '| `Int8` | -128 | 127 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Int8` | -128 | 127 |'
- en: '| `Int16` | -32,768 | 32,767 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Int16` | -32,768 | 32,767 |'
- en: '| `Int32` | -2,147,483,648 | 2,147,483,647 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Int32` | -2,147,483,648 | 2,147,483,647 |'
- en: '| `Int64` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Int64` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
- en: '| `Int` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
- en: '| `UInt8` | 0 | 255 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `UInt8` | 0 | 255 |'
- en: '| `UInt16` | 0 | 65,535 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `UInt16` | 0 | 65,535 |'
- en: '| `UInt32` | 0 | 4,294,967,295 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `UInt32` | 0 | 4,294,967,295 |'
- en: '| `UInt64` | 0 | 18,446,744,073,709,551,615 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `UInt64` | 0 | 18,446,744,073,709,551,615 |'
- en: '| `UInt` | 0 | 18,446,744,073,709,551,615 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `UInt` | 0 | 18,446,744,073,709,551,615 |'
- en: 'Table 3.1: Different Integer types available on Swift'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：Swift 中可用的不同整数类型
- en: You may notice from the chart that unsigned integers begin with a U (`UInt`,
    `UInt8`…), while signed integers do not (`Int`, `Int8`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到从图表中，无符号整数以 U 开头（`UInt`、`UInt8` 等），而带符号的整数则没有（`Int`、`Int8`）。
- en: Unless there is a specific reason to define the size of an integer, I would
    recommend using the standard `Int` or `UInt` types. This will save you from needing
    to convert between different types of integers later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定原因需要定义整数的大小，我建议使用标准的 `Int` 或 `UInt` 类型。这将避免您以后需要在不同的整数类型之间进行转换。
- en: 'In Swift, the `Integer` type and other numerical types are actually named types
    and are implemented in the Swift standard library using structures. This gives
    us a consistent mechanism for the memory management of all the data types, as
    well as properties that we can access. For the preceding chart, I retrieved the
    minimum and maximum values of each `Integer` type using the `min` and `max` properties
    of the `Integer` types. Look at the following playground to see how these values
    were retrieved:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`Integer` 类型和其他数值类型实际上是命名类型，并且使用结构体在 Swift 标准库中实现。这为我们提供了一种一致的机制来管理所有数据类型的内存，以及我们可以访问的属性。对于前面的图表，我使用了
    `Integer` 类型的 `min` 和 `max` 属性来检索每个 `Integer` 类型的最小和最大值。查看以下游乐场，看看这些值是如何检索的：
- en: '![A screenshot of a computer  Description automatically generated](img/B16683_03_03.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_03_03.png)'
- en: 'Figure 3.3: Ranges of different numerical types'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：不同数值类型的范围
- en: 'Integers can also be represented as binary, octal, and hexadecimal numbers.
    We just need to add a prefix to the number to tell the compiler which base the
    number should be in. The prefix takes the form of a zero, followed by the base
    specifier. *Table 3.2* shows the prefix for each numerical base:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 整数也可以表示为二进制、八进制和十六进制数。我们只需要在数字前加上一个前缀，告诉编译器数字应该使用哪种基数。前缀的形式是一个零，后跟基数指定符。*表 3.2*
    展示了每个数值基数的前缀：
- en: '| Base | Prefix |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 基数 | 前缀 |'
- en: '| Decimal | None |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 无 |'
- en: '| Binary | 0b |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 0b |'
- en: '| Octal | 0o |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 八进制 | 0o |'
- en: '| Hexadecimal | 0x |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 0x |'
- en: 'Table 3.2: Prefixes for each numerical base'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：每个数值基数的前缀
- en: 'The following playground shows how the number 95 is represented in each of
    the numerical bases:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下游乐场展示了数字 95 在每种数值基数中的表示方式：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_04.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_03_04.png)'
- en: 'Figure 3.4: Defining values with different numerical bases'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：使用不同的数值基数定义值
- en: 'Swift also allows us to insert arbitrary underscores in our numeric literals.
    This can improve the readability of our code without changing the underlying value.
    As an example, if we were defining the speed of light, which is constant, we could
    define it like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还允许我们在我们的数值字面量中插入任意下划线。这可以提高我们代码的可读性，而不会改变其底层值。例如，如果我们正在定义光速，这是一个常数，我们可以这样定义它：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Swift compiler will ignore these underscores and interpret this value as
    if the underscores were not there.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编译器将忽略这些下划线，并像没有下划线一样解释这个值。
- en: 'The `Integer` type in Swift has a method named `isMultiple(of:)`, which can
    be very useful. This method allows us to check if one number is the multiple of
    another number. Prior to this method, we would have used the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的 `Integer` 类型有一个名为 `isMultiple(of:)` 的方法，这个方法非常有用。此方法允许我们检查一个数字是否是另一个数字的倍数。在此方法之前，我们会使用以下代码：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can use the `isMultiple(of:)` method like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样使用 `isMultiple(of:)` 方法：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While this new method really doesn't eliminate a lot of code, it does make our
    code much easier to read and understand. Now, let's look at floating-point and
    `Double` types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个新方法实际上并没有消除很多代码，但它确实使我们的代码更容易阅读和理解。现在，让我们看看浮点数和 `Double` 类型。
- en: Floating-point and Double values
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数和 Double 值
- en: 'A floating-point number is a number with a decimal component. There are two
    standard floating-point types in Swift: `Float` and `Double`. The `Float` type
    represents a 32-bit floating-point number, while the `Double` type represents
    a 64-bit floating-point number. While the `Float` type is a 32-bit floating-point
    number, Swift actually supports four floating-point types. These are `Float16`,
    `Float32`, `Float64`, and `Float80`. Remember, when the `Float` type is used,
    it is a 32-bit floating-point number; if you want to use the other precisions,
    you will need to define it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是一个带有小数部分的数字。Swift 中有两种标准的浮点数类型：`Float` 和 `Double`。`Float` 类型表示 32 位浮点数，而
    `Double` 类型表示 64 位浮点数。虽然 `Float` 类型是 32 位浮点数，但 Swift 实际上支持四种浮点数类型。这些是 `Float16`、`Float32`、`Float64`
    和 `Float80`。记住，当使用 `Float` 类型时，它是一个 32 位浮点数；如果你想要使用其他精度，你需要定义它。
- en: Swift 5.3, with Swift Evolution SE-0277, added the `Float16` type to the Swift
    language because it is commonly used in graphics programming and also machine
    learning.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 5.3，随着 Swift Evolution SE-0277 的加入，将 `Float16` 类型添加到了 Swift 语言中，因为它在图形编程和机器学习中被广泛使用。
- en: 'It is recommended that we use the `Double` type over the `Float` type unless
    there is a specific reason to use the latter. The `Double` type has a precision
    of at least 15 decimal digits, while the `Float` type''s precision can be as small
    as six decimal digits. Let''s look at an example of how this can affect our application
    without us knowing. *Figure 3.5* shows the results of what happens if we add two
    decimal numbers together using both a `Float` type and a `Double` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们使用 `Double` 类型而不是 `Float` 类型，除非有特定的理由使用后者。`Double` 类型的精度至少为 15 位十进制数字，而
    `Float` 类型的精度可能小到只有六位十进制数字。让我们看看一个例子，看看这如何影响我们的应用程序，而我们却不知道。*图 3.5* 展示了如果我们使用
    `Float` 类型和使用 `Double` 类型将两个十进制数相加会发生什么：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_05.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成](img/B16683_03_05.png)'
- en: 'Figure 3.5: Calculations in Float and Double'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：Float 和 Double 的计算
- en: As we can see from the preceding screenshot, the first two decimal numbers that
    we are adding contain nine digits past the decimal point; however, the results
    in the `Float` type only contain seven digits, while the results in the `Double`
    type contain the full nine digits. This loss of precision can cause issues if
    we are working with currency or other numbers that need accurate calculations,
    as we can see when we compare the results in the second set of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们正在相加的前两个十进制数包含九位小数点后的数字；然而，`Float` 类型的结果只包含七位数字，而 `Double` 类型的结果包含完整的九位数字。这种精度损失可能会在处理货币或其他需要精确计算的数字时引起问题，正如我们在第二组数字的比较中可以看到的那样。
- en: Note that when you use type inference for a decimal number, Swift will default
    to a `Double` type rather than a `Float` type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你为十进制数字使用类型推断时，Swift 将默认使用 `Double` 类型而不是 `Float` 类型。
- en: What if we have two variables, where one is an integer and the other is a double?
    Do you think we can add them as the following code shows?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个变量，其中一个为整数，另一个为双精度浮点数？你认为我们能否像以下代码所示那样将它们相加？
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we put the preceding code into a playground, we would receive the following
    error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码放入游乐场，我们会收到以下错误：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This error lets us know that we are trying to add two different types of numbers,
    which is not allowed. To add an `Int` and a `Double` type together, we need to
    convert the integer value into a double value. The following code shows how to
    do this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们我们正在尝试添加两种不同类型的数字，这是不允许的。要添加 `Int` 和 `Double` 类型，我们需要将整数值转换为双精度浮点数。以下代码展示了如何做到这一点：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice how we use the `Double()` function to initialize a `Double` value with
    the `Int` value. All numeric types in Swift have an initializer to do these types
    of conversion. These initializers are called **convenience initializers**, similar
    to the `Double()` function shown in the preceding code sample. For example, the
    following code shows how you can initialize a `Float` or `uint16` value with an
    integer value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `Double()` 函数用 `Int` 值初始化一个 `Double` 值。Swift 中所有数值类型都有一个用于这些类型转换的初始化器。这些初始化器被称为
    **便利初始化器**，类似于前面代码示例中显示的 `Double()` 函数。例如，以下代码展示了如何用整数值初始化 `Float` 或 `uint16`
    值：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Generally, when we are adding two different types together, we will want to
    convert the number with the least floating-point precision, like an integer or
    float, to the type with the highest precision, like a double.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们把两种不同的类型相加时，我们会希望将精度最低的数字（如整数或浮点数）转换为精度最高的类型，比如双精度浮点数。
- en: The Boolean type
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: '**Boolean** values are often referred to as logical values because they can
    be either `true` or `false`. Swift has a built-in `Boolean` type that accepts
    one of the two built-in Boolean constants: `true` and `false`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔**值通常被称为逻辑值，因为它们可以是`true`或`false`。Swift 有一个内置的 `Boolean` 类型，它接受两个内置布尔常量之一：`true`
    和 `false`。'
- en: 'Boolean constants and variables can be defined like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量和变量可以定义如下：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean values are especially useful when working with conditional statements,
    such as the `if`, `while`, and `guard` statements. For example, what do you think
    this code would do?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在处理条件语句（如 `if`、`while` 和 `guard` 语句）时特别有用。例如，你认为这段代码会做什么？
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you answered that this code would print out `YEA, I cannot wait to learn
    it`, then you would be correct. This line is printed out because the `isSwiftCool`
    Boolean type is set to `true`, while the `isItRaining` variable is set to `false`;
    therefore, the `Get a rain coat` message is not printed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答说这段代码会打印出 `YEA, I cannot wait to learn it`，那么你就对了。这一行被打印出来是因为 `isSwiftCool`
    布尔类型被设置为 `true`，而 `isItRaining` 变量被设置为 `false`；因此，`Get a rain coat` 消息没有被打印。
- en: 'In most languages, if we wanted to toggle the value of a Boolean variable,
    we would have to do something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，如果我们想要切换布尔变量的值，我们必须做类似这样的事情：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Swift, the Boolean type has a method called `toggle()` that lets us toggle
    the value of the variable. This is used if we do not know the value that''s stored
    in the variable. For example, if the `isItRaining` constant was a variable instead
    and we wanted to change the value, but we did not know what it actually was, we
    could use the following line of code to change it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，布尔类型有一个名为 `toggle()` 的方法，允许我们切换变量的值。如果我们不知道变量中存储的值，就会用到这个方法。例如，如果
    `isItRaining` 常量是一个变量，并且我们想要改变它的值，但我们不知道它实际是什么，我们可以使用以下代码行来改变它：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with the Integer's `isMultiple(of:)` method, this makes our code much easier
    to read and understand. Now, let's look at the `String` type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像整数的 `isMultiple(of:)` 方法一样，这使得我们的代码更容易阅读和理解。现在，让我们看看 `String` 类型。
- en: The String type
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'A **string** is an ordered collection of characters, such as `Hello` or `Swift`,
    and is represented by the `String` type. We have seen several examples of strings
    in this book, and therefore the following code should look familiar. This code
    shows how to define two strings:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**是有序字符集合，如 `Hello` 或 `Swift`，由 `String` 类型表示。我们在本书中已经看到了几个字符串的例子，因此以下代码应该看起来很熟悉。这段代码展示了如何定义两个字符串：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also create a string using a multiline string literal. The following
    code shows how we can do that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用多行字符串字面量来创建字符串。以下代码展示了我们如何做到这一点：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that we put three double quotes around the multiline string. We can
    use quotes in our multiline string to quote specific text. The following code
    shows how to do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们用三个双引号包围了多行字符串。我们可以在多行字符串中使用引号来引用特定的文本。以下代码展示了如何做到这一点：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since a string is an ordered collection of characters, we can iterate through
    each character of a string. The following code shows how to do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是有序字符集合，我们可以遍历字符串中的每个字符。以下代码展示了如何做到这一点：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code will display the results that are shown in the following
    screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将显示以下截图所示的结果：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_06.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_03_06.png)'
- en: 'Figure 3.6: Iterating through the string''s characters'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：遍历字符串的字符
- en: 'We can also use the `map()` function, as shown in *Figure 3.6*, of the `String`
    type to retrieve each character, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `map()` 函数，如 *图 3.6* 所示，从 `String` 类型中检索每个字符，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will look at the `map()` method and how it works later on in this book.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分探讨 `map()` 方法及其工作原理。
- en: 'There are two ways in which we can add one string to another. We can concatenate
    them or include them in-line. To concatenate two strings, we can use the `+` or
    `+=` operators. The following code shows both ways in which we can concatenate
    two strings. The first example appends `stringB` to the end of `stringA`, and
    the results are put into the new `stringC` variable. The second example appends
    `string` directly to the end of `stringA`, without creating a new string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个字符串添加到另一个字符串中的两种方式。我们可以连接它们或内联它们。要连接两个字符串，我们可以使用 `+` 或 `+=` 运算符。以下代码展示了两种连接字符串的方法。第一个示例将
    `stringB` 追加到 `stringA` 的末尾，并将结果放入新的 `stringC` 变量中。第二个示例直接将 `string` 追加到 `stringA`
    的末尾，而不创建新的字符串：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To include a string in-line with another string, we use a special sequence
    of characters: `\()`. The following code shows how to include a string interpolation
    with another string:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个字符串内联到另一个字符串中，我们使用一个特殊的字符序列：`\()`。以下代码展示了如何将字符串插值与另一个字符串结合使用：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous example, `stringB` will contain the message `Hello Jon`, because
    Swift will replace the `\(stringA)` sequence of characters with the value of the
    `stringA` variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`stringB` 将包含消息 `Hello Jon`，因为 Swift 将 `\(stringA)` 字符序列替换为 `stringA`
    变量的值。
- en: 'Starting with Swift 5, we have the ability to create raw strings. In previous
    versions of Swift, if we wanted to include quotes or backslashes in a string,
    we had to *escape* it out using a backslash, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swift 5 开始，我们有了创建原始字符串的能力。在 Swift 的早期版本中，如果我们想在字符串中包含引号或反斜杠，我们必须使用反斜杠进行转义，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With a raw string, the double quotes and backslashes are treated as part of
    the string literal, and so we do not need to escape them. The following example
    shows how to do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始字符串，双引号和反斜杠被视为字符串字面部分的一部分，因此我们不需要对它们进行转义。以下示例展示了如何进行这一操作：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the hashtag and double quotes at the start and end of the string. That
    tells Swift that this is a raw string. This makes it much easier to read what
    the string actually contains. If we wanted to append another string in-line, as
    we did previously, we would use the `\#()` character sequence. The following code
    illustrates this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串开头和结尾的井号和双引号。这告诉 Swift 这是一个原始字符串。这使得阅读字符串实际包含的内容变得容易得多。如果我们想像之前那样在行内追加另一个字符串，我们会使用
    `\#()` 字符序列。以下代码说明了这一点：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result of this code would be a `str2` variable containing the following
    string: **The answer is 42**.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的结果将是一个包含以下字符串的 `str2` 变量：**答案是 42**。
- en: 'In Swift, we define the mutability of variables and collections by using the
    `var` and `let` keywords. If we define a string as a variable using `var`, the
    string is mutable, meaning that we can change and edit the value. If we define
    a string as a constant using `let`, the string is immutable, meaning that we cannot
    change or edit the value once it is set. The following code shows the difference
    between a mutable and an immutable string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们使用 `var` 和 `let` 关键字来定义变量和集合的可变性。如果我们使用 `var` 将字符串定义为变量，则该字符串是可变的，这意味着我们可以更改和编辑其值。如果我们使用
    `let` 将字符串定义为常量，则该字符串是不可变的，这意味着一旦设置，我们无法更改或编辑其值。以下代码显示了可变字符串和不可变字符串之间的区别：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Strings in Swift have two methods that can convert the case of the string.
    These methods are `lowercased()` and `uppercased()`. The following example demonstrates
    these methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的字符串有两种方法可以转换字符串的大小写。这些方法是 `lowercased()` 和 `uppercased()`。以下示例演示了这些方法：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run this code, the results will be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，结果将如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Swift provides four ways to compare a string; these are string equality, prefix
    equality, suffix equality, and `isEmpty`. The following example demonstrates these:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了四种比较字符串的方法；这些是字符串相等性、前缀相等性、后缀相等性和 `isEmpty`。以下示例演示了这些方法：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_07.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_03_07.png)'
- en: 'Figure 3.7: String comparison methods in Swift'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：Swift 中的字符串比较方法
- en: The `isEmpty()` method checks to see if the string contains any characters or
    not. The string equality (`==`) checks to see if the characters (which are case-sensitive)
    in the two strings are the same. The prefix and suffix equality checks to see
    if the string starts with or ends with a specific string. The prefix and suffix
    equality is case-sensitive as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEmpty()` 方法检查字符串是否包含任何字符。字符串相等性（`==`）检查两个字符串中的字符（区分大小写）是否相同。前缀和后缀相等性检查字符串是否以特定字符串开头或结尾。前缀和后缀相等性也是区分大小写的。'
- en: 'We can replace all the occurrences of a target string with another string,
    which is done with the `replacingOccurrances(of:)` method. The following code
    demonstrates this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用另一个字符串替换目标字符串的所有出现，这是通过 `replacingOccurrences(of:)` 方法完成的。以下代码演示了这一点：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding example will print `one, two, three, four` to the screen because
    we are replacing all the occurrences of `to` with `two` in the `stringOne` variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将打印 `one, two, three, four` 到屏幕上，因为我们正在将 `stringOne` 变量中所有 `to` 的出现替换为
    `two`。
- en: Note that the `replacingOccurrences(of:)` method is only available on Apple
    platforms and is not available for other platforms.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`replacingOccurrences(of:)` 方法仅在 Apple 平台上可用，在其他平台上不可用。
- en: 'We can also retrieve substrings and individual characters from our strings;
    however, when we retrieve a substring from a string, that substring is an instance
    of the `Substring` type and not the `String` type. The `Substring` type contains
    most of the same methods as the `String` type, so you can use them in a similar
    way. Unlike `String` types, however, they are meant to be used only for short
    periods of time, only while we are working with the value. If you need to use
    a `Substring` type for a long period of time, you should convert it into a `String`
    type. The following example shows how we can work with substrings:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从我们的字符串中检索子字符串和单个字符；然而，当我们从字符串中检索子字符串时，该子字符串是 `Substring` 类型的实例，而不是 `String`
    类型。`Substring` 类型包含与 `String` 类型大多数相同的方法，因此你可以以类似的方式使用它们。然而，与 `String` 类型不同，它们旨在仅用于短时间内，仅在我们处理值时使用。如果你需要长时间使用
    `Substring` 类型，你应该将其转换为 `String` 类型。以下示例显示了如何处理子字符串：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding example, we used the subscript path to retrieve the substring
    between a start and end index. The indices are created with the `index(_: offsetBy:)`
    function. The first property in the `index(_: offsetBy:)` function gives the index
    of where we wish to start, and the `offsetBy` property tells us how much to increase
    the index by.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我们使用了下标路径来检索起始和结束索引之间的子字符串。索引是通过 `index(_: offsetBy:)` 函数创建的。`index(_:
    offsetBy:)` 函数的第一个属性给出了我们希望开始的索引位置，而 `offsetBy` 属性告诉我们需要增加索引多少。'
- en: The `path[..<startIndex]` line creates a substring from the beginning of the
    string to the index, while the `path[endIndex...]` line creates a substring from
    the index to the end of the string. We then use the last property to get the last
    character of the string and the first property to get the first character.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`path[..<startIndex]` 行从字符串的开始到索引创建一个子字符串，而 `path[endIndex...]` 行从索引到字符串的末尾创建一个子字符串。然后我们使用最后一个属性来获取字符串的最后一个字符，使用第一个属性来获取第一个字符。'
- en: The `..<` operator that we saw in the previous example is known as a **half-open
    range operator**. We will look at the different range operators at the end of
    this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面例子中看到的 `..<` 操作符被称为 **半开区间操作符**。我们将在本章末尾查看不同的范围操作符。
- en: 'We can retrieve the number of characters in a string by using the `count` property.
    The following example shows how you can use this function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `count` 属性来检索字符串中的字符数。以下示例显示了如何使用此函数：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This completes our whirlwind tour of strings. We went through these properties
    and functions very quickly, but we will be using strings extensively throughout
    this book, so there will be a lot of code to help you get familiar with them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对字符串的快速浏览。我们非常快速地浏览了这些属性和函数，但在这本书中我们将广泛使用字符串，所以会有很多代码帮助你熟悉它们。
- en: Tuples
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples group multiple values into a single compound type. These values are not
    required to be of the same type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 元组将多个值组合成一个单一的复合类型。这些值不需要是同一类型。
- en: 'The following example shows how to define a tuple:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何定义一个元组：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, an unnamed tuple was created that contains two strings,
    two integers, and one double. The values of the tuple can be decomposed into a
    set of variables, as shown in the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了一个无名的元组，其中包含两个字符串、两个整数和一个双精度浮点数。元组的值可以分解成一组变量，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, the `city` variable will contain `Boston`, the `name`
    variable will contain `Red Sox`, the `wins` variable will contain `97`, the `losses`
    variable will contain `65`, and finally the `percent` variable will contain `59.9`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`city` 变量将包含 `Boston`，`name` 变量将包含 `Red Sox`，`wins` 变量将包含 `97`，`losses`
    变量将包含 `65`，最后 `percent` 变量将包含 `59.9`。
- en: 'The values of the tuple can also be retrieved by specifying the location of
    the value. The following example shows how we can retrieve values by their location:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过指定值的定位来检索元组的值。以下示例展示了如何通过值的位置来检索值：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Naming tuples, known as **named tuples**, allows us to avoid the decomposition
    step. A named tuple associates a name (key) with each element of the tuple. The
    following example shows how to create a named tuple:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组，也称为 **named tuples**，允许我们避免分解步骤。命名元组将一个名称（键）与元组的每个元素关联起来。以下示例展示了如何创建一个命名元组：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Values from a named tuple can be accessed using the dot syntax. In the preceding
    code, we can access the `city` element of the tuple like this: `team.city`. In
    the preceding code, the `team.city` element will contain `Boston`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用点语法访问命名元组的值。在前面代码中，我们可以这样访问元组的 `city` 元素：`team.city`。在前面的代码中，`team.city`
    元素将包含 `Boston`。
- en: Tuples are incredibly useful and can be used for all sorts of purposes. I have
    found that they are very useful for replacing classes and structures that are
    designed to simply store data and do not contain any methods. They are also very
    useful for returning multiple values, of different types, from a function. Now,
    let's look at enumerations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 元组极其有用，可以用于各种目的。我发现它们对于替换仅设计用于存储数据且不包含任何方法的类和结构体非常有用。它们也非常适用于从函数中返回多个不同类型的值。现在，让我们看看枚举。
- en: Enumerations
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations (also known as **enums**) are a special data type that enables
    us to group related types together and use them in a type-safe manner. Enumerations
    in Swift are not tied to integer values as they are in other languages, such as
    C or Java. In Swift, we are able to define an enumeration with a type (string,
    character, integer, or floating-point value) and then define its actual value
    (known as the **raw value**). Enumerations also support features that are traditionally
    only supported by classes, such as computed properties and instance methods. We
    will discuss these advanced features in depth in *Chapter 7*, *Classes, Structures,
    and Protocols*. In this section, we will look at the traditional features of enumerations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举（也称为 **enums**）是一种特殊的数据类型，它使我们能够将相关的类型组合在一起，并以类型安全的方式使用它们。与 C 或 Java 等其他语言不同，Swift
    中的枚举不与整数值绑定。在 Swift 中，我们可以定义一个具有类型（字符串、字符、整数或浮点值）的枚举，然后定义其实际值（称为 **raw value**）。枚举还支持传统上只有类才支持的功能，例如计算属性和实例方法。我们将在
    *第 7 章*，*类、结构和协议* 中深入讨论这些高级功能。在本节中，我们将探讨枚举的传统特性。
- en: 'We will define an enumeration that contains a list of `Planets`, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个包含 `Planets` 列表的枚举，如下所示：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note: When defining the enumeration type, the name of the enumeration should
    be uppercase, like other types. The member values can be uppercase or lowercase;
    however, it should be preferred to use lowercase.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当定义枚举类型时，枚举的名称应该大写，就像其他类型一样。枚举值可以是大写或小写；然而，建议使用小写。
- en: 'The values defined in an enumeration are considered to be the member values
    (or simply the members) of the enumeration. In most cases, you will see the member
    values defined like they are in the preceding example because it is easy to read;
    however, there is a shorter version. This shorter version lets us define multiple
    members in a single line, separated by commas, as the following example shows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举中定义的值被认为是枚举的成员值（或简单地称为成员）。在大多数情况下，你将看到成员值定义得像前面的示例一样，因为这样更容易阅读；然而，还有一个更简短的版本。这个简短版本允许我们在一行中定义多个成员，成员之间用逗号分隔，如下面的示例所示：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can then use the `Planets` enumeration like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样使用 `Planets` 枚举：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The type for the `planetWeLiveOn` and `furthestPlanet` variables is inferred
    when we initialize the variable with one of the member values of the `Planets`
    enumeration. Once the variable type is inferred, we can then assign a new value
    without the `Planets` prefix, as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Planets` 枚举的一个成员值初始化 `planetWeLiveOn` 和 `furthestPlanet` 变量时，变量类型会被推断出来。一旦变量类型被推断出来，我们就可以在不使用
    `Planets` 前缀的情况下分配新值，如下所示：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can compare an enumeration value using the traditional equals (`==`) operator
    or by using a `switch` statement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用传统的等于运算符 (`==`) 或使用 `switch` 语句来比较枚举值。
- en: 'Note: We will learn about the Swift `switch` statement in *Chapter 6*, *Control
    Flow*, later in this book. For now, we wanted to illustrate its use with the enumeration
    type.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在本书后面的 *第 6 章*，*控制流* 中学习 Swift 的 `switch` 语句。现在，我们想通过使用枚举类型来展示其用法。
- en: 'The following example shows how to use the equals operator and the `switch`
    statement with an enum:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用等于运算符和 `switch` 语句与枚举一起使用：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enumerations can come prepopulated with raw values, which are required to be
    of the same type. The following example shows how to define an enumeration with
    string values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举可以预先填充原始值，这些原始值必须是同一类型。以下示例展示了如何定义具有字符串值的枚举：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding example creates an enumeration with three types of devices. We
    then use the `rawValue` property to retrieve the stored value for the `Tablet`
    member of the `Devices` enumeration. This example will print a message saying,
    `We are using an iPad`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例创建了一个包含三种设备类型的枚举。然后我们使用 `rawValue` 属性来检索 `Devices` 枚举中 `Tablet` 成员的存储值。此示例将打印一条消息，表示“我们正在使用
    iPad”。
- en: 'Let''s create another `Planets` enumeration, but this time, we''ll assign numbers
    to the members, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个 `Planets` 枚举，但这次，我们将数字分配给成员，如下所示：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The big difference between these last two enumeration examples is that in the
    second example, we only assign a value to the first member (`mercury`). If integers
    are used for the raw values of an enumeration, then we do not have to assign a
    value to each member. If no value is present, the raw values will be auto-incremented.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个最后枚举示例之间的主要区别在于，在第二个示例中，我们只分配了一个值给第一个成员（`mercury`）。如果枚举的原始值使用整数，那么我们不需要为每个成员分配值。如果没有值存在，原始值将自动递增。
- en: 'In Swift, enumerations can also have associated values. Associated values allow
    us to store additional information, along with member values. This additional
    information can vary each time we use the member. It can also be of any type,
    and the types can be different for each member. Let''s look at how we might use
    associate types by defining a `Product` enumeration, which contains two types
    of products:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，枚举也可以有关联值。关联值允许我们存储额外的信息，以及成员值。这些额外信息每次使用成员时都可能不同。它们也可以是任何类型，并且每个成员的类型可以不同。让我们通过定义一个包含两种产品类型的
    `Product` 枚举来了解如何使用关联类型：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding example, we begin by defining a `Product` enumeration with
    two members: `Book` and `Puzzle`. The `Book` member has associated values of the
    `Double`, `Int`, and `Int` types, while the `Puzzle` member has associated values
    of the `Double` and `Int` types. Notice that we are using named associated types,
    where we assign a name for each associated type. We then create two products,
    `masterSwift` and `worldPuzzle`. We assign the `masterSwift` variable a value
    of `Product.Book` with the associated values of `49.99`, `2017`, and `310`. We
    then assign the `worldPuzzle` variable a value of `Product.Puzzle` with the associated
    values of `9.99` and `200`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先定义了一个`Product`枚举，它有两个成员：`Book`和`Puzzle`。`Book`成员具有`Double`、`Int`和`Int`类型的关联值，而`Puzzle`成员具有`Double`和`Int`类型的关联值。请注意，我们正在使用命名关联类型，为每个关联类型分配一个名称。然后我们创建了两个产品，`masterSwift`和`worldPuzzle`。我们将`masterSwift`变量的值设置为`Product.Book`，并带有关联值`49.99`、`2017`和`310`。然后我们将`worldPuzzle`变量的值设置为`Product.Puzzle`，并带有关联值`9.99`和`200`。
- en: We can then check the `Product` enumeration using a `switch` statement, as we
    did in an earlier example. We then extract the associated values within the `switch`
    statement. In this example, we extracted the associated values as constants with
    the `let` keyword, but you can also extract the associated values as variables
    with the `var` keyword.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`switch`语句检查`Product`枚举，就像我们在之前的示例中所做的那样。然后我们在`switch`语句中提取关联值。在这个例子中，我们使用`let`关键字将关联值提取为常量，但您也可以使用`var`关键字将关联值提取为变量。
- en: 'If you put the previous code into a playground, the following results will
    be displayed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将之前的代码放入游乐场，将会显示以下结果：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We are able to opt into the conformance of the `Comparable` protocols with
    our enumerations that have no associated values or associated values, which themselves
    conform to the `Comparable` protocol. By conforming to the `Comparable` protocol,
    we are able to compare cases of the same enum using the `<` and `>` operators.
    Let''s see how this works:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够选择使我们的枚举符合`Comparable`协议，这些枚举要么没有关联值，要么它们的关联值本身符合`Comparable`协议。通过符合`Comparable`协议，我们能够使用`<`和`>`运算符比较相同枚举的案例。让我们看看这是如何工作的：
- en: Don't worry if you do not understand what protocols are or how a type can conform
    to them at this point. We will be going over protocols in *Chapter 9*, *Protocols
    and Protocol Extensions*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不理解协议是什么，或者类型如何符合它们，请不要担心。我们将在第9章“协议和协议扩展”中介绍协议。
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the previous code, we defined an enumeration that defined the different
    grade levels. By `adding : Comparable` after the enumeration declaration, we are
    adding conformance to the `Comparable` protocol. We then created a constant that
    defined what our acceptable grade level was. We are now able to compare any variable
    that contains a `Grades` value with the `acceptableGrade` constant to make sure
    it contains an acceptable grade, as shown in our example.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '在之前的代码中，我们定义了一个枚举，它定义了不同的成绩等级。通过在枚举声明后添加`: Comparable`，我们添加了对`Comparable`协议的符合。然后我们创建了一个常量，定义了我们的可接受成绩等级。现在我们能够将包含`Grades`值的任何变量与`acceptableGrade`常量进行比较，以确保它包含一个可接受的成绩，正如我们在示例中所展示的那样。'
- en: Synthesized Comparable conformance for enumerations was added to Swift in version
    5.3 with Swift Evolution SE-0266 and is one of the features I am most excited
    about. It allows us to conform to the `Comparable` protocol with our enumerations,
    without having to write the code, to conform to the protocol ourselves.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的合成`Comparable`符合性是在Swift 5.3版本中通过Swift Evolution SE-0266添加的，这是我最兴奋的功能之一。它允许我们使我们的枚举符合`Comparable`协议，而无需编写代码来自己符合该协议。
- en: In future chapters in this book, we will look at additional features of enumerations
    and see why they can be so powerful. So far in this book, we have used operators
    in a number of examples. Let's take a closer look at them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将探讨枚举的附加功能，并了解为什么它们可以如此强大。到目前为止，在本书中，我们在许多示例中使用了运算符。让我们更仔细地看看它们。
- en: Operators
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: An operator is a symbol or combination of symbols that we can use to check,
    change, or combine values. We have used operators in most of the examples so far
    in this book, but we did not specifically call them operators. In this section,
    we will show you how to use most of the basic operators that Swift supports.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是我们可以使用来检查、更改或组合值的符号或符号组合。在本书的许多示例中，我们已经使用了运算符，但并没有特别提到它们。在本节中，我们将向您展示如何使用Swift支持的大多数基本运算符。
- en: Swift supports most standard C operators and also improves on some of them to
    eliminate several common coding errors. For example, the assignment operator does
    not return a value, which prevents it from being used where we are meant to use
    the equality operator, which is two equal signs (`==`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 支持大多数标准 C 运算符，并对其中一些进行了改进，以消除几个常见的编码错误。例如，赋值运算符不返回值，这防止了它在应该使用等于运算符的地方被使用，等于运算符是两个等号（`==`）。
- en: Let's look at the operators in Swift.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Swift 中的运算符。
- en: The assignment operator
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'The assignment operator initializes or updates a variable. Here is a prototype:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符初始化或更新一个变量。这里有一个原型：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Comparison operators
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: The comparison operators return a Boolean value of `true` if the statement is
    `true` or a Boolean value of `false` if the statement is not `true`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符如果语句为真则返回布尔值`true`，如果语句不为真则返回布尔值`false`。
- en: 'Here are some prototypes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些原型：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here are some examples:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Arithmetic operators
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The arithmetic operators perform the four basic mathematical operations. Here
    are some prototypes:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符执行四种基本的数学运算。这里有一些原型：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here are some examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The remainder operator
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 余数运算符
- en: The remainder operator calculates the remainder if the first operand is divided
    by the second operand. In other languages, this is sometimes referred to as the
    modulo or modulus operator.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 余数操作符计算第一个操作数除以第二个操作数后的余数。在其他语言中，这有时被称为取模或模运算符。
- en: 'Here is a prototype:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个原型：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Compound assignment operators
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: The compound assignment operators combine an arithmetic operator with an assignment
    operator.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 复合赋值运算符将算术运算符与赋值运算符组合起来。
- en: 'Here are some prototypes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些原型：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here are some examples:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The closed range operator
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭区间操作符
- en: The closed range operator defines a range that runs from the first number to
    the second number. The numbers are separated by three dots.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 闭区间操作符定义了一个从第一个数字到第二个数字的范围。数字之间由三个点分隔。
- en: 'Here is a prototype:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个原型：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is an example. Note that we will cover the `for` loop in *Chapter 6*,
    *Control Flow*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。注意，我们将在*第6章*，*控制流*中介绍`for`循环：
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This example would print out the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将打印出以下内容：
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The half-open range operator
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半开区间操作符
- en: The half-open range operator defines a range that runs from the first number
    to one, minus the second number. The numbers are separated by two dots and the
    less than sign.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 半开区间操作符定义了一个从第一个数字到第二个数字减一的数字的范围。数字之间由两个点和小于号分隔。
- en: 'Here is a prototype:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个原型：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here is an example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This example would print out the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将打印出以下内容：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice that in the closed range operator, the line `Number: 3` was printed
    out, but with the half open range operator, it wasn''t.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在闭区间操作符中，打印出了行`Number: 3`，但在半开区间操作符中却没有。'
- en: There are also one-side range operators that we use with arrays. We will look
    at those in *Chapter 5*, *Using Swift Collections*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有我们与数组一起使用的一侧范围操作符。我们将在*第5章*，*使用 Swift 集合*中探讨这些。
- en: The ternary conditional operator
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元条件运算符
- en: The ternary conditional operator assigns a value to a variable based on the
    evaluation of a comparison operator or `Boolean` value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 三元条件操作符根据比较操作符或布尔值的评估将值赋给一个变量。
- en: 'Here is a prototype:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个原型：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here is an example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The logical NOT operator
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑非运算符
- en: 'The logical `NOT` operator inverts a `Boolean` value. Here is a prototype:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非操作符反转一个布尔值。这里有一个原型：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is an example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The logical AND operator
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑与运算符
- en: The logical `AND` operator returns `true` if both operands are `true`; otherwise,
    it returns `false`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与运算符如果两个操作数都为真则返回`true`；否则返回`false`。
- en: 'Here is a prototype:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个原型：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is an example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The logical OR operator
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑或运算符
- en: 'The logical `OR` operator returns `true` if either of the operands are `true`.
    Here is a prototype:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或运算符如果任一操作数为真则返回`true`。这里有一个原型：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here is an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For those who are familiar with C or similar languages, these operators should
    look pretty familiar. For those of you who aren't that familiar with the C operators,
    rest assured that, once you begin using them frequently, they will become second
    nature.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 C 或类似语言的人来说，这些运算符看起来应该很熟悉。对于那些不太熟悉 C 运算符的人来说，请放心，一旦你开始频繁使用它们，它们将变得像第二本能一样自然。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered topics ranging from variables and constants to data
    types and operators. The items in this chapter will act as the foundation for
    every application that you write; therefore, it is important to understand the
    concepts we discussed here.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了从变量和常量到数据类型和运算符的各种主题。本章中的内容将成为你编写每个应用程序的基础；因此，理解我们在这里讨论的概念非常重要。
- en: In this chapter, we have seen that we should prefer constants to variables when
    the value is not going to change. Swift will give you a compile-time warning if
    you set but never change a variable's value. We also saw that we should prefer
    type inference over declaring a type.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到当值不会改变时，我们应该优先使用常量而不是变量。如果你设置了一个变量但从未改变其值，Swift 将在编译时给出警告。我们还看到，我们应该优先使用类型推断而不是显式声明类型。
- en: Numeric and string types, which are implemented as primitives in other languages,
    are named types that are implemented with structures in Swift. In future chapters,
    you will see why this is important. One of the most important things to remember
    from this chapter is that, if a variable contains a nil value, you must declare
    it as an optional.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串类型，在其他语言中作为原语实现，在 Swift 中是通过结构体实现的命名类型。在未来的章节中，你将看到为什么这一点很重要。本章需要记住的最重要的事情之一是，如果一个变量包含一个
    nil 值，你必须将其声明为可选的。
- en: In the next chapter, we will look at Swift optional types. The optional type
    in Swift can be one of the hardest concepts to grasp if you are used to languages
    that don't use them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Swift 的可选类型。如果你习惯于不使用可选类型的语言，Swift 中的可选类型可能是一个最难掌握的概念。
