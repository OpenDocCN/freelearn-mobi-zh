- en: Light Estimation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光估计
- en: Magicians spend hours in front of a mirror, watching and studying every angle
    of their performance in order to get it just right. They realize that every detail
    needs to be perfect in order for the audience to believe in the illusion. Even
    a single mistake can ruin not only the illusion, but the entire performance and
    credibility of the magician. As harsh as it is, this is no different to what it's
    like building an AR app. If your app will immerse a user in your world, you need
    to make it as believable as possible. This includes ensuring that all the virtual
    objects in a scene look like they belong. Magicians use lighting and perspective
    tricks to fool the user into believing that something is real. We have already
    seen how we use perspective, so now we need to cover and enhance our use of lighting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术师们会在镜子前花费数小时，观察并研究他们表演的每一个角度，以确保完美无缺。他们意识到，每一个细节都必须完美，才能让观众相信这个幻觉。即使是小小的错误，也可能毁掉整个幻觉，甚至魔术师的整个表演和可信度。虽然这听起来很苛刻，但这与构建AR应用的过程并无二致。如果你的应用要让用户沉浸在你的世界中，你需要尽可能地让它看起来可信。这包括确保场景中的所有虚拟物体看起来就像它们属于那里一样。魔术师们使用照明和透视技巧来欺骗用户，让他们相信某物是真实的。我们已经看到了我们如何使用透视，现在我们需要涵盖并增强我们对照明的使用。
- en: 'In this chapter, we will cover how ARCore uses light estimation techniques
    to make the AR experience more believable to the user. We will then go on to extend
    some of those basic techniques in order to improve our future AR apps. Here are
    the main topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍ARCore如何使用光估计技术来让AR体验对用户来说更加可信。然后我们将继续扩展一些基本技术，以改进我们未来的AR应用。以下是本章我们将涵盖的主要主题：
- en: 3D rendering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D渲染
- en: 3D lighting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D照明
- en: Light estimation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光估计
- en: Cg/HLSL shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cg/HLSL着色器
- en: Estimating light direction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计光方向
- en: We will use Unity in this chapter because it provides an easier platform for
    learning about the rendering process, lighting, and more about shader programs.
    The shader programs in Unity are a different variety and are definitely worth
    taking a look at.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用Unity，因为它提供了一个更容易的平台来学习渲染过程、照明以及更多关于着色器程序的内容。Unity中的着色器程序是不同类型的，绝对值得一看。
- en: 'While this chapter is less than halfway through the book, a reader should consider
    this as an advanced chapter. We will again be covering more about shader programs
    and 3D math concepts. Here''s a good site for those of you who want to review
    or just get a basic understanding of 3D math, through this tutorial, *3D Math:
    Vector Math for 3D Computer Graphics* at [http://chortle.ccsu.edu/vectorlessons/vectorindex.html](http://chortle.ccsu.edu/vectorlessons/vectorindex.html).
    This is an excellent site licensed by *Bradley Kjell*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然这一章还不到书的一半，但读者应该将其视为高级章节。我们还将再次涵盖更多关于着色器程序和3D数学概念的内容。对于那些想要复习或只是想对3D数学有一个基本了解的人来说，这里有一个很好的网站，通过这个教程，*3D
    Math: Vector Math for 3D Computer Graphics* [http://chortle.ccsu.edu/vectorlessons/vectorindex.html](http://chortle.ccsu.edu/vectorlessons/vectorindex.html)。这是一个由*Bradley
    Kjell*授权的极好网站。'
- en: 3D rendering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D渲染
- en: 'Before we get into talking about light estimation for AR, let''s step back
    and review the rendering process of a 3D model. Take a look at the following diagram
    that explains the rendering process at a high level:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论AR中的光估计之前，让我们回顾一下3D模型的渲染过程。看看以下这个图表，它从高层次解释了渲染过程：
- en: '![](img/06d37bf8-5c90-4970-8064-be27a97eceaf.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06d37bf8-5c90-4970-8064-be27a97eceaf.jpg)'
- en: Typical rendering process for a 3D model
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型的典型渲染过程
- en: Now, the diagram only visually demonstrates the rendering process. Geometry
    and vertex shaders never actually render a wireframe model. Rather, they only
    position and color vertices and surfaces, which are then fed into the pixel/fragment
    and lighting shaders. This last step is called **rasterization** and represents
    the final step when the 2D image is generated or rasterized.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个图表只是从视觉上展示了渲染过程。几何和顶点着色器实际上永远不会渲染线框模型。相反，它们只定位和着色顶点和表面，然后这些信息被输入到像素/片段和照明着色器中。这一步被称为**光栅化**，代表了生成或光栅化2D图像的最终步骤。
- en: The rendering process we are talking about here is for standard real-time rendering
    on a device's GPU using DirectX or OpenGL. Keep in mind that there are other rendering
    processes used for real-time (voxel) and non real-time (ray tracing) rendering.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的渲染过程是在设备GPU上使用DirectX或OpenGL进行的标准实时渲染。请记住，还有其他用于实时（体素）和非实时（光线追踪）渲染的渲染过程。
- en: 'Euclideon have developed a voxel-like rendering technology, which they are
    claiming to be, in their words, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Euclideon开发了一种类似体素渲染技术，他们声称如下：
- en: '"The First Truly Applicable Hologram Tech is Here."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"这里有了真正可用的全息技术。"'
- en: '- Euclideon'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '- Euclideon'
- en: This sounds very promising and a game changer for AR and VR. However, this technology
    has come under incredible scrutiny for making, what some feel are outlandish claims
    of rendering trillions of points without frame rate loss.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来非常有前景，并且是AR和VR的一个变革性技术。然而，这项技术因在帧率损失的情况下渲染万亿个点而受到极大的质疑，有些人认为这是荒谬的声明。
- en: Building a test scene
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建测试场景
- en: 'As always, let''s take a look at how this looks in our tools. Open up Unity
    with the sample ARCore project we have already installed, and perform the following
    steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们看看这在我们工具中的样子。打开Unity，使用我们已安装的示例ARCore项目，并执行以下步骤：
- en: From the menu, select File | New Scene. This will create a new empty scene for
    us in Unity.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择文件 | 新建场景。这将在Unity中为我们创建一个新的空场景。
- en: 'From the Project window, drag the Andy prefab from the `Assets/GoogleARCore/HelloARExample/Prefabs`
    folder into the Hierarchy window, as shown in the following screen excerpt:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目窗口中，将安迪预制件从`Assets/GoogleARCore/HelloARExample/Prefabs`文件夹拖动到层次窗口中，如以下屏幕截图中所示：
- en: '![](img/64458ed3-7272-431f-b1b5-866bfd43649f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64458ed3-7272-431f-b1b5-866bfd43649f.png)'
- en: Unity interface showing Andy prefab dragged onto the scene
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显示Unity界面，安迪预制件被拖动到场景中
- en: 'Andy is quite small, so we will adjust his size and the camera so that he fits
    in the Scene and Game windows better. Select Andy and modify Transform Scale to
    X as `25`, Y as `25`, and Z as `25`. Then, select Main Camera and modify its Transform
    Position to Y as `4`. This is shown in the following screen excerpt:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安迪（Andy）相当小，因此我们将调整他的大小和相机，以便更好地适应场景和游戏窗口。选择安迪，并将变换缩放修改为X为`25`，Y为`25`，Z为`25`。然后，选择主相机，并将其变换位置修改为Y为`4`。这在上面的屏幕截图中显示：
- en: '![](img/7a24a2fb-c4f9-4cab-bd23-fc151ae513ea.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a24a2fb-c4f9-4cab-bd23-fc151ae513ea.jpg)'
- en: Setting the Transform of Andy and the Main Camera
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设置安迪和主相机的变换
- en: Click on the Game and Scene tabs to switch views and see how the Andy model
    looks in each view.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击游戏和场景标签页以切换视图，查看安迪模型在每个视图中的样子。
- en: The Scene window in Unity is for composing your scene objects. This is where
    you will generally do most of your work in Unity. The Game window represents the
    view, as close as possible, as it is rendered in game. Unfortunately, for ARCore
    apps, we are limited to testing on a device and thus unable to generate an accurate
    game view. This is why, for now anyway, we will work in a separate scene for discovery
    purposes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的场景窗口用于组合场景对象。你将在Unity中大部分工作都在这里完成。游戏窗口表示游戏中的视图，尽可能接近渲染效果。不幸的是，对于ARCore应用，我们只能限制在设备上进行测试，因此无法生成准确的游戏视图。这就是为什么，至少目前，我们将为探索目的在单独的场景中工作。
- en: From the menu, select GameObject | 3D Object | Plane. This will add a new plane
    to the scene. Ensure that the plane is positioned at `0`,`0`,`0` by clicking on
    the Gear icon beside the Transform component in the Inspector window and selecting
    Reset Position from the menu. After you do that, Andy will be casting a shadow
    on the plane.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择GameObject | 3D Object | Plane。这将向场景添加一个新的平面。确保通过在检查器窗口中点击变换组件旁边的齿轮图标并从菜单中选择重置位置，使平面定位在`0`,`0`,`0`。完成此操作后，安迪将在平面上投射阴影。
- en: 'Switch between views again. Expand the Shaded dropdown just under the Scene
    tab, as shown in the following excerpt:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次切换视图。展开场景标签页下方的着色下拉菜单，如以下摘录所示：
- en: '![](img/6fe07cca-f11f-4345-bef0-b1a41714e3f0.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fe07cca-f11f-4345-bef0-b1a41714e3f0.png)'
- en: The Draw Mode menu
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制模式菜单
- en: This menu represents the various Draw Modes Unity can support. Some of these
    may make sense, such as Wireframe, while others less so. In any case, run through
    the list of each option to see what they do.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此菜单表示Unity可以支持的各种绘制模式。其中一些可能是有意义的，例如线框，而其他则不太有意义。无论如何，运行每个选项的列表，看看它们的作用。
- en: Materials, shaders, and textures
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质、着色器和纹理
- en: 'Okay, now we have seen how Unity renders a scene and the various draw modes
    available. However, we still need to go over how an object is colored or textured.
    In Unity, we typically use materials, shaders, and textures to render 3D objects.
    A material is essentially an encapsulation of a shader, its dependent textures,
    and other settings. Let''s see what AndyMaterial looks like in Unity by following
    the given steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经看到了 Unity 如何渲染场景以及各种绘制模式。然而，我们仍然需要了解对象是如何着色或纹理化的。在 Unity 中，我们通常使用材质、着色器和纹理来渲染
    3D 对象。材质本质上是一个着色器、其依赖的纹理和其他设置的封装。让我们通过以下步骤查看 AndyMaterial 在 Unity 中的样子：
- en: Open the `Assets/GoogleARCore/HelloARExample/Materials/Andy` folder in the Project
    window and select AndyMaterial. Look at the Inspector window and note the name
    of the Shader (`ARCoreDiffuseWithLightEstimation`) at the top. The current Shader
    uses a simple lighting model and has been optimized for mobile AR, which we don't
    currently need, so we will change it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中打开 `Assets/GoogleARCore/HelloARExample/Materials/Andy` 文件夹，并选择 AndyMaterial。查看检查器窗口，注意顶部的着色器名称（`ARCoreDiffuseWithLightEstimation`）。当前着色器使用简单的光照模型，并针对移动
    AR 进行了优化，而我们目前不需要，因此我们将更改它。
- en: 'Expand the Shader dropdown in AndyMaterial and select Standard. This will switch
    the material to using the Standard Shader, as shown in the following screenshot:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AndyMaterial 中展开着色器下拉菜单，选择标准。这将使材质切换到使用标准着色器，如下面的截图所示：
- en: '![](img/2a606dce-ceea-4292-8a90-48daba9241f9.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a606dce-ceea-4292-8a90-48daba9241f9.png)'
- en: Switching Andy to use the Standard Unity shader
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Andy 切换到使用标准 Unity 着色器
- en: The first thing you will immediately note is that Andy gets very dark. This
    is because the Metallic and Smoothness are turned way up. Use your mouse to adjust
    the various values to something more pleasant, as shown by the red arrows in the
    preceding screenshot. Perhaps a metallic shiny Andy?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会立即注意到 Andy 变得非常暗。这是因为金属和光滑度被调得非常高。使用鼠标调整各种值，使其更加愉快，如前一张截图中的红色箭头所示。也许一个金属闪亮的
    Andy？
- en: One thing to note when adjusting materials is that any changes you make to a
    material will be automatically saved and persisted even when running in the play
    or demo mode. Sometimes, it is useful to have backups of settings, especially
    if you found them difficult to achieve.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整材质时要注意的一点是，你对材质所做的任何更改都将自动保存并持久化，即使在播放或演示模式下运行也是如此。有时，保留设置的备份很有用，尤其是如果你发现它们很难实现。
- en: Make a copy of AndyMaterial by selecting it in the Project window and typing
    *Ctrl* + *D* or *command* + *D* on Mac. Rename the new material StandardAndyMaterial.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中选择 AndyMaterial 并按 *Ctrl* + *D* 或在 Mac 上按 *command* + *D* 复制 AndyMaterial。将新材质重命名为
    StandardAndyMaterial。
- en: Select AndyMaterial again. Change Shader back to `ARCore/DiffuseWithLightEstimation`.
    Note how the look of Andy quickly changes.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择 AndyMaterial。将着色器改回 `ARCore/DiffuseWithLightEstimation`。注意 Andy 的外观如何迅速改变。
- en: From the menu, select File | Save Scenes. Save the scene to the `Assets/GoogleARCore/HelloARExample/Scenes`
    folder as `RenderingTest.scene`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择文件 | 保存场景。将场景保存到 `Assets/GoogleARCore/HelloARExample/Scenes` 文件夹，命名为 `RenderingTest.scene`。
- en: As you can see, there are plenty of options and settings that can go into rendering
    a 3D object. Feel free to explore on your own what each of the material settings
    are on the Standard Shader. In the next section, we will expand our understanding
    of rendering by discussing lighting.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有很多选项和设置可以用于渲染 3D 对象。请自由探索标准着色器上的每个材质设置。在下一节中，我们将通过讨论光照来扩展我们对渲染的理解。
- en: 3D lighting
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 光照
- en: 'So far, we have looked at the basics of the rendering process and how a 3D
    model is rendered. What we omitted in the first section, however, is how lighting
    plays into this. In order to get a sense of the importance of lights in a 3D scene,
    how about we go ahead and turn out the lights. Open up Unity to where we left
    off in the first section and follow along:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了渲染过程的基础以及 3D 模型的渲染方式。然而，在第一部分中，我们省略了光照如何影响这个过程。为了了解光照在 3D 场景中的重要性，我们不妨先关闭灯光。打开
    Unity，回到第一部分结束的地方，并按照以下步骤操作：
- en: Select the Directional Light object in the Hierarchy window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择方向光对象。
- en: Disable the Light in the Inspector window by unchecking the box beside the object's
    name. This will turn off or disable the light. You will note that not all the
    lights go off, however. This is because we have an ambient or global light that
    is used to account for general light scattering.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中通过取消选中对象名称旁边的复选框来禁用灯光。这将关闭或禁用灯光。然而，你将注意到并非所有的灯光都关闭了。这是因为我们有一个环境光或全局光，用于解释一般的光散射。
- en: 'You are now left with a dark object with no lights and shadows. Turn back on
    the Directional Light by clicking on the checkbox. Take a look at the properties
    of the Light in the **Inspector** window, as shown:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你面前的是一个没有灯光和阴影的暗物体。通过点击复选框重新打开方向光。查看检查器窗口中光的属性，如图所示：
- en: '![](img/8ba30c1d-96a4-4608-a149-0560247d2fa9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ba30c1d-96a4-4608-a149-0560247d2fa9.png)'
- en: Directional Light properties in the Inspector window
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器窗口中的方向光属性
- en: Play with the Type, Color, **Mode**, and Shadow Type properties in the Inspector
    window. There are four different types of lights you can work with. The Directional
    type represents a light source such as the sun, and as such, we only need to identify
    the direction the light is pointing. For the other light types, such as **point**
    and **spot**, you will need to position the light in the scene correctly in order
    to see any effects.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中调整类型、颜色、**模式**和阴影类型属性。你可以使用四种不同类型的灯光。方向光类型代表如太阳这样的光源，因此我们只需要确定光的方向。对于其他灯光类型，如**点光**和**聚光灯**，你需要正确地将灯光放置在场景中才能看到任何效果。
- en: 'We can calculate simple 3D diffuse lighting with the following equation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方程计算简单的3D漫反射照明：
- en: '![](img/9e407203-35eb-49da-8758-82d70b640467.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e407203-35eb-49da-8758-82d70b640467.png)'
- en: 'Here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: '![](img/dee632b5-0408-475d-ae58-5ff5d8339424.png) is the direction of the light'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/dee632b5-0408-475d-ae58-5ff5d8339424.png) 是光的方向'
- en: '![](img/ec79985f-08b2-431b-b4e5-ce76d43d63c7.png) is the normal to the surface'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/ec79985f-08b2-431b-b4e5-ce76d43d63c7.png) 是表面的法线'
- en: '![](img/6a2d28c1-8564-4d7b-9564-2c7ace5febf8.png) is the intensity of light
    [0 to 1]'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/6a2d28c1-8564-4d7b-9564-2c7ace5febf8.png) 是光的强度 [0到1]'
- en: '![](img/0edecbb9-9645-4bc9-bd5e-7613ef9651a7.png) is then multiplied by the
    color in order to determine the resulting lit color.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/0edecbb9-9645-4bc9-bd5e-7613ef9651a7.png) 然后被乘以颜色，以确定最终的照明颜色。'
- en: The **Standard** Shader we looked at earlier uses **Physically-Based Rendering **(**PBR**)
    or a lighting model, which is quite sophisticated. Unfortunately, PBR shaders
    are currently limited for mobile platforms and often don't work or have poor performance.
    Often, the devices' GPU cannot support the additional instructions required for
    a PBR shader. Therefore, we will be limited to writing our own custom lighting
    shaders.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前查看的**Standard**着色器使用**基于物理的渲染（PBR**）或照明模型，这是一个相当复杂的模型。不幸的是，PBR着色器目前在移动平台上有限制，并且通常无法正常工作或性能不佳。通常，设备的GPU无法支持PBR着色器所需的额外指令。因此，我们将局限于编写我们自己的自定义照明着色器。
- en: Let's explore switching shaders on our AndyMaterial so that we can see what
    effect different lighting models have. Locate AndyMaterial in the `Assets/GoogleARCore/HelloARExample/Materials/Andy`
    folder and select it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们探索在AndyMaterial上切换着色器，以便我们可以看到不同的照明模型会产生什么效果。在`Assets/GoogleARCore/HelloARExample/Materials/Andy`文件夹中找到AndyMaterial并选择它。
- en: 'Switch between `ARCore/DiffuseWithLightEstimation`, **Mobile Diffuse**, and
    the **Standard** shaders to see the effects or the different lighting models,
    as illustrated:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ARCore/DiffuseWithLightEstimation`、**Mobile Diffuse**和**Standard**着色器之间切换，以查看效果或不同的照明模型，如图所示：
- en: '![](img/d41cd325-4480-4822-9f63-a8878a28646f.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d41cd325-4480-4822-9f63-a8878a28646f.jpg)'
- en: Comparison of lighting models from three different shaders
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 三个不同着色器的照明模型比较
- en: Obviously, the Standard shader looks the most natural, but as we learned, PBR
    shaders are currently not supported on mobile platforms. Another option would
    be the Mobile Diffuse shader; let's see how that shader looks in our AR sample
    app.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，Standard着色器看起来最自然，但正如我们所学的，PBR着色器目前在移动平台上不受支持。另一个选择是Mobile Diffuse着色器；让我们看看这个着色器在我们的AR示例应用中的样子。
- en: Switch the shader to the Mobile Diffuse one and then save the project (File | Save
    Project).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器切换到Mobile Diffuse，然后保存项目（文件 | 保存项目）。
- en: Connect your device and type *Ctrl *+ *B*, *command *+ *B* on Mac. This will
    build and run the app on your device. Play with the app and wait for a surface
    to be visible and then tap and place Andy.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的设备连接并输入 *Ctrl *+ *B*，Mac上为 *command *+ *B*。这将构建并在你的设备上运行应用。玩玩这个应用，等待一个表面可见，然后点击并放置Andy。
- en: Note anything different about our friend? That's right, he appears to stick
    out like a hot day in Canada. The reason for this is that the Mobile Diffuse shader
    is assuming a consistent light source, which means our model is always getting
    the same light (direction and intensity), except that in the real world, as the
    user moves, light direction and intensity can change dramatically. Your device's
    camera will try and compensate for this, but you can still see perceptible changes
    in lighting, especially if the lighting around the user changes dramatically.
    You can see this by running the app again, and this time, take a closer look at
    how the lighting looks different on and around our model. ARCore solves this issue
    of inconsistent lighting by performing a process called light estimation. We will
    cover light estimation in detail in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的朋友有什么不同吗？没错，他看起来就像加拿大炎热的夏天一样突出。这是因为移动漫反射着色器假设了一个一致的光源，这意味着我们的模型总是接收到相同的光（方向和强度），但在现实世界中，随着用户的移动，光的方向和强度可以发生显著变化。你的设备相机会尝试补偿这一点，但你仍然可以观察到明显的光照变化，尤其是在用户周围的光照发生显著变化时。你可以通过再次运行应用程序来观察这一点，这次，仔细观察我们的模型及其周围的光照有何不同。ARCore通过执行一个称为光估计的过程来解决不一致光照的问题。我们将在下一节中详细介绍光估计。
- en: Light estimation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光估计
- en: 'Light estimation is a technique for replicating the lighting conditions of
    the real world and applying it to our 3D virtual objects. Ideally, we would like
    to be able to replicate the exact lighting conditions, but of course, we''re not
    there yet. ARCore currently uses an image analysis algorithm to determine light
    intensity based on the current image from the device. This is then applied as
    global light to the 3D objects in the scene. Open up Unity again and let''s see
    how this is done by following along the given steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 光估计是一种复制现实世界光照条件并将其应用于我们的3D虚拟对象的技术。理想情况下，我们希望能够复制确切的光照条件，但当然，我们还没有达到那个水平。ARCore目前使用图像分析算法根据设备当前图像确定光强度。然后，将其作为全局光照应用于场景中的3D对象。再次打开Unity，让我们通过遵循给定的步骤来了解这是如何完成的：
- en: Locate the AndyMaterial again and revert its shader to `ARCore/DiffuseWithLightEstimation`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次定位AndyMaterial并将其着色器还原为`ARCore/DiffuseWithLightEstimation`。
- en: Save the project (File | Save Project).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目（文件 | 保存项目）。
- en: Connect your device and type *Ctrl* + *B* (*command* + *B* on Mac) to build
    and run the app on your device. Place a couple of Andy models and alter the lighting
    conditions. Note how our objects respond to the changes in lighting.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接你的设备，并输入*Ctrl* + *B* (*Mac上的*command* + *B*)来构建和运行设备上的应用程序。放置几个Andy模型并改变光照条件。注意我们的物体是如何对光照变化做出反应的。
- en: Go back to Unity and double-click on the `HelloAR` scene in the `Assets/GoogleARCore/HelloARExample/Scenes`
    folder to open the scene. Feel free to save your `RenderingTest` scene.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，双击`Assets/GoogleARCore/HelloARExample/Scenes`文件夹中的`HelloAR`场景以打开场景。请随意保存你的`RenderingTest`场景。
- en: Direct your attention to the Hierarchy window and double-click on Directional
    Lightto focus and highlight it in the Scene window. Note how the light is pointing
    straight down in the Scene window. In the **Inspector** window, you will see that
    the Shadow Type is set to No Shadows, and the Intensity is turned down to `0.7`,
    which essentially turns the light into a directional ambient or global light.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的注意力转向层级窗口，双击**方向光**以在场景窗口中聚焦并突出显示它。注意在场景窗口中光是如何直指下方的。在**检查器**窗口中，你会看到阴影类型设置为无阴影，并且强度调低到`0.7`，这实际上将光变成了方向性环境光或全局光。
- en: 'Direct your attention back to the Hierarchy window and select **Environmental
    Light**. Go to the **Inspector** window and click on the Gear icon beside the
    **Environmental Light (Script)** component. Then, select the **Edit Script** option
    from the context menu, as shown:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的注意力转回到层级窗口，并选择**环境光**。进入**检查器**窗口，点击**环境光（脚本）**组件旁边的齿轮图标。然后，从上下文菜单中选择**编辑脚本**选项，如图所示：
- en: '![](img/6c61f973-382a-41ad-a138-9848114b4bd5.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c61f973-382a-41ad-a138-9848114b4bd5.png)'
- en: Editing the Environmental Light script
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑环境光脚本
- en: 'This will open up the script in your script editor. By default, Unity installs
    **MonoDevelop**, which will open the script if you have not installed and set
    a different editor. Scroll down to the `Update` method, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开你的脚本编辑器中的脚本。默认情况下，Unity安装了**MonoDevelop**，如果没有安装或设置了不同的编辑器，它将打开脚本。向下滚动到`Update`方法，如下所示：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `#if UNITY_EDITOR` is a compiler directive that checks whether the code
    is running in the editor. The reason we do this is so that when the code runs
    in the Unity editor, we want it to ignore any light estimation calculations. When
    the code is running in the editor, it will execute the next line; the `_GlobalLightEstimation`
    shader variable is set to `1`. This means that when the code is running in the
    editor, all it does is set our light to `1.0`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#if UNITY_EDITOR`是一个编译器指令，用于检查代码是否在编辑器中运行。我们这样做的原因是，当代码在Unity编辑器中运行时，我们希望它忽略任何光估计计算。当代码在编辑器中运行时，它将执行下一行；`_GlobalLightEstimation`着色器变量被设置为`1`。这意味着当代码在编辑器中运行时，它所做的只是将我们的光照设置为`1.0`。'
- en: You will come across the `#if UNITY_EDITOR` directive quite frequently when
    doing mobile development. This directive allows you to write test code that only
    executes when the code is running in the editor. This allows us to simulate the
    object running in the editor without the need to worry about ARCore services or
    device restrictions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行移动开发时，你经常会遇到`#if UNITY_EDITOR`指令。这个指令允许你编写仅在代码在编辑器中运行时执行的测试代码。这允许我们模拟对象在编辑器中的运行，而无需担心ARCore服务或设备限制。
- en: Direct your attention to the `#else` block of code. This is code that is executed
    on the device and first checks whether the `Frame` is tracking. We have already
    seen this check in Android. The rest of the code is essentially just math, but
    if you look at the last highlighted line, you will see a call to `Frame.LightEstimate.PixelIntensity`.
    This is the call where ARCore reads the image from the camera and determines the
    current pixel intensity; a float value from 0 for a totally black image to `1`
    that is fully white. The intensity is normalized based on a constant called `MiddleGray`.
    The `MiddleGray` color or light intensity of `0.18f` corresponds roughly to the
    point where we humans stop recognizing colors.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的注意力转向代码中的`#else`块。这是在设备上执行的代码，首先检查`Frame`是否正在跟踪。我们已经在Android中看到了这个检查。其余的代码基本上只是数学运算，但如果你查看最后高亮的那一行，你会看到一个对`Frame.LightEstimate.PixelIntensity`的调用。这就是ARCore从相机读取图像并确定当前像素强度的调用；一个从完全黑色的图像的`0`到完全白色的`1`的浮点值。强度是根据一个称为`MiddleGray`的常量进行归一化的。`MiddleGray`颜色或光强度为`0.18f`大致对应于我们人类停止识别颜色的点。
- en: We then use the `normalizedIntensity` to determine whether we want a linear
    change in lighting, when `normalizedIntensity` is less than `1.0`, or more gradually,
    when the intensity is greater than `1.0`. That's all that the rest of the math
    is doing, just making the lighting change more gradually after a certain threshold.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`normalizedIntensity`来确定我们是否想要线性变化的光照，当`normalizedIntensity`小于`1.0`时，或者当强度大于`1.0`时，变化更缓慢。这就是其余数学运算所做的一切，只是在某个阈值之后使光照变化更加缓慢。
- en: 'Change the `MiddleGray` constant to match the following line:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MiddleGray`常量更改为以下行：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will convert our light estimation to now use a linear model. Save the code
    change and return to Unity. Unity will automatically recompile the code and inform
    you of any errors in the status bar at the bottom of the editor.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把我们的光估计转换为现在使用线性模型。保存代码更改并返回Unity。Unity将自动重新编译代码，并在编辑器底部的状态栏中通知你任何错误。
- en: Connect your device and build and run. Place an Andy on a surface. Note how
    dark the figure is; this is because the lighting model is too abrupt.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接你的设备并构建运行。将一个Andy放在表面上。注意这个图形有多暗；这是因为光照模型太突然。
- en: We are using a single channel of color or what you may also call gray scale.
    This is why we refer to values as a color but it is in fact just a single float.
    A gray scale color of `0.18f` is equivalent to the RGB color (`0.18f`, `0.18f`,
    `0.18f`) or what ARCore calls `MiddleGray`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是单通道的颜色，或者你也可以称之为灰度。这就是为什么我们称这些值为颜色，但实际上它只是一个单一的浮点数。灰度颜色`0.18f`相当于RGB颜色（`0.18f`，`0.18f`，`0.18f`），或者ARCore称之为`MiddleGray`。
- en: Change the `MiddleGray` constant back to `0.18f`, save the project, and run
    the app. Note the difference in lighting.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MiddleGray`常量改回`0.18f`，保存项目，并运行应用。注意光照的变化。
- en: This covers how ARCore uses image analysis techniques to read the light intensity
    from the camera's image and converts that value into a global light intensity
    or color. The lighting value is set on a shader, and we will follow how that value
    is used in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了ARCore如何使用图像分析技术从相机的图像中读取光强度，并将其转换为全局光强度或颜色。光照值是在着色器上设置的，我们将在下一节中了解这个值是如何被使用的。
- en: Cg/HLSL shaders
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cg/HLSL着色器
- en: 'The shading language used in Unity is a variety of HLSL, or sometimes referred
    to as Cg. This shading variant provides two different forms of shaders: **surface**
    and **vertex**/**fragment** shaders. Now, coming from Android, this may sound
    confusing, since GLSL treats vertex and fragment shaders differently. However,
    variety of HLSL in Unity treats vertex and fragment shaders as the same, since
    they reside in the same file and are in the same workflow. A surface shader, which
    handles the lighting of our model, can be simple or quite complex. The Standard
    Unity surface shader uses a PBR lighting model, which is quite advanced and not
    supported on most mobile devices. This issue, combined with our limited ability
    to track scene lights, limits us to writing our own shaders in order to get our
    object lighting correct. ARCore provides us with a very simple surface shader
    that is used in the sample to light the Andy model. Let''s open up Unity and take
    a look at what that shader looks like by following the given steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中使用的着色语言是HLSL的多种变体，有时也称为Cg。这种着色变体提供了两种不同形式的着色器：**表面**和**顶点**/**片段**着色器。现在，从Android过来，这可能会让人感到困惑，因为GLSL对顶点和片段着色器处理不同。然而，Unity中的HLSL变体将顶点和片段着色器视为相同，因为它们位于同一文件中，并且处于相同的流程中。处理我们模型光照的表面着色器可以是简单的，也可以非常复杂。标准的Unity表面着色器使用PBR光照模型，这是一个相当先进的模型，并且不支持大多数移动设备。这个问题，加上我们有限的场景光照跟踪能力，使我们不得不编写自己的着色器，以正确地获取我们的对象光照。ARCore为我们提供了一个非常简单的表面着色器，用于在示例中为Andy模型提供光照。让我们打开Unity，按照以下步骤查看这个着色器的样子：
- en: Load up the `HelloAR` sample project and scene.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`HelloAR`示例项目和场景。
- en: Select the AndyMaterial in the `Assets/GoogleARCore/HelloARExample/Materials/Andy`
    folder. Ensure that the Shader is set to `ARCore/DiffuseWithLightEstimation`.
    Switch it back if you changed it.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/GoogleARCore/HelloARExample/Materials/Andy`文件夹中选择AndyMaterial。确保着色器设置为`ARCore/DiffuseWithLightEstimation`。如果你更改了它，请将其切换回来。
- en: 'Click on the Gear icon and from the context menu, select Edit Shader. This
    will open the shader in your code editor, and it is also shown here for reference:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击齿轮图标，从上下文菜单中选择编辑着色器。这将打开你的代码编辑器中的着色器，这里也为了参考而展示：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a fairly simple diffuse lighting shader that uses the global light
    estimate we calculated earlier. It starts by defining itself with this line:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个相当简单的漫反射光照着色器，它使用了我们之前计算的全球光照估计。它首先通过以下行定义自己：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, it defines `Properties` in the next code block, where `_MainTex` represents
    the base texture, is called `"Base (RGB)"`, and is set to `2D`. If you quickly
    look back at Unity, you can see this property in the **Inspector** window.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它定义了下一个代码块中的`Properties`，其中`_MainTex`代表基础纹理，被称为`"Base (RGB)"`，并设置为`2D`。如果你快速回顾Unity，你可以在**检查器**窗口中看到这个属性。
- en: 'The block of code that starts with `SubShader` is where the action happens.
    We first define `Tags`, which are sets of key/value pairs that set the rendering
    order and type parameters. In our example, we set this to `Opaque`. Then, we have
    the following line:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`SubShader`开始的代码块是动作发生的地方。我们首先定义`Tags`，这是一组键/值对，用于设置渲染顺序和类型参数。在我们的例子中，我们将此设置为`Opaque`。然后，我们有以下行：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This determines the **level of detail** of the shader. The `LOD` directive
    is used to determine the complexity or performance requirements of the shader.
    You can set the value to anything, but typical values are shown in the following
    list:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这决定了着色器的**细节级别**。`LOD`指令用于确定着色器的复杂度或性能要求。你可以将值设置为任何值，但以下列表显示了典型值：
- en: VertexLit kind of shaders = `100`
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点照明类型着色器 = `100`
- en: Decal, Reflective VertexLit = `150`
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贴图，反射式顶点照明 = `150`
- en: Diffuse = `200`
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漫反射 = `200`
- en: Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = `250`
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漫反射细节，反射式凸起无光照，反射式凸起顶点照明 = `250`
- en: Bumped, Specular = `300`
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凸起，高光 = `300`
- en: Bumped Specular = `400`
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凸起高光 = `400`
- en: Parallax = `500`
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差 = `500`
- en: Parallax Specular = `600`
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差高光 = `600`
- en: As you can see from the list, the simple shader represents a low level of detail.
    This means that lower-level hardware should be able to run this shader without
    any issue. You can set the maximum shader LOD per shader or globally; check the
    Unity documentation for further details.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中可以看出，简单的着色器代表的是低细节级别。这意味着低级硬件应该能够无任何问题地运行这个着色器。你可以为每个着色器或全局设置最大着色器LOD；查看Unity文档以获取更多详细信息。
- en: 'We start our actual shader code with `CGPROGRAM` and then define the form of
    surface shader with the `#pragma` directive, as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`CGPROGRAM`开始编写实际的着色器代码，然后使用`#pragma`指令定义表面着色器的形式，如下所示代码：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first part of the directive, `surface`, defines this as a surface shader.
    Then, we see that the `surf` function name refers to the main surface function.
    Then comes the lighting model, `Lambert` in this case. After that, the options
    are set to `noforwardadd`, which is just a simple way to limit the number of lights
    to one. Finally, we use a custom modification function called `lightEstimation`
    that is set with `finalcolor:lightEstimation`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令的第一部分，`surface`，将其定义为表面着色器。然后，我们看到`surf`函数名称指的是主表面函数。接着是光照模型，本例中为`Lambert`。之后，选项设置为`noforwardadd`，这是一种简单的方式来限制灯光数量为单一。最后，我们使用一个名为`lightEstimation`的自定义修改函数，并通过`finalcolor:lightEstimation`进行设置。
- en: This shader uses the Lambert lighting model. You can find plenty of examples
    of what lighting models Unity supports or how to write your own model at [https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html](https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此着色器使用Lambert光照模型。你可以在[https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html](https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html)找到Unity支持的光照模型的大量示例或如何编写自己的模型。
- en: 'Just inside the `#pragma` directive, we see the definition of the shader inputs:
    `_MainTex`, `_GlobalLightEstimation`, and `struct Input`. If you recall, `_GlobalLightEstimation`
    is the variable we set inside the `EnvironmentalLight` script to represent our
    global light.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`#pragma`指令的内部，我们看到着色器输入的定义：`_MainTex`、`_GlobalLightEstimation`和`struct Input`。如果你还记得，`_GlobalLightEstimation`是我们设置在`EnvironmentalLight`脚本中的变量，用来表示我们的全局光。
- en: 'Next, we will jump down a few lines to the `surf` function, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向下跳几行到`surf`函数，如下所示：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function simply samples the color from our `_MainTex` using `tex2D` and
    the input `uv` coordinates. Then, it sets the color (`Albedo`) and `Alpha` from
    the lookup. This function is called first to determine the color of the surface,
    and then, its output is passed to the Lambert lighting model, after which the
    final color is set by the `lightEstimation` function.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数简单地使用`tex2D`和输入的`uv`坐标从我们的`_MainTex`中采样颜色。然后，它从查找中设置颜色（`Albedo`）和`Alpha`。这个函数首先被调用以确定表面的颜色，然后，其输出被传递到Lambert光照模型，之后最终颜色由`lightEstimation`函数设置。
- en: An input marked as `inout` represents a value that can be modified and will
    automatically be returned.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标记为`inout`的输入表示一个可以修改的值，并且将自动返回。
- en: 'Scroll up a bit to the `lightEstimation` function. Inside this function, the
    code, shown as follows, modifies the color based on the value that was set for
    `_GlobalLightEstimation`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上滚动一点到`lightEstimation`函数。在这个函数内部，以下所示的代码根据为`_GlobalLightEstimation`设置的值修改颜色：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Multiplying the color by the global light estimation is the same as adjusting
    the brightness with a dimmer switch.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将颜色乘以全局光照估计相当于调整亮度开关。
- en: Finally, we complete the shader with `Fallback` and the name of another shader.
    This sets the fall back or backup shader if the current shader is unable to run.
    A shader can fail due to compilation errors or hardware limitations.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过`Fallback`和另一个着色器的名称来完成着色器的设置。这将为当前着色器无法运行时设置一个回退或备用着色器。着色器可能会因为编译错误或硬件限制而失败。
- en: Now that we have a clear understanding of how the light estimation value we
    saw generated earlier is used in the shader, we can move to perhaps enhancing
    our lighting. If you recall, our current light just points straight down, but
    ideally, we would like to position the light to match the strongest light source.
    We will look at a simple but effective technique to track and position a light
    in AR in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地了解了之前生成的光照估计值在着色器中的使用方式，我们可以转向可能增强我们的光照。如果你还记得，我们当前的光线是直接向下的，但理想情况下，我们希望将光线定位到最强的光源处。在下一节中，我们将探讨一种简单但有效的方法来跟踪和定位AR中的光线。
- en: Estimating light direction
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估计光照方向
- en: 'Google provides us with a robust solution for estimating the amount of light
    in an AR scene with ARCore. As we learned, light direction is an equally important
    part of scene lighting. Google didn''t intentionally ignore estimating light direction
    with ARCore; it''s just that that problem is really difficult to do right. However,
    Google did provide us with just enough tools in ARCore to be able to estimate
    light direction, providing some simple assumptions. First, we need to assume that
    our user, for now anyway, will remain in the same room or area. Second, our user
    will need to look in at least an 180 degree arc across their vision, or more simply
    put, the user just needs to look around. Third, it works best if the real-world
    environment is lit from a distant single bright source, such as the sun. Based
    on those assumptions, we can simply store the direction the user saw the brightest
    image in and use that to reverse calculate our light direction. This may sound
    more complex than it is, so hopefully, the following diagram can explain this
    further:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Google通过ARCore为我们提供了一个强大的解决方案，用于估计AR场景中的光照量。正如我们所学的，光方向是场景照明的一个重要组成部分。Google并没有故意忽略使用ARCore估计光方向；只是这个问题真的很难做对。然而，Google确实在ARCore中为我们提供了足够多的工具，使我们能够估计光方向，并做出一些简单的假设。首先，我们需要假设我们的用户，至少目前，将保持在同一个房间或区域。其次，我们的用户需要至少在视野中180度的弧度内查看，或者更简单地说，用户只需要四处看看。第三，如果真实世界环境由一个远处的单一明亮光源照亮，例如太阳，那么效果最好。基于这些假设，我们可以简单地存储用户看到最亮图像的方向，并使用它来反向计算我们的光方向。这可能听起来比实际要复杂，所以希望以下图表可以进一步解释这一点：
- en: '![](img/6845f85e-4266-4ec6-8a32-f96f0d76bdc2.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6845f85e-4266-4ec6-8a32-f96f0d76bdc2.jpg)'
- en: Calculating light direction from camera pixel intensity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从相机像素强度计算光方向
- en: 'Now, this technique may sound quite complicated, but it isn''t. We can actually
    accomplish this with just a few lines of code. Open up Unity and follow along
    to write our directional light detector:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个技术听起来可能相当复杂，但实际上并不复杂。我们实际上只需要几行代码就能完成这个任务。打开Unity并跟随步骤编写我们的方向光检测器：
- en: Ensure that the `HelloAR` scene of the sample app is loaded.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保样本应用中的`HelloAR`场景已加载。
- en: Select the Environmental Light object in the Hierarchy window.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择环境光对象。
- en: Click on the Gear icon beside the Environmental Light (Script) component in
    the **Inspector** window and select Edit Script from the context menu.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中点击环境光（脚本）组件旁边的齿轮图标，并在上下文菜单中选择编辑脚本。
- en: 'Just beneath the class declaration, add the following lines to declare new
    variables:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明下方，添加以下行以声明新变量：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These variables will hold a reference to the scene camera, light, the max global
    intensity we find, and the direction we find it.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些变量将保存对场景相机、光、找到的最大全局强度以及找到的方向的引用。
- en: 'Scroll down in the code until you see the identified line in the `Update` method,
    and add the following lines:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中向下滚动，直到看到`Update`方法中标识的行，并添加以下行：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All this code does is use `Frame.LightEstimate.PixelIntensity` to read the light
    intensity for the current camera direction. Then, we check whether this value
    is higher than any previous seen value (`maxGlobal`). If it is, we set a new maximum
    value and rotate the light (`SceneLight`) in the opposite direction of the camera,
    which means that the light will face toward the camera.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些代码所做的只是使用`Frame.LightEstimate.PixelIntensity`读取当前相机方向的光强度。然后，我们检查这个值是否高于之前看到的任何值（`maxGlobal`）。如果是，我们设置一个新的最大值并将光（`SceneLight`）旋转到与相机相反的方向，这意味着光将面向相机。
- en: Be careful when you edit code outside of the `#if UNITY_EDITOR` directive. This
    code won't be compiled until a build is run for the platform, which means that
    any errors in the code will be identified as build errors. This can be confusing,
    so be careful to avoid syntax errors when coding these sections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑`#if UNITY_EDITOR`指令之外的代码时要小心。这段代码只有在为平台运行构建时才会编译，这意味着代码中的任何错误都会被识别为构建错误。这可能会令人困惑，所以请小心避免在编写这些部分时出现语法错误。
- en: Save the file; that's all the code we need to write in order to adjust the light
    direction. If you recall from the last section, the diffuse shader we are using
    doesn't account for light direction. However, ARCore has provided us with another
    shader that does.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件；这就是我们为了调整光方向需要编写的所有代码。如果你还记得上一节，我们使用的漫反射着色器并没有考虑光方向。然而，ARCore为我们提供了一个考虑了光方向的着色器。
- en: Return to the editor to find and select the AndyMaterial in the Assets/GoogleARCore/HelloARExample/Materials/Andy
    folder.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器以在 Assets/GoogleARCore/HelloARExample/Materials/Andy 文件夹中找到并选择Andy材质。
- en: Change the material to use the `ARCore/SpecularWithLightEstimation` shader.
    This material shows the direction of light better.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质更改为使用`ARCore/SpecularWithLightEstimation`着色器。这种材质能更好地显示光的方向。
- en: Select the Environmental Light object in the Hierarchy window. Note how we have
    two new properties added to the Environmental Light (Script) component. These
    new properties (Scene Camera and Scene Light) were added because we declared them
    as **public** fields in the class.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级窗口中选择环境光照对象。注意我们已向环境光照（脚本）组件添加了两个新属性。这些新属性（场景相机和场景光）被添加是因为我们在类中将它们声明为**公共**字段。
- en: 'Click on the icon that resembles a bullseye next to the Scene Camera property.
    Then, as shown in the following excerpt, select the First Person Camera object
    from the Select GameObject dialog:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击场景相机属性旁边的类似靶心的图标。然后，如以下摘录所示，从**选择游戏对象**对话框中选择First Person Camera对象：
- en: '![](img/5bf994ec-eaf5-4f99-9495-9f55657f92d8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bf994ec-eaf5-4f99-9495-9f55657f92d8.png)'
- en: Setting the Scene Camera and Scene Light properties of the component
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 设置组件的场景相机和场景光属性
- en: Close the **Select GameObject** dialog.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**选择游戏对象**对话框。
- en: Repeat the same process for setting the **Directional Light** as the **Scene
    Light**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复相同的步骤来设置**方向光**作为**场景光**。
- en: Connect your device and build and run. Run the app in an area with a single
    bright light source and see how Andy looks after you place it.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备并构建运行。在一个只有一个明亮光源的区域运行应用，看看放置Andy后他的样子。
- en: Updating the environmental lighting
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新环境照明
- en: 'Now Andy should be lit from what looks like the brightest light source in the
    area. However, because we don''t currently track changes in light direction, if
    you change rooms or the lighting changes, then the illusion is broken. Light tracking
    is difficult, and it''s more difficult than tracking a user, except that we can
    put a simple hack in place to not track the lighting for as long as we do, which
    is currently forever, if you weren''t paying attention. Follow along to put this
    simple hack in the code we just wrote:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Andy应该被看起来区域中最亮的光源照亮。然而，因为我们目前没有跟踪光方向的变化，如果你更换房间或照明发生变化，那么这种幻觉就会被打破。光跟踪很困难，而且比跟踪用户更困难，尽管我们可以实施一个简单的黑客手段来不跟踪照明，目前这个手段是永久的，如果你没有注意的话。跟随以下步骤将这个简单的黑客手段放入我们刚刚编写的代码中：
- en: Open up the `EnvrionmentalLight.cs` script in your text editor of choice. If
    you forgot how to do this, just look back a few pages.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的文本编辑器中打开`EnvrionmentalLight.cs`脚本。如果你忘记了如何做，只需回顾几页。
- en: 'Add the following line right after and before the lines identified:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定的行之后和之前添加以下行：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That single line is a degrade function on the `maxGlobal` variable. Remember
    that `maxGlobal` is the value we identify as the strongest light source. This
    simple function, yep function, degrades this value over time. The value of `.98f` sets
    the speed of decay. A value of `.98f` represents a fairly quick decay rate, whereas
    a value of `.9999f` would represent a slow decay.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那一行是`maxGlobal`变量的降级函数。记住`maxGlobal`是我们识别为最强光源的值。这个简单的函数，是的，函数，随时间降低这个值。`.98f`的值设置了衰减速度。`.98f`代表一个相当快的衰减率，而`.9999f`则代表一个慢衰减率。
- en: Save the file, and yep, that's it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，是的，就这样。
- en: Go back to Unity. Connect and build and run the app. Now when you place an Andy,
    you should quickly see changes in what the app identifies as the strongest light
    source. Feel free to go back and change the decay rate or alter the function and
    use your own method; experiment.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity。连接、构建并运行应用。现在当你放置一个Andy时，你应该很快看到应用识别的最强光源的变化。你可以随意返回并更改衰减率或修改函数，并使用你自己的方法；实验。
- en: What we put together is a simple way to track and estimate light direction.
    As we mentioned, this method works, but it's certainly not without its limitations.
    In any case, this should give the curious reader enough to continue and extend
    this further. We also completely avoided a proper discussion of shadows. Fortunately,
    we will have plenty of time to do that in [Chapter 9](843257a4-843b-4278-99df-fec1e2bd996b.xhtml), *Blending
    Light for Architectural Design*, where we will allow the user to transform their
    own living space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组合的方法是一种简单的跟踪和估计光方向的方式。正如我们提到的，这种方法是有效的，但当然并非没有局限性。无论如何，这应该为好奇的读者提供足够的资料来继续并进一步扩展。我们还完全避免了关于阴影的适当讨论。幸运的是，我们将在第9章[混合光用于建筑设计](https://843257a4-843b-4278-99df-fec1e2bd996b.xhtml)中有很多时间来讨论这一点，我们将允许用户转换他们自己的居住空间。
- en: Exercises
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Complete the following exercises on your own**:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**请独立完成以下练习**：'
- en: Change the `maxGlobal` rate of decay. You decide whether to make it faster or
    slower.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`maxGlobal`衰减率。你决定是让它更快还是更慢。
- en: Increase or decrease the `maxGlobal` rate of decay based on the user's amount
    of movement. Hint—recall how we tracked the user, and use that to determine how
    far they have gone or how fast. Use that information to set the rate of decay.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户的移动量增加或减少`maxGlobal`衰减率。提示——回想一下我们是如何追踪用户的，并利用这一点来确定他们走了多远或有多快。使用这些信息来设置衰减率。
- en: Write your own custom lighting surface shader. This one's difficult, but it's
    worth the effort.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写你自己的自定义光照表面着色器。这个任务可能有些困难，但付出努力是值得的。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Certainly, as you become more of an expert in AR, you realize how important
    lighting is to augmented reality. It's so important that Google developed ARCore
    with light estimation built in, which is why we spent this entire chapter on the
    subject. First, we learned about the rendering process in a bit more depth; then,
    we covered 3D lighting, an essential bit of knowledge that we will need in order
    to understand the added complexity of lighting in AR. This led us to look at the
    way ARCore estimates the light levels or global light in an area by taking a closer
    look at Unity Cg/HLSL shaders and, more specifically, surface shaders. Finally,
    we implemented a simple but effective hack to track and estimate light direct
    in a scene, which we left the reader with to improve on in their own time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着你成为AR领域的专家，你会意识到光照对增强现实的重要性。它如此重要，以至于谷歌开发了内置光估计的ARCore，这就是为什么我们花费了整个章节来讨论这个主题。首先，我们更深入地了解了渲染过程；然后，我们介绍了3D光照，这是我们理解AR中光照增加的复杂性所必需的基本知识。这引导我们研究ARCore如何通过仔细查看Unity
    Cg/HLSL着色器和，更具体地说，表面着色器来估计区域的光照水平或全局光照。最后，我们实施了一个简单但有效的技巧来跟踪和估计场景中的光方向，我们将这个任务留给读者在他们的时间里去改进。
- en: Estimating the actual lighting conditions of the environment will be a major
    hurdle for AR to overcome. However, with the incredible advances in AI and Machine
    Learning, we will likely see some better solutions come out soon. We will take
    a closer look at how Machine Learning can assist AR in the next chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 估计环境中的实际光照条件将是AR需要克服的主要障碍。然而，随着AI和机器学习的惊人进步，我们可能会很快看到一些更好的解决方案出现。我们将在下一章更详细地探讨机器学习如何帮助AR。
