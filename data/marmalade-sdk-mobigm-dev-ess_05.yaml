- en: Chapter 5. Animating 3D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：3D图形动画
- en: We've now seen how to create a 3D model and display it on the screen, but we're
    currently limited to non-animated models. Sure, we can rotate or scale to our
    heart's content, but that really doesn't cut it when you want to animate something
    more complex than a cube, say for example a human figure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何创建3D模型并在屏幕上显示它，但我们目前限于非动画模型。当然，我们可以随意旋转或缩放，但当需要动画化比立方体更复杂的物体时，比如一个人物模型，这真的不够。
- en: 'In this chapter we will be looking at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: A quick overview of the concepts involved in 3D animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D动画涉及概念快速概述
- en: Exporting animations from a 3D modeling package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从3D建模软件包中导出动画
- en: Loading and rendering an exported 3D animation in a Marmalade project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Marmalade项目中加载和渲染导出的3D动画
- en: A quick 3D animation primer
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D动画快速入门
- en: Let's start by looking at the ways in which animation of 3D models can be achieved.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看3D模型动画的实现方式。
- en: Animating with model matrices
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模型矩阵进行动画
- en: By far the simplest and most obvious way of animating a 3D model is to alter
    its position, orientation, and size. All three of these properties can be specified
    using the model matrix set at the time of rendering the model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最简单、最明显地动画化3D模型的方法是改变其位置、方向和大小。这三个属性都可以使用在渲染模型时设置的模型矩阵来指定。
- en: We could store a matrix in our game class, and for each frame multiply it by
    a second matrix representing the change in position, rotation, and scale; but
    this approach is generally not reliable. Over time the matrix starts to degrade
    due to the cumulative effect of precision errors in the multiplications and additions
    involved. The matrix will often end up becoming non-orthogonal (that is, its three
    axes are no longer at right angles to each other), which yields a shearing effect
    on the 3D model. The scale can also be affected by these precision errors, causing
    the 3D model to gradually shrink in size!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏类中存储一个矩阵，并为每一帧乘以一个表示位置、旋转和缩放变化的第二个矩阵；但这种方法通常不可靠。随着时间的推移，矩阵开始退化，这是由于涉及乘法和加法中的精度误差的累积效应。矩阵通常会变得非正交（即其三个轴不再相互垂直），这会对3D模型产生剪切效应。缩放也可能受到这些精度误差的影响，导致3D模型逐渐缩小！
- en: A far more reliable way is to store the translation, rotation, and scale separately,
    and calculate a fresh matrix for every frame. How this can be achieved is described
    in the following sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更可靠的方法是将平移、旋转和缩放分别存储，并为每一帧计算一个新的矩阵。如何实现将在以下章节中描述。
- en: Animating by translation
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过平移进行动画
- en: Our game class simply needs to maintain a position vector containing the current
    world position of the object. We can move an in-game object around the world by
    adding a velocity vector that indicates how far the game object has moved in this
    frame and in what direction, with reference to the stored position vector.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏类只需要维护一个包含对象当前世界位置的位矢量的位置向量。我们可以通过添加一个速度向量来在游戏中移动对象，该向量指示游戏对象在本帧移动了多远以及朝哪个方向移动，相对于存储的位置向量。
- en: To generate the final model matrix all we need to do is copy the position vector
    into the translation part of the matrix. We normally do this as the last step,
    as the act of multiplying matrices together when generating the rotation and scale
    will affect the translation of the matrix.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成最终的模型矩阵，我们只需要将位置向量复制到矩阵的平移部分。我们通常在最后一步这样做，因为在生成旋转和缩放时乘以矩阵会影响矩阵的平移。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Animating by rotation
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过旋转进行动画
- en: The top left 3 x 3 section of the model matrix specifies the rotation at which
    we want the model to be drawn. Our game object stores the required rotation and
    updates it on a frame-by-frame basis. When it is time to render, we just use the
    stored rotation to calculate the rotation matrix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模型矩阵左上角的3x3部分指定了模型要绘制的旋转。我们的游戏对象存储所需的旋转并在每一帧更新它。当渲染时间到来时，我们只需使用存储的旋转来计算旋转矩阵。
- en: There are a number of ways in which the rotation of the object might be stored.
    Three of the most common ways are shown in the following section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对象旋转的方式有很多种。以下章节将展示三种最常见的方式。
- en: Rotation using Euler angles
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用欧拉角进行旋转
- en: '**Euler angles** consist of the required angle of rotation in the x, y, and
    z axes, which we would normally store using a vector. If rotation is not desired
    around every axis, you may choose to store only those rotation values that you
    require.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧拉角**由 x、y 和 z 轴上所需的旋转角度组成，我们通常使用向量来存储这些角度。如果不需要围绕每个轴旋转，你可以选择只存储所需的旋转值。'
- en: Euler angles are quite easy to both visualize and implement, which is why they
    are used so often. To convert a set of Euler angles into a rotation matrix, all
    we need to do is generate three matrices for the rotations around each of the
    axes and then multiply them together.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉角很容易可视化并实现，这也是为什么它们被广泛使用的原因。要将一组欧拉角转换为旋转矩阵，我们只需要为每个轴的旋转生成三个矩阵，然后将它们相乘。
- en: 'However, this is where the problem with Euler angles lies. Matrix multiplication
    yields different results depending on the order in which you multiply the matrices;
    so when using Euler angles, it is vital that you choose the order of multiplication
    carefully, depending on what you are trying to achieve. The following diagram
    shows an example to illustrate this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是欧拉角的问题所在。矩阵乘法的结果取决于矩阵乘法的顺序；因此，在使用欧拉角时，你必须仔细选择乘法顺序，这取决于你想要实现的目标。以下图表展示了如何说明这一点：
- en: '![Rotation using Euler angles](img/3363OT_05_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用欧拉角的旋转](img/3363OT_05_01.jpg)'
- en: In the diagram, we are rotating an arrow that points straight along the positive
    y axis. In the first row we rotate by 90 degrees around the z axis and then by
    90 degrees around the y axis. The arrow ends up pointing along the z axis.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，我们正在旋转一个指向正 y 轴的箭头。在第一行中，我们首先围绕 z 轴旋转 90 度，然后围绕 y 轴旋转 90 度。箭头最终指向 z 轴。
- en: In the second row of the diagram, we take the same original arrow but apply
    the rotations in the opposite order. As you can see, this time the arrow finishes
    in the direction of the x axis.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的第二行中，我们使用相同的原始箭头，但以相反的顺序应用旋转。正如你所看到的，这次箭头最终指向 x 轴的方向。
- en: 'The following code snippet shows how you can build up a complete rotation matrix
    for Euler angles applied in the order XYZ:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何构建用于应用 XYZ 顺序的欧拉角的完整旋转矩阵：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All angles used in Marmalade are specified in radians, not degrees.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 中使用的所有角度都是以弧度指定的，而不是度。
- en: Rotation using axis-angle pairs
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用轴角对进行旋转
- en: The **axis-angle** method of representing a rotation requires a direction vector
    and an angle of rotation to be stored. The vector represents the direction in
    which we want an object to be orientated, while the angle allows the object to
    be rotated around that axis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表示旋转的**轴角**方法需要存储方向向量和旋转角度。该向量表示我们希望对象朝向的方向，而角度允许对象绕该轴旋转。
- en: We might find this way of specifying a rotation useful when dealing with player
    characters. For example, to orient a human character we might specify the direction
    vector as being the positive y axis, which then allows the angle of rotation to
    be used to change the heading of the character.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理玩家角色时，我们可能会发现这种方式指定旋转很有用。例如，为了定位一个人类角色，我们可能会指定方向向量为正 y 轴，这样就可以使用旋转角度来改变角色的航向。
- en: 'Marmalade allows us to convert an axis-angle pair into a matrix for rendering,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 允许我们将轴角对转换为用于渲染的矩阵，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rotation using quaternions
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用四元数的旋转
- en: A **quaternion** is yet another method of representing three-dimensional rotations,
    and is a concept that, when you first come across it, seems a little mind-blowing.
    Instead of going on about four dimensional hyperspheres and making parts of your
    brain melt, I'm just going to provide a quick guide to what you need to know in
    order to use quaternions. If you want to learn more about them, I suggest you
    search for "quaternions" on Google!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**四元数**是表示三维旋转的另一种方法，当你第一次遇到它时，可能会觉得有点令人震惊。我不会继续谈论四维超球体和让你的大脑部分融化，我只会提供一个快速指南，告诉你如何使用四元数。如果你想了解更多，我建议你在
    Google 上搜索“四元数”!'
- en: 'A quaternion consists of four components: x, y, z, and w. A 3D rotation is
    represented as a **unit quaternion**, which, in a similar manner to vectors, just
    means that the magnitude of the sum of the squares of all four components is one.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数由四个分量组成：x、y、z 和 w。3D 旋转可以用**单位四元数**来表示，这与向量的表示方式类似，只是意味着所有四个分量的平方和的模长为 1。
- en: Multiplying two unit quaternions is similar to multiplying two rotation matrices
    together. The result represents the first orientation rotated by the second, and
    the result is different depending on the order in which you perform the multiplication.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单位四元数的乘法类似于两个旋转矩阵的乘法。结果表示第一个方向被第二个方向旋转，并且结果取决于你执行乘法的顺序。
- en: The big problem with quaternions is that they are almost impossible to visualize.
    If given a set of Euler angles or an axis-angle pair, most people can form an
    image in their mind of what that rotation would look like, but the same can't
    be said of quaternions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数的大问题是它们几乎无法可视化。如果给出一个欧拉角或轴角对，大多数人可以在脑海中形成一个关于该旋转外观的图像，但对于四元数来说则不然。
- en: 'Quaternions can however be created fairly easily from both a rotation matrix
    (and therefore Euler angles) and an axis-angle pair. The following diagram shows
    the relationship between the axis-angle pairs and quaternions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数可以从旋转矩阵（以及因此欧拉角）和轴角对中相当容易地创建。以下图表显示了轴角对与四元数之间的关系：
- en: '![Rotation using quaternions](img/3363OT_05_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用四元数进行旋转](img/3363OT_05_02.jpg)'
- en: Quaternions really come into their own for 3D animation of boned characters,
    a topic we will be coming to later in this chapter. This is a technique that requires
    an awful lot of rotations to be calculated every time you want to update the animation
    frame, and luckily quaternions make this far more efficient in terms of both memory
    usage and execution speed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数在骨骼角色3D动画中真正发挥其作用，这是我们将在本章后面讨论的主题。这是一种需要每次更新动画帧时计算大量旋转的技术，幸运的是，四元数在内存使用和执行速度方面都使这一过程更加高效。
- en: 'While the theory behind quaternions may be a little scary for us mere mortals,
    there is really little need to worry about the math, as Marmalade provides us
    with a quaternion class, `CIwFQuat`, that we can use. As an example, creating
    a quaternion from an axis-angle pair and then producing a rotation matrix from
    it can be done as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然四元数的理论对于我们这些凡人可能有点可怕，但实际上我们几乎没有必要担心数学问题，因为Marmalade为我们提供了一个四元数类，`CIwFQuat`，我们可以使用。例如，可以从轴角对创建四元数，然后从中生成旋转矩阵，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Animating by scaling
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过缩放动画
- en: The scaling factor is normally stored either as a vector containing the required
    size in the x, y, and z axes, or alternatively as a single scale value which is
    applied equally to each axis. Often the latter is sufficient, as models tend to
    look odd when they are not scaled uniformly in each axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放因子通常存储为包含x、y和z轴所需大小的向量，或者作为应用于每个轴的单个缩放值。通常后者就足够了，因为当模型在每个轴上不均匀缩放时，它们看起来会很奇怪。
- en: A scaling matrix is very simple to create, as all you have to do is place the
    scaling factors required for the x, y, and z axes in the diagonal going from the
    top left to the bottom right of the 3 x 3 rotation part of the matrix. All the
    other cells are left as zero.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放矩阵的创建非常简单，因为你只需将x、y和z轴所需的缩放因子放置在矩阵3x3旋转部分的从左上角到右下角的对角线上。所有其他单元格都保留为零。
- en: 'Since creating a scaling matrix is so simple, the `CIwFMat` class does not
    include any methods for creating a general scaling matrix. It does however provide
    some shortcut methods that make it easy to scale a matrix by the same scaling
    factor on each axis. The following code snippet provides an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建缩放矩阵非常简单，`CIwFMat`类不包含创建通用缩放矩阵的方法。然而，它确实提供了一些快捷方法，使得通过相同的缩放因子在每个轴上缩放矩阵变得容易。以下代码片段提供了一个示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will create a rotation matrix of 90 degrees around the x axis and
    then scale up just the rotation part of the matrix by a factor of two. You can
    also choose to scale up just the translation part of the matrix or both the rotation
    and translation by using the `ScaleTrans` and `Scale` methods respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将创建一个围绕x轴旋转90度的旋转矩阵，然后仅将矩阵的旋转部分按因子二放大。你也可以选择仅放大矩阵的平移部分，或者使用`ScaleTrans`和`Scale`方法分别放大旋转和平移。
- en: 3D model animation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D模型动画
- en: Model matrix animation is, of course, extremely important, as without it we
    would be unable to orient and move our 3D models in the game world; but on its
    own it doesn't make for the most exciting looking game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模型矩阵动画当然非常重要，因为没有它我们就无法在游戏世界中定位和移动我们的3D模型；但仅凭这一点并不能使游戏看起来最吸引人。
- en: Most games require more than this. For example, we might want a human or animal
    character to walk, run, jump, or perform some other type of motion. Ideally, we
    need a way of making the overall shape of our 3D model change over time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏需要更多。例如，我们可能希望一个人类或动物角色行走、奔跑、跳跃或执行其他类型的动作。理想情况下，我们需要一种方法使3D模型的整体形状随时间变化。
- en: The following sections explain how we can achieve this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将解释我们如何实现这一点。
- en: Using morph targets
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用形态目标
- en: A simple approach to 3D model animation is to use **morph targets** . For this
    we alter the vertex positions of our 3D model to yield **key frames** of the animation.
    A key frame is just a particular set of vertex positions for the model that are
    an important part of the overall animation, such as the various positions a character's
    legs move through as they walk. The key frame also has a time associated with
    it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型动画的一个简单方法是使用**形态目标**。为此，我们改变3D模型的顶点位置以生成动画的**关键帧**。关键帧只是模型的一组特定顶点位置，它是整体动画的重要组成部分，例如，角色行走时腿部移动的各种位置。关键帧还与时间相关联。
- en: The following diagram shows a very simple example of a stick man raising his
    arm. **Key Frame 1** at time index **0** seconds has the arm in a lowered position,
    while **Key Frame 2** at time index **2** seconds has it raised. Each of these
    key frames can be thought of as an individually exported 3D model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个非常简单的例子，一个木偶人举起手臂。**关键帧1**在时间索引**0**秒时手臂处于下垂位置，而**关键帧2**在时间索引**2**秒时手臂被举起。这些关键帧可以被视为独立导出的3D模型。
- en: '![Using morph targets](img/3363OT_05_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用形态目标](img/3363OT_05_03.jpg)'
- en: If we want to play back this animation, we could just draw the relevant 3D model
    at the correct time, but this would yield very jerky results akin to 2D bitmap
    animation. Instead, we can calculate an **Interpolated Frame** for any time index
    between **0** and **2** seconds to give a much smoother result.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要回放这个动画，我们可以在正确的时间绘制相关的3D模型，但这会产生非常生硬的结果，类似于2D位图动画。相反，我们可以在**0**到**2**秒之间的任何时间索引计算**插值帧**，以获得更平滑的结果。
- en: Calculating the interpolated frame is simple enough. We work out a **delta vector**
    from each vertex in the first key frame to the corresponding vertex in the second
    key frame. We then scale the delta vector by the ratio of the time index we want
    to calculate for, divided by the total time between the two key frames, and add
    the scaled result on to the position of the vertex in the first key frame.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算插值帧的过程足够简单。我们从第一个关键帧中的每个顶点计算出与第二个关键帧中相应顶点的**delta向量**。然后，我们将delta向量按我们想要计算的索引时间与两个关键帧之间总时间的比例进行缩放，并将缩放后的结果加到第一个关键帧中顶点的位置上。
- en: In the diagram, we want to calculate an interpolated frame at time index **1**
    second, so we would scale the delta vectors by a factor of half. The end result
    will be the frame shown where the arm is half raised.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们想要计算时间索引**1**秒的插值帧，因此我们将delta向量按一半的比例缩放。最终结果将是手臂半举起时的帧。
- en: 'This approach may be easy to implement, but ultimately we find that there are
    a few problems with it, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能易于实现，但最终我们发现它存在一些问题，如下所述：
- en: 'Accuracy of resultant animation: Take a good look at the interpolated frame
    of the stick man in the previous diagram and you will see that the stick man''s
    arm has actually shrunk. This is because we are interpolating the vertex positions
    in a straight line, whereas we really need the end vertices to be rotated around
    the shoulder point.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果动画的准确性：仔细观察前图中木偶人的插值帧，你会发现木偶人的手臂实际上变短了。这是因为我们正在以直线方式插值顶点位置，而实际上我们需要末端顶点围绕肩部点旋转。
- en: 'Number of key frames required: In order to produce a good quality animation
    we need to store a good number of key frames. In the example of our stick man
    animation, we could provide additional key frames that would then minimize the
    arm shortening effect. However, since we need to store the position of every vertex
    in the model, whether it has moved or not, this soon becomes a large amount of
    data.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的关键帧数量：为了制作高质量的动画，我们需要存储大量关键帧。在我们的木偶人动画示例中，我们可以提供额外的关键帧，从而最小化手臂缩短效果。然而，由于我们需要存储模型中每个顶点的位置，无论其是否移动，这很快就会变成大量数据。
- en: 'The need to ensure that the vertex order does not change between key frames:
    The only way we can reliably implement morph target animation is if every vertex
    in the model is in the same position in the vertex stream for every key frame.
    When exporting a 3D model from a modeling package, the vertex stream order can
    end up changing between frames, which would then cause our animation to behave
    incorrectly as vertices interpolate between completely wrong positions.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保顶点顺序在关键帧之间不发生变化的必要性：我们能够可靠地实现形变目标动画的唯一方法是在每个关键帧中，模型中的每个顶点在顶点流中都处于相同的位置。当从建模软件导出3D模型时，顶点流顺序可能会在帧之间发生变化，这会导致我们的动画在顶点在完全错误的位置之间插值时表现不正确。
- en: For the reasons listed, Marmalade does not support morph target animations,
    though it is fairly trivial to implement such an approach if you so wish. Morph
    targets can still be extremely useful for tasks such as facial animation, which,
    with the increasing power of mobile devices, may soon be a more common feature
    in mobile games.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述原因，Marmalade不支持形变目标动画，尽管如果你愿意，实现这种方法相当简单。形变目标对于面部动画等任务仍然非常有用，随着移动设备性能的不断提高，这可能会很快成为移动游戏中的更常见功能。
- en: Using boned animations
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用骨骼动画
- en: Most 3D video games will implement the animation of 3D models using a boned
    animation system. This method works by allowing an animator to set up a skeleton
    of virtual bones, which can then be used to deform the vertices of a 3D model.
    The 3D model itself often gets referred to as the **skin** for purposes of animation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数3D视频游戏都会使用骨骼动画系统来实现3D模型的动画。这种方法通过允许动画师设置虚拟骨骼的骨骼结构，然后可以使用这些骨骼来变形3D模型的顶点。3D模型本身通常被称为动画的**皮肤**。
- en: To set up a boned animation, the first step is to use a 3D modeling package
    to create the 3D model you want to animate in its **bind pose**. The bind pose
    is normally chosen to be a position in which it is easy to access every polygon
    in the model for texturing and coloring purposes, as well as for laying out the
    skeleton. For a human character this often means a pose where the arms are held
    outstretched horizontally from the body and the feet are spaced a short distance
    apart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置骨骼动画，第一步是使用3D建模软件创建你想要动画化的3D模型，并使其处于**绑定姿态**。绑定姿态通常选择为便于访问模型中每个多边形进行纹理和着色，以及布置骨骼的位置。对于人类角色来说，这通常意味着手臂从身体水平伸展出去的姿态，脚部相隔一段短距离。
- en: With the bind pose created, the animator then starts the **rigging** process.
    This involves adding the skeleton to the model by placing bones in relevant places.
    The bones are linked together to form a **hierarchy**; so whenever a bone is moved,
    all the bones which are linked to it as children will move too. Ultimately there
    will be one top-level parent bone in the hierarchy and this is called the **root
    bone**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建绑定姿态后，动画师开始进行**绑定**过程。这涉及到通过放置骨骼将骨骼添加到模型中。骨骼被链接在一起形成**层次结构**；因此，每当移动一个骨骼时，所有与其链接的子骨骼也会移动。最终，在层次结构中会有一个顶级父骨骼，这被称为**根骨骼**。
- en: 'For performance reasons it is good to keep the number of bones to a minimum,
    but this must be balanced against having enough to allow good quality animation.
    The following diagram shows what the 3D skier character used in our example game
    project looks like after being rigged:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能考虑，最好将骨骼数量保持在最小，但这也必须与保证足够数量以实现高质量动画的需求相平衡。以下图表显示了在我们示例游戏项目中使用的3D滑雪角色在被绑定后的样子：
- en: '![Using boned animations](img/3363_05_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用骨骼动画](img/3363_05_04.jpg)'
- en: Once the bones have been laid out, the next step is to bind the skin (in other
    words, the mesh of polygons) to the skeleton. This is done by allowing each vertex
    of the 3D model to be modified by one or more bones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼布局完成后，下一步是将皮肤（换句话说，多边形的网格）绑定到骨骼上。这是通过允许3D模型的每个顶点被一个或多个骨骼修改来实现的。
- en: If a vertex is mapped to more than one bone, a weight is also defined for each
    bone that determines how much of an effect it will have on the vertex. Weights
    range from zero to one and the sum of all the weights for a particular vertex
    should add up to one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个顶点映射到多个骨骼，也会为每个骨骼定义一个权重，以确定它对顶点的影响程度。权重范围从零到一，特定顶点的所有权重的总和应该等于一。
- en: Most 3D modeling packages will have a good first attempt at doing the binding
    process automatically, but normally the animator will need to make some adjustments
    to the binding so that the skin animates correctly when the bones of the skeleton
    are moved.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 3D 建模软件都会在自动执行绑定过程时有一个良好的尝试，但通常动画师需要对绑定进行一些调整，以确保当骨骼移动时，皮肤能够正确地动画化。
- en: With all that done, the animator can then make the character do whatever they
    want simply by rotating and moving the bones around to define the required key
    frame positions, just like with morph targets. The boned system will produce much
    better quality in the final animation, and the amount of memory required to store
    the key frames is normally not too large, since all that needs to be stored is
    the orientation and position of each bone.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，动画师就可以通过旋转和移动骨骼来定义所需的关键帧位置，从而让角色做他们想做的任何事情，就像使用变形目标一样。骨骼系统将产生最终动画的更好质量，并且存储关键帧所需的内存量通常不会太大，因为需要存储的只是每个骨骼的朝向和位置。
- en: The Marmalade SDK comes complete with a boned animation system, which we will
    be learning about in the rest of this chapter. The system is very flexible and
    there are very few limitations to it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK 配备了一个骨骼动画系统，我们将在本章的剩余部分学习它。该系统非常灵活，几乎没有限制。
- en: The main things to be aware of are that you can only have a single root bone,
    a maximum of 256 bones in total, and each vertex can only be affected by a maximum
    of four bones. In most cases these limitations are unlikely to cause you any problems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要事项是，你只能有一个根骨骼，总共最多 256 个骨骼，并且每个顶点最多只能受到四个骨骼的影响。在大多数情况下，这些限制不太可能给你带来任何问题。
- en: Using a 3D modeling package to create animation data
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 3D 建模软件创建动画数据
- en: Entire books have been written explaining how best to create a 3D animated character;
    so, unsurprisingly, we won't be looking at how to actually produce an animated
    3D model here. Indeed, my warning in the previous chapter about "programmer art"
    probably goes double for "programmer animation". For evidence to back this statement
    up, look no further than the graphics accompanying the example programs of this
    book, which are all examples of "programmer art" made by yours truly. I really
    should heed my own advice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有整本书籍专门讲解如何最好地创建 3D 动画角色；因此，不出所料，我们在这里不会探讨如何实际制作动画 3D 模型。实际上，我在上一章关于“程序员艺术”的警告可能对“程序员动画”来说加倍适用。为了支持这个说法，请看看本书示例程序中的图形，这些都是我亲自制作的“程序员艺术”的例子。我真的应该听从自己的建议。
- en: Anyway, with that tip hopefully now rammed home, let's see how we can export
    animation data from a 3D modeling package.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，希望这个提示现在已经深入人心，让我们看看如何从 3D 建模软件中导出动画数据。
- en: Exporting an animation requires a number of new file types to be exported. These
    will be discussed in detail later, but in short they are files that represent
    the skeleton, the skin, and the actual animations themselves. The following sections
    will show how to export this data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 导出动画需要导出多种新文件类型。这些将在稍后详细讨论，但简而言之，它们是代表骨骼、皮肤以及实际动画本身的文件。以下各节将展示如何导出这些数据。
- en: Exporting animations using the Marmalade 3D exporter plugins
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Marmalade 3D 导出插件导出动画
- en: 'If you are using 3DS Max or Maya to create your animations, the required animation
    files are exported using the Marmalade exporter plugin. To refresh your memory,
    the exporter plugin window is shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 3DS Max 或 Maya 来创建你的动画，所需的动画文件将通过 Marmalade 导出插件导出。为了刷新你的记忆，以下截图显示了导出插件窗口：
- en: '![Exporting animations using the Marmalade 3D exporter plugins](img/3363_05_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Marmalade 3D 导出插件导出动画](img/3363_05_05.jpg)'
- en: 'To export an animation, just load it into your modeling package and follow
    these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出动画，只需将其加载到你的建模软件中，并按照以下步骤操作：
- en: Set up the export options in the same way as we did for exporting a static model.
    Please look at the steps listed in [Chapter 4](ch04.html "Chapter 4. 3D Graphics
    Rendering"), *3D Graphics Rendering*, if you've forgotten what the various options
    are for. We'll now take a look at the additional animation-specific options.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置导出选项的方式与导出静态模型时相同。如果你忘记了各种选项是什么，请查看[第 4 章](ch04.html "第 4 章。3D 图形渲染")中的步骤列表，“3D
    图形渲染”。现在，我们将查看额外的动画特定选项。
- en: Ensure that just the **geometry**, **skeleton**, and **exportgroup** checkboxes
    are ticked in the group labeled **Enable export of**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在标记为**启用导出**的组中仅勾选**几何**、**骨骼**和**exportgroup**复选框。
- en: You can now click on the **Export!** button to write out the GEO, MTL, and GROUP
    files for the model. Two new file types will also be exported, the SKEL and SKIN
    files, which as you can probably guess represent the skeleton and skin information
    for the model.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以点击**导出！**按钮以写入模型的GEO、MTL和GROUP文件。还将导出两种新文件类型，即SKEL和SKIN文件，正如您可能猜到的，它们代表模型的骨骼和皮肤信息。
- en: 'The files exported in these steps are necessary in order to animate the model,
    but they don''t actually contain any animation data as such. Here''s how we get
    hold of the data that will describe how the model is actually animated:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中导出的文件对于动画模型是必要的，但它们实际上并不包含任何动画数据。以下是获取描述模型实际动画方式的数据的方法：
- en: Go back to the exporter plugin window and click on the button to the right of
    the **Export Type** combobox. A pop-up menu should appear from which you should
    select the **anim** option.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回导出插件窗口，并点击**导出类型**组合框右侧的按钮。应该出现一个弹出菜单，您应从中选择**anim**选项。
- en: The checkboxes in the **Enable export of** section should change so that only
    the **animation** checkbox is ticked.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用导出**部分中的复选框应更改，以便仅勾选**动画**复选框。'
- en: In the **Export Flags** section, the **multianim** checkbox can be selected
    if you have several animations in the scene to export. Note that each animation
    should be for the same 3D model.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导出标志**部分，如果您场景中有多个动画要导出，可以选择**multianim**复选框。请注意，每个动画应为相同的3D模型。
- en: The **Anim Range Type** option can take one of three possible values. The default
    is **Visible Range**, which will export only the range of frames that are currently
    visible on the animation track bar in the modeling package. The next option is
    **Individual Anim Range**, which will only export animation data between the first
    and last key frame of each animation. The final option, **Full Range**, is only
    available in Maya. It will export the entire animation regardless of whether a
    range of frames has been set on the animation track bar or not.![Exporting animations
    using the Marmalade 3D exporter plugins](img/3363_05_06.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画范围类型**选项可以取三个可能值之一。默认值为**可见范围**，它将仅导出在建模包中动画轨道栏上当前可见的帧的范围。下一个选项是**单个动画范围**，它将仅导出每个动画的第一个和最后一个关键帧之间的动画数据。最后一个选项**完整范围**仅在Maya中可用。它将导出整个动画，无论是否在动画轨道栏上设置了帧范围。'
- en: The **Anims Ranges** option allows you to split one big animation sequence up
    into several smaller animations. If you click on the **Edit…** button, the dialog
    box just seen will be displayed. Use the **Add** button to create a new animation
    range, use the **Name** textbox to name the animation, and then drag the sliders
    to set the **Start** and **End** frames for the animation. Use the **Delete**
    button to delete an animation range from the list. The **Done** button will close
    the dialog and accept any changes made, while the **Cancel** button will discard
    any changes made before closing the dialog.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画范围**选项允许您将一个大的动画序列拆分成几个较小的动画。如果您点击**编辑…**按钮，将显示刚刚看到的对话框。使用**添加**按钮创建一个新的动画范围，使用**名称**文本框命名动画，然后拖动滑块设置动画的**开始**和**结束**帧。使用**删除**按钮从列表中删除一个动画范围。**完成**按钮将关闭对话框并接受所做的任何更改，而**取消**按钮将在关闭对话框之前丢弃所做的任何更改。'
- en: The final option that affects animation export is the **Sub Anim Root** textbox.
    You can enter the name of one of the bones in the skeleton and the animation data
    will only be exported for that bone and its children. We'll learn more about sub-animations
    later in this chapter.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 影响动画导出的最后一个选项是**子动画根**文本框。您可以输入骨骼中一个骨骼的名称，并且动画数据将仅为此骨骼及其子项导出。我们将在本章后面了解更多关于子动画的内容。
- en: With all the animation-related options in the exporter now set up, just click
    on the **Export!** button to output one or more ANIM files. The number of files
    exported depends on how many animations were in the scene, the status of the **multianim**
    checkbox, and whether the **Anims Ranges** option was used.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出插件中设置好所有与动画相关的选项后，只需点击**导出！**按钮即可输出一个或多个ANIM文件。导出的文件数量取决于场景中动画的数量、**multianim**复选框的状态以及是否使用了**动画范围**选项。
- en: Exporting animations using the Blender plugin
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blender插件导出动画
- en: You can also export animations using the Blender plugin. The terminology used
    in Blender for animations is a little unusual, as Blender calls the skeleton an
    **armature**, but aside from that the approach to animation is the same.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Blender插件导出动画。Blender中用于动画的术语有些不寻常，因为Blender将骨骼称为**骨架**，但除此之外，动画的方法是相同的。
- en: '![Exporting animations using the Blender plugin](img/3363_05_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender插件导出动画](img/3363_05_07.jpg)'
- en: 'Here are the steps you should follow to export an animated model from Blender:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您应遵循的步骤以从Blender导出动画模型：
- en: Load the animation you wish to export into Blender and then go to **File** |
    **Export** | **Marmalade Cross-platform Apps (.group)** to display the export
    options screen. As a reminder, the export options are shown in the previous screenshot,
    but please refer to the steps listed in [Chapter 4](ch04.html "Chapter 4. 3D Graphics
    Rendering"), *3D Graphics Rendering*, for more information about the standard
    model export settings.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您希望导出的动画加载到Blender中，然后转到**文件** | **导出** | **Marmalade跨平台应用程序 (.group**)以显示导出选项屏幕。提醒一下，导出选项在之前的屏幕截图中已显示，但请参考[第4章](ch04.html
    "第4章。3D图形渲染")中列出的步骤，*3D图形渲染*，以获取有关标准模型导出设置的更多信息。
- en: To tell the exporter to write out all the different animation file types, ensure
    that the **Export Armatures** checkbox is selected.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要告诉导出器写入所有不同的动画文件类型，请确保选中**导出骨架**复选框。
- en: The **Animations Frames** combobox contains three options. **None** will export
    no animation data, **Keyframes Only** will export just the data for the key frames
    of the animation (this is the option you would normally want to select), and **Full
    Animation** will export data for every frame regardless of whether it is a key
    frame or not (this is often referred to as "baking" the animation and means you
    get the exact animation seen in the modeling package at the expense of an increase
    in animation memory footprint).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画帧**组合框包含三个选项。**无**将不导出任何动画数据，**仅关键帧**将仅导出动画的关键帧数据（这是您通常会选择的选项），而**完整动画**将导出每帧的数据，无论它是否是关键帧（这通常被称为“烘焙”动画，意味着您将获得建模软件包中看到的精确动画，但代价是动画内存占用增加）。'
- en: The **Animations Actions** combobox contains two settings. **Default Animation**
    will export only the animation that has been selected as the default for the armature.
    The other option is **All Animations**, which will export all the animations currently
    defined for the armature.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动画动作**组合框包含两个设置。**默认动画**将仅导出已选为骨架默认值的动画。另一个选项是**所有动画**，这将导出为骨架定义的所有动画。'
- en: The final setting is the **Animation FPS** value. This dictates the playback
    speed in frames per second for the animation, so it is possible to speed up or
    slow down an animation by changing this value without the need to alter all the
    key frame timings.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的设置是**动画帧率**值。这决定了动画每秒的播放速度，因此可以通过更改此值来加快或减慢动画的播放速度，而无需更改所有关键帧的时间。
- en: To export the data, ensure that you have a file location and name entered in
    the boxes at the top of the screen and then click on the **Export Marmalade**
    button.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导出数据，请确保您已在屏幕顶部的框中输入了文件位置和名称，然后单击**导出Marmalade**按钮。
- en: The Marmalade 3D animation file formats
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade 3D动画文件格式
- en: We can now export the animation data from the 3D modeling package of our choice,
    but before we actually make use of them, let's take a quick look at the new file
    types that we've just generated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从我们选择的3D建模软件包中导出动画数据，但在我们实际使用它们之前，让我们快速查看我们刚刚生成的新文件类型。
- en: The SKEL file
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SKEL文件
- en: A **SKEL file** contains all the information pertaining to the skeleton of our
    animation. The file first defines an instance of a `CIwAnimSkel` class, which
    is a wrapper for a number of `CIwAnimBone` instances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**SKEL文件**包含有关我们动画骨骼的所有信息。文件首先定义了一个`CIwAnimSkel`类的实例，这是一个多个`CIwAnimBone`实例的包装器。'
- en: The `CIwAnimSkel` instance is derived from the `CIwResource` class and therefore
    has a name associated with it so that it can be looked up in the resource manager.
    The name of the instance is taken from the filename of a SKEL file, which in turn
    comes from the name of the root bone of the skeleton.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwAnimSkel`实例是从`CIwResource`类派生出来的，因此它有一个与之关联的名称，以便可以在资源管理器中查找。实例的名称取自SKEL文件的文件名，而SKEL文件的名称又来自骨骼的根骨骼名称。'
- en: Each of the `CIwAnimBone` instances have a name, position, and rotation associated
    with it, which defines the bind pose of the animation. The position is just a
    vector in model space, while the rotation is stored as a quaternion. Except for
    the first bone, which is the root bone, each bone will also list its parent bone,
    thus building up the skeletal hierarchy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`CIwAnimBone`实例都有一个与之关联的名称、位置和旋转，这定义了动画的绑定姿势。位置只是一个模型空间中的向量，而旋转则以四元数的形式存储。除了根骨骼之外，每个骨骼还会列出其父骨骼，从而构建骨骼层次结构。
- en: 'The SKEL file gets exported into the `models` sub-directory alongside the GEO
    and MTL files. An example of a SKEL file is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SKEL文件与GEO和MTL文件一起导出到`models`子目录中。以下是一个SKEL文件的示例：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The SKIN file
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SKIN文件
- en: The **SKIN file** is the bridge between the skeleton and the vertices of the
    3D model in its bind pose. It contains all the data representing which vertices
    are influenced by which bones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**SKIN文件**是骨骼和3D模型绑定姿势中顶点之间的桥梁。它包含所有表示哪些顶点受哪些骨骼影响的数据。'
- en: The file starts by defining an instance of the `CIwAnimSkin` class. This instance
    contains references to the `CIwAnimSkel` instance that defines the bones of the
    required skeleton, and also the `CIwModel` instance that will be used for rendering
    the model once the new vertex positions have been calculated. As with the SKEL
    file, the name given to the `CIwAnimSkin` instance is derived from the filename
    of the SKIN file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件首先定义了`CIwAnimSkin`类的一个实例。此实例包含对定义所需骨骼的`CIwAnimSkel`实例的引用，以及用于在计算新顶点位置后渲染模型的`CIwModel`实例。与SKEL文件一样，`CIwAnimSkin`实例的名称是从SKIN文件的文件名派生的。
- en: The file then contains a number of instances of the `CIwAnimSkinSet` class,
    which indicates which vertices are modified by which bones. This is achieved by
    first listing the bones, up to a maximum of four, then the number of vertices
    in the set. The bone weights are then specified for each vertex by providing the
    index of the vertex in the model vertex stream, followed by a weight value for
    each bone. The sum of the weight values for each vertex must total to one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文件随后包含多个`CIwAnimSkinSet`类的实例，这表明哪些顶点被哪些骨骼修改。这是通过首先列出骨骼（最多四个），然后列出集合中的顶点数量来实现的。然后，通过提供模型顶点流中顶点的索引，随后为每个骨骼提供一个权重值，为每个顶点指定骨骼权重。每个顶点的权重值之和必须总计为1。
- en: The SKIN file is also exported to the `models` subdirectory and the following
    code provides a partial example of one. These files tend to be quite large due
    to the sheer amount of data required for even a simple animation, so an extract
    should provide enough of a flavor of what these files look like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SKIN文件也导出到`models`子目录，以下代码提供了一个部分示例。这些文件由于需要大量数据，即使是简单的动画也会相当大，因此提取应该足以提供这些文件的外观。
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The ANIM file
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ANIM文件
- en: The final file type we need to consider is the **ANIM file**, which as its name
    suggests is the file that actually defines a particular animation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一个文件类型是**ANIM文件**，正如其名称所暗示的，这是定义特定动画的实际文件。
- en: The file first declares an instance of the `CIwAnim` class, which, as with the
    other animation class types, will be given a resource name derived from the filename.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 文件首先声明了`CIwAnim`类的一个实例，与其他动画类类型一样，将给出一个从文件名派生的资源名称。
- en: The skeleton that this animation will be applied to is the first thing that
    the `CIwAnim` instance will specify. This is then followed by a number of `CIwAnimKeyFrame`
    declarations that detail the positions and orientations of each affected bone
    at a particular time index.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画将要应用到的骨骼是`CIwAnim`实例首先指定的内容。然后是多个`CIwAnimKeyFrame`声明，详细说明了在特定时间索引下每个受影响骨骼的位置和方向。
- en: Key frames do not need to list the orientation and position of each bone in
    the skeleton. If a bone has not moved relative to its parent, its position will
    remain as it was at the previous key frame.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧不需要列出骨骼中每个骨骼的朝向和位置。如果一个骨骼相对于其父骨骼没有移动，其位置将保持与上一个关键帧相同。
- en: 'The exporters will create an `anims` sub-directory to hold all the ANIM files.
    An example of an ANIM file is provided in the following code; but as with the
    SKIN file, this is just a partial example so as to not fill the pages of this
    book with lots of numbers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器将创建一个`anims`子目录来保存所有ANIM文件。以下代码提供了一个ANIM文件的示例；但与SKIN文件一样，这只是一个部分示例，以免使这本书的页面充满大量数字：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Loading and rendering an exported 3D animation
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和渲染导出的3D动画
- en: We're now in a position to start rendering a 3D animation, and as with rendering
    a static 3D model it's also surprisingly easy to do.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始渲染3D动画了，就像渲染静态3D模型一样，这出奇地简单。
- en: Adding the IwAnim API to a project
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将IwAnim API添加到项目中
- en: Before we can use Marmalade's animation functionality, we first need to add
    the IwAnim API to our project. This API builds on top of the IwGraphics API required
    for rendering static 3D models.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用Marmalade的动画功能之前，我们首先需要将IwAnim API添加到我们的项目中。这个API建立在渲染静态3D模型所需的IwGraphics
    API之上。
- en: As with all such Marmalade APIs, we add support for IwAnim to a project by listing
    `iwanim` in the `subprojects` section of the MKB file. We must then call `IwAnimInit`
    after `IwGraphicsInit` has been called, and at shutdown time we need to call `IwAnimTerminate`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有此类Marmalade API一样，我们通过在MKB文件的`subprojects`部分列出`iwanim`来为一个项目添加对IwAnim的支持。然后我们必须在调用`IwGraphicsInit`之后调用`IwAnimInit`，在关闭时需要调用`IwAnimTerminate`。
- en: Loading and accessing a 3D animation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和访问3D动画
- en: The GROUP file format comes to our rescue once again in order to get animation
    data loaded into memory. The export process will have created a GROUP file for
    us already that will include the GEO, MTL, SKEL, and SKIN files, so we just need
    to add entries for the ANIM files that we want to use.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GROUP文件格式再次帮助我们，以便将动画数据加载到内存中。导出过程已经为我们创建了一个包含GEO、MTL、SKEL和SKIN文件的GROUP文件，因此我们只需为我们要使用的ANIM文件添加条目。
- en: With everything referenced in the GROUP file, we just need to load it into memory
    using the resource manager, and then access the resources in the same way as we
    do for any other resource.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在GROUP文件中引用所有内容后，我们只需使用资源管理器将其加载到内存中，然后以与我们处理任何其他资源相同的方式访问资源。
- en: 'The following code snippet illustrates how we might load a GROUP file and then
    access the resources needed for rendering an animated 3D model:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了我们如何加载GROUP文件，然后访问渲染动画3D模型所需的资源：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Right, now that we have the resources in memory, we need to do something with
    them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经将资源加载到内存中，我们需要对它们做些什么。
- en: Playing back a 3D animation
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放3D动画
- en: In order to play back an animation, we need to let Marmalade know which animation
    we want to play, how fast it should be played back, and whether we want it to
    be a one shot or looping animation. All this and more is provided by the `CIwAnimPlayer`
    class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了播放动画，我们需要让Marmalade知道我们想要播放哪个动画，播放速度应该是多少，以及我们是否想要它是一次性播放还是循环播放。所有这些以及更多都是由`CIwAnimPlayer`类提供的。
- en: 'After creating a new instance of `CIwAnimPlayer`, we must provide it with a
    pointer to the skeleton instance for animation. This is done as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`CIwAnimPlayer`的新实例后，我们必须提供动画所需的骨骼实例的指针。这如下所示：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The player object is now ready to start animating, so we just need to pass
    it details about the animation we want to play. This can be done with just a single
    line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家对象现在已准备好开始动画，所以我们只需传递我们想要播放的动画的详细信息。这只需一行代码即可完成：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `PlayAnim` method first takes a pointer to the `CIwAnim` instance we wish
    to play. It then expects to see a playback speed, some control flags, and a blending
    interval.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayAnim`方法首先接受我们想要播放的`CIwAnim`实例的指针。然后它期望看到播放速度、一些控制标志和一个混合间隔。'
- en: The playback speed is specified so that a value of `1` yields the normal exported
    animation speed. Doubling this value will play the animation back at twice the
    speed, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 播放速度被指定，使得值为`1`产生正常导出的动画速度。将此值加倍将使动画以两倍速度播放，依此类推。
- en: The function's third parameter is a set of control flags that are primarily
    used to indicate whether the animation should loop when it reaches the last key
    frame. If looping is desired, the flag `CIwAnimBlendSource::LOOPING_F` should
    be used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第三个参数是一组控制标志，主要用于指示动画在达到最后一个关键帧时是否应该循环。如果需要循环，应使用标志`CIwAnimBlendSource::LOOPING_F`。
- en: There are a number of other values defined by `CIwAnimBlendSource`, but most
    of these are intended for read-only status flags and the `CIwAnimPlayer` class
    provides other methods that should be used to determine the current status. Therefore,
    the only other flag that will be used in this method is `CIwAnimBlendSource::RESET_IF_SAME_F`,
    which will force the animation player to restart the specified animation if it
    is already the current animation. If an animation that is already being played
    is passed in to the `PlayAnim` method, the request will be ignored unless this
    flag is used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwAnimBlendSource`定义了多个其他值，但其中大部分是用于只读状态标志的，`CIwAnimPlayer`类提供了其他方法，应该用来确定当前状态。因此，在这个方法中唯一将使用的其他标志是`CIwAnimBlendSource::RESET_IF_SAME_F`，这将强制动画播放器重新启动指定的动画，如果它已经是当前动画。如果将正在播放的动画传递给`PlayAnim`方法，除非使用此标志，否则请求将被忽略。'
- en: 'The animation player is now initialized, so the final thing that must be done
    is instruct it to calculate the required animation frame. This is done by calling
    the `Update` method of the `CIwAnimPlayer` instance on every iteration of the
    main game loop, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 动画播放器现在已初始化，所以最后必须做的事情是指示它计算所需的动画帧。这是通过在主游戏循环的每次迭代中调用`CIwAnimPlayer`实例的`Update`方法来完成的，如下代码所示：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `lTimeStep` parameter is a `float` value indicating the amount of time (in
    seconds) by which the current animation state should be advanced. When this call
    completes, a copy of the skeleton will have been created with all the bones positioned
    and rotated correctly in order to render the current frame of animation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`lTimeStep`参数是一个`float`类型的值，表示当前动画状态应该前进的时间量（以秒为单位）。当这个调用完成后，将创建一个骨骼副本，所有骨骼都将正确定位和旋转，以便渲染当前动画帧。'
- en: Rendering a 3D animation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染3D动画
- en: 'With the animation player now merrily updating away, the final step is to render
    the animated model. This is possibly the easiest part of the entire process, as
    the following code demonstrates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着动画播放器现在愉快地更新，最后一步是将动画模型渲染出来。这可能整个过程中最简单的一部分，如下代码所示：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hopefully most of this already looks familiar to you. The first step is to set
    the view and model matrices we want to use for rendering. We then need to provide
    some information about the frame of animation, namely the animated skeleton and
    the skin data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 希望其中大部分对你来说已经很熟悉了。第一步是设置我们想要用于渲染的视图和模型矩阵。然后我们需要提供一些关于动画帧的信息，即动画骨骼和皮肤数据。
- en: The skeleton information is maintained by the `CIwAnimPlayer` instance and can
    be retrieved using the `GetSkel` method. The skin is just the `CIwAnimSkin` instance
    as loaded by the resource manager. We use the `IwAnimSetSkelContext` and `IwAnimSetSkinContext`
    functions to provide this data to the rendering engine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼信息由`CIwAnimPlayer`实例维护，可以使用`GetSkel`方法检索。皮肤只是由资源管理器加载的`CIwAnimSkin`实例。我们使用`IwAnimSetSkelContext`和`IwAnimSetSkinContext`函数将此数据提供给渲染引擎。
- en: To render the animated model to the screen, all we have to do is call the `Render`
    method on `lpFlag`, which is a pointer to a `CIwModel` instance, just as we would
    if we were rendering the model without any animation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将动画模型渲染到屏幕上，我们只需在`lpFlag`上调用`Render`方法，`lpFlag`是一个指向`CIwModel`实例的指针，就像我们渲染没有动画的模型一样。
- en: After rendering, we clear the skin and skeleton contexts so that future model
    rendering calls won't try and use incorrect data during rendering. This is a good
    habit to get into as determining why an unanimated model has suddenly started
    deforming wildly could be a tricky bug to track down.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染完成后，我们清除皮肤和骨骼上下文，这样未来的模型渲染调用就不会在渲染过程中尝试使用错误的数据。养成这个习惯是好的，因为确定一个未动画模型突然开始剧烈变形的原因可能是一个棘手的错误，难以追踪。
- en: Exploring 3D animation further
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索3D动画
- en: Congratulations! You're now able to render fully animated 3D models! While this
    is a pretty cool achievement, the functionality we've seen so far has only scratched
    the surface of what the IwAnim API allows us to do. The following sections describe
    some of the other features that we have at our disposal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在能够渲染全动画的3D模型了！虽然这是一个相当酷的成就，但我们迄今为止看到的功能只是IwAnim API允许我们做的表面功夫。以下章节描述了一些我们可用的其他功能。
- en: Playing an animation backwards
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向播放动画
- en: There are some occasions when it is useful to be able to play an animation backwards.
    As an example, imagine a character kneeling down to examine an object. Rather
    than create a whole new animation to enable them to stand up again, we could just
    play the kneeling animation backwards instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候能够播放动画倒放是有用的。例如，想象一个角色跪下来检查一个物体。而不是创建一个全新的动画来让他们再次站起来，我们只需播放跪下的动画倒放即可。
- en: Playing an animation backwards is achieved simply by passing a negative animation
    speed into the call to `PlayAnim`, so a value of `-1` will play the animation
    backwards at normal speed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将负动画速度传递给`PlayAnim`调用，可以简单地实现动画倒放，因此`-1`的值将以正常速度倒放动画。
- en: Blending between animations
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画之间的混合
- en: When transitioning between two animations, we often don't want to just snap
    straight to the beginning of the new sequence, as this can result in a noticeable
    jump between the current frame of animation and the first frame of the new animation.
    We can solve this problem by blending between animations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个动画之间转换时，我们通常不希望直接跳转到新序列的开始，因为这可能导致当前动画帧和新动画第一帧之间出现明显的跳跃。我们可以通过在动画之间混合来解决这个问题。
- en: We touched on how to achieve this earlier, when we first introduced the `PlayAnim`
    method. The final parameter in this method is the blending time, which is specified
    as a value in seconds using a floating point number.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在首次介绍`PlayAnim`方法时提到了如何实现这一点。此方法中的最后一个参数是混合时间，它以秒为单位使用浮点数指定。
- en: By specifying a non-zero blending interval, the animation player will calculate
    the frames of animation required for both the old and new animations, then generate
    a third transition frame by interpolating between these two frames over the specified
    time. The transition frame is what is then used to draw the 3D model. Once the
    blend interval is over, the original animation will stop being calculated as it
    is no longer required.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定非零混合间隔，动画播放器将计算旧动画和新动画所需的动画帧，然后在指定的时间内通过在这两个帧之间插值来生成第三个过渡帧。过渡帧是随后用于绘制3D模型的帧。一旦混合间隔结束，原始动画将停止计算，因为它不再需要。
- en: Detecting animation playback events
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测动画播放事件
- en: Being able to detect when an animation has looped or has finished playing is
    important because we can start to link animations together or prevent the user
    from performing a task until an animation has completed. For instance, imagine
    a player has to reload a weapon and an animation is played to show this happening.
    We need to know when the animation has completed so we can allow the player to
    start attacking again.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检测动画是否循环或播放完成非常重要，因为我们可以开始将动画链接在一起或防止用户在动画完成之前执行任务。例如，想象一个玩家需要重新装填武器，并播放一个动画来展示这个过程。我们需要知道动画何时完成，以便允许玩家再次开始攻击。
- en: The `CIwAnimPlayer` class allows us to detect when a one shot animation has
    completed, by calling the `IsCurrentAnimComplete` method that will return `true`
    when the animation has finished.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwAnimPlayer`类允许我们通过调用`IsCurrentAnimComplete`方法来检测一次性动画是否完成，当动画播放完毕时，该方法将返回`true`。'
- en: There is also the `IsCurrentBlendComplete` method that will return `true` when
    the animation player has finished blending between two animations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`IsCurrentBlendComplete`方法，当动画播放器完成两个动画之间的混合时，将返回`true`。
- en: Detecting when an animation has looped is also possible, although `CIwAnimPlayer`
    does not provide us with a quick shortcut way of detecting this event. Instead,
    we have to do a little manual flag testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 检测动画是否循环也是可能的，尽管`CIwAnimPlayer`没有提供快速检测此事件的快捷方式。相反，我们必须进行一些手动标志测试。
- en: 'At any time, the animation player can be updating two main animations: current
    animation (defined as the animation that was last specified using the `PlayAnim`
    method) and the previous animation (the one that was playing at the time `PlayAnim`
    was last called with a blending interval).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，动画播放器都可以更新两个主要动画：当前动画（定义为最后使用`PlayAnim`方法指定的动画）和上一个动画（在`PlayAnim`上次调用时带有混合间隔正在播放的动画）。
- en: 'The current status of these two animations are stored in instances of the `CIwAnimBlendSource`
    class, which we can access using the `CIwAnimPlayer` class'' methods named `GetSourceCurr`
    and `GetSourcePrev`. The `CIwAnimBlendSource` class has a method called `GetFlags`
    that returns playback status information as a bitmask. To detect if the animation
    has looped, we just need to see if the flag `CIwAnimBlendSource::LOOPED_F` is
    set. The following source code shows this in action:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个动画的当前状态存储在`CIwAnimBlendSource`类的实例中，我们可以通过名为`GetSourceCurr`和`GetSourcePrev`的`CIwAnimPlayer`类方法来访问它们。`CIwAnimBlendSource`类有一个名为`GetFlags`的方法，它返回以位掩码形式表示的播放状态信息。要检测动画是否循环，我们只需查看标志`CIwAnimBlendSource::LOOPED_F`是否设置。以下源代码展示了这一操作：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you prefer this approach, you can also use the flag `CIwAnimBlendSource::COMPLETE_F`
    to detect when a single shot animation has finished.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这种方法，您还可以使用标志`CIwAnimBlendSource::COMPLETE_F`来检测单次动画何时完成。
- en: Optimizing animation playback
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化动画播放
- en: Do you remember that we calculated the current animation frame by calling the
    `Update` method of `CIwAnimPlayer`? This method has to do quite a lot of work,
    some of which we might not actually need to do on a frame-by-frame basis. For
    example, if an in-game character is currently not visible on the screen, we might
    want to ensure that we still step through its animation; but calculating the bone
    positions for the current frame of animation is a waste of processor time as we
    won't be rendering the animation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们是通过调用`CIwAnimPlayer`的`Update`方法来计算当前动画帧的吗？这个方法必须做很多事情，其中一些我们可能实际上不需要在每一帧都做。例如，如果一个游戏中的角色当前不在屏幕上可见，我们可能想要确保我们仍然可以遍历其动画；但是，计算当前动画帧的骨骼位置是浪费处理器时间，因为我们不会渲染动画。
- en: The `Update` method is actually implemented by calling three other methods of
    `CIwAnimPlayer`, which we can call independently if we so wish.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update`方法实际上是通过调用`CIwAnimPlayer`的另外三个方法来实现的，如果我们愿意，可以独立调用这些方法。'
- en: The first method is `UpdateParameters`, which takes the time increment we need
    to update the animation by as its sole parameter. This method will update the
    current time indexes of all the animations currently in use by the animation player
    and set flags to indicate whether those animations have completed or looped.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是`UpdateParameters`，它将我们需要更新动画的时间增量作为其唯一的参数。此方法将更新动画播放器当前正在使用的所有动画的时间索引，并设置标志以指示那些动画是否已完成或循环。
- en: The `UpdateSources` method takes no parameters and is used to work out the current
    bone orientations for each animation, applying any blending between animations
    as required.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateSources`方法不接受任何参数，用于计算每个动画的当前骨骼方向，并根据需要应用动画之间的混合。'
- en: Finally there is the `UpdateMatrices` method, which again takes no parameters.
    This performs the final step of converting all the positions and orientations
    of each bone into a matrix that will be used to update the vertex stream of the
    3D model during rendering.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`UpdateMatrices`方法，它同样不需要任何参数。这个方法执行将每个骨骼的位置和方向转换为用于在渲染过程中更新3D模型顶点流的矩阵的最终步骤。
- en: These methods need to be called in the order presented previously, but there
    is no need to call all three methods in every frame if we do not need the results
    of that method to be calculated.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法需要按照之前呈现的顺序调用，但如果不需要计算该方法的输出结果，则不需要在每一帧都调用所有三个方法。
- en: Playing sub-animations
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放子动画
- en: '**Sub-animations** allow us to animate only a part of the entire skeleton,
    which can be useful when we want an in-game character to be able to perform two
    different actions at once. For example, a character might be able to wield several
    different weapons while moving around the game world. The main animation applied
    to the character would be an animation for walking, running, or just standing
    still. Sub-animations can then be overlaid on top of the main animation to show
    the player holding, firing, or reloading the different weapon types.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**子动画**允许我们仅对整个骨骼的一部分进行动画处理，这在我们需要游戏中的角色能够同时执行两个不同的动作时非常有用。例如，一个角色可能在游戏世界中移动时能够挥舞几种不同的武器。应用于角色的主要动画将是一个行走、跑步或仅静止不动的动画。然后，子动画可以叠加在主要动画之上，以显示玩家持有、射击或重新装填不同类型的武器。'
- en: In order to export a sub-animation, all we need to do is specify the name of
    the bone that is the root of the sub-animation in the **Sub Anim Root** field
    of the Marmalade exporter plugin. In the example situation given previously, you
    might choose to export the sub-animation starting at a bone that has the two arm
    bones as children.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导出子动画，我们只需在Marmalade导出插件中的**子动画根**字段中指定子动画的根骨骼名称。在之前给出的示例情况下，你可能会选择从有两个手臂骨骼作为子节点的骨骼开始导出子动画。
- en: The Blender plugin does not currently support this feature unfortunately, though
    you could potentially export the entire animation and then delete by hand any
    references to bones higher in the hierarchy than the sub-animation root bone in
    the ANIM file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Blender插件目前不支持此功能，尽管您可能可以导出整个动画，然后在ANIM文件中手动删除对子动画根骨骼以上层次骨骼的任何引用。
- en: 'With the sub-animation exported, all we have to do to play it back is call
    the `PlaySubAnim` method of `CIwAnimPlayer`. An example of how to use this function
    is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 子动画导出后，要播放它，我们只需调用`CIwAnimPlayer`的`PlaySubAnim`方法。此函数的使用示例如下：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, it is almost identical in structure to the `PlayAnim` method.
    The only difference is an extra initial parameter, which is the sub-animation
    index number. The animation player can support two different sub-animations at
    the same time and the index number should be `0` or `1` to indicate which sub-animation
    you wish to change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它在结构上几乎与`PlayAnim`方法相同。唯一的区别是额外的初始参数，即子动画索引号。动画播放器可以同时支持两个不同的子动画，索引号应为`0`或`1`，以指示您希望更改哪个子动画。
- en: To detect the current playback status of a sub-animation, we can get hold of
    the `CIwAnimBlendSource` instance using the `GetSourceSub` method of `CIwAnimPlayer`.
    This method takes a single parameter, which is the index number of the sub-animation
    required.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测子动画的当前播放状态，我们可以通过`CIwAnimPlayer`的`GetSourceSub`方法获取`CIwAnimBlendSource`实例。此方法接受一个参数，即所需子动画的索引号。
- en: Offset animations
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移动画
- en: When dealing with animations that cause a game character to move, such as walking,
    running, or making an attacking move, it is desirable to update the position of
    the character with respect to the animation being played so that the character's
    feet do not appear to slip on the ground.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理导致游戏角色移动的动画，如行走、奔跑或进行攻击动作时，我们希望根据正在播放的动画更新角色的位置，以便角色的脚看起来不会在地面上滑动。
- en: Marmalade provides a method of doing this by way of an **offset animation**,
    which is an animation that consists of a single bone whose position and rotation
    can be used to move an object around the game world. Offset animations are exported
    using the same export process as any other animation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade提供了一种通过**偏移动画**来实现此功能的方法，这是一种由单个骨骼组成的动画，其位置和旋转可以用来在游戏世界中移动对象。偏移动画使用与其他动画相同的导出过程进行导出。
- en: 'To use an offset animation, we use the `PlayOfsAnim` method of `CIwAnimPlayer`,
    as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用偏移动画，我们使用`CIwAnimPlayer`的`PlayOfsAnim`方法，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parameters of this function are pointers to the offset animation instance,
    the speed of playback (again a value of `1` will play back at normal speed), and
    the required animation flags; so it is possible to play back offset animations
    as one shot or looped.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的参数是指向偏移动画实例的指针、播放速度（再次，值为`1`将以正常速度播放），以及所需的动画标志；因此，可以一次性或循环播放偏移动画。
- en: To find the current status of the offset animation, we can use the `GetSourceOfs`
    method on `CIwAnimPlayer` to retrieve the `CIwAnimBlendSource` instance that maintains
    it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到偏移动画的当前状态，我们可以使用`CIwAnimPlayer`上的`GetSourceOfs`方法来检索维护它的`CIwAnimBlendSource`实例。
- en: We can also find out position and rotation information for the start, end, and
    current offsets using the methods `GetMatOfsInitial`, `GetMatOfsFinal`, and `GetMatOfs`
    of `CIwAnimPlayer`. Each of these methods allows access to a `CIwFMat` object
    representing the current orientation of the offset. We can then use this information
    to allow us to update the position of a game character accordingly, so that other
    game functions such as collision detection continue to work correctly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`CIwAnimPlayer`的`GetMatOfsInitial`、`GetMatOfsFinal`和`GetMatOfs`方法来获取起始、结束和当前偏移的位置和旋转信息。这些方法中的每一个都允许访问一个表示偏移当前方向的`CIwFMat`对象。然后我们可以使用这些信息来更新游戏角色的位置，以便其他游戏功能，如碰撞检测，可以继续正常工作。
- en: Obtaining bone positions and rotations
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取骨骼位置和旋转
- en: When discussing sub-animations earlier, we presented the example of a character
    being able to hold a variety of different weapons. Sub-animations will, of course,
    only provide half the solution to this problem, as they will move the character's
    arms to the correct pose; but, because the weapon is not part of the source 3D
    model, the character will just appear to be clutching at thin air.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论子动画时，我们展示了角色能够携带各种不同武器的例子。子动画当然只能提供这个问题的部分解决方案，因为它们会将角色的手臂移动到正确的姿势；但是，由于武器不是源3D模型的一部分，角色看起来就像是在空中抓取。
- en: We need some way of drawing a further model depicting the weapon, but how can
    we get it positioned in the correct place?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来绘制进一步描述武器的模型，但我们如何将其定位在正确的位置？
- en: The answer is to ask the animation player to provide us with the current orientation
    and position of a bone that is located at the point where the weapon model would
    need to be drawn. We can do this by calling the `GetBoneNamed` method of `CIwAnimPlayer`,
    which will return a pointer to a `CIwAnimBone` instance representing the current
    orientation of the requested bone.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是要求动画播放器提供位于武器模型需要绘制点的骨骼的当前朝向和位置。我们可以通过调用`CIwAnimPlayer`的`GetBoneNamed`方法来实现，该方法将返回指向表示请求骨骼当前朝向的`CIwAnimBone`实例的指针。
- en: The position and rotation of the bone can be found using the `GetPos` and `GetRot`
    methods of `CIwAnimBone`, which allow us to generate a matrix in model space,
    or alternatively the `GetMat` method will return a model space matrix representing
    both the position and rotation of the bone if it has been calculated during the
    update of the `CIwAnimPlayer` instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`CIwAnimBone`的`GetPos`和`GetRot`方法找到骨骼的位置和旋转，这些方法允许我们在模型空间中生成一个矩阵，或者如果它已经在`CIwAnimPlayer`实例的更新过程中计算过，`GetMat`方法将返回一个表示骨骼位置和旋转的模型空间矩阵。
- en: Using the bone information, we can easily calculate a model matrix for rendering
    the weapon model in the correct place. First we use the bone information to generate
    a matrix in model space, we then multiply this by any rotation matrix needed to
    orient the character in the game world. Finally, add the world position of the
    character and the weapon model can be rendered in the character's hand.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用骨骼信息，我们可以轻松地计算出用于在正确位置渲染武器模型的模型矩阵。首先，我们使用骨骼信息在模型空间中生成一个矩阵，然后乘以任何旋转矩阵以将角色定位在游戏世界中。最后，加上角色的世界位置，武器模型就可以在角色的手中渲染出来。
- en: Example code
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The following sections give an overview of the sample projects accompanying
    this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节概述了本章附带的示例项目。
- en: The Flag project
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旗帜项目
- en: 'This example demonstrates playing back both a main and sub-animation. A flag
    is rendered waving in a virtual breeze. Every few seconds the flagpole will wobble
    around but the flag on the end of the pole will continue to flap around. A screen
    grab can be seen in the following figure:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了播放主动画和子动画。一面旗帜在虚拟的风中飘扬。每隔几秒钟，旗杆会摇摆，但杆顶的旗帜会继续飘动。以下图可以看到屏幕截图：
- en: '![The Flag project](img/3363_05_08.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![旗帜项目](img/3363_05_08.jpg)'
- en: The animation of the flag waving is achieved as a looping sub-animation, while
    the flagpole wobble is the main animation, which is started every five seconds
    as a one-shot animation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 旗帜飘扬的动画是通过循环的子动画实现的，而旗杆的摇摆是主动画，每五秒作为一次性的动画启动。
- en: One of the problems with this approach is that the sub-animation will only play
    if there is a main animation currently in progress. Rather than create a one frame
    animation of the flagpole standing still, a cunning trick has been employed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是子动画只有在当前有主动画进行时才会播放。而不是创建一个旗杆静止的一帧动画，这里使用了一个巧妙的技巧。
- en: The flagpole wobble animation is actually playing continuously, but at zero
    speed. Since the first frame of the wobble animation is of the pole in an upright
    position, we have achieved our aim of a static animation frame.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 旗杆摇摆动画实际上是连续播放的，但速度为零。由于摇摆动画的第一帧是杆子直立的位置，我们已经实现了静态动画帧的目标。
- en: Every five seconds the wobble animation is then restarted as a one-shot animation.
    When the wobble animation has completed, we return to playing it at zero speed
    to hold the flagpole steady again.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔五秒，摇摆动画作为一次性的动画重新启动。当摇摆动画完成后，我们将其速度设置为零以再次保持旗杆稳定。
- en: The Skiing project
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: 'The changes to the Skiing project for this chapter really make it seem like
    much more of a game. The following screenshot and the following sections highlight
    the new bits and pieces that have been added:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对滑雪项目的修改真的让它看起来更像一个游戏。以下截图和以下部分突出了添加的新功能：
- en: '![The Skiing project](img/3363_05_09.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![滑雪项目](img/3363_05_09.jpg)'
- en: New gameplay features
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的游戏玩法功能
- en: Previously, there was not a great deal of actual gameplay to be had in the game.
    We could steer the little skier left and right, but aside from crashing into a
    tree there wasn't actually an awful lot to do.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，游戏中并没有太多实际的游戏玩法。我们可以左右操控这个小滑雪者，但除了撞到树上之外，实际上并没有太多可以做的事情。
- en: To combat this, gates consisting of a couple of flags have been added. The player
    must steer the skier through these in order to increase their score, which is
    now displayed at the bottom of the screen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种情况，添加了由几面旗帜组成的门。玩家必须引导滑雪者通过这些门来增加他们的分数，现在分数显示在屏幕底部。
- en: To implement the gates, a new class called `Flag` has been created. The `ModeGame`
    class picks a random position across the course and spawns a flag a short distance
    left and right of that position. The flags scroll up the screen, and when they
    scroll off the top a new random position is chosen for them at the bottom of the
    game world.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现门，创建了一个名为`Flag`的新类。`ModeGame`类在赛道上选择一个随机位置，并在该位置左右稍远处生成一个旗帜。旗帜向上滚动，当它们从顶部滚动出去时，在游戏世界的底部选择一个新的随机位置。
- en: The `ModeGame` class maintains pointers to the two instances of `Flag` so that
    it can be detected when they have scrolled offscreen and need repositioning, plus
    we can also use these pointers to work out when the player has moved between them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModeGame`类维护对两个`Flag`实例的指针，以便在它们滚动出屏幕并需要重新定位时检测到，同时我们也可以使用这些指针来确定玩家是否在它们之间移动。'
- en: Randomly placed rocks have also been introduced, which must be avoided because
    colliding with them ends the game, just like steering into the trees does. These
    are represented by another new class called `Rock`. This class is very similar
    to the existing `Tree` class, the main difference being that when the rock scrolls
    off the top of the screen it is replaced at the bottom with a new horizontal position.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还引入了随机放置的岩石，必须避开它们，因为撞到它们会导致游戏结束，就像撞到树一样。这些由另一个新类`Rock`表示。这个类与现有的`Tree`类非常相似，主要区别在于当岩石从屏幕顶部滚动出去时，它会在底部以新的水平位置替换。
- en: Animations added
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了动画
- en: Given the subject matter of this chapter, it's fairly obvious that adding animations
    to the game would be one of the changes made.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到本章的主题，很明显，向游戏中添加动画将是做出的更改之一。
- en: Our little skier character has been given a looping animation, so the little
    chap now pushes himself along using his skiing poles. If the player collides with
    a tree or rock, the poor little fellow will also now take a tumble and end up
    in a heap on the ground. Ouch!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小滑雪角色现在被赋予了一个循环动画，所以这个小家伙现在用他的滑雪杖推动自己前进。如果玩家撞到树或岩石，这个可怜的小家伙现在也会摔倒，最终在地上堆成一团。哎呦！
- en: The other animation added to the game has been for the flag. It is the same
    animation structure demonstrated in this chapter's other example project. A sub-animation
    plays to make the flag wave in the wind, while the main animation is of the flagpole
    wobbling about.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中添加的另一个动画是为旗帜设计的。它与本章其他示例项目中的动画结构相同。一个子动画播放，使旗帜在风中飘扬，而主动画则是旗帜杆摇摆。
- en: Rather than wobbling at set time intervals, the animation is instead triggered
    when the player skis too close to the flag.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 动画不是在固定的时间间隔摇摆，而是在玩家滑雪太靠近旗帜时触发。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We've covered the topic of 3D animation quite extensively in this chapter. We
    can now move, rotate, and scale our 3D models in the game world, and we can make
    the actual shape of the model change using boned animations to make characters
    walk, run, jump, dance, or whatever we require them to do.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中广泛地介绍了3D动画。现在我们可以在游戏世界中移动、旋转和缩放3D模型，并且我们可以使用骨骼动画来改变模型的实际形状，使角色行走、奔跑、跳跃、跳舞或完成我们需要的任何动作。
- en: We've also looked at some more advanced topics, such as blending between animations,
    applying sub-animations on top of a main animation, and retrieving bone position
    and orientation information from an in-progress animation to allow us to find
    the location of a particular part of a model.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了更多高级主题，例如动画之间的混合、在主动画之上应用子动画，以及从进行中的动画中检索骨骼位置和方向信息，以便我们找到模型特定部分的位置。
- en: In the next chapter we'll return to just two dimensions, as we look at how we
    can make the user interface of our games look a little prettier than just using
    badly laid out debug fonts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到二维空间，探讨我们如何使游戏的用户界面比仅使用布局糟糕的调试字体看起来更漂亮。
