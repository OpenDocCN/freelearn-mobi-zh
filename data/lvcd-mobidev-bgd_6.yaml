- en: Chapter 6. Making a Reminder Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 制作提醒应用
- en: '*Note to self…*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*自我提醒…*'
- en: '*To-do lists, alarms, birthday reminders, notes, shopping lists, and the list
    goes on. There should be an app to keep a list of the different apps that keep
    lists! At the time of writing this book, there were already over 8,000 iOS apps
    that were lists, planners, or alarms. Perhaps, there''s room for one more…*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*待办事项、闹钟、生日提醒、笔记、购物清单，等等。应该有一个应用来保存所有保存列表的应用！在撰写这本书的时候，已经有超过8000个iOS应用是列表、计划或闹钟。或许，还有空间再增加一个…*'
- en: It could take a lot of research, and money, to explore all the reminder apps
    that are out there. The majority of apps will have a lot of features that you'll
    never use and at least one vital feature that is missing. If you're lucky, some
    combination of apps may do all the things you want in a reminder. However, don't
    forget that you use LiveCode and can make your own reminder app!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 探索所有现有的提醒应用可能需要大量的研究和资金。大多数应用都会有你永远不会使用的许多功能，以及至少一个缺失的必要功能。如果你很幸运，一些应用组合可能能够完成你想要的提醒功能。然而，不要忘记你可以使用LiveCode并创建自己的提醒应用！
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss what is meant by a *reminder*
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论一下“提醒”的含义
- en: Create some time measuring utility functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些时间测量实用函数
- en: Define a data structure to store information about an event
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个数据结构来存储关于活动的信息
- en: Make use of mobile device "notifications"
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用移动设备的“通知”
- en: Create a flexible reminder app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个灵活的提醒应用
- en: Different types of reminders
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的提醒
- en: 'Here is the list of a few of the things that you might call a "reminder":'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可能称之为“提醒”的东西的列表：
- en: A shopping list
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物清单
- en: A Christmas present list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞礼物清单
- en: A to-do list
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项列表
- en: An alarm clock
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闹钟
- en: An egg timer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器
- en: A birthday reminder
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生日提醒
- en: Now, is there a single way to describe all of these things? Well, it may get
    wordy, but a reminder could be described as a notification message or sound that
    either appears automatically or shows when you look for it. It is used to let
    you know that a certain time has passed, a moment has arrived, or that an outstanding
    task has not been completed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有没有一种方法可以描述所有这些事情？嗯，可能会有些冗长，但提醒可以被描述为自动出现或在你查找时显示的通知消息或声音。它用于让你知道已经过去了一定时间，某个时刻已经到来，或者一个未完成的任务尚未完成。
- en: 'See, pretty wordy. Breaking it down like this helps us to see what features
    a reminder app will need to have. Before getting to that, let''s test the definition
    against the preceding examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有点冗长。这样分解可以帮助我们看到提醒应用需要具备哪些功能。在深入探讨之前，让我们将这个定义与前面的例子进行对比：
- en: '**A shopping list**: In this case, you go looking for the reminder. Although,
    we could set it up to automatically show when your location happens to be near
    the store! Other than that, this is effectively a task that has not been completed.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**购物清单**：在这种情况下，你需要寻找提醒。尽管，我们可以设置它在你靠近商店时自动显示！除此之外，这实际上是一个尚未完成的任务。'
- en: '**A Christmas present list**: This is much the same as a shopping list, but
    it could use a timed message that let''s you know how few shopping days are left
    for you to buy a Christmas present for your loved ones.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**圣诞礼物清单**：这和购物清单差不多，但它可以使用一个定时消息来告诉你还有多少天可以购买圣诞礼物给你的亲人。'
- en: '**A to-do list**: Again, this is simply a list of tasks that are not yet complete.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**待办事项列表**：再次强调，这仅仅是一个尚未完成的任务列表。'
- en: '**An alarm clock**: This gives you a notification that a moment in time has
    been reached.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**闹钟**：这会给你一个通知，表明时间已经到达。'
- en: '**An egg timer**: This is a notification of a certain amount of time that has
    passed, which could be used as a sequence of such events that might be used in
    a cooking-buddy app.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器**：这是关于一定时间已经过去的通知，这可以用于烹饪伙伴应用中可能用到的此类事件的序列。'
- en: '**A birthday reminder**: This shows whether a certain moment has been reached.
    Really though, you want to set the reminder so that it can notify you ahead of
    the actual event.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**生日提醒**：这显示了是否已经达到某个特定时刻。实际上，你希望设置提醒，以便在事件实际发生之前通知你。'
- en: At least as a starting point, we can use the definition to guide us as we outline
    the abilities the app will need to have.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 至少作为一个起点，我们可以使用这个定义来指导我们概述应用需要具备的能力。
- en: Timing of notifications
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知的时间安排
- en: The mobile notifications that can be created with LiveCode will be sent the
    moment you ask for it to be sent. Strangely though, the value is based on the
    number of seconds since midnight on January 1st, 1970, specifically, in part of
    London! Well, it's named after an area of London called Greenwich.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LiveCode可以创建的移动通知将在您请求发送的那一刻发送。奇怪的是，这个值是基于1970年1月1日午夜以来的秒数，具体来说，部分位于伦敦！嗯，它是以伦敦的一个地区命名的，称为格林威治。
- en: '**Greenwich Mean Time**, often referred to as **GMT**, has been used as the
    standard for measuring time. It is somewhat superseded by **UTC** (**Coordinated
    Universal Time**), but in either case, it represents the exact current time at
    least for countries that are within the same time zone as Greenwich. The rest
    of us add or subtract some amount of time from that value.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**格林威治标准时间**，通常简称为**GMT**，已被用作测量时间的标准。它已被**UTC**（**协调世界时**）所取代，但无论如何，它至少代表格林威治所在时区的确切当前时间。我们其他人会从这个值中加上或减去一些时间。'
- en: In order to adapt to the fact that the Earth doesn't go around the Sun in an
    exact number of days or even an exact number of quarter days, calendars are adjusted
    by one day every four years, though not on 100 year boundaries, except for every
    400 years (for example, the year 2000 was a leap year). These adjustments are
    still not enough to keep the clocks on time! The clocks are out of time by about
    0.6 seconds a year, and so there are "Leap Seconds" added to compensate for that.
    In theory, Leap Seconds could be used to subtract one second, but as of yet, this
    hasn't been needed, as they have only been used to add one second.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应地球围绕太阳转动的天数或四分之一天数的精确数，日历每四年调整一天，但不是在100年边界上，除非每400年（例如，2000年是闰年）。这些调整仍然不足以保持时钟准确！时钟每年会慢大约0.6秒，因此会添加“闰秒”来补偿。理论上，闰秒可以用来减去一秒，但到目前为止，这还没有必要，因为它们只被用来添加一秒。
- en: None of this affects the number of seconds since midnight of January 1, 1970,
    but it does mean that converting LiveCode's **seconds** into time and date using
    your own arithmetic won't give you the right time. Yet, it's still used as the
    basis for notifications. This value is usually referred to as Unix Time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都不会影响自1970年1月1日午夜以来的秒数，但这确实意味着使用您自己的算术将LiveCode的**秒**转换为时间和日期不会得到正确的时间。然而，它仍然用作通知的基础。这个值通常被称为Unix时间。
- en: It doesn't matter much though if you end up sending someone a Happy Birthday
    message 25 seconds early! Don't worry, the way we'll calculate the notification
    time will take care of the oddity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果您提前25秒发送生日祝福信息也不是很重要！不用担心，我们将计算通知时间的方式会处理这种异常。
- en: Date and time pickers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间选择器
- en: As mentioned in the preceding section, mobile notifications use the number of
    seconds since midnight of January 1, 1970 and don't add on the 25 seconds, or
    Leap Seconds, that have occurred since then. When we present the date and time
    pickers to the user, the selections the user makes will come back as the actual
    current or future time. We will adjust for that later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，移动通知使用自1970年1月1日午夜以来的秒数，并且不会添加自那时以来的25秒或闰秒。当我们向用户展示日期和时间选择器时，用户所做的选择将返回为实际当前或未来的时间。我们稍后会进行调整。
- en: Time for action – creating date and time pickers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建日期和时间选择器
- en: 'Let''s make another test-rig stack, which we''ll use to try out some date and
    time pickers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一个测试堆栈，我们将使用它来尝试一些日期和时间选择器：
- en: Create a new Mainstack, name it `ReminderFunctions`, and save the stack.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Mainstack，命名为`ReminderFunctions`，并保存堆栈。
- en: Add two fields and two new buttons.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个字段和两个新的按钮。
- en: Name one field `dateinseconds` and the other `timeinseconds`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个字段为`dateinseconds`，另一个为`timeinseconds`。
- en: Name the buttons as `Pick Date` and `Pick Time`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮命名为`Pick Date`和`Pick Time`。
- en: 'Set the script of the **Pick Date** button to this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**选择日期**按钮的脚本设置为以下内容：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the **Pick Time** button script to this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**选择时间**按钮的脚本设置为以下内容：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Set the Standalone Application Settings so that you can test on iOS or Android.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置独立应用程序设置，以便您可以在iOS或Android上进行测试。
- en: Choose your **Test Target** (in the following steps, you can see that the iPhone
    simulator was chosen in this case) and do a **Test**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的**测试目标**（在以下步骤中，您可以看到在这种情况下选择了iPhone模拟器）并执行**测试**。
- en: Click on the **Pick Date** button.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选择日期**按钮。
- en: Select `December 25th, 2012` and click on **Done**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`2012年12月25日`并点击**完成**。
- en: The number of seconds from midnight of January 1, 1970 to midnight of Christmas
    day 2012 will be shown in the first field that you created.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从1970年1月1日午夜到2012年圣诞节午夜的总秒数将显示在您创建的第一个字段中。
- en: Click on the **Pick Time** button and set the time to `1 am`. The following
    image shows how the picker looks different on iOS and the Android simulator:![Time
    for action – creating date and time pickers](img/image00283.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选择时间**按钮，将时间设置为`凌晨1点`。以下图像显示了iOS和Android模拟器上选择器的外观不同：![创建日期和时间选择器的操作时间 –
    img/image00283.jpeg](img/image00283.jpeg)
- en: Click on **Done** and you will see the number of seconds from midnight of January
    1 1970 to 1 AM of the day you do this test in the right-hand side field.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**，您将在右侧字段中看到从1970年1月1日午夜到您进行此测试当天凌晨1点的秒数。
- en: '*What just happened?*'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just made two simple scripts that call the native date or time picker and
    convert the result into seconds to then show them in a field. What is interesting
    to note is that for the Pick Time case, it doesn't return the number of seconds
    of the current day, that is, all the seconds since midnight of January 1, 1970\.
    In order to set a notification time for a particular time of a particular date,
    we have to do a little arithmetic. We'll go into that a little later when we make
    the actual reminder app in the *Making the reminders app* section of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了两个简单的脚本，这些脚本调用原生的日期或时间选择器，并将结果转换为秒，然后在字段中显示它们。值得注意的是，对于选择时间的情况，它不会返回当前天的秒数，即自1970年1月1日午夜以来的所有秒数。为了设置特定日期特定时间的提醒时间，我们必须进行一些算术运算。我们将在本章的*制作提醒应用*部分稍后进行介绍。
- en: Pop quiz – OA (odd acronyms!)
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验 – OA（奇数缩写！）
- en: You may have noticed that the acronym for "Coordinated Universal Time" is UTC
    and not CUT. Why is that?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，“协调世界时”的缩写是UTC而不是CUT。为什么是这样？
- en: CUT is too common a word.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CUT是一个过于常见的词。
- en: So as not to upset the French.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不冒犯法国人。
- en: The acronym committee members were dyslexics.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩写委员会成员是阅读障碍者。
- en: 'Answer: 2'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：2
- en: The French may not have proactively objected, but indeed, the acronym of UTC
    was chosen so as to not specifically match the English version of the phrase.
    It also fell in nicely with the other acronyms such as UT0, UT1, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 法国可能没有积极反对，但确实，UTC的缩写是为了不与英语版本的短语具体匹配。它也与UT0、UT1等其他缩写很好地结合在一起。
- en: Where?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在哪里？
- en: There is something we can do in a mobile reminder app that would never work
    in a pen and paper version of a reminder; we can present the list of reminders
    based on where you are at the time that you check it! To make use of location,
    you need to know where you are now and how far your location is from the place
    associated with the reminder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动提醒应用中，我们可以做些在纸笔版提醒中永远无法做到的事情；我们可以根据您检查提醒时的位置来展示提醒列表！为了使用位置，您需要知道您现在在哪里以及您的位置与与提醒相关的地方有多远。
- en: At the time of writing this book, there was no ability in LiveCode to directly
    pull in a map so that you could choose locations other than the one you are at
    right now. So, we'll work within that limitation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，LiveCode没有直接拉入地图的能力，以便您可以选择除您现在所在位置之外的其他位置。因此，我们将在这种限制下工作。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: That being said, there is `mergMK` external (for more information, refer to
    [http://mergext.com](http://mergext.com)), which works with iOS versions before
    7.0 and was being updated at the time of writing this book. You could also use
    a combination of HTML and JavaScript as described in the article at [http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode](http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode).
    However, these are both beyond the scope of this beginner's book
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有一个名为`mergMK`的外部工具（更多信息，请参阅[http://mergext.com](http://mergext.com)），它可以与7.0之前的iOS版本一起使用，并且在撰写本书时正在更新。您还可以使用文章中描述的HTML和JavaScript的组合，该文章位于[http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode](http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode)。然而，这些都不在本初学者的书籍范围之内。
- en: The general technique while reading a mobile device's sensors, is to start tracking
    a given sensor, detect when changes happen, and to stop tracking the sensor. You
    can take a reading from the sensor at any time between the start and stop tracking
    commands. You can also specify how detailed a report you want and whether you
    want a precise reading. The precise reading of the location would dictate whether
    GPS was used or not. The advantage of using GPS is that you get greater accuracy
    (assuming there's a clear signal at the time) and the disadvantages are that it
    uses more battery power, and devices that don't have GPS cannot use this feature.
    When using location as part of a reminder, we're mainly interested in whether
    you're at home, the office, or perhaps at the supermarket. So, we'll use the less
    precise reading, the GPS one would be an overkill.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取移动设备传感器时的一般技术是开始跟踪一个给定的传感器，检测何时发生变化，并停止跟踪该传感器。您可以在开始和停止跟踪命令之间的任何时间从传感器读取数据。您还可以指定您想要的报告的详细程度以及是否需要精确读取。位置的精确读取将决定是否使用了
    GPS。使用 GPS 的优点是您可以获得更高的精度（假设当时信号清晰），缺点是它消耗更多的电量，并且没有 GPS 的设备无法使用此功能。当使用位置作为提醒的一部分时，我们主要关心的是您是否在家、办公室，或者可能在超市。因此，我们将使用不太精确的读取，GPS
    的读取可能会过度。
- en: Time for action – trying out native location tracking
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手实践了——尝试原生位置跟踪
- en: 'Later in this chapter, we will add in a feature to allow the app user to add
    a set of favorite locations. For the moment, we''ll just try out the basic functions.
    Location doesn''t work in the simulators; you''ll have to try this on a real device:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将添加一个功能，允许应用程序用户添加一组收藏位置。目前，我们只是尝试基本功能。位置服务在模拟器中不起作用；您必须在真实设备上尝试此操作：
- en: Use the test-rig stack from the preceding steps and add a `Get Location` button
    and a `location` field. Make sure that the `location` field is as wide as the
    card window; it will show three long numbers.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一步骤中的测试架栈，添加一个 `Get Location` 按钮和一个 `location` 字段。确保 `location` 字段与卡片窗口一样宽；它将显示三个长数字。
- en: 'Set the script of the button to the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的脚本设置为以下内容：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `true` value in the second line is the one that defines a *loosely* value
    saying that we don't need the precision of GPS. The `false` value in the third
    line says that we don't need detailed information to be returned.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行中的 `true` 值定义了一个 *松散* 的值，表示我们不需要 GPS 的精度。第三行中的 `false` 值表示我们不需要返回详细的信息。
- en: Go to **Standalone Application Settings** and choose your target device as **iOS**
    or **Android**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **独立应用程序设置** 并选择您的目标设备为 **iOS** 或 **Android**。
- en: For iOS, set the **Display Name**, **Internal App ID**, and **Profile**. Choose
    your device and SDK version):![Time for action – trying out native location tracking](img/image00284.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 iOS，设置 **显示名称**、**内部应用程序 ID** 和 **配置文件**。选择您的设备和 SDK 版本）：![是时候动手实践了——尝试原生位置跟踪](img/image00284.jpeg)
- en: Also, in the iOS **Requirements and Restrictions** section, select **Location
    Services** and **GPS** as required. In the app, you will also have to accept Location
    Services when iOS prompts for it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 iOS 的 **要求和限制** 部分中，选择 **位置服务** 和 **GPS** 作为所需服务。在应用中，当 iOS 提示时，您也必须接受位置服务。
- en: For Android, set the **Label**, **Identifier**, and **Minimum Android Version**
    fields:![Time for action – trying out native location tracking](img/image00285.jpeg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Android，设置 **标签**、**标识符** 和 **最低 Android 版本** 字段：![是时候动手实践了——尝试原生位置跟踪](img/image00285.jpeg)
- en: Additionally, in the **Application Permissions** part of the Android settings,
    make sure that you have asked permission to get the **Coarse Location** permission:![Time
    for action – trying out native location tracking](img/image00286.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 Android 设置的 **应用程序权限** 部分，确保您已请求获取 **粗略位置** 权限：![是时候动手实践了——尝试原生位置跟踪](img/image00286.jpeg)
- en: Select **Save Standalone Application** and install the app onto your device.
    Follow the description given in [Chapter 2](part0026.xhtml#aid-OPEK1 "Chapter 2. Getting
    Started with LiveCode Mobile"), *Getting Started with LiveCode Mobile* if you
    need a reminder on how to do that!
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **保存独立应用程序** 并将应用安装到您的设备上。如果您需要关于如何操作的提醒，请参考 [第 2 章](part0026.xhtml#aid-OPEK1
    "第 2 章。LiveCode Mobile 入门")，*LiveCode Mobile 入门*。
- en: In the app, try the **Pick Date** and **Pick Time** buttons to see how they
    bring up the native controls and then click on the **Get Location** button. Three
    long numbers should appear in the `location` field:![Time for action – trying
    out native location tracking](img/image00287.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用中，尝试点击**选择日期**和**选择时间**按钮，看看它们如何弹出原生控件，然后点击**获取位置**按钮。三个长数字应该出现在`location`字段中：![尝试原生位置跟踪的时间
    - 尝试操作](img/image00287.jpeg)
- en: '*What just happened?*'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: As you can see, there is very little code needed to read a location! If this
    was a tracking app, you would need to keep the tracking open and have functions
    to respond to the change of location messages, but for our app, we just need to
    know where you are at the time you take a look at your list of reminders.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，读取位置所需的代码非常少！如果这是一个跟踪应用，你需要保持跟踪开启，并拥有响应位置变化消息的功能，但对我们这个应用来说，我们只需要知道你在查看提醒列表时的位置。
- en: The numbers that are shown in the location field are the latitude, longitude,
    and elevation of the position of the device. However, how will we use these numbers…?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 位置字段中显示的数字是设备的纬度、经度和海拔。然而，我们将如何使用这些数字…？
- en: Calculating the distance between two points on the Earth
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算地球上两点之间的距离
- en: The plan is to make your app able to sort your reminders list in order of distance
    from where you are right now. Let's say you really use this app a lot and have
    dozens of reminders. The reminder you created about buying some bread may be at
    the bottom of the list, but if you have assigned the location of the supermarket
    to that reminder, sorting the list while you're outside the supermarket should
    bring the shopping list items to the top.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是使你的应用能够根据你现在的位置对提醒列表进行排序。假设你真的经常使用这个应用，并且有几十个提醒。你创建的关于购买面包的提醒可能位于列表底部，但如果你已经为那个提醒分配了超市的位置，当你在外面超市时排序列表应该会将购物清单项目带到顶部。
- en: 'When faced with a problem such as this one, how will you come to know the distance
    between two points on Earth; Google is a good starting place for you to find that
    out! It takes very little research and time to find:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 面对像这样的问题时，你将如何知道地球上两点之间的距离；Google是你找到答案的好起点！只需进行很少的研究和时间就能找到：
- en: '[http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html)'
- en: The article in this URL discusses the original formula for calculating this
    and then shows a JavaScript function. If you find it hard to convert the equation
    into LiveCode handlers, you ought to be able to convert the JavaScript, line by
    line, into the LiveCode equivalent.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网址上的文章讨论了计算这个值的原始公式，然后展示了一个JavaScript函数。如果你发现将方程转换为LiveCode处理程序很困难，你应该能够逐行将JavaScript转换为LiveCode的等效代码。
- en: 'No need to type this in just yet, we''ll integrate it later; however, if you
    want to have a play, put these lines into the stack script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前无需输入此代码，我们稍后会将其集成；然而，如果你想试一试，请将这些行放入堆栈脚本中：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Try this in the message box:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息框中尝试以下操作：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This appears as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示：
- en: '![Calculating the distance between two points on the Earth](img/image00288.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![计算地球上两点之间的距离](img/image00288.jpeg)'
- en: As shown in the preceding screenshot, you should see a value of **5645.48065**.
    The two locations are somewhere near New York and London, and that value would
    be the distance in kilometers between the two along the surface of the Earth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，你应该看到一个值为**5645.48065**。这两个位置位于纽约和伦敦附近，这个值将是地球表面上两点之间的距离（千米）。
- en: Pop quiz – what floor is my apartment on?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 我的公寓在几楼？
- en: Examine the screenshot (the one timed "6:53 PM", which precedes the previous
    screenshot), and given the clue that the building I live in is not much above
    sea level, which floor do I live on?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看截图（时间标记为“下午6:53”，在之前的截图之前），考虑到我住的建筑离海平面不高，我住在哪一层？
- en: 40th floor
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 40楼
- en: 73 floors below ground
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地下73楼
- en: 11th floor
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 11楼
- en: I'm homeless
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我无家可归
- en: 'Answer: 3'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：3
- en: The numbers coming back from the location sensor return as latitude, longitude,
    and elevation. This would make the elevation on where the device was at that time
    be about 37.5 meters, which is much too low to be the 40th floor. There is enough
    information in the screenshot for you to know exactly when it was taken and where
    on Earth!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 来自位置传感器的数字以纬度、经度和海拔高度返回。这将使设备当时的海拔高度约为37.5米，这太低了，不可能是40层。截图中有足够的信息让您知道它是在何时何地拍摄的！
- en: Information needed in a reminder
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提醒中需要的信息
- en: We're well on the way to know how to set a time and date for the reminder notification
    to occur, and we will be able to sort the reminders based on the distance from
    where we are. However, what exact information do we need in the reminder itself?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了如何设置提醒通知的时间和时间，并且我们能够根据我们所在的位置对提醒进行排序。然而，提醒本身需要哪些具体信息？
- en: If this were a birthday reminder app, you would just need to ask for the person's
    name and the date of their birthday. If it were a shopping list app, you would
    need the name of the item and maybe the quantity. For a timer, you would need
    to ask what the event is called and would need to set a time for the event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个生日提醒应用，你只需要询问人的名字和他们生日日期。如果是一个购物清单应用，你需要物品的名称和数量。对于计时器，你需要询问事件名称并设置事件的时间。
- en: Here though, we're trying to make a completely flexible reminder app; it would
    be up to the user to describe the item in whatever manner they wish. So, we'll
    just ask for a title and a brief description. We will also need to offer the option
    of setting a date, time, an associated location, and whether an alert sound should
    be played.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里尝试制作一个完全灵活的提醒应用；用户可以以他们希望的方式描述项目。因此，我们只需要求用户提供标题和简要描述。我们还需要提供设置日期、时间、相关位置以及是否播放警报声音的选项。
- en: Another thing to think about is; where will we store the information for the
    list of reminders? While making the WebScraper app in [Chapter 4,](part0056.xhtml#aid-1LCVG2
    "Chapter 4. Using Remote Data and Media") *Using Remote Data and Media*, we chose
    to duplicate the main application stack into the documents folder and to then
    jump into that copy of the stack. This enabled the ability to save changes to
    the stack. The reminder app is a simpler case; we're only trying to store a few
    text strings to define each reminder and it would be simpler to just write a text
    file using this app.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要考虑的事情是；我们将把提醒列表的信息存储在哪里？在制作[第4章](part0056.xhtml#aid-1LCVG2 "第4章。使用远程数据和媒体")中的WebScraper应用时，我们在“使用远程数据和媒体”中选择了将主应用程序堆栈复制到文档文件夹中，然后跳转到该堆栈的副本。这使得能够保存对堆栈的更改。提醒应用是一个更简单的情况；我们只是试图存储一些文本字符串来定义每个提醒，而使用这个应用直接写入文本文件会更简单。
- en: 'We want to allow the user to make a list of locations, so that a reminder can
    be associated with that location. Rather than writing a different text file, we
    will make the first piece of information in each entry be the function of that
    entry. Right now, the only two functions are `location` and `reminder`. The following
    is an example of how the text file might look:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许用户创建位置列表，以便将提醒与该位置关联。而不是编写不同的文本文件，我们将每个条目中的第一条信息作为该条目的功能。目前，只有两个功能，即`位置`和`提醒`。以下是一个文本文件可能看起来像的示例：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Between each item in the line is a tab character, which will be used to separate
    the parts of the entry. The structure for a location is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每行中的项目之间有一个制表符，它将被用来分隔条目的各个部分。位置的格式如下：
- en: 'Function: `Location`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：`位置`
- en: Location's title
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置标题
- en: Latitude
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度
- en: Longitude
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经度
- en: 'For a reminder, it''s:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提醒来说：
- en: 'Function: `Reminder`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能：`提醒`
- en: Title
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题
- en: Brief description
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要描述
- en: Notification time in seconds since midnight of January 1, 1970
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自1970年1月1日午夜以来的通知时间（以秒为单位）
- en: A location associated with this reminder
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此提醒关联的位置
- en: Whether to play an alert sound (`true` or `false`)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否播放警报声音（`true`或`false`）
- en: Making the reminder app
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作提醒应用
- en: Ok, enough groundwork! Let's start making the reminder app. Rather than adding
    a feature at the time, along with any scripts, we'll make the various cards that
    will be needed to create the app's **GUI** (**graphical user interface**) first
    and then go back and add the scripts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，基础工作已经足够了！让我们开始制作提醒应用。我们不会在添加功能的同时添加任何脚本，而是首先制作创建应用**GUI**（**图形用户界面**）所需的各个卡片，然后再回去添加脚本。
- en: Laying out the cards
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局卡片
- en: We're going to make the first card of the stack be a place where you can see
    the current reminders, sort them by time or location, and add new reminders and
    locations. Then, we will make a second card to enter the location details and
    a third card to enter the details for a new reminder.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使堆栈的第一个卡片成为一个您可以查看当前提醒、按时间或位置排序以及添加新提醒和位置的地方。然后，我们将创建第二个卡片来输入位置详情，以及第三个卡片来输入新提醒的详情。
- en: Time for action – creating the reminder app screens
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建提醒应用屏幕
- en: The steps shown here are going to use the standard LiveCode fields and buttons,
    but feel free to make your version more attractive!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的步骤将使用标准的 LiveCode 字段和按钮，但请随意使您的版本更具吸引力！
- en: Create a new Mainstack, give it the name `EasyReminder`, and save it. Other
    names, such as `Simple Reminders`, might be more descriptive, but it would be
    too long a name if you're using an older iPhone.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Mainstack，将其命名为 `EasyReminder` 并保存。其他名称，如 `Simple Reminders` 可能更具体，但如果您使用的是较旧的
    iPhone，名称可能会太长。
- en: Set the card size to the size of your device. The screenshots shown in this
    section are based on an older iPhone-sized stack.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将卡片大小设置为您的设备大小。本节中显示的截图是基于较旧的 iPhone 大小的堆栈。
- en: Go to **Standalone Application Settings** and set the values in the same way
    that we did while testing the **Location** feature.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **独立应用程序设置** 并以我们在测试 **位置** 功能时相同的方式设置值。
- en: Set the name of the first card to be `home`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个卡片的名称设置为 `home`。
- en: Create a **Sort by Time** button, a **Sort by Location** button, one field named
    `reminders`, another field named `data`, and two buttons named `Create Reminder…`
    and `Create Location…`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **按时间排序** 按钮、一个 **按位置排序** 按钮、一个名为 `reminders` 的字段、另一个名为 `data` 的字段，以及两个名为
    `Create Reminder…` 和 `Create Location…` 的按钮。
- en: Add one more button named `Delete Location or Reminder`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Delete Location or Reminder` 的按钮。
- en: Make sure that both the fields have their **Lock text** and **Don't wrap** box
    checked.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保这两个字段都勾选了 **锁定文本** 和 **不换行** 复选框。
- en: You should now have a screen that looks something like the following screenshot:![Time
    for action – creating the reminder app screens](img/image00289.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该有一个看起来像以下截图的屏幕：![行动时间 – 创建提醒应用屏幕](img/image00289.jpeg)
- en: Make a new card and name it `location`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一张新卡片，并将其命名为 `location`。
- en: 'Add a field and set its contents to: `Enter the latitude and longitude for
    this location`.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个字段并设置其内容为：`输入此位置的纬度和经度`。
- en: Add two input fields named `latitude`, and `longitude`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个名为 `latitude` 和 `longitude` 的输入字段。
- en: Create a button named `Set to Current Location`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Set to Current Location` 的按钮。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Avoid typos**'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**避免拼写错误**'
- en: Although we have placed a field for you to type in the location by hand, use
    the **Set to Current Location** button if possible or at least use that at your
    current location to see the format that is required.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们为您提供了一个手动输入位置的字段，但如果可能的话，请使用 **设置为当前位置** 按钮，或者至少在您当前的位置使用它，以查看所需的格式。
- en: 'Add another instructions field that says: `Enter a name for this location:`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个指示字段，内容为：`为此位置输入名称：`。
- en: Add a third input field named `location name`. Note that on older phones with
    smaller screens, this field location needs to be toward the top of the screen,
    so that it isn't covered by the keyboard popup.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `location name` 的第三个输入字段。请注意，在屏幕较小的旧手机上，此字段位置需要靠近屏幕顶部，以免被键盘弹出窗口覆盖。
- en: Finally, add a button named `Add Location` and `Cancel`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个名为 `Add Location` 和 `Cancel` 的按钮。
- en: For this card, all the three fields need their **Lock text** box to be unchecked.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这张卡片，所有三个字段都需要取消勾选 **锁定文本** 复选框。
- en: The card should look like the following screenshot:![Time for action – creating
    the reminder app screens](img/image00290.jpeg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此卡片应看起来像以下截图：![行动时间 – 创建提醒应用屏幕](img/image00290.jpeg)
- en: Make a third card and name it `reminder`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第三个卡片并将其命名为 `reminder`。
- en: 'Add two instructions fields that say: `Enter a title for this reminder:` and
    `Enter a brief description:`.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个指示字段，内容分别为：`为此提醒输入标题：` 和 `输入简要描述：`。
- en: Create two more input fields named `title`, and `description`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为 `title` 的输入字段。
- en: Create three buttons named `Set Related Location`, `Set Date`, and `Set Time`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个按钮，分别命名为 `Set Related Location`、`Set Date` 和 `Set Time`。
- en: Add three fields next to those buttons, which will be used to show the user
    that the selection they made has taken place. Name the fields `location field`,
    `date field`, and `time field`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些按钮旁边添加三个字段，这些字段将用于向用户显示他们所做的选择已发生。将字段命名为 `location field`、`date field` 和
    `time field`。
- en: Create a checkbox button named `Play Alert Sound`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Play Alert Sound` 的复选框按钮。
- en: Lastly, create two more buttons named `Add Reminder` and `Cancel`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建两个名为 `Add Reminder` 和 `Cancel` 的按钮。
- en: Arrange all of these elements to appear as shown in the following screenshot:![Time
    for action – creating the reminder app screens](img/image00291.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些元素排列成以下截图所示的样子：![开始行动 – 创建提醒应用屏幕](img/image00291.jpeg)
- en: '*What just happened?*'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We've made all of the screens needed for the app to function. That was the easy
    bit. Just wait until you see how much typing you are going to do!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为应用功能制作了所有必要的屏幕。这是简单的一步。只需等待你看到将要进行的输入量！
- en: Stack-level scripts
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈级别脚本
- en: There is quite a bit of code ahead. Describing it feature by feature would require
    us to jump all over the place, which would add to the existing scripts in some
    cases and we would easily get lost in this situation. So, instead of doing it
    that way, we'll look at the code for each card at a time and also at the handlers
    that go into the stack script. It's shown here in the *Time for action* section,
    mainly to give you a break now and then! Without further ado, the stack script…
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面有一大段代码。逐个功能描述会让我们四处跳跃，这可能会在某些情况下增加现有脚本的复杂性，我们很容易在这种情况中迷失方向。所以，我们不会那样做，而是每次查看一个卡片的代码，以及进入栈脚本的处理器。这主要在
    *开始行动* 部分展示，主要是为了给你提供休息的机会！现在，我们不再拖延，直接展示栈脚本…
- en: Time for action – adding stack-level functions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动 - 添加栈级别函数
- en: 'For this app, we''re going to put some of the logic in the buttons on the cards
    themselves, but it still leaves a good amount that will have to go into the Stack
    script. To make it less overwhelming, we''ll show one or two functions at a time
    followed by some explanation about any interesting points in the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们将在卡片本身的按钮中放置一些逻辑，但这仍然留下了一大堆需要放入栈脚本中的内容。为了减少压力，我们将一次展示一个或两个函数，并在接下来的步骤中解释任何有趣之处：
- en: Open the Stack script.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开栈脚本。
- en: 'Type in the the following handlers:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下处理程序：
- en: '[PRE6]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android OS keyboards generally have a button dedicated to the function putting
    the keyboard away. On iOS, this isn't the case, as the button that sits where
    the *Return* key should be, may have a special word instead, such as *Send*, or
    *Done*. Unfortunately, we are entering text into fields that are able to take
    a return character. To solve the issue, we set the Return button to say *Done*,
    which will lead the user to expect the keyboard to go away when that button is
    pressed. We will also trap the `returnInField` message and use it as a way to
    actually put the keyboard away.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android 操作系统的键盘通常有一个专门的按钮用于关闭键盘。在 iOS 上，情况并非如此，因为原本应该放置 *Return* 键的按钮可能显示一个特殊词，例如
    *发送* 或 *完成*。不幸的是，我们正在输入能够接受回车字符的字段。为了解决这个问题，我们将回车按钮设置为显示 *完成*，这样当按下该按钮时，用户就会期待键盘消失。我们还将捕获
    `returnInField` 消息，并利用它来实际关闭键盘。
- en: 'Next, type in the functions that will read, and write the list of reminders
    as a text file to the documents folder on your device:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入将读取和写入设备文档文件夹中提醒列表文本文件的函数：
- en: '[PRE7]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These two functions are using the straightforward ability that LiveCode has
    to read and write text files. Note that `specialFolderPath` is being used to help
    work out where the file will be saved. This works even when you test on desktop
    machines. The LiveCode Dictionary shows a full list of special folder paths, including
    many that don't apply to mobile apps.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个函数正在使用 LiveCode 直接读取和写入文本文件的能力。请注意，`specialFolderPath` 正在被用来帮助确定文件将保存的位置。即使在桌面机器上进行测试，这也同样有效。LiveCode
    字典显示了所有特殊文件夹路径的完整列表，包括许多不适用于移动应用的情况。
- en: 'You can put the following `showdata` function into the Home card''s Card script
    as well, but having it in the Stack level keeps it near other functions that are
    related to it. Type it in now:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将以下 `showdata` 函数放入主卡片脚本中，但将其放在栈级别可以使其靠近与之相关的其他函数。现在就输入它：
- en: '[PRE8]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you recall the sample text file from earlier, the `showdata` function takes
    each line and splits the tab delimited items into chunks of information to present
    to the user. One cute trick is that the notification time, which is a long number
    of seconds, is converted into a human-readable form, showing both the date and
    time of the notification. The `data` field is used to show the raw data that has
    been saved. In the final application, you would not show this, but it's handy
    to check whether the reminder information looks correct or not.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还记得之前的示例文本文件，`showdata`函数会取每一行，并将制表符分隔的项拆分成信息块以呈现给用户。一个巧妙的技巧是将通知时间，即一个长秒数，转换为可读形式，显示通知的日期和时间。`data`字段用于显示已保存的原始数据。在最终应用程序中，你不会显示这个，但检查提醒信息是否正确是很有用的。
- en: 'The last functions in the Stack script are used to set up the notifications
    themselves:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stack脚本中的最后几个函数用于设置通知本身：
- en: '[PRE9]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many mobile apps that use notifications don't ever clear them. In general, maybe
    they don't need to be cleared. Once they go by, they're gone for good! Well, not
    always. Sometimes, you'll go into an app just ahead of when a notification comes
    and you'd do the task, only to then be pestered with notifications about something
    you already did! In our app, we clear all the notifications that were due and
    recreate the whole list again. This way, any that you have deleted won't come
    back to haunt you later. To help in debugging, `alertPayload` is filled in with
    the entire reminder entry and will be shown to you when the notification comes
    in.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多使用通知的移动应用永远不会清除它们。一般来说，可能不需要清除。一旦它们过去，它们就会永远消失！好吧，并不总是这样。有时，你会在通知到来之前进入一个应用，然后完成任务，但随后会因你已完成的任务而受到通知的打扰！在我们的应用中，我们会清除所有到期的通知，并重新创建整个列表。这样，你删除的任何内容都不会在以后回来困扰你。为了帮助调试，`alertPayload`会被填充整个提醒条目，并在通知到来时显示给你。
- en: '*What just happened?*'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In addition to getting your fingers nicely warmed up, you entered all the functions
    to read and write the reminders data and to create and receive the notification
    messages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让你的手指得到很好的预热外，你还输入了所有读取和写入提醒数据以及创建和接收通知消息的函数。
- en: Home card scripts
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主页卡片脚本
- en: We're not going to put any scripts into the card level; they can just be inside
    various buttons. Starting with the ones on the first card.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在卡片级别中放入任何脚本；它们可以仅位于各种按钮内部。从第一张卡片上的按钮开始。
- en: Time for action – making the home card buttons work
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使主页卡片按钮工作
- en: 'The **Sort** **by Location** button''s script is quite something. You should
    look forward to that! First, we''ll start with the **Sort by Time** button:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**按位置排序**按钮的脚本相当有特色。你应该期待那个！首先，我们将从**按时间排序**按钮开始：'
- en: Edit the script of the **Sort by Time** button on the first card.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑第一张卡片上**按时间排序**按钮的脚本。
- en: 'Type in the following short handler:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下简短的处理器：
- en: '[PRE10]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: LiveCode's sort command is powerful and in the preceding case, it sorts the
    list of reminders based on the notification seconds value. Once the lines are
    sorted, the list is recreated for the user to see and the text file is rewritten.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LiveCode的排序命令功能强大，在前面的例子中，它是根据通知秒数值对提醒列表进行排序。一旦行排序完成，列表就会为用户重新创建，并且文本文件将被重写。
- en: Get mentally prepared and then edit the script of the **Sort by Location** button.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在心理上做好准备，然后编辑**按位置排序**按钮的脚本。
- en: 'Type in all of the following lines of code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下所有代码行：
- en: '[PRE11]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first part of the `mouseUp` handler just gets your current location. The
    `distance` and `toRad` functions are the same ones we looked at earlier. The magic
    happens in the way that the sort line uses a function to determine the sort order.
    By passing the Location that you associated with each reminder into the `getdistance`
    function, it's possible to run through the list of locations to find a match and
    to then use that location's latitude and longitude to measure the distance from
    your current location. This distance is then used by the sort command to decide
    the order of the lines.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mouseUp`处理器的第一部分只是获取你的当前位置。`distance`和`toRad`函数是我们之前看过的相同函数。魔法在于排序行使用一个函数来确定排序顺序。通过将你与每个提醒关联的位置传递给`getdistance`函数，可以遍历位置列表以找到匹配项，然后使用该位置的纬度和经度来测量与当前位置的距离。这个距离随后被排序命令用来决定行的顺序。'
- en: 'For a moment''s relaxation, edit the **Create Reminder…** button script and
    set it to this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了短暂的放松，编辑**创建提醒…**按钮的脚本，并设置为以下内容：
- en: '[PRE12]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Likewise, set the **Create Location…** button script to the following:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将**创建位置…**按钮的脚本设置为以下内容：
- en: '[PRE13]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the last script for this card, edit the **Delete Location or Reminder**
    button script and type the following in:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这张卡片的最后一个脚本，编辑**删除位置或提醒**按钮的脚本，并输入以下内容：
- en: '[PRE14]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The delete handler uses `mobilePick` with a particular set of parameters. One
    interesting parameter is `checkmark`. Asking for that type of picker will then
    show a list with checkboxes in it when you're on iPad or Android. That would enable
    you to choose several entries to delete in one go. Hence, the repeat loop that
    goes through as many items as you choose.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 删除处理程序使用`mobilePick`和一组特定的参数。一个有趣的参数是`checkmark`。请求这种类型的选择器会在iPad或Android上显示带有复选框的列表。这将使您能够一次性选择多个条目进行删除。因此，重复循环会遍历您选择的每个项目。
- en: '*What just happened?*'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: All being well, you have recovered by now after trying to understand the sort-by-location
    function! You can at least see how tough the Stack script would have been if all
    of this code would have been placed in that one location. Let's go on to the next
    card…
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您现在应该已经理解了按位置排序的功能！至少您可以看到，如果所有这些代码都放在一个地方，Stack脚本会多么困难。让我们继续到下一张卡片…
- en: Creating a location card
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建位置卡片
- en: Next up, we will create the card that we will show when the user touches the
    **Create a Location…** button on the first card.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建当用户在第一张卡片上触摸**创建一个位置…**按钮时显示的卡片。
- en: Time for action – making the location card work
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使位置卡片生效
- en: 'The Location card has three fields in it for latitude, longitude, and a title
    for the location. The user could type in the details manually, but if they happen
    to be at the location in question, there''s a button there that will grab the
    location and fill in the numbers automatically. The following steps will guide
    you in making the location card work:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 位置卡片中有三个字段，用于纬度、经度和位置的标题。用户可以手动输入详细信息，但如果他们恰好在相关位置，那里有一个按钮可以抓取位置并自动填写数字。以下步骤将指导您使位置卡片生效：
- en: 'Edit the script of the **Set to Current Location** button and type in the following
    lines of code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**设置为当前位置**按钮的脚本，并输入以下代码行：
- en: '[PRE15]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nothing too tricky here; we just captured the location and stored the latitude
    and longitude entries in the two fields.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里没有什么太复杂的；我们只是捕获了位置，并将纬度和经度条目存储在两个字段中。
- en: 'Edit the script of the **Cancel** button and change it to the following easy
    script:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**取消**按钮的脚本，并将其更改为以下简单的脚本：
- en: '[PRE16]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the last item for this card, edit the **Add Location** button script and
    type in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这张卡片最后的条目，编辑**添加位置**按钮的脚本，并输入以下代码：
- en: '[PRE17]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Most of the handler just checks whether the user entered the required information.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数处理程序只是检查用户是否输入了所需的信息。
- en: '*What just happened?*'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: A lot less has happened than what happened on the first card! However, it was
    important all the same. Now, we have a way where the user can set up a location
    to be used by the reminders that they have created. That's where we're headed
    now…
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情比第一张卡片上发生的事情要少得多！然而，它同样重要。现在，我们有一种方法可以让用户为创建的提醒设置一个位置。这就是我们现在要去的方向…
- en: The reminder entry form
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提醒输入表单
- en: This last card is essentially an entry form; we just want to ask the user what
    the reminder is for. There are some tricky aspects to it though and one or two
    lengthy functions to cope with that.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这张卡片本质上是一个输入表单；我们只想询问用户提醒是为了什么。尽管如此，它也有一些棘手的地方和一两个较长的函数来处理这些问题。
- en: Time for action – taking in information about the reminder
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 输入提醒信息
- en: 'The Reminder card makes good use of pickers. There is little typing for the
    user to do, and because they pick an entry from a list we present, there''s a
    good chance the information won''t have any typos in it! Use the following steps
    for taking in information about the reminder:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒卡片很好地利用了选择器。用户几乎不需要输入，因为他们会从我们提供的列表中选择一个条目，所以信息中不太可能出现任何错误！按照以下步骤输入提醒的信息：
- en: 'Edit the script of the **Set Related Location** button and type in the following
    lines of code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**设置相关位置**按钮的脚本，并输入以下代码行：
- en: '[PRE18]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We made the first word of each line in the reminders data either Location or
    Reminder. Here's one place where we can make use of that. Once we pull out the
    lines that are "Location", presenting them inside a picker is easy.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将提醒数据中每行的第一个单词设置为位置或提醒。这里是我们可以利用的一个地方。一旦我们提取出“位置”行，在选择器中呈现它们就很容易了。
- en: 'Edit the script of the **Set Date** button and change it to the following easy-to-understand
    script:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**设置日期**按钮的脚本，并将其更改为以下易于理解的脚本：
- en: '[PRE19]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set the script of the **Set Time** button to the following, which is almost
    an identical script:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**设置时间**按钮的脚本设置为以下内容，这几乎是一个完全相同的脚本：
- en: '[PRE20]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **Cancel** button script is the same as it is on the Location card given
    here:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**取消**按钮的脚本与这里给出的位置卡片上的脚本相同：'
- en: '[PRE21]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Last, and far from least, the **Add Reminder** button script does all the hard
    work:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，**添加提醒**按钮的脚本做了所有艰苦的工作：
- en: '[PRE22]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the preceding script just combines the different bits of information
    together into one reminder entry with the parts delimited with a tab character.
    However, there is one bit of cute arithmetic going on in there too. At the start
    of this chapter, we looked at how Unix Time differs from the actual time at a
    rate of 0.6 seconds per year. If you want to set a notification at 8 AM five years
    from now, you can't take the value that the Set Time button gave you because that
    refers to today's 8 AM. You can't take the value that Set Date gave you because
    that would be midnight. So, by converting the time value to the short date format
    and then back to the seconds format, you can find out what the Unix Time was at
    midnight of the current day. Subtracting that from the value that Set Time gave
    you let's you know the number of seconds since midnight, regardless of how many
    seconds behind Unix Time is. Adding that value to the one from Set Date will give
    us an exact Unix Time in seconds for the notification to occur. Under iOS, there
    is a picker type that allows you to set the date and time together, but as that
    isn't on Android, we've used a way that works for both.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述脚本的大部分只是将不同的信息片段组合成一个带有制表符分隔的提醒条目。然而，其中也有一些有趣的算术操作。在本章的开头，我们探讨了Unix时间与实际时间在每年0.6秒的速率上的差异。如果你想设置五年后的早上8点的提醒，你不能直接使用设置时间按钮给出的值，因为那是指今天的早上8点。你也不能使用设置日期给出的值，因为那将是午夜。所以，通过将时间值转换为短日期格式，然后再转换回秒格式，你可以找出当前天午夜时的Unix时间。从设置时间给出的值中减去这个值，你就可以知道自午夜以来经过的秒数，无论Unix时间落后多少。将这个值加到设置日期给出的值上，将给出通知发生的精确Unix时间（秒）。在iOS中，有一个选择器类型允许你同时设置日期和时间，但由于Android上没有这个功能，我们使用了适用于两者的方法。
- en: '*What just happened?*'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Phew! We got to the end! Try to run the app on your device. If your fingers
    aren't too numb, that is! Honestly, you could bet a fortune that it won't work
    the first time, but if it works well enough to show the raw text in the data field
    on the first card, hopefully, you'll be able to track down any errors in the code.
    You can also type in some test data into the stack on your computer and at least
    test the functions that don't require device-specific features.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！我们终于到达了终点！尝试在你的设备上运行应用。如果你的手指不太麻木的话！说实话，你可以打赌它第一次可能不会工作，但如果它足够好，能够在第一张卡片的数据字段中显示原始文本，那么希望你能追踪到代码中的任何错误。你还可以在你的电脑上的堆栈中输入一些测试数据，至少测试不需要特定设备功能的函数。
- en: Have a go hero – nice transitions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 勇敢的尝试者——流畅的过渡
- en: Really, if you've managed to get through and entered all that code to the point
    that the app is working, you're already a hero! However, read the section in the
    iOS and Android release notes for LiveCode about *Visual effects support*. Check
    whether you can get some typical mobile OS transitions happening as you go to
    and from the different cards.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，如果你已经成功通过并输入了所有这些代码，使得应用开始工作，那么你已经是一个英雄了！然而，请阅读iOS和Android发布说明中关于LiveCode的*视觉效果支持*的部分。检查你是否可以在进入和离开不同卡片时实现一些典型的移动操作系统过渡效果。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was way more exciting than expected! A reminder app is absolutely
    not quite as impressive as Angry Birds, but making use of the location features
    of a mobile device makes it a little more novel. Along the way, we covered the
    process of reading and writing data to the special documents folder as well as
    the use of pickers for straightforward lists, dates, and time. We also showed
    how to read the current location of the device and how to set up local notification
    events.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章比预期的要激动人心得多！提醒应用绝对没有愤怒的小鸟那么令人印象深刻，但利用移动设备的地理位置功能使其变得稍微新颖一些。在这个过程中，我们介绍了读取和写入特殊文档文件夹中的数据以及使用选择器来处理简单的列表、日期和时间的方法。我们还展示了如何读取设备的当前位置以及如何设置本地通知事件。
- en: In the best of cases, you can manage to make a mobile app in a few hours or
    a few days, but there is quite a lot that goes on before you can submit the app
    to the various app stores. Sounds like a good topic for the next chapter!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在最好的情况下，你可以在几小时或几天内制作出一个移动应用，但在你能够将应用提交到各个应用商店之前，还有很多事情要做。这听起来像是下一章的好主题！
