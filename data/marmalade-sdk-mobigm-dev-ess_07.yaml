- en: Chapter 7. Adding Sound and Video
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：添加声音和视频
- en: 'Your game may look stunning, but if it''s silent your audience will probably
    find it a dull experience. Fortunately, Marmalade allows us to remedy this with
    its support for sound and video playback. In this chapter we will learn about
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏可能看起来很惊艳，但如果它是静音的，观众可能会觉得体验很无聊。幸运的是，Marmalade通过支持声音和视频播放来解决这个问题。在本章中，我们将学习以下内容：
- en: Playing back audio files recorded in formats such as MP3
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放记录在MP3等格式的音频文件
- en: Adding multiple simultaneous sound effects using sound samples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声音样本添加多个同时音效
- en: Playing back full-motion video clips
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放全动作视频剪辑
- en: Multimedia support in Marmalade
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade的多媒体支持
- en: Modern mobile phones and tablet devices are now capable of playing back good
    quality music and video, so it makes sense that Marmalade should provide ways
    in which we can harness these abilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现代智能手机和平板设备现在能够播放高质量的音乐和视频，因此Marmalade提供让我们利用这些能力的方法是有意义的。
- en: Marmalade provides three different API layers that apply to multimedia support.
    These are s3eSound, s3eAudio, and s3eVideo. Unsurprisingly, the latter relates
    to the playback of video files, but you may be wondering why there are two APIs
    provided relating to sound.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade提供了三个不同的API层，适用于多媒体支持。这些是s3eSound、s3eAudio和s3eVideo。不出所料，后者与视频文件的播放有关，但您可能想知道为什么提供了两个与声音相关的API。
- en: The difference between s3eSound and s3eAudio is that the former is generally
    used for sound effects while the latter is normally used for music. The s3eSound
    API allows us to play several different sound effects at the same time, but by
    default only provides support for 16-bit mono-PCM sound samples. The s3eAudio
    API on the other hand allows us to play compressed formats such as MP3, but we
    are limited (on most devices) to playing a single audio track.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: s3eSound和s3eAudio之间的区别在于，前者通常用于音效，而后者通常用于音乐。s3eSound API允许我们同时播放多个不同的音效，但默认情况下只提供对16位单声道PCM声音样本的支持。另一方面，s3eAudio
    API允许我们播放压缩格式，如MP3，但（在大多数设备上）我们只能播放单个音频轨道。
- en: The good news is that most modern devices lets us have the best of both worlds
    by allowing both s3eSound and s3eAudio to be used at the same time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，大多数现代设备允许我们同时使用s3eSound和s3eAudio，从而让我们享受到两者的最佳效果。
- en: In the following sections we'll look at how to make use of all three of these
    APIs and will also take a look at another module called `SoundEngine`, that makes
    using the s3eSound API a bit easier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何使用这三个API，并也会看看另一个名为`SoundEngine`的模块，它使得使用s3eSound API变得更容易。
- en: The s3eAudio API
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: s3eAudio API
- en: Let's start with the quickest and easiest way of allowing our games to stop
    being the strong, silent type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最快捷、最简单的方法开始，让我们的游戏不再只是沉默的强者。
- en: The s3eAudio API allows us to play compressed music formats such as MP3 and
    AAC. Some devices may also allow us to play other formats, such as MIDI files.
    Marmalade makes use of whichever audio codecs a particular device may have built-in
    rather than decoding the audio itself, so be sure to check that your chosen audio
    format is supported by all the devices you wish to target.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: s3eAudio API允许我们播放压缩的音乐格式，如MP3和AAC。某些设备也可能允许我们播放其他格式，如MIDI文件。Marmalade使用特定设备可能内置的任何音频编解码器，而不是解码音频本身，因此请确保你选择的音频格式支持你希望针对的所有设备。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to its ubiquity, it is recommended that you use MP3 as your format of choice.
    There are very few devices (if any) that can't play an MP3 file and the format
    itself allows you a wide variety of bit rates so you can trade-off between audio
    quality and file size.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其普遍性，建议您使用MP3作为首选格式。很少有设备（如果有的话）不能播放MP3文件，而且该格式本身提供了广泛的比特率，这样您可以在音频质量和文件大小之间进行权衡。
- en: Let's now take a look at how we can get an audio track playing and what other
    functionality the s3eAudio API provides for us. There is nothing we need to add
    to our MKB file in order to allow us to use s3eAudio, as it is one of the low
    level APIs of Marmalade that is always available for use. All we need to do is
    include the header file `s3eAudio.h` in any source file that needs access to s3eAudio
    functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何播放音频轨道，以及s3eAudio API为我们提供了哪些其他功能。为了使用s3eAudio，我们不需要在MKB文件中添加任何内容，因为它是Marmalade的低级API之一，始终可用。我们只需要在需要访问s3eAudio函数的任何源文件中包含头文件`s3eAudio.h`。
- en: Starting audio playback
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始音频播放
- en: 'There are two ways of starting the playback of an audio track. The first allows
    us to specify the filename of the audio track we want to play and the number of
    times we would like the track to repeat, and looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以开始播放音频轨道。第一种允许我们指定要播放的音频轨道的文件名和轨道重复的次数，看起来像这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The filename is just a standard C, null-terminated string and is relative to
    the `data` directory when run from Windows or the application install directory
    on the device. Specifying a number for the repeat count will cause the audio track
    to play that many times, while setting it to zero will cause the track to loop
    continuously.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名只是一个标准的C语言，以null结尾的字符串，当从Windows运行时相对于` data`目录，或者相对于设备上的应用程序安装目录。指定重复次数的数字将使音频轨道播放指定次数，而将其设置为零将使轨道连续循环。
- en: 'The other method is to play the audio track from an area of memory as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是按照以下方式从内存区域播放音频轨道：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parameters `apBuffer` and `aBufferLength` provide the memory location where
    the audio track resides and the length of audio data in bytes. The repeat count
    is specified in the same manner as with `s3eAudioPlay`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 参数` apBuffer`和` aBufferLength`提供了音频轨道所在的内存位置和音频数据字节数的长度。重复次数的指定方式与` s3eAudioPlay`相同。
- en: In most cases we will find that the first method is good enough since it is
    easy to use and doesn't require us to allocate blocks of memory and fill it with
    data. You may find that the buffer method provides slightly faster initial playback
    if you have preloaded the audio data, but on most recent devices the difference
    is negligible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们会发现第一种方法就足够好了，因为它易于使用，不需要我们分配内存块并填充数据。如果你已经预加载了音频数据，可能会发现缓冲区方法提供了稍微快一点的初始播放，但在大多数最新设备上，这种差异是可以忽略不计的。
- en: If you make a call to either of these functions while an audio track is currently
    playing, that track will be stopped and the new track will begin playing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个音频轨道正在播放时调用这些函数中的任何一个，该轨道将被停止，并开始播放新轨道。
- en: Pausing, resuming, and stopping playback
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停、恢复和停止播放
- en: Once an audio track is playing, we can pause playback by calling the `s3eAudioPause`
    function. The audio can be started again from the point at which it was paused
    by calling `s3eAudioResume`. Finally, to stop playback completely just call `s3eAudioStop`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦音频轨道开始播放，我们可以通过调用` s3eAudioPause`函数来暂停播放。可以通过调用` s3eAudioResume`从暂停点重新开始播放音频。最后，要完全停止播放，只需调用`
    s3eAudioStop`。
- en: All three of these functions take no parameters and will return `S3E_RESULT_SUCCESS`
    when no errors occur. An error is raised if any of these functions are called
    when it makes no sense to do so, for example calling `s3eAudioPause` when there
    is no audio playing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数都不需要参数，在没有错误发生的情况下将返回` S3E_RESULT_SUCCESS`。如果在没有意义的情况下调用这些函数，例如在没有音频播放时调用`
    s3eAudioPause`，则会引发错误。
- en: Changing volume
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变音量
- en: Like most of the low level APIs in Marmalade, s3eAudio features a pair of functions
    called `s3eAudioGetInt` and `s3eAudioSetInt` that are used to change attributes
    related to that API. In s3eAudio, one of the things we use these functions for
    is to change the volume of audio playback.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与Marmalade中的大多数低级API一样，s3eAudio具有一对函数` s3eAudioGetInt`和` s3eAudioSetInt`，用于更改与该API相关的属性。在s3eAudio中，我们使用这些函数之一来更改音频播放的音量。
- en: 'To set the playback volume we can make the following call:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置播放音量，我们可以进行以下调用：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned example we set the volume to half of `S3E_AUDIO_MAX_VOLUME`,
    which is the maximum allowed volume.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们将音量设置为` S3E_AUDIO_MAX_VOLUME`的一半，这是允许的最大音量。
- en: 'To determine the current volume we use this code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定当前音量，我们使用以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can also request the default volume for audio by passing in the value `S3E_AUDIO_VOLUME_DEFAULT`.
    This is the default volume level for playing audio and has been chosen by the
    Marmalade SDK so as to provide a fairly consistent volume level across all devices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过传入值` S3E_AUDIO_VOLUME_DEFAULT`来请求音频的默认音量。这是播放音频的默认音量级别，由Marmalade SDK选择，以便在所有设备上提供相当一致的音量级别。
- en: Other audio queries
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他音频查询
- en: 'The `s3eAudioGetInt` function allows us to make several other queries regarding
    audio playback. The following table shows which properties can be specified:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '` s3eAudioGetInt`函数允许我们进行关于音频播放的几个其他查询。以下表格显示了可以指定的属性：'
- en: '| Property | Description |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_AUDIO_STATUS` | Returns current audio status—one of `S3E_AUDIO_STOPPED`,
    `S3E_AUDIO_PLAYING`, `S3E_AUDIO_PAUSED`, or `S3E_AUDIO_FAILED`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_STATUS` | 返回当前音频状态——`S3E_AUDIO_STOPPED`、`S3E_AUDIO_PLAYING`、`S3E_AUDIO_PAUSED`或`S3E_AUDIO_FAILED`之一。
    |'
- en: '| `S3E_AUDIO_POSITION` | Returns the current position in the audio track in
    milliseconds, or `0` if no track is playing. Note that not all platforms support
    this feature. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_POSITION` | 返回音频轨道中的当前位置，单位为毫秒，如果没有轨道正在播放，则返回`0`。请注意，并非所有平台都支持此功能。
    |'
- en: '| `S3E_AUDIO_CHANNEL` | Returns the currently selected audio channel. This
    property can also be used in `s3eAudioSetInt` to select which audio channel the
    future audio commands will be applied to. See the following property for more
    on audio channels. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_CHANNEL` | 返回当前选定的音频通道。此属性也可以在`s3eAudioSetInt`中使用，以选择将应用于未来音频命令的音频通道。有关音频通道的更多信息，请参阅以下属性。
    |'
- en: '| `S3E_AUDIO_NUM_CHANNELS` | Returns the number of audio channels available.
    On most platforms this will return `1` since most devices only allow a single
    audio track to be played at any time. Some devices provide more than one channel,
    meaning more than one audio track can be played simultaneously. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_NUM_CHANNELS` | 返回可用的音频通道数。在大多数平台上，这将返回`1`，因为大多数设备在任何时候只允许播放一个音频轨道。一些设备提供多个通道，这意味着可以同时播放多个音频轨道。'
- en: '| `S3E_AUDIO_MUTES_S3ESOUND` | Returns `1` if the hardware is not capable of
    outputting sound through both s3eAudio and s3eSound at the same time. In this
    instance playing an audio track will cause s3eSound processing to continue, but
    without actually producing any output. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_MUTES_S3ESOUND` | 如果硬件无法同时通过s3eAudio和s3eSound输出声音，则返回`1`。在这种情况下，播放音频轨道将继续s3eSound处理，但不会实际产生任何输出。
    |'
- en: '| `S3E_AUDIO_DURATION` | Returns the length, in milliseconds, of the track
    currently playing. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_DURATION` | 返回当前播放的轨道长度，单位为毫秒。 |'
- en: '| `S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE` | Returns `1` if the hardware is
    able to play an audio track by streaming from a URL. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE` | 如果硬件能够通过从URL流式传输播放音频轨道，则返回`1`。
    |'
- en: End of track notification
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轨道结束通知
- en: There are two methods we can use to determine when an audio track has finished.
    One is to use a polled approach, the other is to make use of a callback.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法来确定音频轨道何时完成。一种方法是使用轮询方法，另一种方法是使用回调。
- en: 'To poll whether an audio track has completed or not, we can do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要轮询音频轨道是否已完成，我们可以执行以下操作：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function returns `S3E_TRUE` if the audio is currently playing, or `S3E_FALSE`
    if it is stopped or paused. This function is actually just a shortcut for calling
    `s3eAudioGetInt` with the property `S3E_AUDIO_STATUS`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回`S3E_TRUE`，如果音频正在播放，或者返回`S3E_FALSE`，如果它已停止或暂停。实际上，这个函数只是调用`s3eAudioGetInt`并带有属性`S3E_AUDIO_STATUS`的一个快捷方式。
- en: 'The callback approach is also very simple to use, as the following code snippet
    shows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法也非常简单易用，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The callback function will be called whenever an audio track finishes and will
    pass the pointer to user data supplied as the last parameter in the `s3eAudioRegister`
    call by using the `apUserData` argument. It will not be called if we have asked
    the audio track to be looped unless it is the last repetition. The function will
    also be called if the audio is stopped due to an error, such as a corrupted track.
    We can determine whether completion was caused due to error by calling the `s3eAudioGetError`
    function, which returns an error code of the enumerated type `s3eAudioError`.
    A complete list of error codes can be found in `s3eAudio.h`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当音频轨道完成时，回调函数将被调用，并将通过`apUserData`参数传递的用户数据指针传递。如果我们要求音频轨道循环播放，除非是最后一次重复，否则不会调用该函数。如果由于错误（如损坏的轨道）而停止音频，该函数也会被调用。我们可以通过调用返回枚举类型`s3eAudioError`的错误代码的`s3eAudioGetError`函数来确定完成是否由错误引起。错误代码的完整列表可以在`s3eAudio.h`中找到。
- en: The decision of whether to use the polling or callback-based approach depends
    on your application, and indeed quite often in games we don't even really care
    that much about when an audio track has finished as we often just want the same
    track to loop forever until a new piece of audio is required. If you are just
    waiting for a jingle to finish during a splash screen, the polled method is probably
    adequate, but if you want to join several tracks together one after the other,
    the callback approach would probably lead to a clean solution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用轮询或基于回调的方法取决于你的应用程序，实际上在游戏中我们通常并不特别关心音频轨道何时结束，因为我们通常只是希望同一轨道无限循环，直到需要新的音频片段。如果你只是在启动画面期间等待铃声结束，轮询方法可能就足够了，但如果你想要将几个轨道依次连接起来，回调方法可能带来一个干净的解决方案。
- en: The s3eSound API
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: s3eSound API
- en: If you want to add spot sound effects to your game, such as laser bolts and
    explosions, the s3eSound API is what you need to use. This API allows multiple
    sound samples to be played simultaneously at different volumes and pitch by mixing
    them together into a single output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在你的游戏中添加点音效，比如激光束和爆炸声，你需要使用s3eSound API。这个API允许同时以不同的音量和音调播放多个声音样本，通过将它们混合成一个单一的输出。
- en: To make use of the s3eSound API, simply include the file `s3eSound.h` in your
    source code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用s3eSound API，只需在你的源代码中包含文件`s3eSound.h`。
- en: The API expects all sound effects to be supplied as uncompressed 16-bit signed
    PCM. File formats such as WAV are not supported by the API, so you must write
    your own code to load and extract the sample data from such files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: API期望所有音效都作为未压缩的16位有符号PCM提供。API不支持如WAV这样的文件格式，因此你必须编写自己的代码来加载和从这些文件中提取样本数据。
- en: As you read through this section you may start to think that there's an awful
    lot to do in order to play some sound effects. While this may appear to be the
    case, s3eSound is actually a very low-level API and provides enough flexibility
    to allow you to code your own complex sound routines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读这一部分，你可能会开始认为要播放一些音效有很多事情要做。虽然这看起来可能是这样，但s3eSound实际上是一个非常底层的API，提供了足够的灵活性，允许你编写自己的复杂音效程序。
- en: Later in this chapter we will be covering the `SoundEngine` module, which comes
    with Marmalade to provide a wrapper for the s3eSound API. The `SoundEngine` module
    takes care of most of the hard work involved in using the s3eSound API for us
    and also includes the ability to load WAV files directly from a GROUP file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将介绍Marmalade提供的`SoundEngine`模块，它为s3eSound API提供了一个包装器。`SoundEngine`模块为我们处理了使用s3eSound
    API的大部分繁重工作，并且还包括直接从GROUP文件中加载WAV文件的能力。
- en: Starting sound playback
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始播放声音
- en: 'In order to play a sound sample using s3eSound, the first thing we have to
    do is allocate a free sound channel. The s3eSound API provides a limited number
    of channels (we''ll see later how to determine exactly how many are available)
    that allow us to specify a sound sample, volume, and playback rate. The sound
    data for all currently active channels is then mixed together in the inner workings
    of s3eSound into a single waveform and this is what is played through the device''s
    sound hardware. To allocate a free channel, we make the following function call:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用s3eSound播放声音样本，我们首先必须分配一个空闲的声音通道。s3eSound API提供了一定数量的通道（我们稍后会看到如何确定确切的数量），允许我们指定声音样本、音量和播放速率。然后，所有当前活动通道的声音数据在s3eSound的内部工作中被混合成一个单一的波形，这就是通过设备的音频硬件播放的内容。为了分配一个空闲通道，我们进行以下函数调用：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will return the ID number of a free channel, or `-1` if no channel is available.
    Most of the time it is unlikely that a free channel will not be available, but
    if we are playing a lot of sound effects we might want to consider tagging each
    of our sound effects with a priority value and maintaining a list of currently
    active sounds. When we run out of channels, we can check the list of sounds and
    reclaim the channel being used by the lowest priority sound effect, assuming that
    it is at a lower priority than the sound we wish to start of course!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个空闲通道的ID号，如果没有可用通道，则返回`-1`。大多数情况下，不太可能没有空闲通道，但如果我们正在播放很多音效，我们可能想要考虑给每个音效标记一个优先级值，并维护一个当前活动音效的列表。当我们用完通道时，我们可以检查音效列表，并回收被优先级最低的音效使用的通道，当然前提是它比我们希望启动的音效优先级低！
- en: 'Assuming a channel is available we must set up the playback rate of our sample
    data, which is done like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个可用的通道，我们必须设置样本数据的播放速率，这可以通过以下方式完成：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter is the sound channel ID we just allocated. The second parameter
    indicates that we want to set the playback rate for that channel, and the third
    parameter is the actual desired playback rate in Hertz (Hz). The maximum frequency
    that can be set is specified by the define `S3E_SOUND_MAX_FREQ`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们刚刚分配的声音通道ID。第二个参数表示我们想要设置该通道的播放速率，第三个参数是实际期望的播放速率，单位为赫兹（Hz）。可以设置的最大频率由定义`S3E_SOUND_MAX_FREQ`指定。
- en: 'We should also set the volume that we want the sound to be played at, which
    is also done using the `s3eSoundChannelSetInt` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该设置我们想要播放的声音的音量，这同样是通过使用`s3eSoundChannelSetInt`函数来完成的：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The valid values for the `lVolume` parameter are from `0` to the define `S3E_SOUND_MAX_VOLUME`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`lVolume`参数的有效值从`0`到定义`S3E_SOUND_MAX_VOLUME`。'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to change the volume and playback rate at any time once the sound
    has started playing. This makes it possible to implement effects such as volume
    fades or pitch shifts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声音开始播放，就可以随时更改音量和播放速率。这使得可以实现音量淡入淡出或音调转换等效果。
- en: 'Now we can start playing our sound sample. We do this with the following call:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始播放我们的声音样本。我们通过以下调用来完成：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unsurprisingly, we first pass in the channel ID we are using, followed by the
    address in memory where the 16-bit PCM sample data can be found in the `lSampleData`
    parameter. The `lNumSamples` parameter is the number of actual sound samples in
    our waveform (not the number of bytes), and `lRepeatCount` indicates how often
    we want the sound to repeat. A value of `0` will play the sound forever. Finally
    the `lLoopIndex` parameter allows us to specify which sample to start at if the
    sound repeats. This makes it possible to use sounds that only need to repeat a
    portion of the sample data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们首先传入我们正在使用的通道ID，然后是`lSampleData`参数中内存地址，可以在其中找到16位PCM样本数据。`lNumSamples`参数是我们波形中的实际声音样本数量（不是字节数），而`lRepeatCount`表示我们希望声音重复的次数。值为`0`将使声音永远播放。最后，`lLoopIndex`参数允许我们指定如果声音重复，则从哪个样本开始。这使得可以使用只需要重复部分样本数据的声音。
- en: Pausing, resuming, and stopping playback
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停、恢复和停止播放
- en: Once a sound channel has started playing a sound sample, we might want to temporarily
    suspend its playback or stop it entirely. To pause a sound channel we use the
    function `s3eSoundChannelPause`, and we can start playing it again from the paused
    position using `s3eSoundChannelResume`. To stop a sound channel entirely we call
    `s3eSoundChannelStop`. Each of these functions takes a single parameter, which
    is the channel ID we want to affect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声音通道开始播放声音样本，我们可能想要暂时暂停其播放或完全停止它。要暂停声音通道，我们使用`s3eSoundChannelPause`函数，并且我们可以从暂停位置重新开始播放，使用`s3eSoundChannelResume`。要完全停止声音通道，我们调用`s3eSoundChannelStop`。每个这些函数都接受一个单一参数，即我们想要影响的声音通道ID。
- en: 'To determine the current playback status of a particular sound channel we can
    use the `s3eSoundChannelGetInt` function as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定特定声音通道的当前播放状态，我们可以使用`s3eSoundChannelGetInt`函数，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that this function can also be used with the `S3E_CHANNEL_RATE` and `S3E_CHANNEL_VOLUME`
    properties to discover the current sample rate and volume for a particular channel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数也可以与`S3E_CHANNEL_RATE`和`S3E_CHANNEL_VOLUME`属性一起使用，以发现特定通道的当前采样率和音量。
- en: Finally, it is also possible to affect all currently active sound channels at
    once using the functions `s3eSoundPauseAllChannels`, `s3eSoundResumeAllChannels`,
    and `s3eSoundStopAllChannels`. These functions take no inputs and are extremely
    useful for handling situations like going in and out of pause mode, or when switching
    from one part of the game to another (for example, when exiting the title screen
    and entering the main game).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还可以使用`s3eSoundPauseAllChannels`、`s3eSoundResumeAllChannels`和`s3eSoundStopAllChannels`函数一次性影响所有当前活动的声音通道。这些函数不接受任何输入，对于处理进入和退出暂停模式，或从游戏的一个部分切换到另一个部分（例如，退出标题屏幕并进入主游戏）等情况非常有用。
- en: Global sound settings
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局声音设置
- en: 'As well as being able to read and write settings on a per channel basis, we
    can also make settings that affect sound support globally. To do this we use the
    `s3eSoundSetInt` and `s3eSoundGetInt` functions as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够按通道读写设置外，我们还可以设置影响全局声音支持的设置。为此，我们使用`s3eSoundSetInt`和`s3eSoundGetInt`函数，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are some of the more useful values for the `lProperty` parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些 `lProperty` 参数的更有用的值：
- en: '| Property | Description |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_SOUND_VOLUME` | Can be used to read or write the current master sound
    volume. This will scale the volumes of each individual channel appropriately.
    The maximum value is determined by the define `S3E_SOUND_MAX_VOLUME`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_VOLUME` | 可以用来读取或写入当前主音量。这将适当地缩放每个独立通道的音量。最大值由定义 `S3E_SOUND_MAX_VOLUME`
    决定。 |'
- en: '| `S3E_SOUND_DEFAULT_FREQ` | This is the default frequency that will be used
    when starting playback on a sound channel. If all our sound waveforms have the
    same sample rate, it is possible to write to this property once and not have to
    set the sample rate explicitly when playing each individual sound. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_DEFAULT_FREQ` | 这是启动声音通道播放时将使用的默认频率。如果我们的所有声音波形具有相同的采样率，则可以写入此属性一次，而无需在播放每个单独的声音时显式设置采样率。
    |'
- en: '| `S3E_SOUND_NUM_CHANNELS` | A read-only value indicating the maximum number
    of simultaneous sounds that can be played. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_NUM_CHANNELS` | 一个只读值，指示可以同时播放的最大声音数量。 |'
- en: '| `S3E_SOUND_USED_CHANNELS` | A read-only value that shows which sound channels
    are currently in use. This is returned as a bit mask with the least significant
    bit relating to sound channel 0\. This value could be used to determine an available
    sound channel, but for future compatibility using `s3eSoundGetFreeChannel` to
    do this is recommended. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_USED_CHANNELS` | 一个只读值，显示当前正在使用的声音通道。这作为一个位掩码返回，最低有效位与声音通道 0 相关。此值可以用来确定一个可用的声音通道，但为了未来的兼容性，建议使用
    `s3eSoundGetFreeChannel` 来执行此操作。 |'
- en: '| `S3E_SOUND_AVAILABLE` | A read-only value that returns `1` if s3eSound is
    available on the device. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_AVAILABLE` | 一个只读值，如果设备上可用 s3eSound，则返回 `1`。 |'
- en: '| `S3E_SOUND_VOLUME_DEFAULT` | A read-only value that is used as the default
    value for the global sound volume. It can vary from device to device and is intended
    to allow sound output to be at a similar volume across all devices. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_SOUND_VOLUME_DEFAULT` | 一个只读值，用作全局音量的默认值。它可能因设备而异，旨在允许所有设备上的声音输出具有相似的音量。
    |'
- en: There are other values described in the Marmalade documentation, but we won't
    cover them here as they are used for purposes such as custom sound stream generation,
    which are beyond the scope of this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 文档中描述了其他值，但在这里我们不会介绍它们，因为它们用于诸如自定义声音流生成等目的，这些目的超出了本书的范围。
- en: Sound notifications
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音通知
- en: We have already seen how to use a polled method of detecting whether or not
    a sound channel is currently playing, but sometimes it is useful to know exactly
    when a sound sample has finished playing, for example, so we can immediately start
    playing back a new sound effect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用轮询方法来检测声音通道是否正在播放，但有时知道声音样本何时播放完毕也是有用的，例如，这样我们就可以立即开始播放新的声音效果。
- en: 'The s3eSound API allows us to set several different callback functions on a
    per channel basis and we use the functions `s3eSoundChannelRegister` and `s3eSoundChannelUnRegister`
    to enable and disable them as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: s3eSound API 允许我们在每个通道上设置几个不同的回调函数，我们使用 `s3eSoundChannelRegister` 和 `s3eSoundChannelUnRegister`
    函数来启用和禁用它们，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with all other Marmalade callbacks, we specify the code for the callback
    function by passing in a pointer to the function itself, and we can also register
    a block of user data that will be passed into this function when it is triggered.
    There are four different callback types called `S3E_CHANNEL_END_SAMPLE`, `S3E_CHANNEL_STOP_AUDIO`,
    `S3E_CHANNEL_GEN_AUDIO`, and `S3E_CHANNEL_GEN_AUDIO_STEREO`. We will only take
    a look at the first two of them here, as the latter two are concerned with generating
    custom audio streams and are beyond the scope of this book. For an example of
    how to use these callback types, take a look at the source code for the `SoundEngine`
    module, which we'll be covering in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他 Marmalade 回调一样，我们通过传递函数本身的指针来指定回调函数的代码，我们还可以注册一个用户数据块，当它被触发时，此数据块将被传递到该函数中。有四种不同的回调类型，称为
    `S3E_CHANNEL_END_SAMPLE`、`S3E_CHANNEL_STOP_AUDIO`、`S3E_CHANNEL_GEN_AUDIO` 和 `S3E_CHANNEL_GEN_AUDIO_STEREO`。在这里，我们只会查看前两种，因为后两种与生成自定义音频流有关，超出了本书的范围。有关如何使用这些回调类型的示例，请查看
    `SoundEngine` 模块的源代码，我们将在下一节中介绍。
- en: First let's look at the `S3E_CHANNEL_END_SAMPLE` callback, which allows us to
    loop sounds and join different sounds together as a sequence. The registered callback
    function is passed a pointer to an `s3eSoundEndSampleInfo` structure as its first
    parameter. The structure indicates which sound channel has ended by using its
    `m_Channel` member.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`S3E_CHANNEL_END_SAMPLE`回调，它允许我们循环声音并将不同的声音作为一个序列连接起来。注册的回调函数将其第一个参数传递给一个指向`s3eSoundEndSampleInfo`结构的指针。该结构通过其`m_Channel`成员指示哪个声音通道已结束。
- en: If we want to start a completely new sound playing on this channel, we can set
    the `m_NewData` member of the `s3eSoundEndSampleInfo` structure to the start address
    of the new sample data, and the `m_NumSamples` member to the number of samples
    in the new waveform.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在通道上开始播放全新的声音，我们可以将`s3eSoundEndSampleInfo`结构的`m_NewData`成员设置为新的样本数据的起始地址，将`m_NumSamples`成员设置为新波形中的样本数量。
- en: The structure also contains a member called `m_RepsRemaining`, which allows
    us to change the number of repetitions of the sample data we want on this sound
    channel. Note, though, that this callback will still be triggered every time the
    end of the sample data has been reached.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构还包含一个名为`m_RepsRemaining`的成员，它允许我们更改我们希望在声音通道上重复的样本数据的次数。请注意，尽管如此，每次达到样本数据的末尾时，此回调仍然会被触发。
- en: If we wish the channel to continue playing sample data, be it the original data
    or a new sample specified using the `m_NewData` and `m_NumSamples` members of
    the `s3eSoundEndSampleInfo` structure, we must return a non-zero value from the
    callback function. If zero is returned, the sound channel will stop playing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望通道继续播放样本数据，无论是原始数据还是使用`s3eSoundEndSampleInfo`结构的`m_NewData`和`m_NumSamples`成员指定的新样本，我们必须从回调函数返回一个非零值。如果返回零，则声音通道将停止播放。
- en: 'The following code example puts the functionality described previosuly into
    practice:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例将之前描述的功能付诸实践：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second callback type we'll consider is `S3E_CHANNEL_STOP_AUDIO`. This callback
    will occur whenever a sound channel finishes playing a sound completely (for example,
    if we have an `S3E_CHANNEL_END_SAMPLE` callback set and we return zero from it
    to end all playback). It is passed a pointer to an `s3eSoundEndSampleInfo` structure,
    but the only valid field is the `m_Channel` member.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第二种回调类型是`S3E_CHANNEL_STOP_AUDIO`。当声音通道完全播放完声音时（例如，如果我们设置了`S3E_CHANNEL_END_SAMPLE`回调并从中返回零以结束所有播放）将发生此回调。它传递一个指向`s3eSoundEndSampleInfo`结构的指针，但唯一有效的字段是`m_Channel`成员。
- en: The SoundEngine module
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SoundEngine`模块'
- en: As the previous section of this chapter shows, the basics of using s3eSound
    are actually fairly straightforward. The main issue that we have to deal with
    as developers is the fact that s3eSound can only support raw uncompressed 16-bit
    PCM samples, which means it is our responsibility to get the sound data into memory
    so it can be played.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面的部分所示，使用s3eSound的基本方法实际上相当简单。作为开发者，我们必须处理的主要问题是s3eSound只能支持原始未压缩的16位PCM样本，这意味着将声音数据放入内存以便播放是我们的责任。
- en: One of the most common file formats for storing sound samples is the WAV file,
    so wouldn't it be great if we could use this format to store our sound effects?
    Wouldn't it also be great if we could load these files into memory using the same
    resource manager code that we've used for textures and 3D models?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 存储声音样本最常见的文件格式之一是WAV文件，所以如果我们能够使用这种格式来存储我们的声音效果，那岂不是很好？如果我们能够使用与纹理和3D模型相同的资源管理器代码将这些文件加载到内存中，岂不是也很好？
- en: The answer to our prayers is the `SoundEngine` module, which is a layer that
    sits on top of s3eSound and allows us to easily load and access sound effects
    using the resource manager.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所祈求的答案是`SoundEngine`模块，这是一个位于s3eSound之上的层，它允许我们通过资源管理器轻松地加载和访问声音效果。
- en: The `SoundEngine` module doesn't just stop there though. It also wraps up the
    s3eSound calls we've learnt about in this chapter and it allows us to support
    a further sound format that can be stored in WAV files—namely the compressed IMA
    ADPCM type. This is particularly useful given that sound sample data can be quite
    large in size; so this format helps us claw back some memory space at the expense
    of a slight drop in sound quality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEngine`模块不仅仅如此。它还封装了我们在本章中学到的s3eSound调用，并允许我们支持一种可以存储在WAV文件中的进一步的声音格式——即压缩的IMA
    ADPCM类型。鉴于声音样本数据可能相当大，这种格式特别有用；因此，这种格式可以帮助我们在略微降低音质的情况下回收一些内存空间。'
- en: The following sections give a brief introduction to using this module, but for
    full details you should refer to the source and header files to see all the functionality
    `SoundEngine` has to offer. The sound example project accompanying this chapter
    also makes use of this module, so take a look at that to learn more.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分简要介绍了如何使用此模块，但为了获取完整细节，你应该参考源代码和头文件，以查看 `SoundEngine` 提供的所有功能。本章附带的音频示例项目也使用了此模块，因此请查看该部分以了解更多信息。
- en: Adding the SoundEngine module to a project
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 SoundEngine 模块添加到项目中
- en: The `SoundEngine` module actually ships with the Marmalade SDK, but it lives,
    awkwardly, in the `examples` directory. The easiest way to solve this is to just
    copy the entire `SoundEngine` directory to the directory where your project resides
    and then reference it by adding `SoundEngine` to your MKB files subprojects. This
    is the same approach we used with the GUI and `Localise` modules that were introduced
    in the sample code for the previous chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEngine` 模块实际上随 Marmalade SDK 一起提供，但它尴尬地位于 `examples` 目录中。解决这个问题的最简单方法是将整个
    `SoundEngine` 目录复制到你的项目所在的目录，然后通过将 `SoundEngine` 添加到你的 MKB 文件子项目中来引用它。这与我们在上一章的示例代码中引入的
    GUI 和 `Localise` 模块所采用的方法相同。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The location of the `SoundEngine` module in the `examples` folder means it isn't
    really considered part of the main Marmalade SDK. In practice it is highly unlikely
    that the `SoundEngine` code will suddenly disappear from the SDK, since the s3eSound
    API is unlikely to change drastically from what it is now; so you shouldn't have
    any concerns about using it directly in your own projects. If you prefer to write
    your own code, `SoundEngine` does at least serve the purpose of being a very good
    example of how to use the s3eSound API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEngine` 模块位于 `examples` 文件夹中，这意味着它实际上并不被认为是 Marmalade SDK 的主要部分。实际上，`SoundEngine`
    代码突然从 SDK 中消失的可能性非常低，因为 s3eSound API 很可能不会发生剧烈变化；所以你不需要担心直接在自己的项目中使用它。如果你更喜欢编写自己的代码，`SoundEngine`
    至少提供了一个很好的示例，说明了如何使用 s3eSound API。'
- en: With the module added to our project, we can include the file `IwSound.h` in
    our code to make use of it. A call to `IwSoundInit` is needed to set everything
    up and a call to `IwSoundTerminate` cleans up at the end of our program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在将模块添加到我们的项目中后，我们可以在代码中包含 `IwSound.h` 文件以使用它。需要调用 `IwSoundInit` 来设置一切，并在程序结束时调用
    `IwSoundTerminate` 来清理。
- en: 'We must also add a custom resource handler to allow WAV files to be loaded
    by the resource manager. The following code snippet will do the trick:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加一个自定义资源处理程序，以便资源管理器能够加载 WAV 文件。以下代码片段将完成这项工作：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, there is a manager class that takes care of all sound-related events
    and we must ensure that we call the `Update` method of this class somewhere within
    the main game loop. We do this with the following line of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个管理类负责处理所有与声音相关的事件，我们必须确保在主游戏循环的某个地方调用这个类的 `Update` 方法。我们通过以下代码行来实现：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Loading and accessing sound resources
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和访问声音资源
- en: To load a WAV file all we have to do is add a reference to its filename into
    a GROUP file, though we still need to do a little more in order to be able to
    play the sound back. What we need to do is declare an instance of the class `CIwSoundSpec`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载一个 WAV 文件，我们只需在 GROUP 文件中添加对其文件名的引用即可，尽管我们还需要做更多的工作才能播放声音。我们需要做的是声明 `CIwSoundSpec`
    类的一个实例。
- en: 'This class allows us to reference a particular sound sample by name and lets
    us set a volume and pitch to play the sound at. We can also specify whether or
    not we want the sound to loop (note that `SoundEngine` currently provides no way
    of specifying the number of times to loop the sound; we can only indicate continuous
    looping). Here''s an example definition:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们通过名称引用特定的声音样本，并让我们设置音量和音调来播放声音。我们还可以指定是否希望声音循环（请注意，`SoundEngine` 目前没有提供指定循环次数的方法；我们只能表示连续循环）。以下是一个示例定义：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `pitch` and `vol` (volume) parameters are specified as fractional scales,
    where `1.0` indicates the default pitch or volume level of a sound. We can also
    specify a range for both these parameters that allows a random value to be chosen
    when starting the sound. Specifying a range for the pitch can be quite useful
    to add a bit of variety to the sound effects in your game without having to add
    lots of slightly different sound samples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pitch` 和 `vol`（音量）参数被指定为分数比例，其中 `1.0` 表示声音的默认音调或音量级别。我们还可以为这两个参数指定一个范围，以便在开始声音时选择一个随机值。为音调指定一个范围可以非常有用，可以在不添加大量略有不同声音样本的情况下，为你的游戏中的音效添加一些变化。'
- en: 'The example below shows how to specify ranges for the volume and pitch:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了如何指定音量和音调的范围：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another useful class that we have access to is `CIwSoundGroup`. This allows
    us to collect a number of different sound effects together and pause, resume,
    stop, or alter the volume or pitch of any that are currently being played all
    at the same time. Note that a sound group only allows a single volume or pitch
    value to be specified, not a random range:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以访问的有用类是 `CIwSoundGroup`。这个类允许我们将多个不同的音效组合在一起，并且可以同时暂停、恢复、停止，或者改变正在播放的任何音效的音量或音调。请注意，音效组只允许指定一个音量或音调值，而不是一个随机范围：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Sounds can be added to groups using the `addSpec` keyword, or alternatively
    you can add `CIwSoundSpec` to a group when it is defined by using the `group`
    keyword followed by the group name, in its definition. We can use either method,
    but the group or sound must have been declared before we make reference to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `addSpec` 关键字将声音添加到组中，或者你也可以在定义时使用 `group` 关键字后跟组名，将 `CIwSoundSpec` 添加到组中。我们可以使用这两种方法中的任何一种，但组或声音必须在引用它之前被声明。
- en: 'To access a sound specification or group, we just load the GROUP file and retrieve
    them using the resource manager in the normal way. Here''s an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问声音规范或组，我们只需加载 GROUP 文件，并使用资源管理器以正常方式检索它们。以下是一个示例：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Playing, stopping, and altering sound parameters
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放、停止和改变声音参数
- en: Once we have hold of a pointer to `CIwSoundSpec` we can start playing it by
    calling the `Play` method, which will do all the behind-the-scenes stuff of allocating
    a free channel and setting volume and playback speed. The `Play` method can be
    passed an optional parameter, which is an instance of the class `CIwSoundParams`,
    that allows the volume and pitch to be modified when starting the sound.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了指向 `CIwSoundSpec` 的指针，我们就可以通过调用 `Play` 方法开始播放它，这将执行所有幕后操作，如分配一个空闲通道和设置音量和播放速度。`Play`
    方法可以传递一个可选参数，它是一个 `CIwSoundParams` 类的实例，允许在开始声音时修改音量和音调。
- en: The `Play` method returns a pointer to a `CIwSoundInst` class, which has methods
    to allow that single instance of the sound to have its volume or pitch modified,
    and also provides methods called `Pause`, `Resume`, and `Stop`, which should be
    self explanatory! If no free sound channel is available, the `Play` method will
    return `NULL`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play` 方法返回一个指向 `CIwSoundInst` 类的指针，该类提供了修改单个声音实例的音量或音调的方法，并且还提供了名为 `Pause`、`Resume`
    和 `Stop` 的方法，这些方法应该很容易理解！如果没有可用的空闲音效通道，`Play` 方法将返回 `NULL`。'
- en: If we have a pointer to `CIwSoundGroup` we can affect all currently playing
    instances of sounds contained within it. Again there are `Pause`, `Resume`, and
    `Stop` methods that do what you would expect, plus there are the methods `SetVol`
    and `SetPitch` that will scale the current volume and pitch of the sounds. These
    methods use the value `IW_GEOM_ONE` (4096) to indicate a scale of one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指向 `CIwSoundGroup` 的指针，我们可以影响其中所有当前正在播放的声音实例。同样，有 `Pause`、`Resume` 和
    `Stop` 方法，它们会执行你预期的操作，此外还有 `SetVol` 和 `SetPitch` 方法，这些方法将调整声音的当前音量和音调。这些方法使用值
    `IW_GEOM_ONE`（4096）来表示一个比例为一的缩放。
- en: The s3eVideo API
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: s3eVideo API
- en: We'll finish our look at Marmalade's multimedia support by having a whirlwind
    look at support for playing video clips using the s3eVideo API. To make use of
    the functions it provides, we just need to include the `s3eVideo.h` file into
    our source code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过快速浏览 Marmalade 的多媒体支持来结束对 Marmalade 的多媒体支持的探讨，我们将简要了解使用 s3eVideo API 播放视频剪辑的支持。为了使用它提供的功能，我们只需要将
    `s3eVideo.h` 文件包含到我们的源代码中。
- en: Before we begin, there are two things to consider when using video clips in
    our games. The first is that while it is possible to specify where on the screen
    the video clip will appear, it will always be drawn on top of all other graphics.
    The second issue is that due to hardware limitations in many mobile devices, the
    s3eVideo API cannot be used at the same time as the s3eAudio and s3eSound APIs.
    In the case of s3eAudio, any currently playing track will be stopped (this also
    applies the other way around—starting an audio track will stop a currently playing
    video clip). The s3eSound API will continue processing its events while a video
    clip is playing, but its sound output will be silenced until the video clip is
    finished. For most games we would probably decide it is best to explicitly stop
    all s3eSound playback before starting a video clip, particularly if we are doing
    anything advanced like joining sound samples together using the callback system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，使用游戏中的视频片段时需要考虑两件事。首先，虽然可以指定视频片段在屏幕上的显示位置，但它总是会覆盖在所有其他图形之上。第二个问题是，由于许多移动设备硬件的限制，s3eVideo
    API 不能与 s3eAudio 和 s3eSound API 同时使用。在 s3eAudio 的情况下，任何当前正在播放的曲目将被停止（这也适用于相反的情况——开始音频曲目将停止当前正在播放的视频片段）。当视频片段播放时，s3eSound
    API 将继续处理其事件，但其声音输出将被静音，直到视频片段播放完毕。对于大多数游戏，我们可能会决定在开始视频片段之前明确停止所有 s3eSound 播放，尤其是如果我们正在执行任何高级操作，比如使用回调系统将声音样本合并在一起。
- en: Starting video playback
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始视频播放
- en: 'The s3eVideo API works in a similar manner to the s3eAudio API. To start playing
    a video clip we use the `s3eVideoPlay` function, specifying the filename of the
    video clip, the number of times we want it to loop, a screen position, and the
    size that we want to display it at, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: s3eVideo API 的工作方式与 s3eAudio API 类似。要开始播放视频片段，我们使用 `s3eVideoPlay` 函数，指定视频片段的文件名、我们希望它循环的次数、屏幕位置以及我们想要显示的大小，如下所示：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The video clip will automatically resize to fit the rectangle, but no attempt
    is made to keep the correct aspect ratio.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 视频片段将自动调整大小以适应矩形，但不会尝试保持正确的宽高比。
- en: Where possible it is usually best to try to make your video clips the same resolution
    as the rectangular area you want to display them in. This will avoid any unnecessary
    stretching of the image (which can look quite ugly!) and may lead to slightly
    better performance, though on most modern devices the resize will be happening
    in hardware and there will be no appreciable difference.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，通常最好尝试使视频片段的分辨率与您想要显示它们的矩形区域相同。这将避免不必要的图像拉伸（这可能会看起来相当难看！）并可能导致性能略有提升，尽管在大多数现代设备上，缩放将在硬件中完成，并且不会有明显的差异。
- en: The actual size of the video file itself is also worth bearing in mind, since
    we often want to minimize the size of the final install package. Ultimately, we
    need to use a bit of trial and error until we get a result that ticks all the
    boxes for acceptable quality, performance, and file size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 视频文件本身的实际大小也值得考虑，因为我们通常希望最小化最终安装包的大小。最终，我们需要进行一些尝试和错误，直到我们得到一个在可接受的质量、性能和文件大小方面都符合要求的结果。
- en: Determining video codec support
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定视频编解码器支持
- en: The s3eVideo API makes use of the device's built-in video decoding, so not all
    video formats will be playable on all devices. To determine whether support for
    a particular codec is available, there is a function called `s3eVideoIsCodecSupported`
    that takes a value from the `s3eVideoCodec` enum. Take a look at the `s3eVideo.h`
    file or the Marmalade documentation for a complete list of possible values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: s3eVideo API 利用设备的内置视频解码功能，因此并非所有视频格式都能在所有设备上播放。为了确定是否支持特定的编解码器，有一个名为 `s3eVideoIsCodecSupported`
    的函数，它接受来自 `s3eVideoCodec` 枚举的值。查看 `s3eVideo.h` 文件或 Marmalade 文档以获取可能的值的完整列表。
- en: Pausing, resuming, and stopping video playback
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停、恢复和停止视频播放
- en: Again the parallels with the s3eAudio API are apparent when it comes to controlling
    video playback. The functions `s3eVideoPause`, `s3eVideoResume`, and `s3eVideoStop`
    all take no parameters and are used to pause, resume, and finish video clip playback
    respectively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到控制视频播放时，与 s3eAudio API 的相似之处显而易见。函数 `s3eVideoPause`、`s3eVideoResume` 和 `s3eVideoStop`
    都不接受任何参数，并分别用于暂停、恢复和结束视频片段播放。
- en: End of video notification
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频结束通知
- en: We have the choice of polling or callbacks once more for detecting the end of
    video playback. Let's start with the polled method that involves a call to the
    function `s3eVideoIsPlaying`, which will return `S3E_TRUE` if a video is playing
    or `S3E_FALSE` if a video is paused or stopped. Quite simple really!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有选择轮询或回调来检测视频播放结束。让我们从涉及调用函数 `s3eVideoIsPlaying` 的轮询方法开始，该函数如果视频正在播放，则返回
    `S3E_TRUE`，如果视频已暂停或停止，则返回 `S3E_FALSE`。实际上非常简单！
- en: 'If we want to use the callback approach, the following code snippet illustrates
    what to do:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用回调方法，以下代码片段说明了应该做什么：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The callback will be triggered whenever video playback stops, either because
    we explicitly call `s3eVideoStop`, an error in playback such as a corrupted video
    file occurs, or if an audio track is started using `s3eAudioPlay`. Note that the
    callback is not triggered between repetitions of the video clip if we are looping
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当视频播放停止时，回调将被触发，无论是我们明确调用 `s3eVideoStop`，播放过程中发生错误（如损坏的视频文件）发生，还是使用 `s3eAudioPlay`
    开始音频轨道。请注意，如果我们正在循环视频剪辑，则回调在视频剪辑重复之间不会被触发。
- en: For most games, video clips will probably only be used during introductory sequences
    or tutorials, since using video in the game itself is probably not practical.
    With this in mind, a polled approach for detecting when a video clip is finished
    is normally sufficient.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数游戏，视频剪辑可能仅在开场序列或教程中使用，因为在使用游戏本身中的视频可能并不实用。考虑到这一点，检测视频剪辑何时完成的轮询方法通常足够。
- en: Other video queries
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他视频查询
- en: 'The s3eVideo API, like the s3eSound and s3eAudio APIs, also has a pair of functions
    for reading and writing global video parameters. They are called `s3eVideoGetInt`
    and `s3eVideoSetInt`. They are called as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: s3eVideo API，就像 s3eSound 和 s3eAudio API 一样，也有一对用于读取和写入全局视频参数的函数。它们被称为 `s3eVideoGetInt`
    和 `s3eVideoSetInt`。它们如下所示：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following table shows the values that can be used for the `lProperty` parameter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可用于 `lProperty` 参数的值：
- en: '| Property | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_VIDEO_VOLUME` | This property is used to find the current volume level
    for the sound associated with the video clip and also to set a new volume. The
    maximum volume level is defined by the value `S3E_VIDEO_MAX_VOLUME`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_VIDEO_VOLUME` | 此属性用于查找与视频剪辑相关的声音的当前音量级别，也可以设置新的音量。最大音量级别由 `S3E_VIDEO_MAX_VOLUME`
    的值定义。|'
- en: '| `S3E_VIDEO_DEFAULT_VOLUME` | This is a read-only property that shows the
    default volume that will be used for playing back the sound in a video clip. Its
    value is intended to provide a similar level of volume across all device types.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_VIDEO_DEFAULT_VOLUME` | 这是一个只读属性，显示用于在视频剪辑中播放声音的默认音量。其值旨在为所有设备类型提供类似的音量水平。|'
- en: '| `S3E_VIDEO_STATUS` | This is a read-only parameter showing the current status
    of the video playback. It will return one of the following values: `S3E_VIDEO_STOPPED`,
    `S3E_VIDEO_PLAYING`, `S3E_VIDEO_PAUSED`, or `S3E_VIDEO_FAILED`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_VIDEO_STATUS` | 这是一个只读参数，显示视频播放的当前状态。它将返回以下值之一：`S3E_VIDEO_STOPPED`、`S3E_VIDEO_PLAYING`、`S3E_VIDEO_PAUSED`
    或 `S3E_VIDEO_FAILED`。|'
- en: '| `S3E_VIDEO_POSITION` | This property returns the current playback position
    of the video in milliseconds, or `0` if no video is playing. This parameter cannot
    be written to, so it is not possible to jump to a particular point in a video
    clip. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_VIDEO_POSITION` | 此属性返回视频当前播放位置（以毫秒为单位），如果没有视频正在播放，则返回 `0`。此参数不能写入，因此无法跳转到视频剪辑的特定点。|'
- en: Example code
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'This chapter has three example projects associated with it and they are described
    in the following sections. The sound, audio, and video clips used in these projects
    were sourced from a couple of great websites that offer a vast variety of stock
    media for free! Links to these websites are provided here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与三个示例项目相关联，它们将在以下部分中描述。这些项目中使用的声音、音频和视频剪辑是从几个提供大量免费库存媒体的优秀网站上获取的！以下提供了这些网站的链接：
- en: '[http://www.royalty-free-music-room.com](http://www.royalty-free-music-room.com)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.royalty-free-music-room.com](http://www.royalty-free-music-room.com)'
- en: '[http://www.partnersinrhyme.com](http://www.partnersinrhyme.com)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.partnersinrhyme.com](http://www.partnersinrhyme.com)'
- en: The Sound project
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音项目
- en: This project demonstrates use of the s3eAudio API and the `SoundEngine` module
    (which in turn makes use of s3eSound).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目演示了使用 s3eAudio API 和 `SoundEngine` 模块（它反过来又使用 s3eSound）。
- en: On running the example you'll be presented with three clickable buttons that
    have been implemented using the GUI module introduced in the last chapter. The
    first button toggles an MP3 track on and off using s3eAudio, while the other two
    start some sound effects using `SoundEngine`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例时，你会看到三个可点击的按钮，这些按钮是使用上一章中引入的GUI模块实现的。第一个按钮使用s3eAudio切换MP3轨道的开启和关闭，而其他两个按钮则使用`SoundEngine`播放一些音效。
- en: The Video project
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频项目
- en: This is another simple example showing how to use the s3eVideo API to start
    and stop a video clip. A button at the bottom of the screen will start and stop
    a video clip, which is played in a continuous loop.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，展示了如何使用s3eVideo API来启动和停止视频片段。屏幕底部的按钮可以启动和停止一个视频片段，该片段会连续循环播放。
- en: The Skiing project
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: Finally we come to the Skiing project once again and it will come as no surprise
    that it has been enhanced by the addition of some music and sound effects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次回到滑雪项目，它通过添加一些音乐和音效得到了增强，这并不会让人感到惊讶。
- en: The main menu now plays an MP3 audio track while waiting for the player to press
    a button. On pressing a button, a confirmation sound effect is played.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主菜单在等待玩家按按钮时会播放MP3音频轨道。按下按钮时，会播放一个确认音效。
- en: In the game itself, several sounds have been added. A swooshing sound is produced,
    by using a looping sample, whenever the skier moves and the pitch of this sample
    is decreased as the player turns, to make things sound a little more dynamic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏本身中，增加了几个声音。当滑雪者移动时，会通过循环样本产生呼啸声，随着玩家转向，这个样本的音调会降低，使声音听起来更加动态。
- en: Other sounds that have been added include a selection of celebratory sounds
    for when the player passes through a gate, a painful-sounding yell for when the
    player collides with an obstacle, and a springy sound that gets played when the
    player collides with a flag pole and causes it to wobble.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的其他声音包括当玩家通过一个门时播放的庆祝声音，当玩家与障碍物碰撞时发出的痛苦呼喊声，以及当玩家与旗帜杆碰撞并使其晃动时播放的弹簧声。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As this chapter draws to a close, our look at Marmalade's multimedia support
    has now given us the ability to play sound effects, music tracks, and also play
    back video clips.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们对Marmalade的多媒体支持的研究现在使我们能够播放音效、音乐轨道，以及播放视频片段。
- en: There are very few games that don't feature sound or music of some sort, and
    adding a few sound effects can make a world of difference to your game. While
    not all games need to make use of video, it is nice to know we have it at our
    disposal should we ever need to use it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有游戏不包含某种形式的声音或音乐，添加一些音效可以使你的游戏产生巨大的变化。虽然并非所有游戏都需要使用视频，但知道我们随时可以使用它，这感觉很好。
- en: In the next chapter we'll be looking at how Marmalade can make it easier for
    us to target as wide a range of devices as possible, from entry-level handsets
    to top-of-the-range ones.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Marmalade如何帮助我们尽可能多地针对各种设备，从入门级手机到高端手机。
