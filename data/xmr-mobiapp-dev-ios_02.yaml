- en: Chapter 2. The User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 用户界面
- en: A user interface is the primary method of communication between a device and
    the user. The design and appearance is what differentiates a good app from an
    amazing one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面是设备与用户之间主要的通信方式。设计和外观是区分优秀应用程序和卓越应用程序的关键。
- en: 'In this chapter, we will be covering some of the essential features of the
    user interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍用户界面的一些基本功能：
- en: Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布
- en: MonoTouch.Dialog
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MonoTouch.Dialog
- en: Incorporating external views into your user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部视图集成到您的用户界面中
- en: Colors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色
- en: Labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Creating the User Interface with Xcode
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Xcode 创建用户界面
- en: With the exception of `MonoTouch.Dialog`, the user interface for any iOS application
    is created using Xcode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `MonoTouch.Dialog` 之外，任何 iOS 应用程序的用户界面都是使用 Xcode 创建的。
- en: When considering how to create a user interface and the positioning of any of
    the available widgets, you need to think along the lines of fuzzy felt placed
    on a canvas. You are able to place any iOS widget anywhere on the felt.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何创建用户界面以及任何可用小部件的位置时，您需要从在画布上放置毛绒布的角度思考。您可以在毛绒布的任何地方放置任何 iOS 小部件。
- en: 'To create a simple user interface, create a new iOS application. Click on **File**
    then **New**. You will be presented with a window as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建简单的用户界面，创建一个新的 iOS 应用程序。点击**文件**，然后**新建**。您将看到一个如下所示的窗口：
- en: '![Creating the User Interface with Xcode](img/00013.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Xcode 创建用户界面](img/00013.jpeg)'
- en: Click on **Single View Application**, enter a filename in the **Name** field,
    and click on **OK** once it is done. Xamarin.iOS will create a directory containing
    all of the folders and files required to get you started. Unchecking the **Create
    directory for solution** box will still create the application, but the files
    will not be held in a directory structure, but instead wherever the **Location**
    path points to. The application can still be edited and worked on, but there is
    a good chance that files will be lost or overwritten (for example, if you work
    on multiple projects, each project will create an `AppDelegate.cs` file. When
    one is created, the new version will overwrite the old one.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**单视图应用程序**，在**名称**字段中输入文件名，完成后点击**确定**。Xamarin.iOS 将创建一个包含所有文件夹和文件的目录，以帮助您开始。取消选中**为解决方案创建目录**复选框仍然会创建应用程序，但文件将不会保存在目录结构中，而是保存在**位置**路径指向的地方。应用程序仍然可以编辑和修改，但文件丢失或被覆盖的可能性很大（例如，如果您在多个项目中工作，每个项目都会创建一个
    `AppDelegate.cs` 文件。当创建新版本时，它将覆盖旧版本。）
- en: 'Once the application structure is set up, you will be presented with a new
    text editing window shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好应用程序结构，您将看到一个新文本编辑窗口，如下所示：
- en: '![Creating the User Interface with Xcode](img/00014.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Xcode 创建用户界面](img/00014.jpeg)'
- en: 'At the bottom of the solution explorer, there are three files that need attention:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器的底部，有三个文件需要特别注意：
- en: '**testappViewController.cs**: This is the file for creating the C# code for
    your application'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**testappViewController.cs**：这是创建应用程序 C# 代码的文件'
- en: '**testappViewController.designer.cs**: This is a designer file created by Xamarin.iOS
    and is based on the user interface created with Xcode'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**testappViewController.designer.cs**：这是一个由 Xamarin.iOS 创建的设计师文件，基于使用 Xcode
    创建的用户界面'
- en: '**testappViewController_iPad.xib** and **testappViewController_iPhone.xib**:
    Any file with a `.xib` extension is an Xcode designer file![Note](img/00001.gif)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**testappViewController_iPad.xib** 和 **testappViewController_iPhone.xib**：任何以
    `.xib` 扩展名的文件都是 Xcode 设计师文件![注意](img/00001.gif)'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To start Xcode, simply double-click on the `.xib` file. To edit the `.xib` file,
    you must double-click on either the **testappViewController_iPad.xib** or **testappViewController_iPhone.xib**
    file depending on the view controller user interface you wish to edit.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要启动 Xcode，只需双击 `.xib` 文件。要编辑 `.xib` 文件，您必须根据您希望编辑的视图控制器用户界面双击 **testappViewController_iPad.xib**
    或 **testappViewController_iPhone.xib** 文件。
- en: '![Note](img/00001.gif)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: 'Xcode is quite a simple designer, but in that simplicity is a very powerful
    piece of software. On startup, you will see the following screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 是一个非常简单的设计师，但在这个简单性中隐藏着非常强大的软件。启动时，您将看到以下屏幕：
- en: '![Creating the User Interface with Xcode](img/00015.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Xcode 创建用户界面](img/00015.jpeg)'
- en: The Xcode designer is a very complex piece of software. However, because there
    are books written on how to use it to its maximum potential, and due to space
    constraints, I will limit the discussion here to the minimum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode设计器是一个非常复杂的软件。然而，由于有书籍专门介绍如何最大限度地利用它，以及由于篇幅限制，我将在此仅讨论最小化内容。
- en: To add a widget, simply select and drop it into the main view. You can drop
    any widget more or less anywhere. However, your application won't know anything
    about it at all as it needs to be connected. Connecting a widget is simple. The
    preceding screenshot shows a button called Connector. Click on this icon and another
    frame will appear to the left of the properties frame. To connect a widget, click
    on *Ctrl* and drag it to the Connector frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加小部件，只需选择并将其拖放到主视图中。您几乎可以将任何小部件拖放到任何位置。然而，您的应用程序对此一无所知，因为它需要连接。连接小部件很简单。前面的截图显示了一个名为“连接器”的按钮。点击此图标，将在属性框架的左侧出现另一个框架。要连接小部件，请点击*Ctrl*并将其拖动到连接器框架中。
- en: '![Creating the User Interface with Xcode](img/00016.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode创建用户界面](img/00016.jpeg)'
- en: 'From this point, you have to decide the type of the button: **Outlet**, **Action**,
    or **Outlet Collection**. Each is very different and their names are sometimes
    confusing.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，您必须决定按钮的类型：**出口**、**动作**或**出口集合**。每个都大不相同，它们的名称有时会令人困惑。
- en: An **Outlet** button would be normally considered for displaying information
    and not accepting events. However, actions, say, click events, are handled in
    **Outlet**. If you connect a button as **Outlet**, it is considered an interface.
    It is open to all modifiers and events available for that object. **Outlet Collection**
    is a collection of outlets. **Action** is just that—it is a specific action (or
    event) linked to that object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为**出口**按钮用于显示信息而不是接受事件。然而，动作，比如点击事件，是在**出口**中处理的。如果您将按钮作为**出口**连接，它被视为一个接口。它对所有可用的修改器和事件都开放。**出口集合**是一组出口。**动作**就是那样——它是一个与该对象链接的特定动作（或事件）。
- en: There is a major difference, though, between them. If you have a button connected
    as **Outlet**, events have to be specifically added. If you don't do anything
    with the button at all, the application will run on your device, but the button
    will do nothing. If you have the button connected as **Action**, the code for
    the action must be written before the application is run. Failure to do so will
    result in the application crashing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们之间有一个重大区别。如果您将按钮连接为**出口**，则必须专门添加事件。如果您对按钮不做任何操作，应用程序将在您的设备上运行，但按钮将不会做任何事情。如果您将按钮连接为**动作**，则必须在应用程序运行之前编写动作代码。不这样做会导致应用程序崩溃。
- en: Events will be dealt with in a later chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事件将在后面的章节中处理。
- en: Screen origins and sizes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕原点和尺寸
- en: 'All screens and views start with **0,0** at top left. To obtain the screen
    size (remember, this is going to be different for different versions of iPhones
    and iPads), consider the following lines of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有屏幕和视图都从左上角的**0,0**开始。要获取屏幕尺寸（记住，这将因iPhone和iPad的不同版本而异），请考虑以下代码行：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: MonoTouch.Dialog (MT.D)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MonoTouch.Dialog (MT.D)
- en: iOS screens usually contain a lot of data in a list form (think of how Facebook
    or Twitter looks). On iOS, these are constructed using `UITableView`. This is
    a very flexible piece of the UI, but can be tricky to code for. To alleviate the
    problems with `UITableView`, Xamarin created the `MonoTouch.Dialog` class. The
    benefit of `MT.D` is that Xcode is not required for designing the interface so
    it can just as simply be created under Windows as well as Mac.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: iOS屏幕通常以列表形式包含大量数据（想想Facebook或Twitter的外观）。在iOS上，这些是通过`UITableView`构建的。这是UI中非常灵活的部分，但编码起来可能很棘手。为了减轻`UITableView`的问题，Xamarin创建了`MonoTouch.Dialog`类。`MT.D`的好处是，设计界面不需要Xcode，因此它可以在Windows和Mac上一样简单地创建。
- en: '`MonoTouch.Dialog` views are very simple to create and work on a three-tier
    system for design:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.Dialog`视图非常简单创建，并且基于三层系统进行设计：'
- en: '**Elements**: These contain the likes of `on`/`off` Boolean switches, strings,
    images, and anything else you would normally see in a user interface.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素**: 这些包含诸如`on`/`off`布尔开关、字符串、图像以及您通常在用户界面中看到的其他任何内容。'
- en: '**Sections**: These hold any number of elements.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分**: 这些包含任意数量的元素。'
- en: '**Roots**: These hold the sections. An `MT.D` class must have at least one
    root element.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根元素**: 这些元素包含部分内容。`MT.D`类必须至少有一个根元素。'
- en: 'There are many different types of elements. In the following example, a simple
    user interface is constructed (this code is autogenerated from Xamarin Studio
    when you ask it to create an `MT.D` class):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的元素。在以下示例中，构建了一个简单的用户界面（此代码是在您要求Xamarin Studio创建`MT.D`类时自动生成的）：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When compiled, the code produces the following (the first view is the initial
    display; the second view is displayed when the **Hello** entry is clicked on):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，代码生成以下结果（第一个视图是初始显示；第二个视图是在点击**Hello**条目时显示）：
- en: '![MonoTouch.Dialog (MT.D)](img/00017.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![MonoTouch.Dialog (MT.D)](img/00017.jpeg)'
- en: Image A
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图像A
- en: 'We would get the following image after clicking:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击后会得到以下图像：
- en: '![MonoTouch.Dialog (MT.D)](img/00018.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![MonoTouch.Dialog (MT.D)](img/00018.jpeg)'
- en: Image B
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图像B
- en: The keyboard does not have to be a standard QWERTY keyboard. It can be one specific
    for e-mail addresses, phone numbers, or just numbers. This is defined using `UIKeyboardType`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘不必是标准的QWERTY键盘。它可以是一个专门用于电子邮件地址、电话号码或仅数字的键盘。这是使用`UIKeyboardType`定义的。
- en: Changing the keyboard type
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改键盘类型
- en: 'Consider the following line of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the preceding line of code is attached to an MT.D class view, tapping
    the element will bring up a standard alphanumeric keyboard. For standard entry,
    this is fine; in this example, though, a different type of keyboard is required.
    To set this, either of the following can be used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码行附加到MT.D类视图时，点击元素将弹出一个标准字母数字键盘。对于标准输入，这很好；然而，在这个例子中，需要不同类型的键盘。为此，可以使用以下任一方法：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is an issue, though, with these keyboards and that is dismissing them.
    For the likes of a standard alphanumeric keyboard, a return key can be added to
    the keyboard itself using:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些键盘有一个问题，那就是关闭它们。对于标准字母数字键盘，可以通过以下方式在键盘本身添加一个回车键：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The likes of the numeric keyboards do not have a return key, even if `ReturnKeyType`
    is added. There are three ways to sort this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数字键盘，即使添加了`ReturnKeyType`，也没有回车键。有三种方法可以解决这个问题：
- en: '`ShouldReturn`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldReturn`'
- en: '`ResignFirstResponder`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResignFirstResponder`'
- en: Add a toolbar to the keyboard with a done button that dismisses the keyboard
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向键盘添加一个带有关闭按钮的工具栏
- en: Using ShouldReturn
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ShouldReturn
- en: 'This is a simple method to use but relies on a return key being on the keyboard:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的方法来使用，但它依赖于键盘上有回车键：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using ResignFirstResponder
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ResignFirstResponder
- en: Unless it is defined in the designer or in code, the `FirstResponder` method
    is whatever control is clicked on first. When something else is clicked (say another
    `EntryElement` but this also applies to any other control), that needs to become
    the `FirstResponder` control. By issuing a `ResignFirstResponder` method, the
    keyboard for that control is closed. Clicking onto a new control should issue
    a `BecomeFirstResponder` control and its keyboard appears (assuming that a keyboard
    is associated with the control).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在设计师或代码中定义，否则`FirstResponder`方法就是首先点击的控制。当点击其他东西（比如另一个`EntryElement`，但这也适用于任何其他控制）时，需要将其变为`FirstResponder`控制。通过发出`ResignFirstResponder`方法，关闭该控制的键盘。点击新的控制应该发出`BecomeFirstResponder`控制，并且其键盘出现（假设与控制相关联的键盘）。
- en: Adding a toolbar to the keyboard
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向键盘添加工具栏
- en: Toolbars are not actually part of the keyboard but can be attached to the keyboard
    to provide additional or missing functionality to the keyboard. Adding the keyboard
    is different for an `MT.D` class than for a standard `UITextField` or `UITextView`
    control.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏实际上不是键盘的一部分，但可以附加到键盘上以提供额外的或缺失的功能。对于`MT.D`类，添加键盘的方式与标准`UITextField`或`UITextView`控件不同。
- en: '**For an MT.D**'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**对于MT.D**'
- en: Here, a subclass of the `EntryElement` class will be needed to implement the
    `InputAccessoryView` method. While the cell being used can be found by looking
    at the `TableView` from the Root constructor, the `InputAccessoryView` from this
    is a read-only parameter so it cannot be set.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，需要一个`EntryElement`类的子类来实现`InputAccessoryView`方法。虽然可以通过从Root构造函数查看`TableView`来找到正在使用的单元格，但`InputAccessoryView`是从这里的一个只读参数，因此不能设置。
- en: 'An example of the subclass would be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 子类的示例如下：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `EntryElement` class in the main code would need to be altered to read.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码中的`EntryElement`类需要修改以读取。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Note](img/00001.gif)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For this example, I have not included the password parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我没有包括密码参数。
- en: '![Note](img/00001.gif)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: '**For a standard UITextField**'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**对于标准的UITextField**'
- en: 'Here, the toolbar (as described in the preceding section) is created but without
    the action sheet, and then added to the `UITextField` method using:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，工具栏（如前一小节所述）被创建，但没有动作表，然后通过以下方式添加到 `UITextField` 方法中：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Image B (section *MonoTouch.Dialog (MT.D)*) shows the `UIAlertView` control.
    This is a customizable alert box that is usually used for information (for example,
    errors, during a slow process to stop the user from getting worried, or if a user
    choice is required).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图像B（*MonoTouch.Dialog (MT.D)*部分）显示了 `UIAlertView` 控件。这是一个可定制的警告框，通常用于信息（例如，错误、在慢速过程中停止用户担心，或需要用户选择时）。
- en: The real beauty of `MT.D` is that it removes the tedium associated with the
    `UITableView` control. It gives the developer the majority of the facilities required
    from the `UITableView` control without having to mess about. Also, if you need
    something special (such as a standard interface button), these can be achieved
    simply by creating a subclass of an element type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`MT.D` 的真正美在于它消除了与 `UITableView` 控件相关的乏味。它为开发者提供了从 `UITableView` 控件中所需的大多数功能，而无需麻烦。此外，如果您需要特殊的东西（例如标准界面按钮），这些可以通过简单地创建元素类型的子类来实现。'
- en: 'The basic element types supported in an `MT.D` class are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`MT.D` 类支持的元素类型如下：'
- en: '| Element | Uses | Caveats to use |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Element | 使用 | 使用注意事项 |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ActivityElement` | Used to show that something is happening (it''s a spinner)
    |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityElement` | 用于显示正在发生的事情（它是一个旋转器） |   |'
- en: '| `BadgeElement` | Image with text next to it |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `BadgeElement` | 带文本的图像 |   |'
- en: '| `BaseBooleanImageElement` |   | Base type for the Booleans, cannot be used
    directly (abstract class) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `BaseBooleanImageElement` |   | 布尔的基础类型，不能直接使用（抽象类） |'
- en: '| `BooleanElement` | Simple `on`/`off` switch |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `BooleanElement` | 简单的 `开`/`关` 开关 |   |'
- en: '| `BooleanImageElement` | Simple `on`/`off` switch that allows for two different
    images to be displayed |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `BooleanImageElement` | 简单的 `开`/`关` 开关，允许显示两种不同的图像 |   |'
- en: '| `BoolElement` |   | Cannot be used directly (abstract class) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `BoolElement` |   | 不能直接使用（抽象类） |'
- en: '| `CheckboxElement` | Tick next to a string when selected |   |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `CheckboxElement` | 选择时在字符串旁边打勾 |   |'
- en: '| `DateElement` | Displays a date picker | This is a two-part element. Part
    one looks like a standard `StringElement` element but with a **>** symbol next
    to the value on the right. When clicked, a `UIDatePicker` element is displayed.
    The selected value is returned in the value element. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `DateElement` | 显示日期选择器 | 这是一个两部分的元素。第一部分看起来像标准的 `StringElement` 元素，但在右侧值的旁边有一个
    **>** 符号。点击时，会显示一个 `UIDatePicker` 元素。选定的值在值元素中返回。 |'
- en: '| `DateTimeElement` | Displays a date/time picker | Essentially is the same
    as `DateElement`, except that it includes the time. The time can be set in the
    12 or 24 hour clock |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `DateTimeElement` | 显示日期/时间选择器 | 实质上与 `DateElement` 相同，但包括时间。时间可以设置为12小时或24小时制
    |'
- en: '| `Element` |   | Base element |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Element` |   | 基础元素 |'
- en: '| `EntryElement` | Allows for data entry | The optional fourth parameter in
    the constructor allows for the entry to be used for passwords (set as `true` for
    password). The constructor takes three strings: caption, placeholder, and value.
    Placeholder and value can be string or `Empty`, but caption must have a value.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `EntryElement` | 允许数据输入 | 构造函数中的可选第四个参数允许将输入用于密码（将密码设置为 `true`）。构造函数接受三个字符串：标题、占位符和值。占位符和值可以是字符串或
    `Empty`，但标题必须有值。 |'
- en: '| `FloatElement` | Slider bar | Values are float |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `FloatElement` | 滑块栏 | 值为浮点数 |'
- en: '| `HtmlElement` | Caption that leads to an HTML view | This is a crossover
    element in that the originator is just an `Element`, but gives a `UIWebView` element
    when clicked. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `HtmlElement` | 带有HTML视图的标题 | 这是一个交叉元素，因为发起者只是一个 `Element`，但点击时显示一个 `UIWebView`
    元素。 |'
- en: '| `ImageElement` | Produces an image |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `ImageElement` | 生成图像 |   |'
- en: '| `ImageStringElement` | Produces an image with a string next to it |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ImageStringElement` | 生成带有字符串的图像 |   |'
- en: '| `JsonElement` | Allows for the loading of content from a local or remote
    URL |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `JsonElement` | 允许从本地或远程URL加载内容 |   |'
- en: '| `LoadMoreElement` | Allows users to add more items to the list on screen
    |   |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `LoadMoreElement` | 允许用户向屏幕上的列表添加更多项目 |   |'
- en: '| `MessageElement` | Consider this as the sort of message you find on Twitter
    |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `MessageElement` | 将其视为在Twitter上找到的消息类型 |   |'
- en: '| `MultilineElement` | Allows multiple lines of text to be displayed | Cannot
    be styled |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `MultilineElement` | 允许显示多行文本 | 不能被样式化 |'
- en: '| `OwnerDrawnElement` | Not used directly | Must be subclassed. The `Height`
    and `Draw` methods must be overridden |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `OwnerDrawnElement` | 不直接使用 | 必须子类化。必须重写 `Height` 和 `Draw` 方法 |'
- en: '| `RadioElement` | A radio element that allows for a single option to be chosen
    from multiple choices. | Requires a radio group to be specified in the element
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `RadioElement` | 允许从多个选项中选择单个选项的无线电元素 | 需要在元素中指定一个无线电组 |'
- en: '| `RootElement` | Base element for the root |   |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `RootElement` | 根元素 |   |'
- en: '| `StringElement` | A simple caption on the left with a value on the right
    | This element can also be used as a button by providing an anonymous delegate
    as the second parameter (as in the example above) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `StringElement` | 左侧有一个简单的标题，右侧有一个值 | 此元素也可以用作按钮，通过提供匿名代理作为第二个参数（如上例所示） |'
- en: '| `StyledMultilineElement` | Essentially the same as `MultilineElement` except
    can by styled |   |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `StyledMultilineElement` | 与 `MultilineElement` 基本相同，但可以自定义样式 |   |'
- en: '| `StyledStringElement` | Allow for strings to be shown using the built-in
    styles (such as colors, fonts, and sizes) and custom formats. |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `StyledStringElement` | 允许使用内置样式（如颜色、字体和大小）和自定义格式来显示字符串 |   |'
- en: '| `TimeElement` | Displays a time picker | Same as `DateElement`, but for time.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `TimeElement` | 显示时间选择器 | 与 `DateElement` 相同，但用于时间。 |'
- en: '| `UIViewElement` | `UIView` that can be displayed | Design `UIView` using
    Xcode. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `UIViewElement` | 可显示的 `UIView` | 使用 Xcode 设计 `UIView`。 |'
- en: Creating your own Pickers on MT.D
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 MT.D 上创建自己的选择器
- en: I've decided to demonstrate this using `UIPickerView` with `UIToolBar` added
    to the top and incorporate it within `UIActionSheet`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定使用 `UIPickerView` 并将其与顶部的 `UIToolBar` 结合，然后将其整合到 `UIActionSheet` 中来演示这一点。
- en: 'To start off with, we need two things: an event to latch onto and the model
    (containing the information that `UIPickerView` requires). It''s then a case of
    wiring the two together.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要两样东西：一个事件来挂钩，以及模型（包含 `UIPickerView` 所需的信息）。然后就是将这两者连接起来。
- en: 'First the event:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是事件：
- en: '[PRE9]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Actually, this can return anything, not just a string. But for my purposes,
    I'll keep it as a string.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，这可以返回任何东西，不仅仅是字符串。但出于我的目的，我会将其保持为字符串。
- en: 'Next is the model:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是模型：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not rocket science—the only important part is that the `Selected()` method from
    the parent class is being overridden to send back the value from the row selected;
    everything else overrides the default class settings.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不是什么火箭科学——唯一重要的是父类的 `Selected()` 方法被重写以返回所选行的值；其他所有内容都覆盖了默认类设置。
- en: 'To wire this into the main `MT.D` class, `EntryElement` is used:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将其连接到主 `MT.D` 类，使用 `EntryElement`：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A `UIActionSheet` element is also needed:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要一个 `UIActionSheet` 元素：
- en: '[PRE12]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then create `UIPickerView`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建 `UIPickerView`：
- en: '[PRE13]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, create `UIToolbar` and `UIBarButtonItem`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `UIToolbar` 和 `UIBarButtonItem`
- en: '[PRE14]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `EntryElement` object:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `EntryElement` 对象：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now it is just a case of using the `EntryStarted` event to call the picker:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需要使用 `EntryStarted` 事件来调用选择器：
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When this is all coded in, the result is as follows:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当所有代码都编写完成后，结果如下：
- en: '![Creating your own Pickers on MT.D](img/00019.jpeg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在 MT.D 上创建自己的选择器](img/00019.jpeg)'
- en: 'Subclassing an element is equally simple. The subclass `EntryElement` allows
    only a specific number of characters to be entered:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元素的子类化同样简单。子类 `EntryElement` 允许输入特定数量的字符：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You are still free to use `UITableView` and `UITableViewCell` of course.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你仍然可以使用 `UITableView` 和 `UITableViewCell`。
- en: UITableView and UITableViewCell
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UITableView` 和 `UITableViewCell`'
- en: The `UITableView` method is the workhorse of the iPhone. Most, if not all, list
    data of whatever description is displayed using the `TableView` and `TableViewCell`
    methods. If you are a user of Facebook, Twitter, the standard iPhone text message
    application, or any form of configuration on the iPhone, you will have used these
    two components—this gives you an idea of how much they are used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 方法是 iPhone 的主力。大多数，如果不是所有，的列表数据都是通过 `TableView` 和 `TableViewCell`
    方法显示的。如果你是 Facebook、Twitter、标准 iPhone 文本消息应用或 iPhone 上的任何形式配置的用户，你将使用这两个组件——这让你了解到它们的使用程度。'
- en: The topic is a massive one to cover and will be dealt with further in [Chapter
    4](../Text/part0026.html#page "Chapter 4. Controllers"), *Controllers*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题非常庞大，将在第 4 章[控制器](../Text/part0026.html#page "第 4 章。控制器")中进一步讨论。
- en: Colors, buttons, and labels
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色、按钮和标签
- en: '`UILabel` is the simplest method of putting text onto a screen. It has a very
    limited range of actions associated with its use (for example, you cannot use
    it as something that is clickable). The color and text of the label can be set,
    as can the formatting. For example, consider the following lines of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`UILabel`是将文本放置在屏幕上的最简单方法。与其使用相关联的操作范围非常有限（例如，你不能将其用作可点击的对象）。可以设置标签的颜色和文本，也可以设置格式。例如，考虑以下代码行：'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `UILabel` method has five constructors, of which two are of great use:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`UILabel`方法有五个构造函数，其中两个非常有用：'
- en: '`UILabel()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILabel()`'
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second constructor can be replicated using the `Frame` property as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数可以使用`Frame`属性来复制，如下所示：
- en: UILabel lbl = new UILabel();
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILabel lbl = new UILabel();`'
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One of the main issues with using `UILabel` is ensuring that the bounding frame
    is large enough. There is a way to get around this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UILabel`的一个主要问题是确保边界框足够大。有一种方法可以解决这个问题：
- en: Make the label much larger than required.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签的大小做得比所需的大得多。
- en: Calculate the length of the string and, using the `Frame` property, alter the
    size of the label.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字符串的长度，并使用`Frame`属性来改变标签的大小。
- en: Reduce the font size of the string to ensure it fits.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减小字符串的字体大小以确保其能够适应。
- en: Both of these approaches have their benefits and disadvantages. The first is
    that text will always fit but only if the font size is the system default. The
    second is that you will always have the correct size-bounding box, but that you
    will have to calculate the size, and that will take time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优点和缺点。第一种是文本总是能够适应，但前提是字体大小是系统默认值。第二种是你会始终拥有正确的大小边界框，但你需要自己计算大小，这会花费时间。
- en: Ensuring you have the correct size bounding boxes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保你有正确的大小边界框
- en: 'This assumes that a label has already been created using Xcode. The label in
    this case has a width of 96 (enough to write “More text to”):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设已经使用Xcode创建了一个标签。在这个例子中，标签的宽度是96（足够写“更多文本”）：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: UIColor
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIColor
- en: iOS comes with a number of preset colors (such as red, green, blue, black, and
    white). It is also possible to create your own using `UIColor.FromRGB[A]` as well
    as `FromHSB[A]` (where `HSB` is hue, saturation, and brightness and `[A]` is the
    alpha channel). Think of the latter as being the colors' opacity. The color can
    also be set from a pattern (this is useful, as it creates a color based on an
    image that can then be used as a brush to paint the image), `CoreImage` and `CoreGraphicsColor`
    (`CI` and `CGColor`), and `FromWhiteAlpha` (a gray-scale color based on the current
    color space).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: iOS自带一系列预设的颜色（如红色、绿色、蓝色、黑色和白色）。你也可以使用`UIColor.FromRGB[A]`以及`FromHSB[A]`（其中`HSB`代表色调、饱和度和亮度，而`[A]`是透明度通道）来创建自己的颜色。后者可以看作是颜色的透明度。颜色也可以从图案（这很有用，因为它可以根据图像创建颜色，然后可以用作画笔来绘制图像）、`CoreImage`和`CoreGraphicsColor`（`CI`和`CGColor`）以及`FromWhiteAlpha`（基于当前颜色空间的灰度颜色）中设置。
- en: Using `CIColor` and `CGColor` requires a lot more legwork but does allow for
    greater flexibility in the colors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CIColor`和`CGColor`需要做更多的工作，但允许在颜色上有更大的灵活性。
- en: The simplest to use, though, is `FromRGB`. This allows the values to be entered
    as byte, int, and float. The caveat here, though, is that the float values go
    from `0` to `1` rather than `0` to `255`, so the value for `82, 184, 33` would
    be `0.32`, `0.72`, `0.13` (that is, 82/255, 184/255, and 33/255).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单易用的方法是`FromRGB`。这允许输入的值以字节、整数和浮点数的形式输入。但在这里需要注意的是，浮点数的范围是从`0`到`1`而不是从`0`到`255`，所以`82,
    184, 33`的值将是`0.32`、`0.72`和`0.13`（即82/255、184/255和33/255）。
- en: UIButton
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIButton
- en: A button is not just a button; it can have a whole range of interesting effects
    applied to it (such as the addition of graphics, a gradient color, text, and graphics).
    Let's assume a button (`btn`) has been created in Xcode and we wish to apply a
    gradient color to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个按钮不仅仅是一个按钮；它可以应用一系列有趣的效果（如添加图形、渐变色、文本和图形）。假设在Xcode中创建了一个按钮（`btn`），我们希望给它应用渐变色。
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`CAGradientLayer` come from the `CoreAnimation` namespace.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAGradientLayer`来自`CoreAnimation`命名空间。'
- en: Adding an image is also quite trivial, though the important point here is to
    remember that, when placing anything on a button, you have to treat that button
    as a new view with the origin set at the top left of the button. Remember also
    that a button can have a foreground and background image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 添加图像也是相当简单的，但重要的是要记住，当在按钮上放置任何东西时，你必须将那个按钮视为一个新的视图，其原点设置在按钮的左上角。还要记住，按钮可以有前景和背景图像。
- en: Typically, a background image will cover the entire button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，背景图像会覆盖整个按钮。
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second parameter here (`UIControlState`) is the state the button (or control)
    is in. `Normal` is when it has not been selected. When the button is depressed,
    the state becomes `Highlighted` and when released, it is `Normal` again. This
    means you can have different images depending on the state of the button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个参数（`UIControlState`）是按钮（或控件）所处的状态。`Normal` 表示未选中状态。当按钮被按下时，状态变为 `Highlighted`，当释放时，状态再次变为
    `Normal`。这意味着你可以根据按钮的状态显示不同的图片。
- en: 'The foreground image will typically not cover the entire button, but will be
    of a particular size. For example, say the button is 92 x 92\. To fill most of
    the button, a gap of 4 on each side would be good; this makes the dimension 84
    x 84 (left and right gaps, as well as for both the height and width). To create
    this image for the button is a two-step process: create the image and add the
    image. This time, though, `ImageView` is initially used and then fed into the
    `SetImage` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前景图像通常不会覆盖整个按钮，而会是一个特定的尺寸。例如，假设按钮是 92 x 92。为了填充按钮的大部分区域，每边 4 的间距会很好；这使得尺寸为 84
    x 84（左右间距，以及高度和宽度）。为按钮创建此图像是一个两步过程：创建图像并添加图像。这次，`ImageView` 首先被使用，然后通过 `SetImage`
    方法传递：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: An alternative is to add `ImageView` as a subview to the button.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将 `ImageView` 作为子视图添加到按钮中。
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `UIButton` can also just have a color assigned to it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIButton` 也可以直接为其分配颜色。'
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The button also comes with a default piece of text on it called `Title`. As
    with any text element, this can be set:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮上还有一个默认的文本，称为 `Title`。与任何文本元素一样，这也可以设置：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A more interesting effect is to have both text and graphics on a button. The
    simplest way to consider the placement is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的效果是在按钮上同时显示文本和图形。考虑放置的最简单方法是以下这样：
- en: Let `a` and `b` be the position of the top left and right of the image (in our
    previous example, that would be `4`, `4`). For ease, the same gap is on the right.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设 `a` 和 `b` 为图像的左上角和右下角的位置（在我们之前的例子中，这将是 `4`, `4`）。为了方便，右侧也有相同的间距。
- en: Let `c` be the offset from the top (`a` + “image height” + “some gap”).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设 `c` 为从顶部（`a` + “图像高度”+ “一些间距”）的偏移量。
- en: The trick here, though, is to ensure there is enough of a gap at the bottom
    so it doesn't look messy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的技巧是确保底部有足够的间距，以免看起来杂乱。
- en: Adding the image is a two- or three-step process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 添加图像是一个两步或三步的过程。
- en: If `Title` is set, clear it (this can be one in or out of the designer).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设置了 `Title`，则清除它（这可以在设计器中实现）。
- en: Add the image (see previous example).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加图片（参见上一个示例）。
- en: Create and add a `UILabel`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加一个 `UILabel`。
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: UIControlStates
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIControlStates
- en: 'There are (as previously mentioned) a number of `UIControlStates`: `Application`,
    `Disabled`, `Highlighted`, `Normal`, `Reserved`, and `Selected`. For most day-to-day
    considerations, `Disabled`, `Highlighted`, and `Normal` are the ones used most
    commonly.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: （如前所述）有几种 `UIControlStates`：`Application`、`Disabled`、`Highlighted`、`Normal`、`Reserved`
    和 `Selected`。对于大多数日常考虑，最常用的是 `Disabled`、`Highlighted` 和 `Normal`。
- en: If the `Enabled` property is `false`, the button is `Disabled`. The only problem
    is that this is the only way to tell if a button is disabled using the system
    defaults. It is probably a better idea to set the background color as well as
    the text when disabled.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Enabled` 属性为 `false`，按钮处于 `Disabled` 状态。唯一的问题是这是使用系统默认值判断按钮是否禁用的唯一方式。可能更好的做法是在禁用状态下设置背景颜色以及文本。
- en: 'A button does not have to be a rounded rectangle. There are four predefined
    buttons (`ContactsAdd`, `DetailDisclosure` [the **>** arrow], `InfoDark`, and
    `InfoLight` [the info icon with either a dark or light background]). There is
    also a custom `UIButtonType` type. This by default gives no border to the button,
    but allows for interesting buttons where a `.png` file could be the button shape.
    So if you want an octagonal button, you would have a `.png` file of an octagon
    and then write the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮不一定是圆形的。有四个预定义的按钮（`ContactsAdd`、`DetailDisclosure` [即 **>** 箭头]、`InfoDark`
    和 `InfoLight` [带有深色或浅色背景的信息图标]）。还有一个自定义的 `UIButtonType` 类型。默认情况下，它不会为按钮添加边框，但允许创建有趣的按钮，其中
    `.png` 文件可以是按钮的形状。所以如果你想有一个八边形的按钮，你将需要一个八边形的 `.png` 文件，然后编写以下代码：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see from this whistle-stop tour, iOS gives you a massively rich and
    varied number of different objects usable within the UI. In later chapters, we
    will see how these can be extended and how to get the most from them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这次匆匆一瞥中可以看到，iOS 为您提供了大量丰富且多样化的对象，这些对象可以在 UI 中使用。在后续章节中，我们将看到这些对象如何被扩展，以及如何最大限度地利用它们。
