- en: Chapter 6. Behavioral Patterns – Chain of Responsibility and Command
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。行为模式 – 责任链和命令模式
- en: In this chapter, we will continue to explore the behavioral patterns—the **chain
    of responsibility** and **command** patterns. Both of these patterns are concerned
    with passing requests to appropriate objects that will then execute the action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨行为模式——**责任链**和**命令**模式。这两个模式都涉及将请求传递给将执行操作的适当对象。
- en: The main difference between these two patterns is the way that the requests
    are passed between objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间的主要区别在于请求在对象之间传递的方式。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: The chain of responsibility pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The chain of responsibility pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链模式
- en: When you write an application, it may be that an event generated by an object
    needs to be handled by another object. You may also want the handle to be inaccessible
    by another object.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写应用程序时，可能一个对象生成的事件需要由另一个对象处理。你可能还希望处理对另一个对象不可访问。
- en: Roles
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: In this section, you will notice that the chain of responsibility pattern creates
    a chain of objects in such a way that if an object of this chain cannot handle
    the request, it sends the request to the next object, the successor, until one
    of them can handle the request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你会注意到责任链模式以这种方式创建对象链，如果链中的对象无法处理请求，它将请求发送到下一个对象，即后续对象，直到其中一个可以处理请求。
- en: This pattern allows an object to send a request without knowing which object
    will receive and handle it. The request is sent from one object to another, making
    them parts of a chain. Each object of this chain can handle the request, pass
    it to its successor, or do both.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许一个对象发送请求，而无需知道哪个对象将接收并处理它。请求从一个对象发送到另一个对象，使它们成为链的一部分。链中的每个对象都可以处理请求，将其传递给其后续对象，或者两者都做。
- en: 'You may want to use this pattern when:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用此模式时：
- en: You want to decouple the sender of a request to its receiver, allowing other
    objects to handle the request too
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望解耦请求的发送者与接收者，允许其他对象也处理请求
- en: Objects that can handle the request are part of a chain of work, the request
    passes from one object to another until at least one of these objects can handle
    it
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理请求的对象是工作链的一部分，请求从一个对象传递到另一个对象，直到至少有一个这些对象可以处理它。
- en: You want to allow objects that can process requests to be ordered in a preferential
    sequence that can be reordered, without having any impact on the calling component
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望允许能够处理请求的对象按照优先级顺序排列，并且可以重新排序，而不影响调用组件
- en: Design
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram illustrates the generic representation of the chain of
    responsibility pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了责任链模式的通用表示：
- en: '![Design](img/B04852_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/B04852_06_01.jpg)'
- en: Participants
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'This pattern has three participants, which are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式有三个参与者，如下所示：
- en: '`AbstractHandler`: This defines the interface of the requests and implements
    the association of the chain of responsibility pattern.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractHandler`：这定义了请求的接口并实现了责任链模式的关联。'
- en: '`ConcreteHandlers`: These objects can handle requests that they are responsible
    for. If it cannot handle the request, it passes the request to its successor or
    stops the chain.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteHandlers`：这些对象可以处理它们负责的请求。如果它们无法处理请求，则将请求传递给其后续对象或停止链。'
- en: '`Client`: The client sends the request to the first object of the chain that
    may handle the request.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：客户端将请求发送到可能处理请求的链中的第一个对象。'
- en: Collaboration
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: 'The following sequence diagram illustrates the collaboration between objects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图展示了对象之间的协作：
- en: '![Collaboration](img/B04852_06_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![协作](img/B04852_06_02.jpg)'
- en: The client sends the request to the first object of the chain. Then, this request
    is propagated throughout the chain until at least one of the objects of the chain
    can handle it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将请求发送到链中的第一个对象。然后，此请求在整个链中传播，直到至少有一个链中的对象可以处理它。
- en: Illustration
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: Suppose that you are supervising the development of a mobile application, and
    you want to handle some log messages differently, depending on the priority of
    the logger.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在监督一个移动应用程序的开发，并且你想要根据记录器的优先级以不同的方式处理一些日志消息。
- en: 'You define three types of priority, which means three levels of loggers: `DEBUG`,
    `INFO`, and `ERROR`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了三种类型的优先级，这意味着三种日志级别：`DEBUG`、`INFO`和`ERROR`。
- en: 'Depending on the level of the log messages, you can handle it as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据日志消息的级别，你可以如下处理：
- en: If the level (or priority) is `DEBUG`, then this will be handled by the standard
    output logger
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果级别（或优先级）是 `DEBUG`，那么这将由标准输出记录器处理
- en: If the level is `INFO`, then we will use the standard output logger and e-mail
    logger that will send an e-mail with the message
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果级别是 `INFO`，那么我们将使用标准输出记录器和电子邮件记录器，它们将发送包含消息的电子邮件
- en: 'If the level is `ERROR`, then all the three loggers will handle the message:
    the standard output logger, e-mail logger, and error logger'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果级别是 `ERROR`，那么三个日志记录器都将处理消息：标准输出记录器、电子邮件记录器和错误记录器
- en: 'As we can see here, we need to define a chain of objects in the following order:
    `StdOutLogger`, `EmailLogger`, and `ErrorLogger`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们需要以下顺序定义对象链：`StdOutLogger`、`EmailLogger` 和 `ErrorLogger`。
- en: 'The client will then only call the first concrete handler, the class that may
    handle the request: `StdOutLogger`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将只调用第一个具体处理程序，即可能处理请求的类：`StdOutLogger`。
- en: Implementation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To implement our pattern, we will need to prepare our abstract class first.
    Remember that with Swift, an abstract class does not really exist. We will write
    our abstract class as a class, but methods that need to be overridden will have
    the following statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的模式，我们首先需要准备我们的抽象类。记住，在 Swift 中，抽象类实际上并不存在。我们将以类的方式编写我们的抽象类，但需要重写的方法将具有以下声明：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, if the code of the abstract class is called instead of the one
    available in the derived class, an exception similar to the following will be
    raised:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果调用抽象类的代码而不是派生类中可用的代码，将引发类似于以下异常：
- en: '![Implementation](img/4852_06_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_03.jpg)'
- en: Let's now begin with the implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始实施。
- en: First, open the `ChainOfResponsibilityPattern` project that you will find in
    the `Chapter 6` folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开你可以在 `第 6 章` 文件夹中找到的 `ChainOfResponsibilityPattern` 项目。
- en: 'The project is organized with the following structure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 项目按照以下结构组织：
- en: '![Implementation](img/4852_06_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_04.jpg)'
- en: There's nothing complex here; we will define our chain and make a call to the
    `main.swift` file. The abstract class is defined in the `Logger.swift` file, and
    our three `concreteHandlers` classes have their own respective Swift files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么是复杂的；我们将定义我们的链并调用 `main.swift` 文件。抽象类在 `Logger.swift` 文件中定义，我们的三个 `concreteHandlers`
    类有自己的 Swift 文件。
- en: 'We will define the abstract class as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下定义抽象类：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We define three static variables that will represent our different levels of
    logs: `ERROR`, `INFO`, and `DEBUG`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个静态变量，将代表我们不同的日志级别：`ERROR`、`INFO` 和 `DEBUG`。
- en: 'Then, we have two other variables that are declared, which are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还有两个其他变量被声明，具体如下：
- en: '**Mask**: This variable is intrinsic to the object and will be set during the
    initialization of the handler. This variable will be used to compare its value
    against the level of the received request, which means that if the mask is less
    than or equal to the level, the object will be able to handle the request.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掩码**：这个变量是对象固有的，将在处理程序的初始化期间设置。这个变量将用于将其值与接收到的请求级别进行比较，这意味着如果掩码小于或等于级别，对象将能够处理请求。'
- en: '**Next**: This variable is also intrinsic to the object and this permits the
    chaining. This variable contains the next `ConcreteHandler` where the request
    will be passed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一个**：这个变量也是对象固有的，这允许链式调用。这个变量包含将请求传递的下一个 `ConcreteHandler`。'
- en: 'We have the following three functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下三个函数：
- en: '`func nextHandler(…)`: This is a function that allows you to assign the next
    concrete handler to the `next` variable. Note that this function returns a logger.
    This is called `nextLogger`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func nextHandler(…)`: 这是一个允许你将下一个具体处理程序分配给 `next` 变量的函数。请注意，这个函数返回一个记录器。这被称为
    `nextLogger`。'
- en: 'So, if we write the following statement:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，如果我们编写以下语句：
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, `l1` is an `EmailLogger` instance and not a `StdOutLogger`.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，`l1` 是一个 `EmailLogger` 实例，而不是 `StdOutLogger`。
- en: '`func message(…)`: This is the main function that has the responsibility (or
    not) to process the request and/or pass it to the next object of the chain.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func message(…)`: 这是主要函数，它负责（或不）处理请求和/或将其传递给链中的下一个对象。'
- en: '`writeMessage(…)`: This function is called by the `message(…)`function to simulate
    the work applied on the request. Here, we will only display a message that is
    linked to the current concrete handler object. Since we are in an abstract class,
    we add a `preconditionfailure(…)` statement that will inform us that `this` function
    must be overridden in the derived class. If the code is executed and the derived
    class does not override `this` method, a fatal error will be raised, which is
    explained in the *Implementation* section of this pattern.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeMessage(…)`：此函数由`message(…)`函数调用，以模拟对请求应用的工作。在这里，我们只会显示与当前具体处理器对象相关联的消息。由于我们处于抽象类中，我们添加了一个`preconditionfailure(…)`语句，它将通知我们`this`函数必须在派生类中重写。如果代码执行且派生类没有重写此方法，将引发一个致命错误，这在模式的*实现*部分中有所解释。'
- en: '`prepareDefaultChain(…)`: This is a class function that encapsulates the creation
    of our default chain.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepareDefaultChain(…)`：这是一个类函数，封装了我们默认链的创建。'
- en: Our abstract class is now ready; we have only to write our derived classes.
    Remember that the `writeMessage(…)` function must be overridden, and we need to
    initialize the mask of our concrete handler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的抽象类现在已经准备好了；我们只需要编写我们的派生类。记住，`writeMessage(…)`函数必须被重写，并且我们需要初始化我们具体处理器的掩码。
- en: 'First, let''s take a look at the `StdOutLogger` concrete handler, which is
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看具体的`StdOutLogger`处理器，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we have the `EmailLogger` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`EmailLogger`类：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition, we have the `ErrLogger` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`ErrLogger`类：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All of our concrete handlers are now ready. It is time for us to write our test
    in the `main.swift` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有具体处理器现在都准备好了。现在是时候在`main.swift`文件中编写我们的测试了。
- en: 'We first prepare our chain using the `Logger` class function, `prepareDefaultChain`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`Logger`类的函数`prepareDefaultChain`准备我们的链：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we send a request (a string message with a logger type) to the first
    object of the chain (`l` is `StdOutLogger`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向链的第一个对象（`l`是`StdOutLogger`）发送一个请求（一个包含日志类型的字符串消息）：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will build and run the project. You will see the following result on
    the console:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建并运行项目。你将在控制台上看到以下结果：
- en: '![Implementation](img/4852_06_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_05.jpg)'
- en: The console output is very clear. The first handler has handled the first request
    only, and the second request has been handled by the `StdOutLogger` class and
    the `EmailLogger` class. The third request has been handled by all three handlers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出非常清晰。第一个处理器只处理了第一个请求，第二个请求由`StdOutLogger`类和`EmailLogger`类处理。第三个请求由所有三个处理器处理。
- en: The command pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: The concept behind this pattern is to transform a request into an object in
    order to facilitate some actions, such as undo/redo, insertion into a queue, or
    tracking of the request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式背后的概念是将请求转换成一个对象，以便简化某些操作，例如撤销/重做、将请求插入队列或跟踪请求。
- en: Roles
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The command pattern creates distance between the client that requests an operation
    and the object that can perform it. The request is encapsulated into an object.
    This object contains a reference to the receiver who will effectively execute
    the operation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在请求操作的客户端和可以执行它的对象之间创建距离。请求被封装成一个对象。此对象包含对将实际执行操作的接收者的引用。
- en: The real operation is managed by the receiver and the command is like an order;
    it only contains a reference to the invoker, the object that will perform the
    action and an execute function will call the real operation on the worker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作由接收者管理，命令就像一个指令；它只包含对调用者的引用，即执行动作的对象，以及一个执行函数将调用工作者的实际操作。
- en: 'This pattern allows the following features:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许以下功能：
- en: Sending requests to different receivers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向不同的接收者发送请求
- en: Queuing, logging, and rejecting requests
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排队、记录和拒绝请求
- en: Undoable actions (the `execute` method can memorize the state and allows you
    to go back to that state)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可撤销的操作（`execute`方法可以记住状态，并允许你回到那个状态）
- en: Encapsulate a request in an object
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求封装在对象中
- en: Allows the parameterization of clients with different requests
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许客户端使用不同的请求进行参数化
- en: Design
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic diagram class is represented as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通用图类表示如下：
- en: '![Design](img/B04852_06_06.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/B04852_06_06.jpg)'
- en: Participants
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The classes participating in this pattern are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参与此模式的类如下：
- en: '`Command`: This declares the interface for executing an operation.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`：这声明了执行操作的接口。'
- en: '`ConcreteCommand`: This implements the `Command` interface with the `execute`
    method by invoking the corresponding operations on `Receiver`. It defines a link
    between the `Receiver` class and the action.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteCommand`：通过在 `Receiver` 上调用相应的操作来实现 `Command` 接口，并使用 `execute` 方法。它定义了
    `Receiver` 类和动作之间的链接。'
- en: '`Client`: This creates a `ConcreteCommand` object and sets its receiver.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：创建一个 `ConcreteCommand` 对象并设置其接收者。'
- en: '`Invoker`: This asks the command to carry out the request.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoker`：请求命令执行请求。'
- en: '`Receiver`: This knows how to perform the operations.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Receiver`：知道如何执行操作。'
- en: Collaboration
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: 'The following sequence diagram defines the collaboration between all objects
    participating in the command pattern:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图定义了所有参与命令模式的对象的协作：
- en: '![Collaboration](img/B04852_06_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![协作](img/B04852_06_07.jpg)'
- en: 'Let''s discuss the preceding diagram in detail:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论前面的图示：
- en: The client asks for a command to be executed and specifies its receivers
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端请求执行命令并指定其接收者
- en: The client then sends the command to the invoker that stores it (or places it
    in a queue system if some actions needs to be performed before execution of the
    command) in order to execute it later
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端随后将命令发送给执行者，执行者将其存储（或将其放入队列系统，如果某些操作需要在执行命令之前执行）以便稍后执行
- en: The invoker is then called to launch the command by invoking the execute function
    on the appropriate command object
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，调用执行者来启动命令，通过在适当的命令对象上调用执行函数
- en: The concrete command asks the receiver to execute the appropriate operation
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体命令请求接收者执行适当的操作
- en: Illustration
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: 'Imagine that your company is working on a new universal controller that can
    manage up to four commands. This controller has four slots where we can add two
    commands to each of them. Near each slot, we have two buttons: the "On" and "Off"
    buttons.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的公司正在开发一个新的通用控制器，它可以管理多达四个命令。这个控制器有四个插槽，我们可以为每个插槽添加两个命令。在每个插槽附近，我们有两个按钮：“开”和“关”按钮。
- en: 'Your team has already two objects and their specifications that allow a remote
    control to manipulate them:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队已经有两个对象及其规格，允许遥控器操作它们：
- en: The objects that we will work with are a light and audio player
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将与之交互的对象是一个灯具和一个音频播放器
- en: The light can only be turned on and off
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯具只能打开和关闭
- en: The audio player can be turned on or off, and we can play or stop the music
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频播放器可以打开或关闭，我们可以播放或停止音乐
- en: Your job is to conceptualize commands that will be stored in the universal remote
    controller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的工作是构思将被存储在通用遥控器中的命令。
- en: When we press the on or off button of a slot, the appropriate command should
    be sent to the appropriate device (the audio player or the light).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下插槽的开关按钮时，应向适当的设备（音频播放器或灯具）发送适当的命令。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we will not implement the undo/redo action. We will show you
    another pattern that is dedicated to this situation in the next chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会实现撤销/重做操作。我们将在下一章展示另一个针对这种情况的专用模式。
- en: Implementation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Open the Xcode project called `CommandPattern.xcodeproj`. Here is the organization
    of our project:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开名为 `CommandPattern.xcodeproj` 的 Xcode 项目。以下是我们的项目组织结构：
- en: '![Implementation](img/4852_06_08.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_08.jpg)'
- en: 'The structure of our project reflects the class diagram that we have seen in
    the *Design* section of the command pattern:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的结构反映了我们在命令模式的 *设计* 部分看到的类图：
- en: We have the `Invoker` folder that contains our `UniversalRemoteController` object
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `Invoker` 文件夹，其中包含我们的 `UniversalRemoteController` 对象
- en: The `Receiver` folder contains two devices that will be able to receive commands
    to execute the appropriate operation
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Receiver` 文件夹包含两个设备，它们将能够接收命令以执行适当的操作'
- en: The `Interface` folder contains the definition of a command
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interface` 文件夹包含了命令的定义'
- en: The `ConcreteCommand` folder contains all the commands that we want to use with
    our universal remote controller
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteCommand` 文件夹包含了我们想要与我们的通用遥控器一起使用的所有命令'
- en: Lastly, the `main.swift` file contains the code that will allow us to see the
    demo
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`main.swift` 文件包含了允许我们查看演示的代码
- en: To implement this example, let's begin with defining our `Command` interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个例子，让我们从定义我们的 `Command` 接口开始。
- en: 'We only need an `execute()` method to execute the command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个 `execute()` 方法来执行命令：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we write our concrete command objects, let''s see how our `Light` and
    `AudioPlayer` objects are implemented:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写具体的命令对象之前，让我们看看我们的 `Light` 和 `AudioPlayer` 对象是如何实现的：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is quite simple; the `on()` function will turn on the light and the `off()`
    function will turn it off.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单；`on()` 函数会打开灯光，而 `off()` 函数会关闭它。
- en: 'Now, let''s define the `AudioPlayer` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义 `AudioPlayer` 类：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This object is more complex. We have the same `on()` and `off()`methods, but
    we also have the `playCD()` and `StopCD()` methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象更复杂。我们拥有相同的 `on()` 和 `off()` 方法，但我们还有 `playCD()` 和 `StopCD()` 方法。
- en: We see that this object has an internal state. The state changes depending on
    the function called and the state is also used to control if the asked function
    is possible.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个对象有一个内部状态。状态根据调用的函数和状态也会用来控制请求的函数是否可行。
- en: Now that we have all the necessary information, we can start writing our commands.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的信息，我们可以开始编写我们的命令。
- en: Let's begin with the light. What we want is to be able to use our universal
    remote controller to turn a light on or off, depending on the button pushed near
    the slot.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从灯光开始。我们希望能够使用我们的通用遥控器根据插槽附近的按钮来打开或关闭灯光。
- en: 'Therefore, we can first write our `LightOnCommand` concrete command object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先编写我们的 `LightOnCommand` 具体命令对象：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we created an object called `LightOnCommand` that implements the `ICommand`
    interface.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `LightOnCommand` 的对象，该对象实现了 `ICommand` 接口。
- en: 'The command needs to know what the receiver object is, so we pass an argument
    to it during the initialization of the object:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 命令需要知道接收器对象是什么，因此我们在初始化对象时传递一个参数给它：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, the `execute` method encapsulates the call to the `on()` function of the
    `Light` object to effectively process the command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`execute` 方法封装了对 `Light` 对象 `on()` 函数的调用，以有效地处理命令。
- en: That's all; your `LightOnCommand` object is now ready.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你的 `LightOnCommand` 对象现在准备好了。
- en: 'We do the same with the `LightOffCommand` class and make changes wherever it
    is appropriate in order to use the `off()` function of the `Light` object instead
    of `on()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `LightOffCommand` 类也做了同样的处理，并在适当的地方进行修改，以便使用 `Light` 对象的 `off()` 函数而不是 `on()`：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our commands to control lights are both ready. Let's now see what we will do
    for the audio player. What we want is to be able to turn on or off the audio player,
    play, or stop music. These commands are similar to what we have already done with
    the light.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制灯光的命令都已经准备好了。现在让我们看看我们将为音频播放器做些什么。我们希望能够打开或关闭音频播放器，播放或停止音乐。这些命令与我们之前对灯光所做的是相似的。
- en: 'The `AudioPlayerOnCommand` class is written as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerOnCommand` 类编写如下：'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `AudioPlayerOffCommand` class is written as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerOffCommand` 类编写如下：'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `AudioPlayerPlayCdCommand` class is written as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerPlayCdCommand` 类编写如下：'
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `AudioPlayerStopCDCommand` class is written as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioPlayerStopCDCommand` 类编写如下：'
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, all the commands needed are written.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有需要的命令都已经编写完成。
- en: 'We want to use our remote controller that has only four slots, as shown in
    the following diagram. With the remote controller, we want to be able to manipulate
    two lights: one in the bedroom, one in the hall, and an audio player to play and
    stop music:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用只有四个插槽的遥控器，如下面的图所示。通过遥控器，我们希望能够操作两个灯光：一个在卧室，一个在大厅，以及一个音频播放器来播放和停止音乐：
- en: '![Implementation](img/4852_06_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_10.jpg)'
- en: Why not create a command that will turn on the audio player and play the music
    in the same command object? Indeed, using our remote controller to execute only
    the on or off command is useless. What we want is to play or stop the music.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不创建一个命令，该命令可以在同一个命令对象中打开音频播放器和播放音乐呢？确实，使用我们的遥控器只执行开或关命令是毫无用处的。我们想要的只是播放或停止音乐。
- en: Imagine that you want to be able to turn on the audio player and play the CD
    only by pressing one button; in the same way, you want to be able to stop the
    CD player and turn off the audio player only by pressing one button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你只想通过按一个按钮就能打开音频播放器和播放光盘；同样地，你只想通过按一个按钮就能停止光盘播放器和关闭音频播放器。
- en: 'To implement this, we only have to encapsulate appropriate functions of the
    audio player object on the execute function of the command. When our remote controller
    will invoke the `execute` method, we will first call the `on` function of the
    `audioPlayer` class and then the `playCD()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们只需要在命令的 `execute` 函数中封装适当的音频播放器对象的函数。当我们的遥控器调用 `execute` 方法时，我们首先调用
    `audioPlayer` 类的 `on` 函数，然后调用 `playCD()` 函数：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we proceed with our `StopMusicAndSetOff` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们继续我们的 `StopMusicAndSetOff` 命令：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our devices are ready to accept commands and command objects are ready. Before
    we start writing our demo code, let''s see how the remote controller works:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设备已准备好接受命令，命令对象也已就绪。在我们开始编写演示代码之前，让我们看看遥控器是如何工作的：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the remote controller is initialized, the four slots have a `NoCommand`
    object that is assigned. This object is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当遥控器初始化时，四个槽位分配了一个`NoCommand`对象。该对象如下：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, if we do not use the `addCommandToSlot(…)` function, each button will call
    the `execute` function of the `NoCommand` object, which means that there is nothing
    to do.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们不使用`addCommandToSlot(…)`函数，每个按钮将调用`NoCommand`对象的`execute`函数，这意味着没有事情要做。
- en: The remote controller has two buttons near each slot. Depending on the button
    and slot, `buttonOnIsPushedOnSlot(…)` or `buttonOffIsPushedOnSlot` is called.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器有两个按钮靠近每个槽。根据按钮和槽，将调用`buttonOnIsPushedOnSlot(…)`或`buttonOffIsPushedOnSlot`。
- en: 'As commands are stored in the `onCommands` and `offCommands` arrays, when `addCommandToSlot`
    is called, we call the `execute` command of the appropriate object. To execute
    the on command of a slot, we will run the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令存储在`onCommands`和`offCommands`数组中，当调用`addCommandToSlot`时，我们将调用相应对象的`execute`命令。要执行槽的开启命令，我们将运行以下代码：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To execute the off command of the same slot we will also run the following
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行相同槽位的关闭命令，我们也将运行以下代码：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `slot` is the index of the button slot. Now, it is time to implement our
    demo code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`slot`是按钮槽的索引。现在，是时候实现我们的演示代码了。
- en: 'First, we initialize our remote controller, create our `audioPlayer`, and create
    our two lights: the bedroom light and hall light:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的遥控器，创建我们的`audioPlayer`，并创建我们的两个灯：卧室灯和走廊灯：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we create all our command objects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建所有命令对象：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once our commands are ready, we can assign them to the remote controller using
    the `addCommandToSlot` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的命令准备就绪后，我们可以使用`addCommandToSlot`函数将它们分配给遥控器：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last thing that is needed for the demo is to simulate the press on each
    button:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 演示所需的最后一件事是模拟每个按钮的按下：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, note that we have not added the concurrency protection. If the command
    is used by several components, we should make sure that the concurrency protection
    is added.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有添加并发保护。如果命令被多个组件使用，我们应该确保添加并发保护。
- en: For this, we need to create a queue that will receive all the commands, execute
    them in a synchronous way, and have the first command receive in the queue, being
    the first command executed (first in first out). To see how to implement concurrency
    protection, you can check the implementation of the mediator pattern in [Chapter
    7](ch07.html "Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer"),
    *Behavioral Patterns – Iterator, Mediator, and Observer* and the note about concurrency
    protection available in the same chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要创建一个队列，该队列将接收所有命令，以同步方式执行它们，并且第一个进入队列的命令将是第一个执行的命令（先进先出）。要了解如何实现并发保护，您可以查看[第7章](ch07.html
    "第7章。行为型模式 – 迭代器、中介者和观察者")中中介者模式的实现，*行为型模式 – 迭代器、中介者和观察者*以及同一章节中关于并发保护的注释。
- en: Click on build and run the demo.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 点击构建并运行演示。
- en: 'You will now see the following result on the console, corresponding to each
    button pressed on the universal remote controller:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将在控制台看到以下结果，对应于通用遥控器上按下的每个按钮：
- en: '![Implementation](img/4852_06_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_06_09.jpg)'
- en: Comparison between the chain of responsibility and command patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链模式和命令模式之间的比较
- en: The difference between the two patterns is the way in which the request is decoupled.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间的区别在于请求解耦的方式。
- en: In the chain of responsibility pattern, the request is passed to potential receivers,
    whereas the command pattern uses a command object that encapsulates a request.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在责任链模式中，请求被传递给潜在的接收者，而命令模式使用一个封装请求的命令对象。
- en: 'The following table describes the difference between the chain of responsibility
    and command patterns:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了责任链模式和命令模式之间的区别：
- en: '|   | Chain of responsibility | Command |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|   | 责任链 | 命令 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Client creates | Handler objects | Command objects |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 客户端创建 | 处理器对象 | 命令对象 |'
- en: '| Different kinds of | Handler classes at different levels | Command classes
    and receiver classes |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 不同类型的 | 不同级别的处理器类 | 命令类和接收者类 |'
- en: '| Client can work with | Multiple handlers | Different receivers |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 客户端可以与 | 多个处理器 | 不同的接收者 |'
- en: '| Client calls | Handler objects | Receiver objects |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 客户端调用 | 处理器对象 | 接收器对象 |'
- en: '| Work is done in | `HandleRequest` in a handler | `ActionToPerform` in a receiver
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 在处理器中完成工作 | 处理器中的`HandleRequest` | 接收器中的`ActionToPerform` |'
- en: '| Decision based on | Mask in handlers | Routing in commands |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 基于决策 | 处理器中的掩码 | 命令中的路由 |'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope this chapter was interesting. In this chapter, we learned how to decouple
    senders and receivers in both the chain of responsibility and command patterns,
    thus improving the layering and reusability of a system.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章对您来说很有趣。在这一章中，我们学习了如何在责任链模式和命令模式中解耦发送者和接收者，从而提高系统的分层和可复用性。
- en: 'In the next chapter, we will explore three new patterns: the iterator, mediator,
    and observer patterns that are dedicated to the communication between objects
    while maintaining their independence.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨三种新的模式：迭代器模式、中介者模式和观察者模式，这些模式专注于在保持对象独立性的同时进行对象间的通信。
