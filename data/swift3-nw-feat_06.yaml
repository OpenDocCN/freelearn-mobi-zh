- en: Chapter 6. Extra, Extra Collection and Closure Changes That Rock!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。额外，额外令人兴奋的集合和闭包变化！
- en: In this chapter, we are focusing on collection and closure changes in Swift
    3\. Collections are important to all programming languages because they allow
    you hold groups of related items. Closures are also important to Swift because
    they give you the ability to pass around functionality to be used in a different
    location of your code. There are several nice additions that will make working
    with collections even more fun. We will also explore some of the confusing side
    effects of creating closures in Swift 2.2 and how those have been fixed in Swift
    3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于 Swift 3 中的集合和闭包的变化。集合对于所有编程语言都很重要，因为它们允许你持有相关项的组。闭包对于 Swift 也同样重要，因为它们赋予你将功能传递到代码中不同位置的能力。有一些很好的新增功能将使使用集合变得更加有趣。我们还将探讨在
    Swift 2.2 中创建闭包的一些令人困惑的副作用，以及这些副作用如何在 Swift 3 中得到修复。
- en: Collection and sequence type changes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和序列类型变化
- en: 'Let''s begin our discussion with Swift 3 changes to Collection and Sequence
    types. Some of the changes are subtle and others are bound to require a decent
    amount of refactoring to your custom implementations. Swift provides three main
    collection types for warehousing your values: arrays, dictionaries, and sets.
    Arrays allow you to store values in an ordered list. Dictionaries provide unordered
    key-value storage for your data. Finally, sets provide an unordered list of unique
    values (that is, no duplicates allowed).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Swift 3 对集合和序列类型的变化开始讨论。其中一些变化很微妙，而另一些则可能需要对你自定义实现进行相当数量的重构。Swift 提供了三种主要的集合类型来存储你的值：数组、字典和集合。数组允许你按顺序列表存储值。字典为你提供无序的键值存储。最后，集合提供了一组无序的唯一值列表（即不允许重复）。
- en: Lazy FlatMap for sequence of optional [SE-0008]
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰的 FlatMap 用于可选序列 [SE-0008]
- en: Arrays, dictionaries, and sets are implemented as generic types in Swift. They
    each implement the new Collection protocol, which implements the Sequence protocol.
    Along this path from top-level type to Sequence protocol, you will find various
    other protocols that are also implemented in this inheritance chain. For our discussion
    on `flatMap` and lazy `flatMap` changes, I want to focus on Sequences.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、字典和集合在 Swift 中作为泛型类型实现。它们各自实现了新的 Collection 协议，该协议实现了 Sequence 协议。沿着从顶级类型到
    Sequence 协议的路径，你将找到在这个继承链中也实现了的各种其他协议。对于我们对 `flatMap` 和懒 `flatMap` 变化的讨论，我想专注于序列。
- en: Sequences contain a group of values that allow the user to visit each value
    one at a time. In Swift, you might consider using a for-in loop to iterate through
    your collection. The Sequence protocol provides implementations of many operations
    that you might want to perform on a list using sequential access; all of which
    you can override when you adopt the protocol in your custom collections. One such
    operation is the `flatMap` function, which returns an array containing the flattened,
    or rather concatenated, values resulting from a transforming operation applied
    to each element of the sequence. Let's consider how we could use the `flatMap`
    method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 序列包含一组值，允许用户逐个访问每个值。在 Swift 中，你可能会考虑使用 for-in 循环来遍历你的集合。Sequence 协议提供了许多操作的实施，这些操作可能是你想要在列表上使用顺序访问来执行的操作；所有这些你都可以在采用协议时在你的自定义集合中重写。其中一个操作是
    `flatMap` 函数，它返回一个包含从序列的每个元素应用转换操作得到的扁平化或连接的值的数组。让我们考虑一下我们如何使用 `flatMap` 方法。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our example above, we take a list of scores and call `flatMap` with our transforming
    closure. Each value is converted into a sequence containing the original value
    and a doubled value. Once the transforming operations complete, the `flatMap`
    method flattens the intermediate sequences into a single sequence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的示例中，我们取一个分数列表，并使用我们的转换闭包调用 `flatMap`。每个值都被转换成一个包含原始值和双倍值的序列。一旦转换操作完成，`flatMap`
    方法将中间序列扁平化为单个序列。
- en: We can also use the `flatMap` method with *Sequences* that contain optional
    values to accomplish a similar outcome. This time we are omitting values from
    the Sequence we flatten by return nil on the transformation. In the next example,
    we use the `flatMap` method to remove all nil values from our collection.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `flatMap` 方法与包含可选值的 *序列* 来实现类似的结果。这次我们在扁平化的序列中省略了值，通过在转换中返回 nil。在下一个示例中，我们使用
    `flatMap` 方法从我们的集合中移除所有 nil 值。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous two examples were fairly basic transformations on small sets of
    values. In a more complex situation, the collections that you need to work with
    might be very large with expensive transformation operations. Under those parameters,
    you would not want to perform the `flatMap` operation or any other costly operation
    until it was absolutely needed. Luckily, in Swift we have lazy operations for
    this use case. Sequences contain a `lazy` property that returns a `LazySequence`
    that can perform lazy operations on Sequence methods. Using our first example
    above, we can obtain a lazy sequence and call `flatMap` to get a lazy implementation.
    Only in the lazy scenario, the operation isn't completed until scores is used
    sometime later in code. To demonstrate lazy operations, we define a collection
    that uses the `lazy` property with our `flatMap` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例是对小集合值的基本转换。在更复杂的情况下，你需要处理的集合可能非常大，且转换操作成本高昂。在这些参数下，你不会想在绝对需要之前执行 `flatMap`
    操作或其他任何昂贵的操作。幸运的是，在 Swift 中我们有针对此用例的懒操作。序列包含一个 `lazy` 属性，它返回一个 `LazySequence`，可以对序列方法执行懒操作。使用我们上面的第一个示例，我们可以获得一个懒序列并调用
    `flatMap` 来获取懒实现。只有在懒操作场景下，操作才会在代码中稍后使用 `scores` 时完成。为了演示懒操作，我们定义了一个使用 `lazy`
    属性和我们的 `flatMap` 方法的集合。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `lazy` operation works as we would expect in our test above. However, when
    we use the `lazy` form of `flatMap` with our second example that contains optionals,
    our `flatMap` executes immediately in Swift 2\. Using the lazy version of `oddSquared`
    should delay execution of our `flatMap` operation until we use the variable. However,
    the `flatMap` method executes immediately, as if the lazy form didn't exist..
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy` 操作在我们上面的测试中按预期工作。然而，当我们使用包含可选值的第二个示例中的 `lazy` 形式的 `flatMap` 时，Swift
    2 中的 `flatMap` 会立即执行。使用 `oddSquared` 的懒版本应该会延迟 `flatMap` 操作的执行，直到我们使用该变量。然而，`flatMap`
    方法立即执行，就像没有懒形式一样。'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Essentially, this was a feature in Swift that has been changed in Swift 3 to
    behave similar to other lazy implementations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这曾是 Swift 中的一项特性，在 Swift 3 中被修改，以使其行为类似于其他懒加载实现。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md](https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中阅读提案 [https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md](https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md)
- en: Adding a first(where:) method to Sequence [SE-0032]
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 first(where:) 方法添加到 Sequence [SE-0032]
- en: A common task for working with collections is to find the first element that
    matches a condition. An example would be to ask for the first student in an array
    of students whose test scores contain  100\. You could accomplish this by using
    a predicate to return the filtered sequence that matched the criteria and then
    just give back the first student in the sequence. However, it would be much easier
    to just call a single method that could return the item without the two-step approach.
    This functionality was missing in Swift 2, but was voted in by the community and
    has been added for this release. In Swift 3 there is now a method on the Sequence
    protocol to implement `first(where:).`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合的一个常见任务是找到符合某个条件的第一元素。例如，你可以要求在包含 100 分的测试分数的学生数组中找到第一个学生。你可以通过使用谓词来返回匹配条件的过滤序列，然后只需在序列中返回第一个学生。然而，直接调用一个可以返回项目的方法会更简单，而不需要两步操作。这个功能在
    Swift 2 中缺失，但经过社区投票，已被添加到这次发布中。在 Swift 3 中，现在在 Sequence 协议上有一个方法来实现 `first(where:).`
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `first(where:)` extension is a nice addition to the language because it
    ensures that a simple and common task is actually easy to perform in Swift.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `first(where:)` 扩展是语言的一个很好的补充，因为它确保了一个简单且常见的任务在 Swift 中实际上很容易执行。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md](https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中阅读提案 [https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md](https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md)
- en: 'Add sequence(first: next:) and sequence(state: next:) [SE-0094]'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '添加序列（first: next:）和序列（state: next:）[SE-0094]'
- en: 'Swift 3 introduces two new global functions that operate on sequences: `sequence(first:next:)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 3 引入了两个新的全局函数，用于操作序列：`sequence(first:next:)`
- en: and `(state:next:)`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `(state:next:)`。
- en: 'Let''s look at the full definitions below:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的完整定义：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These two functions were added as replacements to the C-style for loops that
    were removed in Swift 3 and to serve as a compliment to the global reduce function
    that already exists in Swift 2\. What''s interesting about the additions is that
    each function has the capability of generating and working with infinite sized
    sequences. Let''s examine the first sequence function to get a better understanding
    of how it works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数被添加作为对 Swift 3 中移除的 C 风格 for 循环的替代，并作为对 Swift 2 中已经存在的全局 reduce 函数的补充。这些添加有趣的地方在于，每个函数都有生成和处理无限大小序列的能力。让我们检查第一个序列函数，以更好地理解它是如何工作的：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first sequence method returns a sequence that is created from repeated
    invocations of the *next* parameter, which holds a closure that will be lazily
    executed. The return value is an `UnfoldSequence` that contains the `first` parameter
    passed to the sequence method plus the result of applying the *next* closure on
    the previous value. The sequence is finite if `next` eventually returns `nil`
    and is infinite if `next` never returns *nil*. In the example that follows, we
    create and assign our sequence using the trailing closure form of `sequence(first:
    next:)`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个序列方法返回一个由重复调用 *next* 参数创建的序列，该参数包含一个将按需执行的闭包。返回值是一个 `UnfoldSequence`，它包含传递给序列方法的
    `first` 参数以及将 *next* 闭包应用于前一个值的结果。如果 `next` 最终返回 `nil`，则序列是有限的；如果 `next` 永远不返回
    *nil*，则序列是无限的。在下面的示例中，我们使用 `sequence(first: next:)` 的尾随闭包形式创建和分配我们的序列。'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our finite sequence will begin with 1.1 and will call `next` repeatedly until
    our next result is greater than 2 at which case `next` will return `nil`. We could
    easily convert this to an infinite sequence by removing our condition that our
    previous value must not be greater than 2\. The second sequence function maintains
    mutable state that is passed to all lazy calls of `next` to create and return
    a sequence. Let''s consider an example using the second method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的有限序列将从 1.1 开始，并重复调用 `next`，直到我们的下一个结果大于 2，此时 `next` 将返回 `nil`。我们可以很容易地将这个转换为无限序列，通过移除我们之前值不能大于
    2 的条件。第二个序列函数维护一个可变状态，该状态传递给所有 `next` 的懒调用以创建和返回一个序列。让我们考虑一个使用第二个方法的示例：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This version of the sequence function uses a passed in closure that allows you
    to update the mutable state each time `next` is called. As was the case with our
    first sequence function, a finite sequence ends when `next` returns a `nil`. You
    can turn a finite sequence into an infinite one by never returning `nil` when
    `next` is called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的序列函数使用一个传入的闭包，允许你在每次调用 `next` 时更新可变状态。正如我们第一个序列函数的情况一样，一个有限序列在 `next` 返回
    `nil` 时结束。你可以通过在调用 `next` 时永远不返回 `nil` 来将有限序列转换为无限序列。
- en: Let's create an example of how this version of the sequence method might be
    used. Traversing a hierarchy of views with nested views or any list of nested
    types is a perfect task for using the second version of the sequence function.
    Let's create a an Item class that has two properties. A name property and an optional
    parent property to keep track of the item's owner. The ultimate owner will not
    have a parent, meaning the parent property will be `nil`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例，说明这个版本的序列方法可能如何使用。遍历具有嵌套视图或任何嵌套类型列表的视图层次结构是一个使用第二个版本序列函数的完美任务。让我们创建一个具有两个属性的
    Item 类。一个名称属性和一个可选的父属性，以跟踪项的所有者。最终所有者将没有父项，这意味着父属性将是 `nil`。
- en: Let's define an Item class to use in our example to demonstrate usage of these
    new concepts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 Item 类来在我们的示例中使用，以展示这些新概念的使用。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we create a parent and two nested children items. Parent of `child1` will
    be the parent item and parent of `child2`  will be `child1`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个父项和两个嵌套的子项。`child1` 的父项将是父项本身，而 `child2` 的父项将是 `child1`。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now it''s time to create our sequence. The sequence needs two parameters from
    us: a `state` parameter and a `next` closure. I made the state an `Item` with
    an initial value of `child2`. The reason for this is because I want to start at
    the lowest leaf of my tree and traverse to the ultimate parent. Our example only
    has three levels, but you could have lots of levels in a more complex example.
    As for the *next* parameter, I''m using a closure expression that expects a mutable
    Item as its state. My closure will also return an optional Item. In the body of
    our closure, I use our current Item (mutable state parameter) to access the Item''s
    parent. I update the state and return the parent.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的序列了。序列需要我们提供两个参数：一个 `state` 参数和一个 `next` 闭包。我将状态设为一个 `Item`，初始值为 `child2`。这样做的原因是我希望从树的最低层叶子节点开始遍历到最终父节点。我们的示例只有三个层级，但在更复杂的示例中可能会有很多层级。至于
    `*next*` 参数，我使用了一个期望可变 `Item` 作为其状态的闭包表达式。我的闭包还将返回一个可选的 `Item`。在我们的闭包体中，我使用当前的
    `Item`（可变状态参数）来访问 `Item` 的父节点。我更新状态并返回父节点。
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are some gotchas here that I want to address so that you will better understand
    how to define your own next closure for this sequence method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的问题，我想指出，以便你更好地理解如何为这个序列方法定义自己的下一个闭包。
- en: The state parameter could really be anything you want it to be. It's for your
    benefit in helping you determine the next element of the sequence and to give
    you relevant information about where you are in the sequence. One idea to improve
    our example above would be to track how many levels of nesting we have. We could
    have made our state a tuple that contained an integer counter for the nesting
    level along with the current item.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态参数实际上可以是任何你想要的内容。它是为了帮助你确定序列的下一个元素，并为你提供有关你在序列中位置的相关信息。改进我们上述示例的一个想法是跟踪我们有多少层嵌套。我们可以将状态设为一个元组，其中包含一个表示嵌套层级的整数计数器以及当前项。
- en: The next closure needs to be expanded to show the signature. Because of Swift's
    expressiveness and conciseness when it comes to closures, you might be tempted
    to convert the *next* closure into a shorter form and omit the signature. Do not
    do this unless your *next* closure is extremely simple and you are positive that
    the compiler will be able to infer your types. Your code will be harder to maintain
    when you use the short closure format and you won't get extra points for style
    when someone else inherits it.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个闭包需要扩展以显示签名。由于 Swift 在闭包方面的表达性和简洁性，你可能会倾向于将 `*next*` 闭包转换为更短的形式并省略签名。除非你的
    `*next*` 闭包非常简单，并且你确信编译器能够推断出你的类型，否则不要这样做。使用短闭包格式会使你的代码更难维护，而且当其他人继承它时，你也不会因为风格而得到额外的分数。
- en: Don't forget to update your state parameter in the body of your closure. This
    really is your best chance to know where you are in your sequence. Forgetting
    to update the state will probably cause you to get unexpected results when you
    try to step through your sequence.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记在闭包体中更新你的状态参数。这真的是你了解自己在序列中位置的最佳机会。忘记更新状态可能会在你尝试遍历序列时导致你得到意外的结果。
- en: Make a clear decision ahead of time about whether you are creating a finite
    or infinite sequence. This decision is evident in how you return from your next
    closure. An infinite sequence is not bad to have when you are expecting it, however,
    if you iterate over this sequence using a `for…in` loop, you could get more than
    you bargained for, provided you were assuming this loop would end.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前明确决定你是在创建有限序列还是无限序列。这一决定在你从下一个闭包返回时是显而易见的。当你期望无限序列时，它并不是坏事，然而，如果你使用 `for…in`
    循环遍历这个序列，你可能会得到比你预期的更多，前提是你假设这个循环会结束。
- en: A new model for collections and indices [SE-0065]
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和索引的新模型 [SE-0065]
- en: 'Swift 3 introduces a new model for collections that moves the responsibility
    of the index traversal from the index to the collection itself. To make this a
    reality for collections, the Swift team introduced four areas of change:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 3 引入了一个新的集合模型，将索引遍历的责任从索引转移到集合本身。为了使这一变化适用于集合，Swift 团队引入了四个方面的变化：
- en: The Index property of a collection can be any type that implements the *Comparable*
    protocol
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的索引属性可以是实现 *Comparable* 协议的任何类型
- en: Swift removes any distinction between intervals and ranges; leaving just ranges
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 移除了区间和范围之间的任何区别；只留下范围
- en: Private index traversal methods are now public
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有索引遍历方法现在是公开的
- en: Changes to ranges make closed ranges work without the potential for errors
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Range的变化使得闭包范围可以无错误地工作
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md](https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读提案：[Swift 3迁移现有类型时的问题](https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md)
- en: Introducing the Collection protocol
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Collection协议
- en: In Swift 3, Foundation collection types such as Arrays, Dictionaries, and Sets
    are generic types that implement the newly created Collection protocol. This change
    was needed in order to support traversal on the collection. If you want to create
    custom collections of your own, you will need to understand the Collection protocol
    and where it lives in the Collection protocol hierarchy. We are going to cover
    the important aspects to the new collection model to ease you transition and to
    get your ready to create custom collection types of your own.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3中，Foundation集合类型如Arrays、Dictionaries和Sets是实现了新创建的Collection协议的泛型类型。这一变化是为了支持集合的遍历。如果您想创建自己的自定义集合，您需要了解Collection协议以及它在Collection协议层次结构中的位置。我们将介绍新集合模型的重要方面，以帮助您过渡并准备好创建自己的自定义集合类型。
- en: The Collection protocol builds on the Sequence protocol to provide methods for
    accessing specific elements when using a collection. For example, you can use
    a collection's `index(_:offsetBy:)` method to return an index that is a specified
    distance away from the reference index.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Collection协议建立在Sequence协议之上，提供在集合中使用时访问特定元素的方法。例如，您可以使用集合的`index(_:offsetBy:)`方法返回一个距离参考索引指定距离的索引。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our example above, we create the `twoAheadIndex` constant to hold the position
    in our numbers collection that is two positions away from our starting index.
    We simply use this index to retrieve the value from our collection using subscript
    notation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的例子中，我们创建了`twoAheadIndex`常量来保存我们的数字集合中距离起始索引两个位置的索引。我们只需使用这个索引通过下标符号从我们的集合中检索值。
- en: Conforming to the Collection protocol
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵守Collection协议
- en: 'If you would like to create your own custom collections, you need to adopt
    the Collection protocol by declaring `startIndex` and `endIndex` properties, a
    subscript to support access to your elements, and the `index(after: )` method
    to facilitate traversing your collection''s indices.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建自己的自定义集合，您需要通过声明`startIndex`和`endIndex`属性、一个支持访问您元素的索引和`index(after:)`方法来采用Collection协议，以方便遍历您的集合索引。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we are migrating existing types over to Swift 3, the migrator has some
    known issues with converting custom collections. It's likely that you can easily
    resolve the compiler issues by checking the imported types for conformance to
    the Collection protocol.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将现有类型迁移到Swift 3时，迁移器在转换自定义集合时存在一些已知问题。您很可能会通过检查导入的类型是否符合Collection协议来轻松解决编译器问题。
- en: Additionally, you need to conform to the Sequence and IndexableBase protocols
    as the Collection protocol adopts them both.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要遵守Sequence和IndexableBase协议，因为Collection协议采用了这两个协议。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A simple custom collection could look like the following example. Notice that
    I have defined my `Index` type to be an `Int.` In Swift 3, you define the index
    to be any type that implements the Comparable protocol:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的自定义集合可能看起来像以下示例。请注意，我已经将我的`Index`类型定义为`Int`。在Swift 3中，您可以将索引定义为任何实现了Comparable协议的类型：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Collection protocol has default implementations for most of its methods,
    the Sequence protocols methods, and the IndexableBase protocols methods. This
    means you are only required to provide a few things of your own. You can, however,
    implement as many of the other methods that make sense for your collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Collection协议为其大多数方法、Sequence协议的方法和IndexableBase协议的方法提供了默认实现。这意味着您只需要提供一些自己的东西。然而，您可以为您的集合实现尽可能多的其他方法。
- en: New Range and associated indices types
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的Range和相关索引类型
- en: 'Swift 2''s `Range<T>`, `ClosedInterval<T>`, and `OpenInterval<T>` are going
    away in Swift 3\. These types are being replaced with four new types. Two of the
    new range types support general ranges with bounds that implement the Comparable
    protocol: `Range<T>` and `ClosedRange<T>`. The other two range types conform to
    `RandomAccessCollection`. These types support ranges whose bounds implement the
    Strideable protocol.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 的 `Range<T>`、`ClosedInterval<T>`和`OpenInterval<T>`在 Swift 3 中将被弃用。这些类型将被四种新类型所取代。其中两种新的范围类型支持具有实现`Comparable`协议边界的通用范围：`Range<T>`和`ClosedRange<T>`。其他两种范围类型符合`RandomAccessCollection`。这些类型支持具有实现`Strideable`协议边界的范围。
- en: Last, ranges are no longer iterable since ranges are now represented as a pair
    of indices. To keep legacy code working, the Swift team introduced an associated
    Indices type, which is iterable. In addition, three generic types were created
    to provide a default *Indices* type for each type of collection traversal category.
    The generics are `DefaultIndices<C>`, `DefaultBidirectionalIndices<C>`, and `DefaultRandomAccessIndices<C>`;
    each stores its underlying collection for traversal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于范围现在表示为两个索引的配对，它们不再可迭代。为了保持旧代码的兼容性，Swift 团队引入了一个关联的`Indices`类型，它是可迭代的。此外，创建了三个泛型类型，为每种集合遍历类别提供默认的`Indices`类型。这些泛型是`DefaultIndices<C>`、`DefaultBidirectionalIndices<C>`和`DefaultRandomAccessIndices<C>`；每个都存储其底层集合以进行遍历。
- en: Quick takeaways
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速总结
- en: I covered a lot of stuff in a just a few pages on collection types in Swift
    3\. Here are the highlights to keep in mind about the collections and indices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Swift 3 的集合类型仅用几页纸就涵盖了大量内容。以下是关于集合和索引的要点，请记住。
- en: Collection types (built-in and custom) implement the Collection protocol.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集类型（内置和自定义）实现了收集协议。
- en: Iterating over collections has moved to the Collection - the index no longer
    has that ability.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合已移动到 Collection - 索引不再具有该功能。
- en: 'You can create your own collections by adopting the Collection protocol. You
    need to implement:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过采用收集协议来创建自己的集合。您需要实现：
- en: '`startIndex` and `endIndex` properties,'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startIndex`和`endIndex`属性，'
- en: The subscript method to support access to your elements
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下标方法以支持访问您的元素
- en: 'And the `index(after: )` method to facilitate traversing your collection''s
    indices.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且提供了`index(after:)`方法来方便遍历集合的索引。
- en: Closure changes for Swift 3
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 3 的闭包变化
- en: A closure in Swift is a block of code that can be used in a function call as
    a parameter or assigned to a variable to execute their functionality at a later
    time. Closures are a core feature to Swift and are familiar to developers that
    are new to Swift as they may remind them of lambda functions in other programming
    languages. For Swift 3, there were two notable changes that I will highlight in
    this section. The first change deals with inout captures. The second is a change
    that makes non-escaping closures the default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的闭包是一段代码块，可以用作函数调用的参数或分配给变量，以便在稍后执行其功能。闭包是 Swift 的核心特性，对于新接触 Swift 的开发者来说很熟悉，因为它们可能会让他们想起其他编程语言中的
    lambda 函数。对于 Swift 3，这里将突出两个显著的变化。第一个变化是关于 inout 捕获。第二个变化是将非逃逸闭包作为默认值。
- en: Limiting inout Capture of @noescape Closures [SE-0035]
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制@noescape闭包的inout捕获 [SE-0035]
- en: In Swift 2, capturing `inout` parameters in an escaping closure is difficult
    for developers to understand. Some closures are assigned to variables and then
    passed to functions as arguments. If the function that contains the closure parameter
    returns from its call and the passed in closure is used later, then you have an
    escaping closure. On the other hand, if the closure is only used within the function
    to which it is passed and not used later, then you have a non-escaping closure.
    The distinction is important here because of the mutating nature of `inout` parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，在逃逸闭包中捕获`inout`参数对开发者来说难以理解。一些闭包被分配给变量，然后作为参数传递给函数。如果包含闭包参数的函数从其调用中返回，并且传递的闭包稍后被使用，那么您有一个逃逸闭包。另一方面，如果闭包仅用于传递给它的函数中，并且以后不再使用，那么您有一个非逃逸闭包。这里的区别很重要，因为`inout`参数的修改性质。
- en: When we pass an `inout` parameter to a closure, there is a possibility that
    we will not get the result we expect due to how the `inout` parameter is stored.
    The `inout` parameter is captured as a shadow copy and is only written back to
    the original if the value changes. This works fine most of the time. However,
    when the closure is called at a later time (that is, when it escapes), we don't
    get the result we expect. Our shadow copy can't write back to the original. Let's
    look at an example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`inout`参数传递给闭包时，可能会因为`inout`参数的存储方式而无法得到预期的结果。`inout`参数被捕获为阴影副本，并且只有在值发生变化时才会写回原始值。这大多数时候都工作得很好。然而，当闭包在稍后时间被调用（即，当它逃逸时），我们不会得到预期的结果。我们的阴影副本无法写回原始值。让我们看一个例子。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the example above, we get what we expect. We have created a closure to increment
    our passed in `inout` parameter and then return the new parameter multiplied by
    10\. When we check the value of *seed* after the closure is called, we see that
    the value has increased to `11`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们得到了预期的结果。我们创建了一个闭包来增加传入的`inout`参数，然后返回乘以10的新参数。当我们调用闭包后检查`seed`的值，我们看到值已经增加到`11`。
- en: In our second example, we modify our closure to return a function instead of
    just an `Int` value. We move our logic to the closure that we are defining as
    our return value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个例子中，我们修改我们的闭包，使其返回一个函数而不是仅仅一个`Int`值。我们将我们的逻辑移动到我们定义的返回值闭包中。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time when we execute the `modifiedClosure` with our `seed` value we get
    a function as the result. After executing this intermediate function, we check
    our *seed* value and see that the value is unchanged; even though we are still
    incrementing the `seed` value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们用`seed`值执行`modifiedClosure`时，我们得到一个函数作为结果。执行这个中间函数后，我们检查`seed`的值，发现值没有改变；尽管我们仍在增加`seed`值。
- en: These two slight differences in syntax when using `inout` parameters generate
    different results. Without knowledge of how shadow copy works, it would be hard
    to understand the difference in results. Ultimately, this is just another situation
    where you receive more harm than good by allowing this feature to remain in the
    language.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`inout`参数时，这两个微小的语法差异会产生不同的结果。如果没有了解阴影副本的工作原理，就很难理解结果之间的差异。最终，这又是一个你因为允许这个特性保留在语言中而得到更多伤害而不是好处的例子。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md](https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中阅读提案 [https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md](https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md)
- en: Resolution
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: In Swift 3, the compiler now limits `inout` parameter usage with closures to
    non-escaping (`@noescape`). You will receive an error if the compiler detects
    that your closure escapes when it contains `inout` parameters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3中，编译器现在限制`inout`参数在闭包中的使用为非逃逸（`@noescape`）。如果编译器检测到你的闭包包含`inout`参数时逃逸，你会收到一个错误。
- en: Making non-escaping closures the default [SE-0103]
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将非逃逸闭包设置为默认值 [SE-0103]
- en: In previous versions of Swift, the default behavior of function parameters whose
    type was a closure was to allow escaping. This made sense as most of the Objective-C
    blocks (closures in Swift) imported into Swift were escaping. The delegation pattern
    in Objective-C, as implemented as blocks, was composed of delegate blocks that
    escaped. So why would the Swift team want to change the default to non-escaping
    as the default? Let's look at examples in Swift 2.2 and Swift 3 to get a better
    understanding of why this change makes sense.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift的早期版本中，函数参数的类型为闭包时的默认行为是允许逃逸。这很有道理，因为大多数导入到Swift中的Objective-C块（Swift中的闭包）都是逃逸的。Objective-C中的代理模式，作为块实现，由逃逸的代理块组成。那么Swift团队为什么要将默认值改为非逃逸呢？让我们通过Swift
    2.2和Swift 3的例子来更好地理解这个变化为什么合理。
- en: 'In Swift 2.2:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2.2中：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Swift 3:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Swift team believes you can write better functional algorithms with non-escaping
    closures. An additional supporting factor is the change to require non-escaping
    closures when using `inout` parameters with the closure *[SE-0035]*. All things
    considered, this change will likely have little impact on your code. When the
    compiler detects that you are attempting to create an escaping closure, you will
    get a warning that you are possibly creating an escaping closure. You can easily
    correct the error by adding `@escaping` or via the `fixit` that accompanies the
    error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Swift团队认为，您可以使用非逃逸闭包编写更好的函数式算法。另一个支持因素是，当使用闭包的`inout`参数时，要求使用非逃逸闭包*[SE-0035]*。综合考虑，这个变化可能对您的代码影响很小。当编译器检测到您正在尝试创建一个逃逸闭包时，您将收到一个警告，提示您可能正在创建一个逃逸闭包。您可以通过添加`@escaping`或通过伴随错误的`fixit`轻松纠正错误。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md](https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读提案[https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md](https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md)
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered changes to collections and closures. We learned about
    the new Collection protocol that forms the base of the new collection model and
    how to adopt the protocol in our own custom collections. The new collection model
    made a significant change in moving collection traversal from the index to the
    collection itself. The new collection model changes are necessary in order to
    support Objective-C interactivity and to provide a mechanism to iterate over the
    collections items using the collections itself. As for closures, we also explored
    the motivation for the language moving to non-escaping closures as the default.
    We also learned how to properly use `inout` parameters with closures in Swift
    3\. In the next chapter, we are will cover more type changes and type aliases
    within protocols and protocol extensions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了集合和闭包的变化。我们学习了新的集合协议，它是新集合模型的基础，以及如何在我们的自定义集合中采用该协议。新的集合模型通过将集合遍历从索引移动到集合本身，实现了重大变化。为了支持Objective-C的交互性并提供一种机制，使用集合本身来遍历集合项，新的集合模型变化是必要的。至于闭包，我们还探讨了语言转向非逃逸闭包作为默认值的动机。我们还学习了如何在Swift
    3中正确使用`inout`参数与闭包。在下一章中，我们将介绍更多协议和协议扩展中的类型变化和类型别名。
