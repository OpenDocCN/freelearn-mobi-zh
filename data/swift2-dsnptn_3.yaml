- en: Chapter 3. Structural Patterns – Composite and Flyweight
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 结构模式 - 组合和享元
- en: 'We have already seen three structural patterns: the decorator, proxy, and bridge
    patterns that provide us with ways of adding state and behavior dynamically, controlling
    the creation and access of objects, and keeping specifications and implementations
    separate. This chapter will now focus on the composite and flyweight patterns
    that are designed to facilitate the manipulation of a group of objects or large
    number of small objects. The composite is often used and we can also make use
    of the flyweight pattern.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了三种结构模式：装饰者模式、代理模式和桥接模式，它们为我们提供了动态添加状态和行为、控制对象的创建和访问以及保持规范和实现分离的方法。现在，本章将重点关注组合模式和享元模式，这些模式旨在简化对一组对象或大量小对象的操作。组合模式经常被使用，我们还可以利用享元模式。
- en: The flyweight pattern efficiently shares the common information present in small
    objects by helping you reduce the memory consumption or storage requirements when
    many values are duplicated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式通过帮助您减少在许多值重复时的内存消耗或存储需求，有效地共享小对象中存在的公共信息。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: The composite pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: The flyweight pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: 'The objectives of these two new structural patterns are described in the following
    table:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了这两种新结构模式的目标：
- en: '| Pattern | Objective |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 目标 |'
- en: '| --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The composite pattern | This pattern allows you to compose objects into tree
    structures and treat the group of objects as an instance of an object. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 组合模式 | 此模式允许您将对象组合成树结构，并将对象组视为对象的一个实例。 |'
- en: '| The flyweight pattern | This pattern allows you to manage huge number of
    objects by instantiating them on the fly to improve the performance efficiently.
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 享元模式 | 此模式允许您通过即时实例化来管理大量对象，从而有效地提高性能。 |'
- en: The composite pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: This pattern is very often used to manipulate a group of objects. Swift, like
    many other languages already makes use of the composite pattern in its internal
    structure. For example, in the case of the `UIView` class available in the `cocoa`
    framework, which defines a common behavior of an app layout. Then, individuals
    view objects in the view hierarchy can be leaf nodes (such as labels) or composites
    that have collections of other views (such as table view controllers).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式经常用于操作一组对象。Swift，像许多其他语言一样，已经在其内部结构中使用了组合模式。例如，在`cocoa`框架中可用的`UIView`类，它定义了应用布局的通用行为。然后，视图层次结构中的单个视图对象可以是叶节点（如标签）或具有其他视图集合的复合（如表视图控制器）。
- en: Roles
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: This pattern permits you to treat single components and a group of components
    in the same way by providing a structured hierarchy of objects. It allows you
    to build structures of objects in the form of trees that contain both compositions
    of objects and individual objects as nodes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许您通过提供对象的分层结构来以相同的方式处理单个组件和一组组件。它允许您以树的形式构建对象结构，其中包含对象的组合和作为节点的单个对象。
- en: Using this pattern, we can create complex trees and treat them as a whole or
    as parts. Operations can be applied to the whole or the parts too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式，我们可以创建复杂的树，并将它们作为一个整体或部分来处理。操作也可以应用于整体或部分。
- en: We generally find the `add`, `remove`, `display`, `find`, and `group` operations
    in the `Composite` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在`Composite`类中找到`add`、`remove`、`display`、`find`和`group`操作。
- en: 'This pattern can be used when:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况发生时，可以使用此模式：
- en: It is necessary to have a composition hierarchy in a system
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统中必须有组合层次结构
- en: Clients need to be ignored if they are working with composites objects
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端正在处理组合对象，则需要忽略它们。
- en: Design
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic UML class diagram is represented in the following figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了通用的UML类图：
- en: '![Design](img/4852_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_03_01.jpg)'
- en: Participants
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of this pattern are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的参与者如下：
- en: '`Component`: This is an abstract class that introduces an object''s interface
    of the composition, implements common methods, and defines the method signature
    that manages the addition or deletion of components.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component`：这是一个抽象类，它引入了对象的组合接口，实现了常用方法，并定义了管理组件添加或删除的方法签名。'
- en: '`Leaf`: This is a concrete class that defines the behavior of the elements
    in the composition. It implements the operations that the `Composite` class supports.
    A `Leaf` class does not have its own components.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Leaf`：这是一个具体类，它定义了组成中元素的行为。它实现了 `Composite` 类支持的运算。`Leaf` 类没有自己的组件。'
- en: '`Composite`: This is a concrete class that defines the behavior of the components
    that have children and store the child components. It implements the `Leaf` class-related
    operations. This class has an aggregation of the `Component` class.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Composite`：这是一个具体类，它定义了具有子组件并存储子组件的组件的行为。它实现了与 `Leaf` 类相关的操作。这个类聚合了 `Component`
    类。'
- en: '`Client`: This class uses the component''s interface to manipulate the objects
    in the composition.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：这个类使用组件的接口来操作组成中的对象。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Composite` contains components. Components can be `Leaf` or `Composite`. It
    is indeed recursive. A composite holds a set of children; these children may be
    other composites or leaf elements.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Composite` 包含组件。组件可以是 `Leaf` 或 `Composite`。这确实是递归的。一个复合体包含一组子组件；这些子组件可能是其他复合体或叶元素。'
- en: Collaboration
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: A client sends a request to the leaf throughout the `Component` interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过 `Component` 接口向叶组件发送请求。
- en: When a component receives a request, it reacts depending on its class. If the
    component is a leaf, then it will treat the request itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件收到一个请求时，它会根据其类来反应。如果组件是叶组件，那么它将自行处理请求。
- en: If the component is a composite, it will first treat on itself, then it will
    send a message to each of its child, which in turn will execute a treatment too.
    Then, when every child completes their treatment, the composite will execute the
    last treatment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是复合体，它将首先处理自身，然后向每个子组件发送消息，这些子组件接着也会执行处理。然后，当每个子组件完成处理后，复合体将执行最后的处理。
- en: Illustration
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: Our company has an online catalog of **Video on demand** (**VOD**). All our
    movies are categorized by genre. As this is a pay-per-view system, each of our
    videos will have a price, name, and small description.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公司有一个在线的 **视频点播**（**VOD**）目录。我们所有的电影都按类型分类。由于这是一个按次付费的系统，我们每个视频都将有一个价格、名称和简短描述。
- en: 'Now, we want to easily manipulate the display of our full catalog using this
    new pattern. The following schema represents the organization of our catalog:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望通过这个新模式轻松地操作我们完整目录的显示。以下图表示了目录的组织结构：
- en: '![Illustration](img/4852_03_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![插图](img/4852_03_02.jpg)'
- en: Implementation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'So, it''s time for us to apply the generic design of the composite pattern
    to our case. First, we will redesign our pattern according to our scenario in
    order to understand what we need to do, as shown in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候将组合模式的通用设计应用到我们的案例中。首先，我们将根据我们的场景重新设计我们的模式，以便了解我们需要做什么，如下面的图所示：
- en: '![Implementation](img/4852_03_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_03_03.jpg)'
- en: The `VODManager` class will use the `VODComponent` interface to access the VOD
    categories and VOD items. The `VODComponent` class is our abstract class that
    will provide the default implementation of the defined methods. The `VODItem`
    class will only override the methods that make sense. The `VODCategory` class
    will also override methods that make sense, including a way to add the new `VODItem`
    and `VODCategory` objects. After reorganizing our pattern, we are now ready to
    implement our solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`VODManager` 类将使用 `VODComponent` 接口来访问 VOD 类别和 VOD 项目。`VODComponent` 类是我们提供的抽象类，它将提供定义方法的默认实现。`VODItem`
    类将只覆盖有意义的方 法。`VODCategory` 类也将覆盖有意义的方 法，包括添加新的 `VODItem` 和 `VODCategory` 对象的方式。在重新组织我们的模式后，我们现在可以开始实现我们的解决方案。'
- en: Implementation of the VODComponent
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VODComponent 的实现
- en: 'First, we create our abstract class, which both `VODItem` and `VODCategory`
    will inherit form. This class will provide the interface for the leaf nodes and
    composite nodes. Swift doesn''t support an abstract class; nevertheless, nothing
    should prevent us from implementing the default behavior onto our methods, such
    as informing that a method is not supported using an **assert**. An assert will
    just inform us that if it is used in an inappropriate class, then the method will
    not be supported. We could write our "fake" abstract class like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建我们的抽象类，`VODItem`和`VODCategory`都将从这个类继承。这个类将为叶子节点和组合节点提供接口。Swift不支持抽象类；然而，没有什么应该阻止我们将默认行为应用到我们的方法上，比如使用**assert**来通知一个方法不被支持。assert将只是通知我们，如果它在不适用的类中使用，那么该方法将不被支持。我们可以像这样编写我们的“假”抽象类：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implementation of the VODItem leaf
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VODItem 叶子节点的实现
- en: 'Our component class is ready; a default behavior is available for each method.
    We can now implement our `VODItem` class. It is a leaf class in the composite
    diagram and implements the behavior of the elements of the composite:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件类已经准备好了；每个方法都有一个默认行为。我们现在可以实现我们的`VODItem`类。它是在组合图中的一个叶子类，实现了组合中元素的行为：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See how I have defined the private variables with `!`. This means that the values
    of these variables cannot be nil after initialization. This is true because we
    added a constructor (the `init` method) where all our arguments must be passed
    to initialize our private fields.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我是如何使用`!`定义私有变量的。这意味着这些变量的值在初始化后不能为nil。这是因为我们添加了一个构造函数（`init`方法），其中所有我们的参数都必须传递以初始化我们的私有字段。
- en: Then, we override only methods that interest us. The `Add`/`Remove` and `GetChild`
    methods don't need to be overridden here; this will be done in the composite class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只重写这个类中我们感兴趣的方法。`Add`/`Remove`和`GetChild`方法在这里不需要重写；这将在组合类中完成。
- en: To ensure that each name, description, and price has a value, we added an exclamation
    mark to unwrap it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个名称、描述和价格都有一个值，我们添加了一个感叹号来解包它。
- en: 'It is now time to implement our composite category class. We will call this
    composite class: `VODCategory`. It will hold `VODItems` or `VODCategory`. You''ll
    see that again we will override only methods that interest us in this class. The
    `getPrice()` method will not interest us as it doesn''t make sense.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们的组合类别类了。我们将把这个组合类命名为：`VODCategory`。它将包含`VODItems`或`VODCategory`。你会看到，我们在这里只重写这个类中我们感兴趣的方法。`getPrice()`方法不会引起我们的兴趣，因为它没有意义。
- en: Implementation of the VODCategory composite
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VODCategory 组合的实现
- en: 'The first shot of the `VodCategory` class could be written as follow:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`VodCategory`类的第一个版本可以写成如下：'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Well, as with `VODComponent`, we override the methods that interest us. As we
    can have any number of `VODComponent`, we add an array of type `VODComponent`
    to hold them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，就像`VODComponent`一样，我们重写了我们感兴趣的方法。由于我们可以有任意数量的`VODComponent`，我们添加了一个类型为`VODComponent`的数组来保存它们。
- en: We added the `Add`, `Remove`, and `GetChild` methods. The `Add` method will
    allow us to add an item, category, or subcategory. We can also remove it and return
    a `VODComponent` class based on its index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`Add`、`Remove`和`GetChild`方法。`Add`方法将允许我们添加一个项目、类别或子类别。我们也可以删除它，并基于其索引返回一个`VODComponent`类。
- en: Again, we can add a name and description to our composite that will be displayed
    when the `display()` method will be invoked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以给我们的组合添加一个名称和描述，当调用`display()`方法时将显示出来。
- en: 'Let''s take a look at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you write it like the preceding code, you'll get an error because Swift doesn't
    provide a `remove` method for the `Array` type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像前面的代码那样编写，你会得到一个错误，因为Swift没有为`Array`类型提供`remove`方法。
- en: It's time to make some modifications in our implementation and introduce you
    to the use of extensions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候对我们的实现做一些修改，并介绍扩展的使用了。
- en: Our problem is that we want to be able to remove an object of the type `VODComponent`
    to our `vodComponents` array using a method called `remove` (or anything else),
    where we pass an object that represents the object we want to remove from the
    list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题是，我们想要能够通过一个名为`remove`（或任何其他名称）的方法从我们的`vodComponents`数组中移除一个`VODComponent`类型的对象，其中我们传递一个表示我们想要从列表中移除的对象的实例。
- en: 'If we check the available method when the auto-completion is displayed, we
    do not see any method that can help us in this purpose, as shown in the following
    screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在自动完成时检查可用的方法，我们看不到任何可以帮助我们实现这个目的的方法，如下面的截图所示：
- en: '![Implementation of the VODCategory composite](img/4852_03_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![VODCategory组合的实现](img/4852_03_04.jpg)'
- en: In [Chapter 2](ch02.html "Chapter 2. Structural Patterns – Decorator, Proxy,
    and Bridge"), *Structural Patterns – Decorator, Proxy, and Bridge,* you could
    have used the decorator pattern to add such methods to the `Array` type; you can
    also propose to simply add a method to the class that will test all the elements
    in the array by comparing them one by one, and if they are identical, remove them
    from the list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。结构型模式 – 装饰器、代理和桥接")*结构型模式 – 装饰器、代理和桥接*中，你可以使用装饰器模式将此类方法添加到`Array`类型；你也可以提议简单地添加一个方法到类中，该方法将通过逐个比较来测试数组中的所有元素，如果它们相同，则从列表中删除它们。
- en: What we want is something that can be reused and generic. For this, Swift has
    `extension`. This permits you to add a behavior to a class very easily. Let's
    do it by adding a `remove` method to the type `Array`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是可以重用和通用的东西。为此，Swift有`extension`。这允许你非常容易地向类添加行为。让我们通过向`Array`类型添加`remove`方法来实现这一点。
- en: The extension must not be added to a class. Indeed, extensions are global. If
    you add extensions to an OS X or iOS project, you'll generally add them to a dedicated
    Swift file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展不能添加到类中。实际上，扩展是全局的。如果你要将扩展添加到OS X或iOS项目中，你通常会将其添加到一个专门的Swift文件中。
- en: 'Here is our extension:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的扩展：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As this function modifies the instance of the `Array` type and its properties,
    we mark this function as mutating. Then, we start from the end of the list and
    compare the elements that we want to find in the current elements of the list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数修改了`Array`类型及其属性，我们将此函数标记为可变。然后，我们从列表的末尾开始，比较我们想要在列表当前元素中找到的元素：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, here there are some tricky things to do to make this code without any
    error. This function tells that we want that `Array` of type `T` must implement
    `Equatable` (is said with `remove <T: Equatable>` ) to be able to make the comparison:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，这里有一些棘手的事情要做，以使这段代码没有任何错误。这个函数告诉我们，我们想要`T`类型的`Array`实现`Equatable`（用`remove
    <T: Equatable>`表示）以便能够进行比较：'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Therefore, we need to modify our abstract class, telling that our class implements
    the `Equatable` protocol:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要修改我们的抽象类，说明我们的类实现了`Equatable`协议：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, adding this protocol modifies our class diagram a little, but no
    matter. By implementing this protocol we are telling that elements of type `VODComponent`
    can be compared using `==` and `!=`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，添加这个协议会稍微修改我们的类图，但没关系。通过实现这个协议，我们是在说`VODComponent`类型的元素可以使用`==`和`!=`进行比较。
- en: 'If this is not completed, then we need to implement this protocol, so the best
    way to do this is by making a global function outside any class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还没有完成，那么我们需要实现这个协议，所以最好的方法是在任何类之外创建一个全局函数：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `===` operator tells us whether the instances of the two components are
    identical or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`运算符告诉我们两个组件的实例是否相同。'
- en: So, now, all the code required for this class is written; the `remove` method
    is available and works perfectly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，这个类的所有代码都已经编写完成；`remove`方法可用且工作完美。
- en: Some improvements need to be added to our class to fully complete the implementation
    of the composite.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的类进行一些改进，以完全完成组合的实现。
- en: Have you seen how we implemented the `display` method in our composite (`VODCategory`)
    ? Indeed, the `display()` method of the composite only displays the information
    about itself, but it must invoke the `display()` method of each element that is
    contained in the composite. To do this, we will simply add a small part of the
    code that will iterate all elements that the composite contains in its array by
    adding a call to their respective `display()` methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我们如何在组合（`VODCategory`）中实现了`display`方法了吗？确实，组合的`display()`方法只显示它自己的信息，但它必须调用组合中每个元素的`display()`方法。为此，我们将简单地添加一小段代码，通过调用它们各自的`display()`方法来迭代组合中包含的所有元素。
- en: 'Let''s change the `display()` method of the `VODCategory` class to add an iteration
    to all our elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变`VODCategory`类的`display()`方法，为所有我们的元素添加一个迭代：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, we iterate over each element of the array using `for … in` and call the
    `display()` method of each element.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`for … in`遍历数组的每个元素，并调用每个元素的`display()`方法。
- en: Usage
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: All our classes are now ready and it's time to see how we can use this pattern
    in our client to test all of this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有类现在都已准备就绪，现在是时候看看我们如何在客户端使用这个模式来测试所有这些了。
- en: 'We first prepare our `VODManager` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先准备我们的`VODManager`类：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we write our test code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写我们的测试代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to prepare all our components. So, first, we prepare our tree category
    and then we add items to the good category.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要准备所有组件。所以，首先，我们准备我们的树形类别，然后向好的类别添加项目。
- en: At the end of the script, we call the `vodManager.displayCatalog()` method that
    will invoke the `display` method of all the components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本末尾，我们调用`vodManager.displayCatalog()`方法，这将调用所有组件的`display`方法。
- en: So, why don't we see something interesting in Playground? In fact, we have some
    clues that tell us that the code has been properly executed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在Playground中看不到有趣的东西呢？事实上，我们有一些线索告诉我们代码已经被正确执行。
- en: 'On the right-hand side of the screen, we can see the number of times a method
    has been called, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，我们可以看到方法被调用的次数，如下面的截图所示：
- en: '![Usage](img/4852_03_05.jpg)![Usage](img/4852_03_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Usage](img/4852_03_05.jpg)![Usage](img/4852_03_06.jpg)'
- en: 'However, we will modify this a little bit to get something more accurate for
    our test. We will modify each `display()` method by adding the string `return`
    type and replace the `print` statement with a `return` statement that contains
    the string to be returned:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将对其进行一点修改，以使测试结果更准确。我们将通过添加字符串`return`类型并替换`print`语句为包含要返回的字符串的`return`语句来修改每个`display()`方法：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You need to change the `display()` method of the `VODComponent`, `VODItem`,
    and `VODCategory` classes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更改`VODComponent`、`VODItem`和`VODCategory`类的`display()`方法。
- en: 'For `VODCategory`, you need to modify it like the following code so that it
    is easily readable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`VODCategory`，你需要像以下代码那样修改它，以便它易于阅读：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For `VODManager`, you need to simply add the return type and replace `print`
    with `return`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`VODManager`，你只需要添加返回类型并将`print`替换为`return`：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, move the `tvSeriesCategory.add(voSTTvSeries)` line in the *Usage*
    section (marked with a comment : // USAGE) of the Playground file ( just before
    the `vodManager.display()`line; this will make our result easier to read.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将*Usage*部分（带有注释：// USAGE）中的`tvSeriesCategory.add(voSTTvSeries)`行（在`vodManager.display()`行之前）移动，这将使我们的结果更容易阅读。
- en: 'Now, you will see something on the right-hand side just after the `vodManager.display()`
    line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在`vodManager.display()`行后立即在右侧看到一些内容：
- en: '![Usage](img/4852_03_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Usage](img/4852_03_07.jpg)'
- en: 'Click on the Eye icon on the right-hand side of the screen. You''ll see the
    result of our `vodManager.display()` invocation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击屏幕右侧的“眼睛”图标。你会看到我们的`vodManager.display()`调用的结果：
- en: '![Usage](img/4852_03_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Usage](img/4852_03_08.jpg)'
- en: Notice that the `display()` method of the composite or leaf is called recursively.
    The items are organized depending on the categories that we have added them to.
    In the preceding screenshot, we can see that after `Horror VODCategory` is called,
    all horror movies (`VODItem`) that we defined are displayed, then it continues
    with the TV series that also contain a `VOST TV Series` subcategory, and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组合或叶子的`display()`方法被递归调用。项目根据我们添加它们的类别进行组织。在前面的截图中，我们可以看到在调用`Horror VODCategory`之后，我们定义的所有恐怖电影（`VODItem`）都被显示出来，然后继续显示包含`VOST
    TV Series`子类别的电视剧，依此类推。
- en: This concludes our discovery of the composite pattern.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对组合模式的发现结束。
- en: The flyweight pattern
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元模式
- en: This pattern can be used when the system needs to deal with a large number of
    similar objects. Instead of creating each element one by one, this pattern permits
    you to reuse an object that shares the same data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统需要处理大量相似对象时，可以使用此模式。而不是逐个创建每个元素，此模式允许您重用具有相同数据的对象。
- en: Roles
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The flyweight pattern is used to reduce the memory and resource usage of complex
    models that contain many hundreds and thousands of similar objects by reducing
    the number of objects created. It tries to reuse similar existing objects or creates
    a new one when no match is found.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式通过减少创建的对象数量来减少包含数百甚至数千个相似对象的复杂模型的内存和资源使用。它试图重用相似现有的对象，或者在找不到匹配项时创建一个新的对象。
- en: 'This pattern can be used when:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况发生时，可以使用此模式：
- en: We need to manipulate a lot of small similar objects
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要操作很多小而相似的对象
- en: The cost (the memory/execution time) of this manipulation is high
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此操作的代价（内存/执行时间）很高
- en: Design
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following class diagram represents the generic structure of the pattern:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图代表了该模式的通用结构：
- en: '![Design](img/4852_03_09.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Design](img/4852_03_09.jpg)'
- en: Participants
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'There are three participants to the flyweight pattern, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式有三个参与者，如下所示：
- en: '`Flyweight`: This declares an interface that contains an intrinsic state and
    implements methods. These methods can receive and act on the extrinsic state of
    the flyweights.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flyweight`：这个接口声明了一个包含内在状态并实现方法的接口。这些方法可以接收并作用于享元的额外状态。'
- en: '`FlyweightFactory`: This factory creates and manages a flyweight''s objects.
    It assures that the flyweight is shared, thanks to the method that it returns
    a reference to the flyweight.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyweightFactory`：这个工厂创建并管理享元对象。它通过返回享元的引用来确保享元的共享。'
- en: '`Client`: This contains references to the used flyweight. It also contains
    the extrinsic state of these flyweights.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：这包含了对使用的享元对象的引用。它还包含这些享元的额外状态。'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The extrinsic state**: This is the state that belongs to the context of the
    object (external) or unique to that instance.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**外在状态**：这是属于对象上下文的状态（外部）或对该实例唯一的状态。'
- en: '**The intrinsic state**: This is the state that belongs to the flyweight object
    and should be permanent or immutable (internal).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**内在状态**：这是属于享元对象的状态，应该是永久或不可变的（内部）。'
- en: Collaboration
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: Clients do not create the flyweight by themselves, but they use the `FlyweightFactory`
    method that guarantees the sharing of flyweights.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不会自己创建享元，而是使用 `FlyweightFactory` 方法，该方法保证了享元的共享。
- en: When a client invokes a method of a flyweight, it needs to send its extrinsic
    state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端调用享元的方法时，它需要发送其额外状态。
- en: Illustration
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: Suppose that we want to display 200000 rectangles on a 1024 x 768 screen. These
    rectangles are generated randomly; they can have a random color from a list of
    10 different colors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在 1024 x 768 的屏幕上显示 200000 个矩形。这些矩形是随机生成的；它们可以从 10 种不同颜色的列表中随机选择颜色。
- en: We need to reduce the time taken to execute the function and use as less memory
    as possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要减少执行函数所需的时间，并尽可能少地使用内存。
- en: Implementation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In this example, we will use an `XCTest` project with the `XCTest` framework
    and instrument tool to illustrate how this pattern will help us reduce the memory
    consumption.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用带有 `XCTest` 框架和工具的 `XCTest` 项目来展示这个模式将如何帮助我们减少内存消耗。
- en: First, open the project called `Flyweight Pattern_Demo1` that you will find
    in the source code folder of this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开名为 `Flyweight Pattern_Demo1` 的项目，你可以在本章的源代码文件夹中找到它。
- en: 'Go to the Xcode project named `FlyweightPattern_Demo1Tests` and click on the
    `FlyweightPattern_Demo1Tests.swift` file, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前往名为 `FlyweightPattern_Demo1Tests` 的 Xcode 项目，并点击下面的 `FlyweightPattern_Demo1Tests.swift`
    文件，如图所示：
- en: '![Implementation](img/4852_03_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_03_10.jpg)'
- en: In this file, you'll see the different test methods that are already implemented.
    Before starting with the implementation of our flyweight pattern, let's see what
    we currently have.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你会看到已经实现的不同测试方法。在我们开始实现享元模式之前，让我们看看我们目前有什么。
- en: 'We already have an abstract class called `AbstractPerfTest` that contains some
    already defined properties, fields, and methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个名为 `AbstractPerfTest` 的抽象类，其中包含一些已经定义的属性、字段和方法：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is another class called `NoPattern` that inherits from this abstract
    class and overrides the run method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `NoPattern` 的类，它继承自这个抽象类并重写了 `run` 方法：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `SimpleRect` class is defined in the `SimpleRect.swift` file of the `NoPattern`
    group folder. It is an object defined by a color, *x* and *y* position, width,
    and height.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleRect` 类定义在 `NoPattern` 组文件夹的 `SimpleRect.swift` 文件中。它是一个由颜色、*x* 和 *y*
    位置、宽度和高度定义的对象。'
- en: I will not comment too much on the `NoPattern` class, but what we see here is
    that the `run` method of the `NoPattern` class generates `NUMBER_TO_GENERATE`
    (set to `100000` by default in the `FlyweightPattern_Demo1Tests.swift` file) rectangles
    with a random color taken from the list of the colors array (defined in the abstract
    class). It then generates a position and dimension for each of these rectangles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会对 `NoPattern` 类进行过多的注释，但在这里我们看到的是，`NoPattern` 类的 `run` 方法生成了 `NUMBER_TO_GENERATE`（默认在
    `FlyweightPattern_Demo1Tests.swift` 文件中设置为 `100000`）个随机颜色的矩形，这些颜色来自颜色数组列表（在抽象类中定义）。然后为这些矩形中的每一个生成一个位置和尺寸。
- en: Now, let's check the performance of the `run` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `run` 方法的性能。
- en: Come back to the `FlyweightPattern_Demo1Tests.swift` file and check the method
    named `testSimpleScreenFilling_noFlyWeight()`. Here, the method will execute the
    code implemented in the `NoPattern` class that, like the name of the method tells
    us, does not implement the flyweight pattern. The execution time of this method
    will be used as a baseline to compare the same method but with the implementation
    of the flyweight pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `FlyweightPattern_Demo1Tests.swift` 文件，检查名为 `testSimpleScreenFilling_noFlyWeight()`
    的方法。在这里，该方法将执行 `NoPattern` 类中实现的代码，正如方法名所告诉我们的，它没有实现飞重量模式。这个方法的执行时间将被用作基线，以比较实现飞重量模式后的相同方法。
- en: 'So, let''s execute the test by clicking on the small icon on the left-hand
    side of the `func testSimpleScreenFilling_noFlyWeight()` function, as shown in
    the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过点击 `func testSimpleScreenFilling_noFlyWeight()` 函数左侧的小图标来执行测试，如下面的截图所示：
- en: '![Implementation](img/4852_03_12.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_03_12.jpg)'
- en: 'We need to ensure that the console is visible in Xcode. While executing, you''ll
    see that the console log with **200000 rects generated** has been repeated 10
    times. This proves that our code has generated 2,00,000 rectangles 10 times. By
    default, the `self.measureBlock` closure is executed 10 times, and it calculates
    the standard deviation of these 10 executions to obtain an average execution time:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保在 Xcode 中可见控制台。在执行过程中，你会看到带有 **200000 个矩形已生成** 的控制台日志被重复了 10 次。这证明了我们的代码已经生成了
    200,000 个矩形 10 次。默认情况下，`self.measureBlock` 闭包执行 10 次，并计算这 10 次执行的方差以获得平均执行时间：
- en: '![Implementation](img/4852_03_13.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_03_13.jpg)'
- en: 'On my MacBook Pro 15 Retina Late 2013, the average time is **0.804** seconds:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 MacBook Pro 15 Retina Late 2013 上，平均时间是 **0.804** 秒：
- en: '![Implementation](img/4852_03_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_03_14.jpg)'
- en: Now, the best part is to refactor our code to reduce the time taken to generate
    these 2,00,000 rectangles. As you have already seen in the generic structure of
    the pattern, we will need a few classes to manage our flyweights.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最好的部分是将我们的代码重构以减少生成这些 200,000 个矩形所需的时间。正如你已经在模式的通用结构中看到的那样，我们需要几个类来管理我们的飞重量。
- en: Let's start with our `flyweightRect` class. Note that the `flyweightRect` and
    `SimpleRect` classes are used in the `NoPattern` class to generate rectangles
    that are identical.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的 `flyweightRect` 类开始。注意，`flyweightRect` 和 `SimpleRect` 类在 `NoPattern`
    类中使用，以生成完全相同的矩形。
- en: Therefore, in the following code, you'll find our `FlyweightRect` class with
    the definition of our rectangle. So, we have a color, *x* and *y* position, height,
    and width of the rectangle.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下面的代码中，你会找到我们的 `FlyweightRect` 类以及我们矩形的定义。因此，我们有一个颜色，*x* 和 *y* 位置，矩形的高度和宽度。
- en: 'Note that because I really want to see the gain in performance, I added two
    fields: `image` and `sprite`. Because the value of these fields have a cost in
    terms of performance on the instantiation of the class, I added them to show you
    clearly that the flyweight pattern permits you to reduce the calculation costs
    (and memory usage) when applied.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我真的很想看到性能的提升，我添加了两个字段：`image` 和 `sprite`。因为这些字段的值在类实例化时会有性能成本，所以我添加了它们，以便清楚地展示飞重量模式允许你在应用时减少计算成本（和内存使用）。
- en: 'We will add a constructor to the intrinsic state as an argument: this will
    be the color. We will add another `display()`method that will receive extrinsic
    states as arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向固有状态添加一个构造函数作为参数：这将是有色。我们将添加另一个 `display()` 方法，它将接收外延状态作为参数：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once our flyweight is defined, we can now prepare our `FlyweightFactory` object.
    Remember that this factory will first check if we already have a rectangle that
    is similar to the new one that we want to position on the screen; if it is not
    similar, then it will create a new one:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的飞重量被定义，我们现在可以准备我们的 `FlyweightFactory` 对象。记住，这个工厂将首先检查我们是否已经有了与我们要在屏幕上定位的新矩形相似的矩形；如果不是相似的，那么它将创建一个新的：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We declare a static `rectsMap` variable of the type `Dictionary` that will contain
    our shared objects and manage their existence. The dictionary `Key` will contain
    a `Color` object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个静态的 `rectsMap` 变量，其类型为 `Dictionary`，它将包含我们的共享对象并管理它们的生存期。字典的 `Key` 将包含一个
    `Color` 对象。
- en: Then, we define a static method called `getFlyweightRect` that will return a
    `FlyweightRect` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个名为 `getFlyweightRect` 的静态方法，它将返回一个 `FlyweightRect` 类。
- en: As `rectMaps[color]` returns `nil`, we unwrap the optional with a `if let` statement.
    If it is not `nil`, we return the result; otherwise, we create a new flyweight
    with the appropriate color, add it to our dictionary, and return the result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `rectMaps[color]` 返回 `nil`，我们使用 `if let` 语句解包可选值。如果它不是 `nil`，我们返回结果；否则，我们创建一个新的具有适当颜色的享元，将其添加到我们的字典中，并返回结果。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the `FlyweightPattern_Demo1.swift` file, you'll find several test methods
    that test the response time of the factory depending on the type of the object
    that manages our flyweights. In the project, I tested the performance of the object
    that manages our flyweights using the `Dictionary<SKColor, FlyweightRect>`, `NSMutableDictionary`,
    and `NSCache` types.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FlyweightPattern_Demo1.swift` 文件中，你可以找到几个测试方法，这些方法测试了根据管理我们的享元对象的对象类型，工厂的响应时间。在项目中，我使用了
    `Dictionary<SKColor, FlyweightRect>`、`NSMutableDictionary` 和 `NSCache` 类型来测试管理我们的享元对象的对象性能。
- en: 'The complete code of the `FlyweightRectFactory.swift` file is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlyweightRectFactory.swift` 文件的完整代码如下：'
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Usage
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Using our pattern is extremely easy. You need to check the `run()` method of
    the `WithPattern.swift` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的模式非常简单。你需要检查 `WithPattern.swift` 文件中的 `run()` 方法：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will simply make a loop to create 200000 `FlyweightRect` objects (`NUMBER_TO_GENERATE`
    is a constant defined at the top of the `FlyweightPattern_Demo1Tests.swift` file).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地循环创建 200000 个 `FlyweightRect` 对象（`NUMBER_TO_GENERATE` 是在 `FlyweightPattern_Demo1Tests.swift`
    文件顶部定义的一个常量）。
- en: 'The `WithPattern` class written in the preceding does the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面编写的 `WithPattern` 类执行以下操作：
- en: We first generate a random number that returns a value that will correspond
    to the index of a color available in the colors array (defined in the `AbstractPerfTest.swift`
    file).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先生成一个随机数，该随机数返回一个值，将对应于颜色数组（在 `AbstractPerfTest.swift` 文件中定义）中可用的颜色的索引。
- en: Then, we tell the factory to return a flyweight with the appropriate color.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们告诉工厂返回具有适当颜色的享元。
- en: Then, we generate the extrinsic state (*x* position, *y* position, width, and
    height).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成外部的状态（*x* 位置，*y* 位置，宽度，和高度）。
- en: Once the loop is complete, we display the number of generated rectangles.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦循环完成，我们显示生成的矩形数量。
- en: Performance results
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能结果
- en: To check the performance, there is an `XCTest` class available in the project
    with the `self.measureblock` closure that allows us to measure the performance
    of our block.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查性能，项目中有一个 `XCTest` 类，它有一个 `self.measureblock` 闭包，允许我们测量我们代码块的性能。
- en: 'To launch all the tests available in the project, click on the **Show the Test
    navigator** button on the left-hand side, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动项目中所有可用的测试，请点击左侧的 **显示测试导航器** 按钮，如图所示：
- en: '![Performance results](img/4852_03_15.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](img/4852_03_15.jpg)'
- en: 'Then, click on the play button that is visible on the right-hand side of the
    highlighted line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击高亮行右侧可见的播放按钮：
- en: '![Performance results](img/4852_03_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](img/4852_03_16.jpg)'
- en: After a few seconds, all the tests would have been run and you can now check
    your performance results.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，所有测试都会完成，你现在可以检查你的性能结果。
- en: 'Come back to the `FlyweightPattern_Demo1Tests.swift` file and check the end
    of each `measureblock()` method. This is the result with the flyweight pattern
    using a dictionary. You can see that it took an average of 0.247 seconds to generate
    200000 rectangles, as shown in the following screenshot. You''ll see a text with
    `Time xxxx` written; this is the average time taken to execute this block:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `FlyweightPattern_Demo1Tests.swift` 文件并检查每个 `measureblock()` 方法的末尾。这是使用字典的享元模式的性能结果。你可以看到生成
    200000 个矩形平均花费了 0.247 秒，如图所示。你会看到一个带有 `Time xxxx` 文字的文本；这是执行此块的平均时间：
- en: '![Performance results](img/4852_03_17.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](img/4852_03_17.jpg)'
- en: 'As compared to an average of **0.877** seconds without using the pattern:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与未使用模式时的平均 **0.877** 秒相比：
- en: '![Performance results](img/4852_03_18.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![性能结果](img/4852_03_18.jpg)'
- en: 'After reviewing the results, you''ll see that generating rectangles are better
    when (best performance first):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看结果后，你会发现生成矩形时（性能最好的先列出来）：
- en: The flyweight pattern with a `Dictionary` object is used to manage our shared
    objects
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Dictionary` 对象的享元模式用于管理我们的共享对象
- en: The flyweight pattern with a `NSDictionary` object is used to manage our shared
    objects
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `NSDictionary` 对象的享元模式用于管理我们的共享对象
- en: The flyweight pattern with a `NSCache` object is used to manage our shared objects
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `NSCache` 对象的享元模式用于管理我们的共享对象
- en: No pattern is applied
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有应用任何模式
- en: In this example, we can say that generating 200000 `FlyweightRect` objects is
    3,55 times faster than without using the pattern.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以说，生成 200000 个 `FlyweightRect` 对象比不使用模式快 3,55 倍。
- en: The test project proves that Swift is faster than Objective-C and `NSCache,`
    which are encapsulated.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目证明，Swift 比 Objective-C 和封装的 `NSCache` 更快。
- en: The `NSDictionary` object will have its own logic while handling the cache.
    It can create more objects inside its own hidden code structure, so it's slower
    than the `NSDictionary` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理缓存时，`NSDictionary` 对象将拥有自己的逻辑。它可以在自己的隐藏代码结构内部创建更多对象，因此比 `NSDictionary` 对象慢。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to deal with structures of multiple objects.
    The composite pattern allows you to access and alter data structures in a uniform
    way, whereas the flyweight pattern is a more accurate way to save the memory space
    or time spent in calculation when they are multiple similar objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何处理多个对象的结构。组合模式允许你以统一的方式访问和修改数据结构，而享元模式则是当存在多个相似对象时，更精确地节省内存空间或计算时间的做法。
- en: A flyweight pattern is useful with other patterns to keep data as small as possible.
    The composite pattern is useful in combination with other patterns to manage the
    data structure. The composite pattern can use a flyweight pattern, but the inverse
    will not.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式与其他模式结合使用时，有助于将数据保持得尽可能小。组合模式与其他模式结合使用时，有助于管理数据结构。组合模式可以使用享元模式，但反之则不行。
- en: In this chapter, I tried to present you with something different; using the
    `XCTest` framework, to test the performance of our pattern. If you want to dive
    deeper, you can try to see the difference in the memory allocation using the instrument
    tools provided in Xcode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我尝试向你展示一些不同之处；使用 `XCTest` 框架来测试我们模式的性能。如果你想深入了解，你可以尝试使用 Xcode 提供的仪器工具查看内存分配的差异。
- en: In the next chapter, we will continue with the discovery of our structural patterns
    by learning what the adapter and facade patterns are.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过学习适配器和外观模式来发现我们的结构模式。
