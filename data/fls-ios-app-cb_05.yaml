- en: Chapter 5. Multi-touch and Gesture Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 多点触控和手势支持
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Setting the touch point input mode
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置触摸点输入模式
- en: Detecting multiple touch points
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测多个触摸点
- en: Dragging multiple display objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动多个显示对象
- en: Tracking movement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪移动
- en: Setting the gesture input mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置手势输入模式
- en: Handling a swipe gesture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理滑动手势
- en: Panning an object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平移一个对象
- en: Rotating an object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转一个对象
- en: Zooming an object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放一个对象
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The iPhone wasn't the first to use the technology, but its success kick-started
    the touch-screen revolution. Critical to that success was Apple's decision to
    include multi-touch support. Be it a single tap, swipe, or pinch; interaction
    with the iPhone's screen always feels intuitive and natural.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 并非第一个使用这项技术的设备，但它的成功启动了触摸屏革命。对这一成功至关重要的是苹果决定包含多点触控支持。无论是单次点击、滑动还是捏合；与
    iPhone 屏幕的交互总是直观而自然。
- en: The Flash platform allows application developers to take full advantage of multi-touch
    when targeting iOS. In this chapter, we will explore how to work with multiple-touch
    points before covering how to detect and respond to gestures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Flash 平台允许应用程序开发者充分利用多点触控，当针对 iOS 时。在本章中，我们将探讨如何处理多个触摸点，然后再介绍如何检测和响应手势。
- en: Setting the touch point input mode
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置触摸点输入模式
- en: The success of the iPhone has changed how people use mobile devices, with users
    now expecting to interact directly with a device by physically touching its screen.
    While a mouse is limited to the selection of a single point, iOS devices can detect
    multiple touches and track the movement of each of them simultaneously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 的成功改变了人们使用移动设备的方式，现在用户期望通过物理触摸屏幕直接与设备交互。虽然鼠标仅限于选择单个点，但 iOS 设备可以检测多个触摸并同时跟踪它们的每个移动。
- en: Flash provides full support for multi-touch but in order to take advantage of
    it you must first inform the platform of your intentions to receive and use touch-based
    events.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flash 提供了对多点触控的全面支持，但为了利用它，您必须首先通知平台您的意图，即接收和使用基于触摸的事件。
- en: Let us see how this is done.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个 FLA 作为本菜谱的起点。
- en: From the book's accompanying code bundle, open `chapter5\recipe1\recipe.fla`
    into Flash Professional.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter5\recipe1\recipe.fla` 打开到 Flash Professional 中。
- en: Sitting on the stage is a dynamic text field named `output`. We will write some
    code to enable multi-touch input and write the success or failure of the request
    to the text field.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段上有一个名为 `output` 的动态文本字段。我们将编写一些代码以启用多点触控输入并将请求的成功或失败写入文本字段。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a document class and name it `Main`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Main` 的文档类。
- en: 'Add the following two import statements:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两个导入语句：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now within the constructor add some code to enable multi-touch support:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在构造函数中添加一些代码以启用多点触控支持：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the class file as `Main.as`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类文件保存为 `Main.as`。
- en: Publish the FLA and deploy the IPA file to your iOS device.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 文件部署到您的 iOS 设备上。
- en: 'When you run the app, the following text should be output to the screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，以下文本应输出到屏幕上：
- en: '**inputMode = touchPoint**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**inputMode = touchPoint**'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Flash provides various multi-touch input modes, which determine the type of
    events your application can receive. In order to receive touch events, you need
    to set the `Multitouch.inputMode` property to `MultitouchInputMode.TOUCH_POINT`.
    Here is the line of code from your document class that does this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flash 提供了各种多点触控输入模式，这些模式决定了您的应用程序可以接收的事件类型。为了接收触摸事件，您需要将 `Multitouch.inputMode`
    属性设置为 `MultitouchInputMode.TOUCH_POINT`。这是您文档类中执行此操作的代码行：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition to setting `Multitouch.inputMode`, you can also query it to determine
    the currently selected input mode. For this recipe, the current input mode is
    written to the `output` text field to confirm that it was successfully set:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置 `Multitouch.inputMode`，您还可以查询它以确定当前选定的输入模式。对于这个菜谱，当前输入模式被写入 `output` 文本字段以确认它已成功设置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although Flash supports multi-touch across all iOS devices, the same is not
    true for all other operating systems and platforms. When writing cross-platform
    code, you may want to confirm support by checking the `Multitouch.supportsTouchEvents`
    property. In our code example, this is done before setting the input mode.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flash支持所有iOS设备的多触控，但并非所有其他操作系统和平台都如此。在编写跨平台代码时，您可能需要通过检查`Multitouch.supportsTouchEvents`属性来确认支持。在我们的代码示例中，这是在设置输入模式之前完成的。
- en: For more information regarding the multi-touch input mode, perform a search
    for `flash.ui.Multitouch` and `flash.ui.MultitouchInputMode` within Adobe Community
    Help.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于多触控输入模式的信息，请在Adobe社区帮助中搜索`flash.ui.Multitouch`和`flash.ui.MultitouchInputMode`。
- en: It is also highly recommended that you spend time with Apple's iOS Human Interface
    Guidelines, where you will find best practices for driving the user experience
    through multi-touch. The documentation can be found on the iOS Dev Center at [http://developer.apple.com/devcenter/ios](http://developer.apple.com/devcenter/ios).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还强烈建议您花时间研究苹果的iOS人机界面指南，在那里您将找到通过多触控驱动用户体验的最佳实践。文档可以在iOS开发中心[http://developer.apple.com/devcenter/ios](http://developer.apple.com/devcenter/ios)找到。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let us look at some additional detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些额外的细节。
- en: Available touch events
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用的触控事件
- en: Setting the input mode for touch allows you to listen for touch-specific events
    being dispatched by objects of type `InteractiveObject` or objects that inherit
    `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage`. On a multi-touch
    screen, each point of contact that can be made by a finger is known as a touch
    point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置触控的输入模式允许您监听由类型为`InteractiveObject`或继承自`InteractiveObject`的对象（如`Sprite, MovieClip`和`Stage`）分发的特定于触控的事件。在多触控屏幕上，每个手指可以接触的点称为触点。
- en: 'The following touch events are available:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可用的触控事件：
- en: '| Touch events | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 触控事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TOUCH_BEGIN` | A touch point has been pressed. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_BEGIN` | 触点已被按下。|'
- en: '| `TOUCH_END` | A touch point has been released. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_END` | 触点已被释放。|'
- en: '| `TOUCH_MOVE` | A touch point is being moved. This occurs when a finger is
    being dragged across the screen. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_MOVE` | 触点正在移动。这发生在手指在屏幕上拖动时。|'
- en: '| `TOUCH_TAP` | A quick finger tap. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_TAP` | 快速的手指轻触。|'
- en: '| `TOUCH_OVER` | A touch point has moved over an interactive object. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_OVER` | 触点已移至交互对象上。|'
- en: '| `TOUCH_OUT` | A touch point has been moved away from an interactive object.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_OUT` | 触点已从交互对象移开。|'
- en: '| `TOUCH_ROLL_OVER` | A touch point has moved over an interactive object. Unlike
    `TOUCH_OVER`, this event will not fire for any children belonging to the object.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_ROLL_OVER` | 触点已移至交互对象上。与`TOUCH_OVER`不同，此事件不会对对象的所有子对象触发。|'
- en: '| `TOUCH_ROLL_OUT` | A touch point has been moved away from an interactive
    object. Unlike `TOUCH_OUT`, this event will not fire for any children belonging
    to the object. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `TOUCH_ROLL_OUT` | 触点已从交互对象移开。与`TOUCH_OUT`不同，此事件不会对对象的所有子对象触发。|'
- en: We will see some of these events in action during the next few recipes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将看到一些这些事件的实际应用。
- en: Determining the number of supported touch points
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定支持的触点数量
- en: You can determine the number of touch points supported by your iOS device by
    examining the static `Multitouch.maxTouchPoints` property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查静态属性`Multitouch.maxTouchPoints`来确定您的iOS设备支持的触点数量。
- en: While you will find that five touch points are supported across the range of
    iOS devices, this property is of more practical use on cross-platform projects,
    where the number of touch points can vary wildly depending on the operating system
    and choice of input device. When targeting multiple platforms, optimize your content
    with this in mind.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您会发现iOS设备支持5个触点，但此属性在跨平台项目中更有实用价值，因为在不同的操作系统和输入设备选择下，触点数量可能会有很大的变化。当针对多个平台时，请考虑这一点来优化您的内容。
- en: Touch point hit targets
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触点击中目标
- en: For elements that can be tapped within your application, ensure that a hit area
    that is at least the size of a fingertip is used. This equates to approximately
    44x44 pixels on a standard resolution screen and 88x88 pixels on a Retina display.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您应用程序中可以点击的元素，请确保使用至少与指尖大小相当的击中区域。在标准分辨率屏幕上，这相当于大约44x44像素，在Retina显示屏上为88x88像素。
- en: Mouse events
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: The default input mode is `MultitouchInputMode.NONE`, which specifies that all
    user interaction with a touch-enabled device is interpreted as a mouse event.
    However, unlike `MultitouchInputMode.TOUCH_POINT`, only a single touch point can
    be processed at any one time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输入模式是 `MultitouchInputMode.NONE`，这表示所有与触摸设备交互的用户操作都被解释为鼠标事件。然而，与 `MultitouchInputMode.TOUCH_POINT`
    不同，任何时刻只能处理一个触摸点。
- en: Note that when the input mode is set to `MultitouchInputMode.TOUCH_POINT`, you
    can continue to listen for and respond to mouse events provided by `flash.events.MouseEvents`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当输入模式设置为 `MultitouchInputMode.TOUCH_POINT` 时，你可以继续监听和响应由 `flash.events.MouseEvents`
    提供的鼠标事件。
- en: Testing in ADL
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 ADL 中测试
- en: 'It is most likely that testing this recipe''s code within ADL will result in
    the following message being output to the screen:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能在 ADL 中测试此菜谱代码会导致以下消息输出到屏幕：
- en: '**Multi-touch events not supported.**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持多点触控事件。**'
- en: Not all desktop computers or operating systems support multi-touch. When using
    touch-based events within your code, it is advisable that you test directly on
    an iOS device.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有台式计算机或操作系统都支持多点触控。当在代码中使用基于触摸的事件时，建议直接在 iOS 设备上测试。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a basic document class, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建基本文档类，[第 3 章](ch03.html "第 3 章。编写你的第一个应用程序")*'
- en: '*Handling user interaction, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理用户交互，[第 4 章](ch04.html "第 4 章。将 Flash 项目移植到 iOS")*'
- en: '*Detecting multiple touch points*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测多个触摸点*'
- en: '*Setting the gesture input mode*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置手势输入模式*'
- en: Detecting multiple touch points
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测多个触摸点
- en: The term multi-touch refers to the ability to simultaneously detect and track
    two or more distinct points of contact on a touch-screen. Touch events are similar
    to the mouse events provided by Flash, except you can listen for and respond to
    multiple touch events all at once.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多点触控术语指的是同时检测和跟踪触摸屏上两个或更多不同接触点的功能。触摸事件类似于 Flash 提供的鼠标事件，除了你可以同时监听和响应多个触摸事件。
- en: Let us revisit the Bubbles app from [Chapter 3](ch03.html "Chapter 3. Writing
    your First App") and add multi-touch interaction to it. We will add functionality
    to let the user trap multiple bubbles by holding a finger on top of each.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第 [3 章](ch03.html "第 3 章。编写你的第一个应用程序") 中的 Bubbles 应用程序，并向其中添加多点触控交互。我们将添加功能，使用户可以通过在每个气泡上方放置手指来捕获多个气泡。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A version of the Bubbles FLA has been provided for you to work from.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 已为你提供了一个 Bubbles FLA 版本供你工作。
- en: From Flash Professional, open `chapter5\recipe2\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Flash Professional 打开书籍附带代码包中的 `chapter5\recipe2\recipe.fla`。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will be making changes to both the FLA's document class and `Bubble.as`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 FLA 的文档类和 `Bubble.as` 进行修改。
- en: Updating the Bubble class
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 Bubble 类
- en: 'Let us start by adding some code to `Bubble.as` that prevents any of the bubble
    instances from moving if being held:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `Bubble.as` 添加一些代码开始，以防止在触摸时移动任何气泡实例：
- en: Open the `Bubble.as` class.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Bubble.as` 类。
- en: 'Add the following member variable:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下成员变量：
- en: '[PRE4]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now write a getter and a setter method for the `_held` variable:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为 `_held` 变量编写获取器和设置器方法：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Move to the `update()` method and write a few lines of code at the start to
    prevent the bubble''s update logic from running if it is being held:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 `update()` 方法，并在开始处编写几行代码以防止在触摸时更新气泡的逻辑：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, within the constructor, disable user input for any child display objects
    within the bubble—we are only interested in receiving events for the bubble''s
    container:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构造函数中，禁用气泡内任何子显示对象的用户输入——我们只对接收气泡容器的事件感兴趣：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save `Bubble.as.`
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Bubble.as`。
- en: Responding to multiple touch events
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应多个触摸事件
- en: 'Now within the FLA''s document class, let us listen for multi-touch events
    and trap any bubbles that are being touched:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 FLA 的文档类中，让我们监听多点触控事件并捕获任何被触摸的气泡：
- en: Open the `Main.as` document class.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Main.as` 文档类。
- en: 'Include the following three import statements:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下三个导入语句：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within the constructor, set the input mode, and listen for `TouchEvent.TOUCH_BEGIN`
    and `TouchEvent.TOUCH_END` being dispatched from the stage:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中设置输入模式，并监听从舞台派发的 `TouchEvent.TOUCH_BEGIN` 和 `TouchEvent.TOUCH_END`：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Write a handler for the `TOUCH_BEGIN` event:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `TOUCH_BEGIN` 事件编写处理程序：
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And add a handler for the `TOUCH_END` event too:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并为 `TOUCH_END` 事件添加处理程序：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save `Main.as`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Main.as`。
- en: Publish the FLA and deploy the IPA file to your device.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA文件并将IPA文件部署到您的设备上。
- en: Run the app and hold your fingers on multiple bubbles to stop them from floating
    upwards. Lifting your finger off a bubble will release it again.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用，并将手指放在多个气泡上以阻止它们向上漂浮。将手指从气泡上抬起将再次释放它。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe took advantage of multi-touch to allow the detection of touch points
    across multiple objects simultaneously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱利用了多点触控，允许同时检测多个对象的触摸点。
- en: 'Touch was enabled with the following line of code within the `Main` class''
    constructor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`类的构造函数中，通过以下代码行启用了触摸功能：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Touch events can be dispatched by any `InteractiveObject` or sub-class of `InteractiveObject`,
    such as `Sprite, MovieClip`, and `Stage`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`InteractiveObject`或其子类，如`Sprite, MovieClip`和`Stage`，都可以分发触摸事件。
- en: 'Listeners for the following two events were added to the stage:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 已经将以下两个事件的监听器添加到了舞台：
- en: '`TouchEvent.TOUCH_BEGIN`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchEvent.TOUCH_BEGIN`'
- en: '`TouchEvent.TOUCH_END`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchEvent.TOUCH_END`'
- en: The `TOUCH_BEGIN` event is fired when the user presses a finger onto any child
    interactive object of the stage. This is the case even if other areas of the screen's
    surface are already being touched. When the user lifts their finger from an interactive
    object, the `TOUCH_END` event is dispatched.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将手指按在任何舞台的子交互对象上时，会触发`TOUCH_BEGIN`事件。即使屏幕的其他区域已经被触摸，这也是这种情况。当用户从交互对象上抬起手指时，会分发`TOUCH_END`事件。
- en: In this recipe, the stage's child objects consist of bubble instances and a
    single background movie clip. The event handlers simply check to see if the event
    was dispatched from a `Bubble` instance, and if so the bubble's `held` property
    is set. For the `TOUCH_BEGIN` event, the bubble's `held` property is set to `true`,
    thus freezing it. When the `TOUCH_END` event is received, the bubble's held property
    is set to `false`, allowing it to start moving upwards again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，舞台的子对象包括气泡实例和单个背景电影剪辑。事件处理程序只是检查事件是否是从`Bubble`实例分发的，如果是，则将气泡的`held`属性设置为。对于`TOUCH_BEGIN`事件，将气泡的`held`属性设置为`true`，从而将其冻结。当接收到`TOUCH_END`事件时，将气泡的`held`属性设置为`false`，允许它再次向上移动。
- en: You can obtain more information regarding the `flash.events.TouchEvent` class
    from Adobe Community Help.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Adobe社区帮助中获取有关`flash.events.TouchEvent`类的更多信息。
- en: Handling roll out
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理滚动退出
- en: Sometimes the user's finger may slide away from the bubble rather than being
    cleanly lifted from it. When this happens in this recipe's example code, the held
    bubble doesn't receive the `TOUCH_END` event and therefore doesn't start floating
    upwards again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用户的指尖可能从气泡上滑开，而不是干净地抬起。当在此菜谱的示例代码中发生这种情况时，被持有的气泡不会收到`TOUCH_END`事件，因此不会再次开始向上漂浮。
- en: 'You can rectify this by listening for `TouchEvent.TOUCH_ROLL_OUT` being dispatched
    from each of the bubble instances. Simply add the following line within the `Main`
    class'' constructor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过监听每个气泡实例分发的`TouchEvent.TOUCH_ROLL_OUT`来纠正这一点。只需在`Main`类的构造函数中添加以下行：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when the user slides his or her finger away from a bubble, the `touchEnd()`
    handler will get called and the bubble will start moving again.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户将手指从气泡上滑开时，`touchEnd()`处理程序将被调用，气泡将再次开始移动。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can carry your code from this recipe into the next. If you have added an
    event listener for `TouchEvent.TOUCH_ROLL_OUT`, then remove it again before continuing
    as it isn't required and will produce odd behavior if left in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此菜谱中的代码带入下一个菜谱。如果您为`TouchEvent.TOUCH_ROLL_OUT`添加了事件监听器，则在继续之前请将其再次移除，因为它不是必需的，如果保留它会产生奇怪的行为。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Each event object that your handler receives contains a number of properties
    related to that touch event. You may find the following properties useful when
    detecting multiple touch points.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您的处理程序收到的每个事件对象都包含与该触摸事件相关的多个属性。在检测多个触摸点时，您可能会发现以下属性很有用。
- en: Primary touch point
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要触摸点
- en: When touching a screen at multiple locations, the primary touch point is deemed
    to be the location that was first touched. When your event handler receives a
    `TouchEvent` object, you can query its `isPrimaryTouchPoint` property to determine
    this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当在屏幕的多个位置触摸时，首先触摸的位置被认为是主要触摸点。当您的处理程序接收到`TouchEvent`对象时，您可以通过查询其`isPrimaryTouchPoint`属性来确定这一点。
- en: Touch point ID
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触摸点ID
- en: A unique ID is assigned to every new touch point and is used across all events
    associated with that point of contact. You can determine the touch point that
    an event is associated with by examining its `touchPointID` property.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的触摸点都会分配一个唯一的 ID，并用于所有与该接触点相关的事件。您可以通过检查事件的 `touchPointID` 属性来确定与事件相关联的触摸点。
- en: Local touch coordinates
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地触摸坐标
- en: You can use the `localX` and `localY` properties to determine the coordinates
    at which a touch event occurred relative to the interactive object. Bear in mind
    that these two properties won't provide pixel-perfect accuracy on touch-screen
    devices due to the nature of the technology and the surface area that is covered
    by a finger tip.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `localX` 和 `localY` 属性来确定触摸事件相对于交互对象的坐标。请注意，由于技术的性质和指尖覆盖的表面积，这两个属性在触摸屏设备上不会提供像素级的精确度。
- en: Global touch coordinates
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局触摸坐标
- en: You can also obtain the position at which an event occurred in global stage
    coordinates. Simply inspect the value of the event's `stageX` and `stageY` properties.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以获取事件发生的位置，在全局舞台坐标中。只需检查事件的 `stageX` 和 `stageY` 属性的值。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类链接到电影剪辑符号，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用更新循环，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
- en: '*Setting the touch point input mode*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置触摸点输入模式*'
- en: '*Dragging multiple display objects*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拖动多个显示对象*'
- en: Dragging multiple display objects
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动多个显示对象
- en: With touch-enabled screens, the act of dragging a display object with a finger
    is very intuitive. Adobe AIR provides API calls that allow this type of interaction
    without much effort. In addition, the multi-touch capabilities of iOS can be harnessed
    to allow multiple objects to be dragged at once.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸屏上，用手指拖动显示对象的行为非常直观。Adobe AIR 提供了 API 调用，允许这种类型的交互而不需要太多努力。此外，iOS 的多点触控功能可以被利用，以允许同时拖动多个对象。
- en: We will continue where we left off in the *Detecting multiple touch points*
    recipe and add the ability to drag the bubbles around the screen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在 *检测多个触摸点* 配方中留下的地方，并添加拖动气泡在屏幕周围的能力。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already done so, complete the *Detecting multiple touch points*
    recipe before proceeding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在继续之前完成 *检测多个触摸点* 配方。
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    from the book's accompanying code bundle, open `chapter5\recipe3\recipe.fla` into
    Flash Professional and work from there.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用在该配方中编写的代码。或者，从本书的配套代码包中，将 `chapter5\recipe3\recipe.fla` 打开到 Flash Professional
    中，并从那里开始工作。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open the FLA''s document class and perform the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 FLA 的文档类并执行以下步骤：
- en: 'Declare the following member variable:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下成员变量：
- en: '[PRE14]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This array will be used to map touch points to `Bubble` instances.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此数组将用于将触摸点映射到 `Bubble` 实例。
- en: 'Within the constructor, set the `touching` member variable to an empty array:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将 `touching` 成员变量设置为空数组：
- en: '[PRE15]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Move to the `touchBegin()` event handler and make the following changes:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 `touchBegin()` 事件处理程序并做出以下更改：
- en: '[PRE16]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now alter the `touchEnd()` handler too:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在也修改 `touchEnd()` 处理程序：
- en: '[PRE17]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save `Main.as`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Main.as`。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 部署到您的设备上。
- en: When you run the app, you will now be able to stop and drag the bubbles. You
    can even drag multiple bubbles simultaneously. Give it a try.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您现在将能够停止并拖动气泡。您甚至可以同时拖动多个气泡。试试看。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Much of the work in this recipe is performed by `startTouchDrag()` and `stopTouchDrag()`.
    Both methods are defined by `flash.display.Sprite` and are also available to classes
    that inherit it, including our `Bubble` class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方中的大部分工作都是由 `startTouchDrag()` 和 `stopTouchDrag()` 执行的。这两个方法都是由 `flash.display.Sprite`
    定义的，并且也适用于继承它的类，包括我们的 `Bubble` 类。
- en: The `startTouchDrag()` method allows the user to drag a bubble across the screen.
    It does this by associating a touch point ID with a bubble, continuously updating
    the bubble's position to reflect that of the touch point.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTouchDrag()` 方法允许用户拖动气泡穿过屏幕。它是通过将触摸点 ID 与气泡关联，并持续更新气泡的位置以反映触摸点的位置来实现的。'
- en: On the other hand, the `stopTouchDrag()` method stops the bubble from being
    dragged by the specified touch point ID.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`stopTouchDrag()` 方法通过指定的触摸点 ID 停止气泡的拖动。
- en: 'Let us take a look at the `touchBegin()` event handler where `startTouchDrag()`
    is called. Two lines of code that are of particular interest have been highlighted:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用 `startTouchDrag()` 的 `touchBegin()` 事件处理器。有两行代码特别引人注目：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, the interactive object that was touched is obtained by querying the event's
    `target` property and an attempt is made to cast it to a `Bubble` object. If the
    object is a bubble, then its `startTouchDrag()` method is called with the event's
    touch point ID being passed as an argument.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过查询事件对象的 `target` 属性来获取被触摸的交互对象，并尝试将其转换为 `Bubble` 对象。如果对象是气泡，则使用事件对象的触摸点
    ID 作为参数调用其 `startTouchDrag()` 方法。
- en: 'Every point of contact made with the screen is assigned a unique ID that can
    be used by methods such as `startTouchDrag()` and `stopTouchDrag().` You can determine
    the touch point that an event is associated with by examining its `touchPointID`
    property. We take advantage of these unique IDs within our code to associate a
    bubble with a touch point. You can see this mapping taking place near the end
    of the `touchBegin()` event handler:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的每个接触点都被分配了一个唯一的 ID，这些 ID 可以用于 `startTouchDrag()` 和 `stopTouchDrag()` 等方法。您可以通过检查事件的
    `touchPointID` 属性来确定与事件相关联的触摸点。我们利用这些唯一的 ID 在代码中将气泡与触摸点关联起来。您可以在 `touchBegin()`
    事件处理器的末尾看到这种映射：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The handler makes use of the `touching` member variable to store a reference
    to the bubble that is being dragged by the user. The bubble instance is placed
    in the `touching` array, with the event's touch point ID being used as the index
    position.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器使用 `touching` 成员变量来存储用户正在拖动的气泡的引用。气泡实例被放置在 `touching` 数组中，事件对象的触摸点 ID 被用作索引位置。
- en: 'Let us now take a look at the `touchEnd()` event handler, where we obtain from
    the `touching` array, the bubble that has just been released by the user:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `touchEnd()` 事件处理器，我们从 `touching` 数组中获取用户刚刚释放的气泡：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the above method, the event's `touchPointID` is obtained and used to retrieve
    the associated bubble from the `touching` array. If a bubble instance was retrieved,
    then its `stopTouchDrag()` method is called with the event's touch point ID being
    passed as an argument. This will stop the bubble being dragged by the user's finger.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，通过获取事件对象的 `touchPointID` 并使用它从 `touching` 数组中检索相关的气泡。如果检索到了气泡实例，则使用事件对象的触摸点
    ID 作为参数调用其 `stopTouchDrag()` 方法。这将停止用户用手指拖动气泡。
- en: 'Finally, at the end of the method, the bubble reference is removed from the
    `touching` array as it is no longer required:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在方法末尾，从 `touching` 数组中移除气泡引用，因为它不再需要：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is all there is to it. With the use of the `Sprite` class' `startTouchDrag()`
    and `stopTouchDrag()` methods and by tracking touch point IDs, we were able to
    manage the dragging of multiple interactive objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部内容。通过使用 `Sprite` 类的 `startTouchDrag()` 和 `stopTouchDrag()` 方法以及跟踪触摸点 ID，我们能够管理多个交互对象的拖动。
- en: You can obtain more information regarding the `flash.display.Sprite` class from
    Adobe Community Help.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 Adobe 社区帮助中获取有关 `flash.display.Sprite` 类的更多信息。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Following is some more information regarding `startTouchDrag().`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 `startTouchDrag()` 方法的更多信息。
- en: startTouchDrag() parameters
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: startTouchDrag() 参数
- en: 'The `startTouchDrag()` method expects three arguments with only the first being
    mandatory:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTouchDrag()` 方法期望有三个参数，其中只有第一个是必需的：'
- en: '`touchPointID:` The ID of the touch point that will be used to drag the sprite.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchPointID:` 将用于拖动精灵的触摸点的 ID。'
- en: '`lockCenter:` Whether to lock the center of the sprite to the touch point `(true)`
    , or lock to the point where contact was made with the sprite `(false)` . Defaulted
    to `false`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lockCenter:` 是否将精灵的中心锁定到触摸点（`true`），还是锁定到与精灵接触的点（`false`）。默认为 `false`。'
- en: '`bounds:` A `Rectangle` that defines a constraint region for the sprite that
    is being dragged. Defaulted to `null` meaning there is to be no constraint region.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bounds:` 定义正在拖动的精灵的约束区域的 `Rectangle`。默认为 `null`，表示没有约束区域。'
- en: This recipe's example code only used the first argument. Meaning the center
    of the bubble wasn't locked to the user's finger and the user was free to drag
    the bubble anywhere on the screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例代码只使用了第一个参数。这意味着气泡的中心没有被锁定到用户的指尖，用户可以自由地将气泡拖动到屏幕上的任何位置。
- en: 'To force the bubble''s center to lock to the user''s finger, simply pass `true`
    as the second argument:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制将气泡的中心锁定到用户的指尖，只需将 `true` 作为第二个参数传递：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following example also constrains the bubble to a 200x200 pixel region
    at the top-left corner of the screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例还将气泡限制在屏幕左上角的 200x200 像素区域内：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try applying each example to your code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将每个示例应用到你的代码中。
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Setting the touch point input mode*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置触摸点输入模式*'
- en: '*Tracking movement*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟踪移动*'
- en: Tracking movement
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪移动
- en: One important touch-based event that we haven't looked at yet in detail is `TouchEvent.TOUCH_MOVE`.
    This event is fired whenever the user moves a finger across the screen and can
    be queried to determine the contact point's coordinates. Every time the user's
    finger changes position, a new `TOUCH_MOVE` event is dispatched.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有详细研究的一个重要基于触摸的事件是 `TouchEvent.TOUCH_MOVE`。当用户在屏幕上移动手指时，此事件被触发，可以通过查询来确定接触点的坐标。每次用户的手指改变位置时，都会派发一个新的
    `TOUCH_MOVE` 事件。
- en: Although `startTouchDrag()` and `stopTouchDrag()` are recommended for dragging
    objects, you can instead update an object's position in response to `TOUCH_MOVE`
    events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `startTouchDrag()` 和 `stopTouchDrag()` 建议用于拖动对象，但你也可以通过响应 `TOUCH_MOVE` 事件来更新对象的位置。
- en: Let us make some changes to the code from the *Dragging multiple display objects*
    recipe to do this.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 *拖动多个显示对象* 配方中的代码进行一些修改以实现这一点。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already done so, complete the *Dragging multiple display objects*
    recipe before proceeding.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，如果你还没有这样做，请完成 *拖动多个显示对象* 配方。
- en: You can continue to work with your code from that recipe. Alternatively, from
    the book's accompanying code bundle, open `chapter5\recipe4\recipe.fla` into Flash
    Professional and work from there.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用那个配方中的代码。或者，从本书的配套代码包中，打开 `chapter5\recipe4\recipe.fla` 到 Flash Professional
    中，并从那里开始工作。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps within the FLA''s document class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FLA 的文档类中执行以下步骤：
- en: Move to the constructor and add a listener for `TouchEvent.TOUCH_MOVE:`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到构造函数并添加对 `TouchEvent.TOUCH_MOVE:` 的监听器：
- en: '[PRE24]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Remove the call to `startTouchDrag()` from the `touchBegin()` handler by deleting
    the highlighted line of code from the `if` statement:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 `if` 语句中删除高亮显示的代码行，从 `touchBegin()` 处理器中删除对 `startTouchDrag()` 的调用：
- en: '[PRE25]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also remove the call to `stopTouchDrag()` from the `touchEnd()` handler by
    deleting the highlighted line of code from the `if` statement:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要从 `touchEnd()` 处理器中删除对 `stopTouchDrag()` 的调用，通过从 `if` 语句中删除高亮显示的代码行：
- en: '[PRE26]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now write the `touchMove()` event handler:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写 `touchMove()` 事件处理器：
- en: '[PRE27]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save `Main.as`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Main.as`。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 部署到您的设备上。
- en: This example should behave in an identical way to the previous recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应与上一个配方以相同的方式表现。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although dragging was previously taken care of by `startTouchDrag()` and `stopTouchDrag()`,
    for this recipe we manually update the position of the bubbles by responding to
    `TouchEvent.TOUCH_MOVE`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前通过 `startTouchDrag()` 和 `stopTouchDrag()` 来处理拖动，但在这个配方中，我们通过响应 `TouchEvent.TOUCH_MOVE`
    来手动更新气泡的位置。
- en: 'The bulk of the work is performed within the `touchMove()` event handler, which
    is shown again as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作是在 `touchMove()` 事件处理器中完成的，如下所示：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using the event's touch point ID, a reference to the bubble associated with
    it (if any) is retrieved from the `touching` array. The bubble's `x` and `y` properties
    are then updated to reflect the on-screen position of the user's finger, which
    is retrieved from the event's `stageX` and `stageY` properties.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件的触摸点 ID，从 `touching` 数组中检索与其关联的气泡（如果有）。然后更新气泡的 `x` 和 `y` 属性，以反映用户手指在屏幕上的位置，该位置是从事件的
    `stageX` 和 `stageY` 属性中检索到的。
- en: Every time one of the user's fingers changes position on the device's screen,
    the `TOUCH_MOVE` event is dispatched, and any bubble associated with that contact
    point is re-positioned to match the finger's position.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户的手指在设备屏幕上改变位置时，`TOUCH_MOVE` 事件就会被派发，并且与该接触点关联的任何气泡都会重新定位以匹配手指的位置。
- en: While this recipe has concentrated on the use of `TOUCH_MOVE` to perform dragging,
    the event can be applied to many other tasks. For example, it could be used to
    track finger movement for a paint application or to trace a path for a game character
    to follow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个配方主要集中在使用 `TOUCH_MOVE` 来执行拖动，但此事件可以应用于许多其他任务。例如，它可以用于跟踪绘画应用程序中的手指移动或为游戏角色绘制路径。
- en: If you are implementing dragging within your app, it is recommended that you
    use `startTouchDrag()` and `stopTouchDrag()` instead, which has performance benefits
    over listening for `TOUCH_MOVE` events. However, now that you are comfortable
    working with the `TOUCH_MOVE` event, you should be able to put it to various other
    uses.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的应用中实现拖动，建议你使用 `startTouchDrag()` 和 `stopTouchDrag()`，这比监听 `TOUCH_MOVE`
    事件有更好的性能。然而，既然你已经熟悉了 `TOUCH_MOVE` 事件，你应该能够将其用于各种其他用途。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考也
- en: '*Setting the touch point input mode*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置触摸点输入模式*'
- en: '*Dragging multiple display objects*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拖动多个显示对象*'
- en: Setting the gesture input mode
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置手势输入模式
- en: Along with handling simple multi-touch events, AIR for iOS provides support
    for gestures such as zoom, rotation, and swipe. A gesture is a single event that
    is made up from a sequence of simpler multi-touch events. Although you can capture
    multi-touch events and translate them into gestures yourself, the Flash platform
    also provides support for the most common ones, reducing your workload.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理简单的多触点事件外，AIR for iOS 还提供了对缩放、旋转和滑动等手势的支持。手势是由一系列简单的多触点事件组成的单个事件。虽然你可以捕获多触点事件并将它们转换为手势，但
    Flash 平台也提供了对最常见手势的支持，从而减轻了你的工作量。
- en: In order to receive gesture events, you must select the appropriate input mode.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收手势事件，你必须选择适当的输入模式。
- en: Let us see how this is done.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From Flash Professional, open `chapter5\recipe5\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Flash Professional 中，打开书籍附带代码包中的 `chapter5\recipe5\recipe.fla`。
- en: Sitting on the stage is a dynamic text field named `output`. We will write some
    code to enable gesture input and write the success or failure of the request to
    the text field.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上坐着的是一个名为 `output` 的动态文本字段。我们将编写一些代码以启用手势输入，并将请求的成功或失败写入文本字段。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a document class and name it `Main`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为 `Main`。
- en: 'Add the following two import statements:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两个导入语句：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now within the constructor, add some code to enable gesture support:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在构造函数中，添加一些代码以启用手势支持：
- en: '[PRE30]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save the class file as `Main.as`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类文件保存为 `Main.as`。
- en: Publish the FLA and deploy the IPA file to your iOS device.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 文件部署到你的 iOS 设备上。
- en: 'When you run the app, the following text should be output on the screen:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用时，以下文本应显示在屏幕上：
- en: '**inputMode = gesture**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**inputMode = gesture**'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Flash provides various multi-touch input modes, which determine the type of
    events your application can receive. In order to receive gesture events, you need
    to set the `Multitouch.inputMode` property to `MultitouchInputMode.GESTURE`. The
    following is the line of code from your document class that does this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Flash 提供了各种多触点输入模式，这些模式决定了你的应用可以接收的事件类型。为了接收手势事件，你需要将 `Multitouch.inputMode`
    属性设置为 `MultitouchInputMode.GESTURE`。以下是从你的文档类中执行此操作的代码行：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In addition to setting `Multitouch.inputMode`, you can also query it to determine
    the currently selected input mode. In this recipe''s code example, the current
    input mode is written to the `output` text field to confirm that it was successfully
    set:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置 `Multitouch.inputMode`，你还可以查询它以确定当前选定的输入模式。在这个菜谱的代码示例中，当前输入模式被写入 `output`
    文本字段以确认它已成功设置：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although Flash provides gesture support across all iOS devices, when writing
    cross-platform code you may want to confirm support by checking the `Multitouch.supportsGestureEvents`
    property. In our code example, this is done before setting the input mode.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Flash 在所有 iOS 设备上提供手势支持，但在编写跨平台代码时，你可能想通过检查 `Multitouch.supportsGestureEvents`
    属性来确认支持。在我们的代码示例中，这是在设置输入模式之前完成的。
- en: It should be noted that when the input mode is set for handling gestures you
    will be unable to receive basic touch events from the `TouchEvent` class. If you
    need to receive both touch and gesture events at the same time, then you will
    need to select the `MultitouchInputMode.TOUCH_POINT` input mode and capture multiple
    touch events before synthesizing them into gesture events yourself.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，当输入模式设置为处理手势时，你将无法从 `TouchEvent` 类接收基本的触摸事件。如果你需要同时接收触摸和手势事件，那么你需要选择 `MultitouchInputMode.TOUCH_POINT`
    输入模式，并在将它们合成手势事件之前捕获多个触摸事件。
- en: For more information regarding the gesture input mode, perform a search for
    `flash.ui.Multitouch` and `flash.ui.MultitouchInputMode` within Adobe Community
    Help.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于手势输入模式的更多信息，请在Adobe社区帮助中搜索`flash.ui.Multitouch`和`flash.ui.MultitouchInputMode`。
- en: Apple places a lot of importance on the correct use of gestures in order to
    provide consistency across applications. Apple's iOS Human Interface Guidelines
    contains a list of standard gestures and the actions users typically perform with
    them. When supporting gestures within your own applications, try not to deviate
    from the expected behavior.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果非常重视手势的正确使用，以确保应用程序之间的一致性。苹果的iOS人机界面指南包含了一系列标准手势以及用户通常使用它们执行的操作。当在您自己的应用程序中支持手势时，尽量不偏离预期的行为。
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following are some additional details regarding gestures.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于手势的额外细节。
- en: Available gesture events and types
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用的手势事件和类型
- en: Setting the input mode for gestures allows you to listen for gesture-specific
    events being dispatched by objects of type `InteractiveObject` or objects that
    inherit `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置手势的输入模式允许您监听由类型为`InteractiveObject`或继承自`InteractiveObject`的对象（如`Sprite, MovieClip`,
    和`Stage`）分发的特定手势事件。
- en: As with touch point input, gestures can also take advantage of multiple touch
    points.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与触摸点输入一样，手势也可以利用多个触摸点。
- en: 'The following gesture events are available:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下手势事件可用：
- en: '`GestureEvent.GESTURE_TWO_FINGER_TAP:` Dispatched when two fingers are used
    to tap the screen.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureEvent.GESTURE_TWO_FINGER_TAP:` 当使用两个手指轻击屏幕时触发。'
- en: '`TransformGestureEvent.GESTURE_PAN:` An attempt is made to move content that
    is typically too large to fit on screen. The pan gesture is fired when two fingers
    are being moved across on-screen content.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_PAN:` 尝试移动通常太大而无法适应屏幕的内容。当两个手指在屏幕内容上移动时，平移手势被触发。'
- en: '`TransformGestureEvent.GESTURE_ROTATE:` Dispatched when two touch points are
    rotated around each other. This gesture is typically used to rotate on-screen
    content.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_ROTATE:` 当两个触摸点相互旋转时触发。此手势通常用于旋转屏幕上的内容。'
- en: '`TransformGestureEvent.GESTURE_SWIPE:` A quick stroke of a finger across the
    screen. Swipe gestures are commonly used to scroll lists or quickly flick between
    pages of information.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_SWIPE:` 用手指快速在屏幕上划过。滑动手势通常用于滚动列表或快速在信息页之间切换。'
- en: '`TransformGestureEvent.GESTURE_ZOOM:` Two touch points are either being moved
    towards or away from one another. This gesture is commonly used to zoom on-screen
    content.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_ZOOM:` 两个触摸点要么相互靠近，要么相互远离。此手势通常用于缩放屏幕上的内容。'
- en: We will see some of these events in action throughout the remainder of this
    chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章剩余部分看到一些这些事件的实际应用。
- en: Determining the supported gestures
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定支持的手势
- en: You can obtain a list of gestures supported by your iOS device using the static
    `Multitouch.supportedGestures` property. A vector array of strings will be returned,
    where each string represents a gesture event.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用静态属性`Multitouch.supportedGestures`获取您的iOS设备支持的手势列表。将返回一个字符串向量数组，其中每个字符串代表一个手势事件。
- en: Mouse events
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: The default input mode is `MultitouchInputMode.NONE`, which specifies that all
    user interaction with a touch-enabled device is interpreted as a mouse event.
    However, unlike `MultitouchInputMode.GESTURE` and `MultitouchInputMode.TOUCH_POINT`,
    only a single touch point can be processed at any one time.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输入模式是`MultitouchInputMode.NONE`，它指定所有与触摸设备交互的用户操作都被解释为鼠标事件。然而，与`MultitouchInputMode.GESTURE`和`MultitouchInputMode.TOUCH_POINT`不同，任何时刻只能处理一个触摸点。
- en: Note that when the input mode is set to `MultitouchInputMode.GESTURE`, you can
    continue to listen for and respond to mouse events provided by `flash.events.MouseEvents`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当输入模式设置为`MultitouchInputMode.GESTURE`时，您可以继续监听并响应由`flash.events.MouseEvents`提供的鼠标事件。
- en: Testing in ADL
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ADL中进行测试
- en: 'It is most likely that testing this recipe''s code within ADL will result in
    the following message being output on the screen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能在ADL中测试此代码配方会导致屏幕上输出以下消息：
- en: '**Gesture events not supported.**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持的手势事件。**'
- en: Not all desktop computers or operating systems support gesture-based events.
    When using gestures within your code, it is advisable that you test directly on
    an iOS device.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有台式电脑或操作系统都支持基于手势的事件。当在代码中使用手势时，建议您直接在iOS设备上进行测试。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Handling user interaction,*Chapter 4'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理用户交互*，第四章'
- en: '*Setting the touch point input mode*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置触摸点输入模式*'
- en: '*Handling a swipe gesture*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理滑动手势*'
- en: '*Panning an object*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平移对象*'
- en: Handling a swipe gesture
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理滑动手势
- en: The introduction of touch-screens has made the process of moving between pages
    of information more natural. The iPhone made simple touch gestures, such as swiping,
    popular. For example, many photo viewer applications allow the user to quickly
    flick their finger across the screen in order to view the next image in a sequence.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏的引入使得在信息页面之间移动的过程变得更加自然。iPhone 使得简单的触摸手势，如滑动，变得流行。例如，许多图片查看器应用程序允许用户快速滑动手指以查看序列中的下一张图片。
- en: The `TransformGestureEvent.GESTURE_SWIPE` event is available, allowing both
    vertical and horizontal swiping gestures to be detected and acted upon.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent.GESTURE_SWIPE` 事件可用，允许检测并处理垂直和水平滑动手势。'
- en: Let us see how this is done.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From Flash Professional, open `chapter5\recipe6\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Flash Professional 中，打开书籍附带代码包中的 `chapter5\recipe6\recipe.fla`。
- en: Sitting on the stage is a container movie clip named `content`, which is over
    twice the width of the stage. Inside the container are two distinct bubbles, with
    only a single bubble able to fit on screen at any one time. We will write code
    to let the user swipe horizontally between the two bubbles.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上有一个名为 `content` 的容器电影剪辑，其宽度是舞台的两倍以上。容器内部有两个不同的气泡，任何时刻只能有一个气泡能够显示在屏幕上。我们将编写代码，让用户可以在两个气泡之间水平滑动。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何完成...
- en: 'Perform the following steps to listen for and respond to a horizontal swipe
    gesture:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以监听并响应水平滑动手势：
- en: Create a document class and name it `Main`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为 `Main`。
- en: 'Include the following import statements:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下导入语句：
- en: '[PRE33]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code within the class'' constructor:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数中添加以下代码：
- en: '[PRE34]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now add the swipe gesture''s event handler:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加滑动手势的事件处理程序：
- en: '[PRE35]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the class file as `Main.as`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类文件保存为 `Main.as`。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 IPA 部署到您的设备上。
- en: Quickly swipe your finger from right to left to move to the second bubble, and
    left to right to move back to the first.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 快速从右向左滑动手指以移动到第二个气泡，从左向右滑动以返回到第一个。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Gesture events can be dispatched by any `InteractiveObject` or sub-class of
    `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage.`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 手势事件可以由任何 `InteractiveObject` 或其子类（如 `Sprite, MovieClip` 和 `Stage`）触发。
- en: In this recipe, we took advantage of the gesture input mode to listen for and
    respond to `TransformGestureEvent.GESTURE_SWIPE`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们利用手势输入模式来监听并响应 `TransformGestureEvent.GESTURE_SWIPE`。
- en: 'Support for gesture-based input was enabled with the following line of code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码行启用了基于手势的输入支持：
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A listener was then added for the `GESTURE_SWIPE` event:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加了对 `GESTURE_SWIPE` 事件的监听器：
- en: '[PRE37]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice the listener was actually added to the stage, allowing the user to swipe
    anywhere on screen and not just on the `content` movie clip.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，监听器实际上被添加到了舞台，允许用户在屏幕上的任何位置滑动，而不仅仅是 `content` 电影剪辑上。
- en: It is within the `swipe()` handler where we respond to the user's swipe gesture
    and slide the `content` movie clip either to its far-left or far-right.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `swipe()` 处理程序中，我们响应用户的滑动手势并将 `content` 电影剪辑滑动到其最左侧或最右侧。
- en: 'To decide which direction to slide the movie clip, we inspect the `TransformGestureEvent`
    object''s `offsetX` property. A value of `1` indicates that the user swiped to
    the right, whereas a value of `-1` indicates the user swiped to the left. You
    can see the code for this highlighted as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定将电影剪辑滑动到哪个方向，我们检查 `TransformGestureEvent` 对象的 `offsetX` 属性。值为 `1` 表示用户向右滑动，而值为
    `-1` 表示用户向左滑动。您可以看到以下代码被突出显示：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally the actual scrolling of the content is performed. The `fl.transitions.Tween`
    class is used to slide the `content` movie clip into position. To perform a gradual
    acceleration and deceleration during the sliding transition, the `fl.motion.easing.Sine`
    class was used. Refer to Adobe Community Help for more information regarding these
    two classes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的内容滚动操作被执行。使用 `fl.transitions.Tween` 类将 `content` 电影剪辑滑动到正确位置。为了在滑动过渡期间实现逐渐加速和减速，使用了
    `fl.motion.easing.Sine` 类。有关这两个类的更多信息，请参考 Adobe Community Help。
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The following is one more property of `TransformGestureEvent` that is relevant
    to swipe gestures.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与滑动手势相关的 `TransformGestureEvent` 的另一个属性。
- en: Swiping vertically
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直滑动
- en: Although it wasn't covered in this recipe's example code, you can just as easily
    detect a vertical swipe by querying the event's `offsetY` property. A value of
    `-1` will be returned for an upwards swipe, whereas `1` will be returned for a
    downwards swipe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本食谱的示例代码中没有涉及，但您同样可以通过查询事件的`offsetY`属性来轻松检测垂直滑动。向上滑动将返回`-1`的值，而向下滑动将返回`1`。
- en: Although both horizontal and vertical swiping motions are represented by separate
    properties, AIR for iOS does not support diagonal swiping gestures. A user can
    either swipe horizontally or vertically.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然水平和垂直滑动动作分别由不同的属性表示，但AIR for iOS不支持对角线滑动手势。用户可以水平或垂直滑动。
- en: See also
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Setting the gesture input mode*'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置手势输入模式*'
- en: '*Panning an object*'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平移对象*'
- en: Panning an object
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平移对象
- en: Given the size constraints of screens on iOS devices, such as the iPhone and
    iPod touch, a user may need to pan or scroll to reveal content that is sitting
    out of view. The Flash platform provides the `TransformGestureEvent.GESTURE_PAN`
    event that you can listen for in order to detect a pan gesture on any interactive
    object. The gesture is initiated by the user placing two fingers on an object
    then sliding them across the screen to move it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iOS设备（如iPhone和iPod touch）屏幕的大小限制，用户可能需要平移或滚动以显示隐藏的内容。Flash平台提供了`TransformGestureEvent.GESTURE_PAN`事件，您可以通过监听该事件来检测任何交互对象的平移手势。手势是通过用户将两个手指放在一个对象上并在屏幕上滑动它们来触发的。
- en: This recipe will show you how to take advantage of the pan gesture in your projects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何利用平移手势在您的项目中。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From Flash Professional, open `chapter5\recipe7\recipe.fla` from the book's
    accompanying code bundle.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flash Professional中，打开书籍附带代码包中的`chapter5\recipe7\recipe.fla`。
- en: Sitting on the stage is a movie clip named `bubble`, which is too large to fit
    fully on screen. We will write some ActionScript to let the user pan the movie
    clip in order to see parts that are hidden from view.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台上有一个名为`bubble`的电影剪辑，它太大而无法完全显示在屏幕上。我们将编写一些ActionScript代码，让用户可以平移电影剪辑，以便看到隐藏的部分。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a document class and name it `Main`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的文档类。
- en: 'Add the following three import statements:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下三个导入语句：
- en: '[PRE39]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Within the constructor, set the input mode and listen for `TransformGestureEvent.GESTURE_PAN:`
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，设置输入模式并监听`TransformGestureEvent.GESTURE_PAN:`。
- en: '[PRE40]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Write a handler for the `GESTURE_PAN` event:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`GESTURE_PAN`事件的处理程序：
- en: '[PRE41]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Save the class file as `Main.as`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类文件保存为`Main.as`。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并将IPA部署到您的设备上。
- en: Touch the on-screen bubble with two fingers then slide them across the screen
    to pan the content.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 用两个手指触摸屏幕上的气泡，然后滑动它们以平移内容。
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to respond to a panning gesture, a listener for `TransformGestureEvent.GESTURE_PAN`
    was added:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应平移手势，添加了一个监听器`TransformGestureEvent.GESTURE_PAN`：
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `GESTURE_PAN` event is repeatedly dispatched as the user slides both fingers
    across the screen. The actual panning of the content takes place within the `pan()`
    event handler. Here, we use the `offsetX` and `offsetY` properties of the `TransformGestureEvent`
    object that was passed to the method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕上滑动两个手指时，`GESTURE_PAN`事件会重复发送。实际的内容平移发生在`pan()`事件处理程序中。在这里，我们使用传递给方法的`TransformGestureEvent`对象的`offsetX`和`offsetY`属性：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Together, both properties provide the horizontal and vertical distance that
    the user's fingers have travelled since the last `GESTURE_PAN` event. We simply
    use these offsets to reposition the `bubble` movie clip.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 两个属性共同提供了用户自上次`GESTURE_PAN`事件以来手指移动的水平和垂直距离。我们只需使用这些偏移量来重新定位`bubble`电影剪辑。
- en: For more information, perform a search for `flash.events.TransformGestureEvent`
    within Adobe Community Help.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在Adobe社区帮助中搜索`flash.events.TransformGestureEvent`。
- en: There's more...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The following are a couple of final things regarding panning, including a property
    of the `TransformGestureEvent` class that you may find of interest.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于平移的最终事项，包括`TransformGestureEvent`类的一个可能对你有用的属性。
- en: Gesture phases
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手势阶段
- en: Some gesture events are split into three distinct phases known as beginning,
    update, and end. If your application is required to respond to a gesture event's
    individual phase, then you can query the event's `phase` property. Each phase
    is represented by a constant provided by the `flash.events.GesturePhase` class.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一些手势事件被分为三个不同的阶段，称为开始、更新和结束。如果您的应用程序需要响应手势事件的各个阶段，则可以查询事件的`phase`属性。每个阶段都由`flash.events.GesturePhase`类提供的常量表示。
- en: 'For example, when a user is panning on-screen content, the `GESTURE_PAN` event
    will go through each of these phases:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户在屏幕上平移内容时，`GESTURE_PAN`事件将经历这些阶段中的每一个：
- en: '`GesturePhase.BEGIN:` The user touches the screen with both fingers and starts
    to move them across the screen'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GesturePhase.BEGIN:` 用户用两只手指触摸屏幕并开始在其上移动'
- en: '`GesturePhase.UPDATE:` The user is moving both fingers across the screen'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GesturePhase.UPDATE:` 用户正在屏幕上移动两只手指'
- en: '`GesturePhase.END:` The user lifts one or both fingers from the screen'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GesturePhase.END:` 用户从屏幕上抬起一个或两个手指'
- en: 'Let us look at a simple example where the `bubble` movie clip from this recipe
    is expanded in size at the beginning of a gesture phase, then shrinks back to
    its original size at the end. During the update phase, the user will be able to
    pan the content as before:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，其中此菜谱中的`bubble`电影剪辑在手势阶段的开始时扩大尺寸，然后在手势阶段的结束时缩小回原始尺寸。在更新阶段，用户将能够像以前一样平移内容：
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Make the changes to your code and add an import statement for `flash.events.GesturePhase`.
    Deploy the IPA to your device and try panning the on-screen content to get a feel
    of it when each of the gesture's phases occur.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 修改您的代码，并添加对`flash.events.GesturePhase`的导入语句。将IPA部署到您的设备上，尝试平移屏幕内容，以感受手势的各个阶段发生时的感觉。
- en: Note
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can carry your code from this recipe into the next. If you have made the
    changes above, then remove them before continuing as they aren't required.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此菜谱中的代码带入下一个菜谱。如果您已经做了上述更改，那么在继续之前请删除它们，因为它们不是必需的。
- en: Neither the swipe nor two-finger tap gesture have multiple phases. When working
    with either of these gestures, the `phase` property will always return `GesturePhase.ALL`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取和双指轻触手势都没有多个阶段。当使用这两种手势之一时，`phase`属性将始终返回`GesturePhase.ALL`。
- en: Single finger panning
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单指平移
- en: The `GESTURE_PAN` event only detects panning that is initiated and controlled
    using two fingers. Single finger panning, which is the expected behavior on iOS,
    can be achieved using the `startTouchDrag()` and `stopTouchDrag()` methods provided
    by `flash.display.Sprite`. For details refer to the *Dragging multiple display
    objects* recipe earlier in this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`GESTURE_PAN`事件仅检测使用两只手指发起和控制的平移。在iOS上预期的单指平移可以通过使用`flash.display.Sprite`提供的`startTouchDrag()`和`stopTouchDrag()`方法来实现。有关详细信息，请参阅本章前面的*拖动多个显示对象*菜谱。'
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: '*Setting the gesture input mode*'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置手势输入模式*'
- en: '*Dragging multiple display objects*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拖动多个显示对象*'
- en: '*Rotating an object*'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旋转对象*'
- en: Rotating an object
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转对象
- en: Rotation is another popular gesture used within iOS apps. It is performed by
    placing two fingers on your device's screen and rotating either one contact point
    around the other, or both around each other. To allow the rotation of content,
    you can listen for and respond to the `TransformGestureEvent.GESTURE_ROTATE` event.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是iOS应用中另一种流行的手势。它通过在您的设备屏幕上放置两只手指，并围绕另一个接触点旋转一个接触点，或者围绕彼此旋转两个接触点来执行。为了允许内容的旋转，您可以监听并响应`TransformGestureEvent.GESTURE_ROTATE`事件。
- en: We will continue from the *Panning an object* recipe and add the ability to
    rotate the on-screen content.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*平移对象*菜谱继续，并添加旋转屏幕内容的功能。
- en: Getting ready
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already done so, complete the *Panning an object* recipe before
    proceeding.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在继续之前完成*平移对象*菜谱。
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    open `chapter5\recipe8\recipe.fla` from the book's accompanying code bundle and
    work from there. You will also find the FLA's document class in the same folder.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用在该菜谱中编写的代码。或者，从书籍的配套代码包中打开`chapter5\recipe8\recipe.fla`，并从那里开始工作。您也可以在同一个文件夹中找到FLA的文档类。
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps within the FLA''s document class:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在FLA的文档类中执行以下步骤：
- en: Within the constructor, listen for `TransformGestureEvent.GESTURE_ROTATE:`
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听`TransformGestureEvent.GESTURE_ROTATE:`
- en: '[PRE45]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a handler that responds to the event:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个响应事件的处理器：
- en: '[PRE46]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save your changes.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改。
- en: Publish the FLA and test it on your device.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在你的设备上测试它。
- en: You should now be able to rotate the on-screen content as well as being able
    to pan it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够旋转屏幕上的内容，同时也能够平移它。
- en: Note
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are testing on an older device, then you may find that the app performs
    poorly with the frame rate falling quite short of its target. This will be particularly
    true if you are developing with Flash Professional CS5\. Don't worry; there are
    ways to dramatically improve the performance, which we will cover in [Chapter
    6](ch06.html "Chapter 6. Graphics and Hardware Acceleration"),*Graphics and Hardware
    Acceleration.*
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在较旧的设备上进行测试，可能会发现应用程序性能不佳，帧率远低于目标。如果你使用Flash Professional CS5进行开发，这一点尤其正确。不用担心；有方法可以显著提高性能，我们将在[第6章](ch06.html
    "第6章。图形和硬件加速")*图形和硬件加速*中介绍。
- en: How it works...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Only a few simple steps were required to add rotation support.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需要几个简单的步骤即可添加旋转支持。
- en: 'First, a listener for the `TransformGestureEvent.GESTURE_ROTATE` event was
    added to the `bubble` movie clip:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向`bubble`电影剪辑中添加了对`TransformGestureEvent.GESTURE_ROTATE`事件的监听器：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, the actual event handler queried the event''s `rotation` property
    in order to determine how much to rotate the movie clip:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的事件处理程序查询了事件的`rotation`属性，以确定如何旋转电影剪辑：
- en: '[PRE48]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `rotation` property specifies the change in rotation, measured in degrees,
    since the previous gesture event. This value was then added to the bubble's current
    angle of rotation in order to correctly update it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation`属性指定了自上次手势事件以来的旋转变化，以度为单位。然后，将此值添加到气泡的当前旋转角度，以正确更新它。'
- en: See also
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Setting the gesture input mode*'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置手势输入模式*'
- en: '*Zooming an object*'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缩放对象*'
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图矩阵，[第6章](ch06.html "第6章。图形和硬件加速")*'
- en: Zooming an object
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放对象
- en: The final gesture we will look at in this chapter is "zoom", which allows a
    user to scale content. It is typically performed by pinching the screen with two
    fingers. Drawing your fingers closer will zoom-out while pulling them apart will
    zoom-in. The Flash platform provides the `TransformGestureEvent.GESTURE_ZOOM`
    event that you can listen for and respond to.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一个手势是“缩放”，它允许用户缩放内容。通常是通过用两个手指捏合屏幕来执行。将手指靠近会缩小视图，而将手指分开则会放大视图。Flash平台提供了`TransformGestureEvent.GESTURE_ZOOM`事件，你可以监听并响应它。
- en: Getting ready
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already done so, complete the *Rotating an object* recipe before
    performing this one.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请在执行此操作之前完成*旋转对象*配方。
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    work from the FLA and document class found in the book's accompanying code bundle
    at `chapter5\recipe9\`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用在那个配方中编写的代码。或者，从书中附带代码包中的FLA和文档类开始工作，位于`chapter5\recipe9\`。
- en: How to do it...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Make these changes to the FLA''s document class:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对FLA的文档类进行以下更改：
- en: 'Within the constructor, listen for the `GESTURE_ZOOM` event:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听`GESTURE_ZOOM`事件：
- en: '[PRE49]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, add an event handler for the zoom gesture:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为缩放手势添加事件处理程序：
- en: '[PRE50]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Save the class file.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类文件。
- en: Publish the FLA and deploy the IPA to your device.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并将IPA部署到你的设备上。
- en: You should now be able to pan, rotate, and zoom the bubble using the gestures
    provided by the Flash platform.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够使用Flash平台提供的手势来平移、旋转和缩放气泡。
- en: Note
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are testing on an older device, then you may find that the app performs
    poorly with the frame rate falling quite short of its target. This will be particularly
    true if you are developing with Flash Professional CS5\. Don't worry; there are
    ways to dramatically improve the performance, which we will cover in [Chapter
    6](ch06.html "Chapter 6. Graphics and Hardware Acceleration"),*Graphics and Hardware
    Acceleration.*
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在较旧的设备上进行测试，可能会发现应用程序性能不佳，帧率远低于目标。如果你使用Flash Professional CS5进行开发，这一点尤其正确。不用担心；有方法可以显著提高性能，我们将在[第6章](ch06.html
    "第6章。图形和硬件加速")*图形和硬件加速*中介绍。
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with the other gestures covered in this chapter, implementing pinch zoom
    isn't difficult.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中介绍的其他手势一样，实现捏合缩放并不困难。
- en: An event listener for `TransformGestureEvent.GESTURE_ZOOM` was added followed
    by the event's handler, which was responsible for actually zooming into the `bubble`
    movie clip.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为`TransformGestureEvent.GESTURE_ZOOM`添加了一个事件监听器，随后是事件处理器，该处理器负责实际放大`bubble`电影剪辑。
- en: 'The following is the line of code that was used to register the listener:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用以注册监听器的代码行：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And you can see the bubble''s `scaleX` and `scaleY` properties being set within
    the `zoom()` event handler as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`zoom()`事件处理器中看到气泡的`scaleX`和`scaleY`属性被设置如下：
- en: '[PRE52]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `TransformGestureEvent` object's `scaleX` and `scaleY` properties specify
    the change in horizontal and vertical scale since the previous gesture event.
    To apply these values to a display object, simply multiply the display object's
    `scaleX` and `scaleY` properties with the event object's `scaleX` and `scaleY`
    properties respectively. You can see this being done in the code earlier.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformGestureEvent`对象的`scaleX`和`scaleY`属性指定了自上次手势事件以来的水平和垂直缩放变化。要将这些值应用到显示对象上，只需将显示对象的`scaleX`和`scaleY`属性分别与事件对象的`scaleX`和`scaleY`属性相乘。您可以在之前的代码中看到这一操作。'
- en: It may not be immediately obvious, but the bubble's library symbol has its registration
    point set at its center. When scaling content, make sure the artwork within your
    container clip is centered otherwise the user may be presented with unexpected
    behavior when performing a zoom gesture.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是立即显而易见的，但气泡的库符号其注册点设置在其中心。在缩放内容时，确保您容器剪辑内的艺术品居中，否则当用户执行缩放手势时可能会遇到意外的行为。
- en: See also
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Setting the gesture input mode*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置手势输入模式*'
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存作为位图矩阵，[第6章](ch06.html "第6章。图形和硬件加速")*'
