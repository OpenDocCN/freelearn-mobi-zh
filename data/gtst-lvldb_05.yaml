- en: Chapter 5. Using Objective-C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：使用Objective-C
- en: As we've seen, the native C++ interface of LevelDB is fairly simple. However,
    most OS X and iOS programmers want to be able to use their familiar `NSData` and
    `NSString` data types with a database. The use of **blocks** is steadily increasing
    in Cocoa APIs, as a way to apply small pieces of logic to collections of data.
    Some people also have a strong aversion to using C++ and will avoid anything that
    lacks an Objective-C interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，LevelDB的本地C++接口相当简单。然而，大多数OS X和iOS程序员希望能够使用他们熟悉的`NSData`和`NSString`数据类型与数据库一起使用。**blocks**在Cocoa
    API中的应用正在稳步增加，作为一种将小块逻辑应用于数据集合的方式。有些人也非常反感使用C++，会避免任何缺乏Objective-C接口的东西。
- en: Open source wrappers for LevelDB in Objective-C
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C中LevelDB的开源封装
- en: There are three significant Objective-C wrappers for LevelDB, all started in
    2011 when it was announced. They are the top hits and links if searching for Objective-C
    LevelDB.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个重要的Objective-C封装LevelDB，所有这些都是在2011年宣布时开始的。它们是搜索Objective-C LevelDB时的顶级结果和链接。
- en: Two come with their own projects to build a library or framework, but as of
    June 2013, these didn't work with Xcode 4.6 or higher. These two include a valuable
    suite of unit tests in each but not examples for iOS. Their relative popularity
    is hard to judge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 两个都附带了自己的项目来构建库或框架，但截至2013年6月，这些项目与Xcode 4.6或更高版本不兼容。这两个都包含了一套有价值的单元测试，但没有iOS的示例。它们的相对流行度很难判断。
- en: Instead of trying to fix their builds, our downloadable `Sample05` has OS X
    and iOS projects with all three wrappers' source included and a common set of
    tests. It uses the LevelDB libraries we created earlier. This approach of copying
    the wrapper classes is more likely to survive changes in Xcode and lets you debug
    by stepping into source.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图修复他们的构建，我们提供的`Sample05`包含了所有三个封装的源代码和一套共同的测试项目。它使用了我们之前创建的LevelDB库。这种复制封装类的方法更有可能适应Xcode的变化，并允许你通过进入源代码进行调试。
- en: '`Sample05` is a very important sample to explore the code in its entirety as
    it includes demo code in Objective-C of all the data updating and iteration concepts
    we have seen so far, rewritten from C++ for each of the three wrappers. This lets
    you see the stylistic differences side-by-side. The code samples in this chapter
    use all three, for contrast.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample05`是一个非常重要的示例，可以全面探索代码，因为它包含了到目前为止我们所看到的所有数据更新和迭代概念的Objective-C示例代码，每个封装都从C++重写。这让你可以并排看到风格上的差异。本章中的代码示例使用了所有三个封装，以进行对比。'
- en: '**LevelDB-ObjC**, from [https://github.com/hoisie/LevelDB-ObjC](https://github.com/hoisie/LevelDB-ObjC),
    was the earliest and simplest wrapper, providing the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**LevelDB-ObjC**，来自[https://github.com/hoisie/LevelDB-ObjC](https://github.com/hoisie/LevelDB-ObjC)，是最早且最简单的封装，提供了以下功能：'
- en: A way to call the basic `Put`, `Get`, and `Delete` operations with `NSString`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种使用`NSString`调用基本的`Put`、`Get`和`Delete`操作的方法
- en: Storing objects and dictionaries or arrays of objects using `NSKeyedArchiver`
    to encode them into the value
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`NSKeyedArchiver`将对象和字典或对象数组存储起来，以将它们编码到值中
- en: Iteration through all keys with a block that can stop the iteration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个可以停止迭代的块遍历所有键
- en: '**APLevelDB** from [https://github.com/preble/APLevelDB](https://github.com/preble/APLevelDB)
    is partly based on LevelDB-ObjC, trying to be a cleaner Objective-C wrapper, and:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**APLevelDB**，来自[https://github.com/preble/APLevelDB](https://github.com/preble/APLevelDB)，部分基于LevelDB-ObjC，试图成为一个更干净的Objective-C封装，并且：'
- en: 'Adds separate iterators and direct array-like access with subscripting: `db[@"key"]
    = @"value"`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了独立的迭代器和通过下标访问的类似数组的直接访问：`db[@"key"] = @"value"`
- en: Adds `WriteBatch` support as a separate protocol
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`WriteBatch`支持的单独协议
- en: Cleanly separates out different concepts into different protocols
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰地将不同的概念分离到不同的协议中
- en: Rather than burying an encoding implementation, gets and sets `NSData` so you
    can do your own encoding and pass it via `NSData*`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是埋藏编码实现，获取和设置`NSData`，这样你可以进行自己的编码并通过`NSData*`传递
- en: '**NuLevelDB**, from [https://github.com/nulayer/NULevelDB](https://github.com/nulayer/NULevelDB),
    is a very ambitious layer with many classes, featuring the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**NuLevelDB**，来自[https://github.com/nulayer/NULevelDB](https://github.com/nulayer/NULevelDB)，是一个非常雄心勃勃的层，包含许多类，具有以下特点：'
- en: '`NSData` is used for keys as well as values, making it easy to compose complex
    keys, as well as the `NSString` keys and values like the others'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSData`用于键和值，使得组合复杂的键以及像其他`NSString`键和值一样容易'
- en: Separate optimized 64 bit integer keys and a lot of enumerate (iteration) methods
    for ranges and arbitrary sets of integer keys
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离优化的 64 位整数键和许多用于范围和任意整数键集合的枚举（迭代）方法
- en: Consistent use of the `NSError**` parameters to get errors back
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致地使用 `NSError**` 参数来获取错误信息
- en: Easy copying an entire database or a specific list of keys, to/from `NSDictionary`
    and `NSArray`, in the file `NULDBDB+BulkAccess.m`;
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件 `NULDBDB+BulkAccess.m` 中，轻松复制整个数据库或特定的键列表，到/从 `NSDictionary` 和 `NSArray`；
- en: Its own `NULDBSerializable` protocol for exploding an object into a set of individual
    key/value pairs.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自己的 `NULDBSerializable` 协议，可以将对象分解成一系列单独的键/值对。
- en: 'Some of the following listed issues may not be issues for everyone. Remember
    these wrappers are open source and easy to extend, if you lack a feature. The
    following are the most serious issues with the different wrappers, or points most
    likely to dissuade you from using a particular one. I found APLevelDB easier to
    extend with minor changes. The issues are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的一些问题可能对每个人来说都不是问题。请记住，这些包装器是开源的，易于扩展，如果你缺少某个功能。以下是最严重的不同包装器问题，或者是最有可能让你放弃使用特定包装器的问题。我发现
    APLevelDB 通过一些小的修改更容易扩展。问题如下：
- en: LevelDB-ObjC and NuLevelDB are not ARC-compliant.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB-ObjC 和 NuLevelDB 不符合 ARC 规范。
- en: LevelDB-ObjC exposes the `leveldb/db.h` header so you have to make any files
    using it into `.mm` Objective-C++ source.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB-ObjC 公开了 `leveldb/db.h` 头文件，因此你必须将使用它的任何文件转换为 `.mm` Objective-C++ 源文件。
- en: LevelDB-ObjC and APLevelDB's iteration methods lack any way to specify ranges
    so you lose most of the power of LevelDB. Their blocks can end the iteration but
    you can't start from a given key or part-key.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB-ObjC 和 APLevelDB 的迭代方法没有任何指定范围的方式，因此你失去了 LevelDB 的大部分功能。它们的块可以结束迭代，但你不能从一个给定的键或部分键开始。
- en: NuLevelDB has a very rich iteration support but ignores any database's custom
    comparator and uses just the LevelDB's `BytewiseComparator` class method.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuLevelDB 具有非常丰富的迭代支持，但忽略了任何数据库的自定义比较器，并仅使用 LevelDB 的 `BytewiseComparator` 类方法。
- en: None of them expose the full read and write options of LevelDB. NuLevelDB is
    best with properties for write `sync` and read `fill_cache`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都没有公开 LevelDB 的完整读写选项。NuLevelDB 在写 `sync` 和读 `fill_cache` 属性方面表现最佳。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**ARC** (**Automatic Reference Counting**) was introduced in OS X Lion and
    iOS 5 and by now is used in most new Objective-C code. However, much older source
    has not been converted to ARC. To use non-ARC source files in an ARC project,
    use the **Build Phases** tab, **Compile Sources** section, and add the flag `–fno-objc-arc`
    on each file as needed. You will know this is necessary because of an **ARC Restrictions**
    compiler error.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARC**（**自动引用计数**）在 OS X Lion 和 iOS 5 中被引入，并且现在在大多数新的 Objective-C 代码中都被使用。然而，许多较旧的源代码尚未转换为
    ARC。要在 ARC 项目中使用非 ARC 源文件，请使用 **构建阶段** 选项卡，**编译源代码** 部分，并在需要时为每个文件添加标志 `–fno-objc-arc`。你会知道这是必要的，因为出现了
    **ARC 限制** 编译器错误。'
- en: Using Objective-C for simple data access
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Objective-C 进行简单的数据访问
- en: The core data creation, finding and deleting we saw in [Chapter 3](ch03.html
    "Chapter 3. Basic Key-value Operations – Creating and Deleting Data"), *Basic
    Key-value Operations–Creating and Deleting Data*, looks like this with the LevelDB-ObjC
    wrapper.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](ch03.html "第 3 章。基本键值操作 – 创建和删除数据") 中看到的 LevelDB-ObjC 包装器中的核心数据创建、查找和删除操作如下所示。
- en: 'Create a database object and open a file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个数据库对象并打开一个文件：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check to be sure a key doesn''t exist, and then add a couple of records, checking
    that the `Packt` key works but lowercase `packt` still fails:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以确保键不存在，然后添加几条记录，检查 `Packt` 键是否工作，但小写 `packt` 仍然失败：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Write an existing key again, changing its value, and check to make sure that
    it has changed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次写入现有的键，更改其值，并检查以确保它已更改：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compose a key with an embedded null, using a different way to create an `NSString`
    object from arbitrary characters, and prove we can read it back by that key:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的方式从任意字符创建一个 `NSString` 对象，并使用该键证明我们可以通过该键读取它：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Delete a record and check to be sure it can no longer be read:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一条记录并检查以确保它不能再被读取：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can print out all the keys that were just added, like `Sample04`, but will
    use a block to stop after the first three records. A typical use of a block is
    to process data from a collection, either just the keys or both keys and values.
    Most of the iterators using blocks also allow the block to stop iteration by returning
    `NO`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出刚刚添加的所有键，如 `Sample04`，但将使用一个块在第一个三个记录后停止。块的一个典型用途是从集合中处理数据，无论是键还是键值。大多数使用块的迭代器也允许块通过返回
    `NO` 来停止迭代：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Extending APLevelDB to expose the C++ API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 APLevelDB 以公开 C++ API
- en: If we want to add our own extensions to APLevelDB or the other wrappers, the
    internal `leveldb::DB*` has to be exposed. Just getting that pointer is enough
    to be able use all the C++ logic we saw in earlier chapters. This requires a minor
    change to `APLevelDB.h`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 APLevelDB 或其他包装器中添加自己的扩展，必须公开内部的 `leveldb::DB*`。仅仅获取这个指针就足够了，这样我们就可以使用我们在前面章节中看到的所有
    C++ 逻辑。这需要对 `APLevelDB.h` 进行一些小的修改。
- en: 'Firstly declare a return type for `getDB` which can be safely included in pure
    Objective-C so we don''t force people to move to Objective-C++ with `.mm` files:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为 `getDB` 声明一个返回类型，这样就可以安全地将其包含在纯 Objective-C 中，我们不需要强迫人们使用 `.mm` 文件迁移到 Objective-C++：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then inside `@interface APLevelDB : NSObject` add a public getter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，在 `@interface APLevelDB : NSObject` 中添加一个公共获取器：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is simply implemented in `ApLevelDB.mm`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `ApLevelDB.mm` 中简单地实现：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can add a **class category** to extend `APLevelDB` with other methods.
    Just one is shown here. We declare a method taking a prefix string and applying
    a block to the keys which match that prefix, passing a `BOOL` parameter so the
    block can stop enumerating:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个 **类分类** 来扩展 `APLevelDB` 并添加其他方法。这里只展示了一个例子。我们声明了一个接受一个前缀字符串并应用一个块到匹配该前缀的键的方法，传递一个
    `BOOL` 参数，以便块可以停止枚举：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's a simple example of how being able to get the database pointer allows
    writing some Objective-C++ code to add methods to APLevelDB. A similar technique
    can be used to extend the other frameworks. It also shows how Objective-C++ allows
    us to mix languages. The method `enumerateKeysWithPrefix:block` is an extension
    to APLevelDB with a pure Objective-C interface. It takes a block which can be
    pure Objective-C. The bits of C++ are the call to `NewIterator` and loop through
    the records calling the block. However, you could also just pass the `leveldb::DB*`
    to pure C++ .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何能够获取数据库指针来允许编写一些 Objective-C++ 代码以向 APLevelDB 添加方法的简单示例。可以采用类似的技术来扩展其他框架。这也展示了
    Objective-C++ 如何允许我们混合语言。`enumerateKeysWithPrefix:block` 方法是 APLevelDB 的一个扩展，具有纯
    Objective-C 接口。它接受一个块，可以是纯 Objective-C。C++ 的部分是调用 `NewIterator` 并通过记录循环调用块。然而，你也可以直接传递
    `leveldb::DB*` 到纯 C++。
- en: Importing text data to load a database
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入文本数据以加载数据库
- en: 'The following function shows a complete loop for importing a tab-delimited
    text file and generating records using the APLevelDB database. The `Sample500.txt`
    file is bundled with both the OS X and iOS projects. We use a little helper function
    in `main06ios.m` or `main06osx.m`, to find the data file relative to the application.
    This finds a file bundled into an app package of Cocoa iOS or OS X app, a common
    way to include demos:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数展示了导入一个制表符分隔的文本文件并使用 APLevelDB 数据库生成记录的完整循环。`Sample500.txt` 文件包含在 OS X 和
    iOS 项目中。我们在 `main06ios.m` 或 `main06osx.m` 中使用了一个小的辅助函数，以找到相对于应用程序的数据文件。这会找到一个打包在
    Cocoa iOS 或 OS X 应用程序包中的文件，这是包含演示的常见方法：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Command-line OS X tools such as `Sample05` don''t automatically bundle files.
    To get the sample copied relative to the app, it was added to the **Build Phases**
    tab''s **Copy Files** setting the relative path `./SampleData` as used in the
    helper function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行 OS X 工具，如 `Sample05`，不会自动打包文件。为了将样本复制到相对于应用程序的位置，它被添加到 **构建阶段** 选项卡的 **复制文件**
    设置中，设置相对路径 `./SampleData`，正如在辅助函数中使用的那样：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the function void `testAPLevelDBImportStrings` in its entirety. Open
    the text file, reading it into a single string then splitting into an array of
    lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是整个 `testAPLevelDBImportStrings` 函数。打开文本文件，将其读取到一个单独的字符串中，然后将其拆分为行数组：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a database, using another helper function `pathToSampleDB`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个辅助函数 `pathToSampleDB` 创建一个数据库：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In one `WriteBatch`, for speed and safety, loop through the array of lines,
    separating each at a tab and writing two records per line. The first key is a
    combination of last and first name and contains a JSON-encoded array. The second
    record is keyed by the phone number field and its value is the first key, so it''s
    like a secondary index. This is shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`WriteBatch`中，为了速度和安全，遍历行数组，每行用制表符分隔，每行写两条记录。第一个键是姓氏和名字的组合，包含一个JSON编码的数组。第二个记录由电话号码字段键入，其值是第一个键，所以它就像一个二级索引。以下代码展示了这一点：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This uses Apple''s standard `NSJSONSerialization` to pack a record, which does
    simple quoting to store an array as a string, for example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用Apple的标准`NSJSONSerialization`来打包记录，它对数组进行简单的引号处理以存储为字符串，例如：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To unpack the record, we get the data back with `dataForKey` and then recreate
    an array with the method `JSONObjectWithData`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包记录，我们使用`dataForKey`获取数据，然后使用`JSONObjectWithData`方法重新创建一个数组：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach can serialize dictionaries and arrays of simple types such as
    `NSString`, including nested arrays and dictionaries. If your data is mostly text,
    it is reasonably compact and efficient. Using other variants of `NSCoder` lets
    you store and recreate your own objects, but you have to write overrides for encoding
    and decoding methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以序列化字典和简单类型（如`NSString`）的数组，包括嵌套的数组和字典。如果你的数据主要是文本，它既紧凑又高效。使用`NSCoder`的其他变体让你可以存储和重新创建自己的对象，但你必须编写编码和解码方法的覆盖。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A quick look at the Objective-C wrappers for LevelDB showed us how they are
    used for the same tasks we mastered in C++. You also learned a general technique
    for loading text data bundled with your app. The text data loader showed a new
    way to encode the data values for a key and build a secondary index of phone numbers.
    We will now move on to putting a Cocoa user interface on top of this to see the
    data in something more exciting than a console output window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看LevelDB的Objective-C包装器让我们了解了它们是如何用于我们在C++中掌握的相同任务的。你也学会了加载与你的应用程序捆绑的文本数据的一般技术。文本数据加载器展示了一种新的方法来编码键的数据值并构建电话号码的二级索引。现在，我们将继续在这个基础上添加Cocoa用户界面，以便在比控制台输出窗口更令人兴奋的地方查看数据。
