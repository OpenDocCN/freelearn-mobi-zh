- en: Chapter 2. Bluetooth Pet Door Locker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：蓝牙宠物门锁
- en: This project is about a pet door controller that, by measuring external light
    and temperature, locks or unlocks your house's pet door. Through an iOS device
    you can check the status of the door (locked or unlocked) and overrun the logic
    implemented on Arduino for manually locking the door.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是关于一个宠物门控制器，通过测量外部光照和温度，锁定或解锁你的房屋宠物门。通过iOS设备，你可以检查门的状态（锁定或解锁）并手动覆盖Arduino上实现的逻辑以手动锁定门。
- en: In this project, you will learn how to work with analog sensors, switches, 1-Wire
    sensors (to measure temperatures) and control a servo motor wired to Arduino.
    Moreover, you will wire a Bluetooth 4.0 board to Arduino to communicate with your
    iOS device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习如何与模拟传感器、开关、1-Wire传感器（用于测量温度）以及连接到Arduino的伺服电机进行交互。此外，你还将为Arduino连接一个蓝牙4.0板，以便与你的iOS设备通信。
- en: Then, you will learn how to write a Bluetooth iOS application to send and receive
    data from Arduino.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将学习如何编写一个蓝牙iOS应用程序，用于从Arduino发送和接收数据。
- en: Towards the end of this chapter, we will discuss different types of sensors
    and their communication protocols with Arduino, in order to learn how to manage
    the most used technologies to measure quantities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将讨论不同类型的传感器及其与Arduino的通信协议，以便学习如何管理最常用的测量技术。
- en: This project requires some DIY skills in order to mount the locker to the pet
    door and to link it to the servo motor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目需要一些DIY技能，以便将锁具安装到宠物门上，并将其连接到伺服电机。
- en: 'The chapter is organized into the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下部分：
- en: '**Door locker requirements**: We will briefly recap the project requirements'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**门锁要求**：我们将简要回顾项目要求'
- en: '**Hardware**: We will describe the hardware and the electronic circuit needed
    for the project'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件**：我们将描述项目所需的硬件和电子电路'
- en: '**Arduino code**: We will write the code for Arduino to control the latch and
    communicate with the iOS device'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arduino代码**：我们将为Arduino编写代码以控制闩锁并与iOS设备通信'
- en: '**iOS code**: We will write the code for the iOS device'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS代码**：我们将为iOS设备编写代码'
- en: '**How to go further**: More ideas to improve the project and learn more'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何进一步发展**：更多改进项目和学习的想法'
- en: '**Different types of sensors**: A quick overview of analog and digital sensors,
    low-level communication protocols, and their pros and cons'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同类型的传感器**：对模拟和数字传感器、低级通信协议及其优缺点的快速概述'
- en: Door locker requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门锁要求
- en: 'We are going to build an automatic system that allows you to lock the pet door
    in the following different scenarios:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个自动系统，允许你在以下不同场景下锁定宠物门：
- en: At night, when the outside light is less luminous than a predefined threshold
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在夜间，当外部光照低于预定义的阈值时
- en: When the external temperature is too low or too high for your beloved pet, that
    is, when the temperature is below a predefined threshold or above a predefined
    threshold
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部温度对于你心爱的宠物来说过低或过高时，即当温度低于预定义的阈值或高于预定义的阈值时
- en: Moreover, we need to see the external temperature on our iOS device, we also
    need to know if the pet door is locked or unlocked, and override the automatic
    behavior, manually locking the door.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在iOS设备上查看外部温度，了解宠物门是否锁定或解锁，并手动覆盖自动行为，手动锁定门。
- en: Hardware
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: In this project, we have to build an electro-mechanical device, based on a latch
    and a servo motor to lock/unlock the pet door. Moreover, we need to build a simple
    electronic circuit to read sensors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们必须构建一个基于闩锁和伺服电机的机电装置，用于锁定/解锁宠物门。此外，我们还需要构建一个简单的电子电路来读取传感器。
- en: Required materials and electronics components
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必备材料和电子元件
- en: 'To build the locker you need little hardware that will be available at your
    local hardware store:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建锁具，你需要少量硬件，这些硬件可以在你当地的五金店找到：
- en: A small door latch, which is best if flat and without any notch. Since it has
    to be operated by a servo motor it has to slide very smoothly.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小门闩，最好是平的且没有凹槽。由于它必须由伺服电机操作，因此它必须滑动非常顺畅。
- en: Some nuts and bolts to mount the latch to the door.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些螺母和螺栓，用于将闩锁安装到门上。
- en: A few centimeters of metal wire (diameter of 2 mm or so).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几厘米的金属线（直径约2毫米）。
- en: 'Other required components are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他必备元件包括：
- en: Mini servo motor powered at 5V.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5V供电的微型伺服电机。
- en: Normally closed magnetic switch and a small magnet.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常闭合的磁开关和一个小磁铁。
- en: A photoresistor.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个光敏电阻。
- en: 'Resistors: 2 × 10K, 1 × 4.7K.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电阻：2 × 10K，1 × 4.7K。
- en: A digital DS18B20 temperature sensor. It's more expensive than analog sensors
    (like TMP 35), but it's much more precise and the readings are almost insensitive
    to the voltage fluctuations and electric noise.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字 DS18B20 温度传感器。它比模拟传感器（如 TMP 35）贵，但精度更高，读数几乎不受电压波动和电噪声的影响。
- en: Adafruit Bluefruit LE nRF8001 breakout ([http://www.adafruit.com/product/1697](http://www.adafruit.com/product/1697)).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit Bluefruit LE nRF8001 开发板 ([http://www.adafruit.com/product/1697](http://www.adafruit.com/product/1697))。
- en: Assembly latch and servo motor
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装闩锁和伺服电机
- en: To assemble the latch, you can refer to the following picture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要组装闩锁，可以参考以下图片。
- en: '![Assembly latch and servo motor](img/image00160.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![组装闩锁和伺服电机](img/image00160.jpeg)'
- en: The small magnet is glued on the latch, so that when it is completely retracted,
    the magnetic switch is open.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 小磁铁被粘贴在闩锁上，因此当它完全缩回时，磁开关是打开的。
- en: The photoresistor and the temperature sensor have to be placed outside the house
    and wired to Arduino. They need to be protected from humidity and dust, so it's
    better to set them inside a small plastic box. The box has to be drilled so that
    the air can freely circulate to help the temperature sensor to measure correctly.
    Moreover, the photoresistor should not be exposed to direct light to avoid blinding.
    A small plastic tube can do the job.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 光敏电阻和温度传感器必须放置在室外，并连接到 Arduino。它们需要防止湿气和灰尘，因此最好将它们放在一个小塑料盒内。盒子必须钻孔，以便空气可以自由流通，帮助温度传感器正确测量。此外，光敏电阻不应暴露在直射光下，以免失明。一个小塑料管可以完成这项工作。
- en: Electronic circuit
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子电路
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了项目所需的电子电路的电原理图：
- en: '![Electronic circuit](img/image00161.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00161.jpeg)'
- en: 'The following picture shows how to mount the circuit on a breadboard:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了如何在面包板上安装电路：
- en: '![Electronic circuit](img/image00162.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00162.jpeg)'
- en: 'For quick reference, the following list recaps the **nRF8001** wiring:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速参考，以下列表总结了 **nRF8001** 的接线：
- en: SCK to digital pin 13
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCK 连接到数字引脚 13
- en: MISO to digital pin 12
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MISO 连接到数字引脚 12
- en: MOSI to digital pin 11
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOSI 连接到数字引脚 11
- en: REQ to digital pin 10
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REQ 连接到数字引脚 10
- en: RST to digital pin 9
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RST 连接到数字引脚 9
- en: RDY to digital pin 2
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDY 连接到数字引脚 2
- en: 'If you are using **Arduino MEGA** instead of **UNO**, the wiring of **nRF8001**
    board has to be changed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 **Arduino MEGA** 而不是 **UNO**，则 **nRF8001** 板的接线必须按以下方式更改：
- en: SCK to digital pin 52
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCK 连接到数字引脚 52
- en: MISO to digital pin 50
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MISO 连接到数字引脚 50
- en: MOSI to digital pin 51
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOSI 连接到数字引脚 51
- en: REQ to digital pin 10
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REQ 连接到数字引脚 10
- en: RST to digital pin 9
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RST 连接到数字引脚 9
- en: RDY to digital pin 2
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDY 连接到数字引脚 2
- en: Light is measured using the photoresistor and an analog input of Arduino (A0).
    A photoresistor is a device whose resistance decreases with the increasing of
    the incident light intensity. In the circuit, the photoresistor is in a voltage
    divider with R1\. Voltage across R1 increases if the light on the photoresistor
    increases, and it's measured using the analog pin A0 of Arduino.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 光线是通过光敏电阻和 Arduino 的模拟输入（A0）测量的。光敏电阻是一种电阻随入射光强度增加而减小的器件。在电路中，光敏电阻与 R1 串联。如果光敏电阻上的光增加，R1
    上的电压也会增加，并通过 Arduino 的模拟引脚 A0 进行测量。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: R1 forces to ground the Arduino input when the photoresistor is not lighted
    and its resistance is very high.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当光敏电阻未受光照且其电阻非常高时，R1 会强制将 Arduino 输入接地。
- en: In the Arduino code, you can get the value of the voltage at an analog pin using
    the `analogRead` function. It returns a value in the range 0-1023 which is proportional
    to the voltage applied to the analog pin.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arduino 代码中，你可以使用 `analogRead` 函数获取模拟引脚上的电压值。它返回一个在 0-1023 范围内的值，该值与施加到模拟引脚上的电压成正比。
- en: The latch position is determined using a magnetic switch and a digital input
    of Arduino (D4). The magnetic switch closes when the magnet on the latch is close
    to it. The switch is in a voltage divider with R2\. The voltage across R2 is almost
    5V when the switch is closed, or about 0V when the switch is open.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 闩锁位置是通过磁开关和 Arduino 的数字输入（D4）确定的。当闩锁上的磁铁靠近时，磁开关关闭。开关与 R2 串联。当开关关闭时，R2 上的电压几乎为
    5V，而当开关打开时，约为 0V。
- en: '![Electronic circuit](img/image00163.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00163.jpeg)'
- en: Voltage divider
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 分压器
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The voltage divider is a simple circuit made of two resistors. Assuming that
    the current that flows outside the circuit is negligible, V2 is approximately
    *V1*R2/(R1+R2)*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分压器是由两个电阻组成的简单电路。假设电路外部的电流可以忽略不计，V2 约等于 *V1*R2/(R1+R2)*。
- en: Using an Arduino digital input you can determine if the switch is open or closed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Arduino数字输入，你可以确定开关是打开还是关闭。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Arduino code, you can get the value of a digital pin using the `digitalRead`
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino代码中，你可以使用`digitalRead`函数获取数字引脚的值。
- en: The temperature sensor is a digital sensor that uses the 1-Wire protocol, and
    it is read using a digital pin.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 温度传感器是一个使用1-Wire协议的数字传感器，它通过数字引脚读取。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To read the value of the temperature sensor you have to use the `OneWire` library
    and the `DallasTemperature` library through which a function directly returns
    the temperature in Celsius.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取温度传感器的值，你必须使用`OneWire`库和`DallasTemperature`库，通过这些库，一个函数可以直接返回摄氏度的温度。
- en: The servo motor requires a PWM signal to be controlled. Pulse width modulation
    is a technique for getting analog results with digital means. It is a square wave
    with a period of 2 ms. The width of the positive pulse determines the rotation
    of the servo (for example, a 1.5 ms pulse will make the motor turn to the 90-degree
    position). Fortunately, the servo library (already included in the IDE) hides
    the complexity and we can move the motor by just calling a function with the desired
    motor position.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机需要PWM信号来控制。脉冲宽度调制是一种使用数字手段获得模拟结果的技术。它是一个周期为2毫秒的方波。正脉冲的宽度决定了伺服电机的旋转（例如，1.5毫秒的脉冲将使电机旋转到90度位置）。幸运的是，伺服库（已包含在IDE中）隐藏了复杂性，我们只需调用一个带有期望电机位置的函数即可移动电机。
- en: Arduino code
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino代码
- en: 'The full code of this project can be downloaded from here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的完整代码可以从这里下载：
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
- en: For a better understanding of the explanations in the next paragraphs, you should
    open the downloaded code while reading.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，你应该在阅读时打开下载的代码。
- en: Each Arduino program almost always has the following structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Arduino程序几乎总是具有以下结构。
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The instruction `#include <library_1.h>` tells the compiler to use a library
    and the instruction `#define SOMETHING A_VALUE` tells the compiler to replace
    `SOMETHING` with `A_VALUE` all over the program. It's easier to make changes if
    you use defined values. If you need to replace `A_VALUE` with something else,
    you can do it at a single place instead of in all instances in the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`#include <library_1.h>`告诉编译器使用一个库，而指令`#define SOMETHING A_VALUE`告诉编译器在程序中所有地方用`A_VALUE`替换`SOMETHING`。如果你使用定义的值，那么更改会更简单。如果你需要将`A_VALUE`替换为其他内容，你可以在一个地方而不是在代码的所有实例中这样做。
- en: Function prototypes are generally used for functions, which are used during
    the code but their bodies are put at the end of the program source. Global variables
    are variables whose values have to be preserved across the execution of the program.
    The function `setup` is used for initializing libraries and variables; it's called
    only once, at the board's power up or reset. The function `loop` instead is called
    over and over again. Variables defined in the loop function lose their value across
    calls; this is why we need global variables. Callback functions are called from
    libraries when an event happens, or data are available for processing. Instead,
    functions that are called from the loop help to make the code easier to read,
    maintain, and debug.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型通常用于在代码中使用但将主体放在程序源代码末尾的函数。全局变量是那些需要在程序执行期间保留其值的变量。`setup`函数用于初始化库和变量；它只在板子上电或复位时调用一次。相反，`loop`函数会反复调用。在`loop`函数中定义的变量在调用之间会丢失其值；这就是为什么我们需要全局变量的原因。回调函数是在库中发生事件或数据可用于处理时被调用的。相反，从`loop`中调用的函数有助于使代码更容易阅读、维护和调试。
- en: Installing additional required libraries
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装额外的必需库
- en: For this project we need some libraries. Some are already available in the Arduino
    IDE and others have to be added ( for example, `OneWire`, `DallasTemperature`,
    and `Adafruit_BLE_UART`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要一些库。其中一些已经在Arduino IDE中可用，而其他则需要添加（例如，`OneWire`、`DallasTemperature`和`Adafruit_BLE_UART`）。
- en: 'To add them, follow this simple procedure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加它们，请遵循以下简单步骤：
- en: Select the menu item **Sketch** | **Include Library** | **Manage Libraries**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单项**Sketch** | **Include Library** | **Manage Libraries**。
- en: In the search field enter `OneWire`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`OneWire`。
- en: Select the row with **OneWire** and click **Install** (see picture below).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择带有**OneWire**的行并点击**安装**（见下图）。
- en: Enter `DallasTemp` in the search field, click on **MAX31850** and then **Install**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`DallasTemp`，点击**MAX31850**然后**安装**。
- en: Enter `nRF8001` in the search field, click **Adafruit nRF8001** and then **Install**.![Installing
    additional required libraries](img/image00164.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`nRF8001`，点击**Adafruit nRF8001**然后**安装**。[安装额外的必需库](img/image00164.jpeg)
- en: Initializing global variables and libraries
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化全局变量和库
- en: 'The temperature sensor uses the 1-Wire protocol for communicating with Arduino,
    so we need the `OneWire` library. Fortunately another library (`DallasTemperature`)
    is available to make temperature readings very easy. We need to create global
    variables for the two libraries:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 温度传感器使用1-Wire协议与Arduino通信，因此我们需要`OneWire`库。幸运的是，另一个库（`DallasTemperature`）使得温度读数变得非常简单。我们需要为这两个库创建全局变量：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And one for storing the sensor address:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个用于存储传感器地址：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The global variables for the nRF8001 library are in a line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: nRF8001库的全局变量在一行中：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you change the pins used in the previous line, you have to also change them
    in the circuit wiring.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改上一行中使用的引脚，你必须在电路布线中也进行更改。
- en: 'To control the servo motor we need another global variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制伺服电机，我们需要另一个全局变量：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need two more global Boolean variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要两个额外的全局布尔变量：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first is true when the iOS device is connected to Arduino, the second is
    true when the user needs to keep the pet door closed regardless of the light and
    temperature values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量在iOS设备连接到Arduino时为真，第二个变量在用户需要无论光照和温度值如何都保持宠物门关闭时为真。
- en: Setup code
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代码
- en: 'We start setting up the Serial communication library:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始设置串行通信库：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is not strictly necessary but it is required for writing to the console,
    which may be useful for debugging purposes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是严格必要的，但它是写入控制台所必需的，这可能对调试很有用。
- en: 'Then we initialize the sensor library:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们初始化传感器库：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also read the address of the device number 0 (the only one present in our
    circuit):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还读取设备编号0（我们电路中唯一的设备）的地址：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**The 1-Wire address**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-Wire地址**'
- en: Each 1-Wire device has its own address defined at time of production and it
    cannot be changed. To perform any operation on the device you have to know its
    address. The `getAddress` and `search` library functions can help you to find
    the address of your devices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个1-Wire设备在制造时都有自己的地址定义，并且不能更改。要对设备执行任何操作，你必须知道其地址。`getAddress`和`search`库函数可以帮助你找到设备的地址。
- en: 'The sensor can provide readings with different levels of precision, but the
    more precision we ask for, the more the device is slow to answer. For our purposes,
    we don''t need a high precision, so we can set the precision to 9 bits:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器可以提供不同精度的读数，但我们需要更高的精度时，设备响应就会越慢。就我们的目的而言，我们不需要高精度，因此可以将精度设置为9位：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The library has to know the pin where the servo motor is wired on:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 库必须知道伺服电机连接的引脚：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both the pins used for the photoresistor and the switch need to be configured
    as input:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用于光敏电阻和开关的引脚都需要配置为输入：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For communicating with the nRF8001 board we need to set up a couple of callback
    functions; one, to know when the iOS device is connected or disconnected:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与nRF8001板通信，我们需要设置几个回调函数；一个，以知道iOS设备何时连接或断开：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other callback function is for receiving data that are transmitted by the
    iOS device:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个回调函数用于接收由iOS设备发送的数据：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The nRF8001 library calls the `rxCallback` when data from the iOS device are
    available for processing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当iOS设备的数据可用于处理时，nRF8001库会调用`rxCallback`。
- en: We are now ready to take a look at the main part of the code, which implements
    the algorithm to control the pet door and the iOS communication.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备查看代码的主要部分，它实现了控制宠物门和iOS通信的算法。
- en: Main program
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: 'From the project''s requirements, we conclude that the Arduino program has
    to implement a simple logic:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目需求中，我们得出结论，Arduino程序必须实现一个简单的逻辑：
- en: Read light intensity
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取光强度
- en: Read temperature
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取温度
- en: If the light intensity is above `LIGHT_THRESHOLD`, at a temperature between
    `LOW_TEMPERATURE_THRESHOLD` and `HIGH_TEMPERATURE_THRESHOLD`, the servo motor
    has to move to the `UNLOCK_POSITION` (180 degree), otherwise to the `LOCK_POSITION`
    (65 degree)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果光强度高于`LIGHT_THRESHOLD`，在`LOW_TEMPERATURE_THRESHOLD`和`HIGH_TEMPERATURE_THRESHOLD`之间的温度下，伺服电机必须移动到`UNLOCK_POSITION`（180度），否则移动到`LOCK_POSITION`（65度）
- en: Moreover, when the iOS device is connected, it has to receive information about
    the latch position (opened or closed) and the external temperature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当iOS设备连接时，它必须接收有关锁存位置（打开或关闭）和外部的温度信息。
- en: 'In the main loop function we read the light intensity with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环函数中，我们使用以下方法读取光强度：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The temperature with:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法读取温度：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And the latch position with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用以下方法获取锁存位置：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Light is a value in the range 0-1023 (2^(10)) proportional to the light intensity,
    if the latch is opened, the `latchIsOpened` has value true (1), and `temperature`
    is the temperature measured by the sensor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 光是一个在0-1023（2^10）范围内的值，与光强度成正比，如果锁存器打开，则`latchIsOpened`的值为true（1），`temperature`是传感器测量的温度。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Voltage at the analog pin**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟引脚上的电压**：'
- en: The **analog to digital converter** (**ADC**) inside Arduino, attached to an
    analog pin, transforms the voltage at the pin into an integer value using 10 bits,
    which is an integer value in the range 0-1023 (2^(10) values).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino内部的**模数转换器（ADC**），连接到模拟引脚，使用10位将引脚上的电压转换为整数值，这是一个在0-1023（2^10个值）范围内的整数值。
- en: 'Since the voltage at the analog pin can be between 0 V and 5 V (the power voltage)
    each bit has a value that is 5 / 1024, then you can calculate the voltage at the
    analog pin using this formula:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模拟引脚上的电压可以在0V和5V（电源电压）之间，因此每个位都有一个值，该值为5/1024，然后你可以使用此公式计算模拟引脚上的电压：
- en: '*voltage = analogRead(<ANALOG PIN>) * 5/1024*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*电压 = analogRead(<模拟引脚>) * 5/1024*'
- en: If you power on Arduino through the USB port of your computer, the power voltage
    is never exactly 5V but usually less. To get a better reading, you should measure
    the power voltage with a digital multimeter, and replace 5 with the actual power
    voltage in the previous formula.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过电脑的USB端口给Arduino供电，电源电压永远不会正好是5V，通常会更低。为了获得更好的读数，你应该使用数字万用表测量电源电压，并在之前的公式中将5替换为实际的电源电压。
- en: In the loop function it's necessary to call the `pollACI` function so that the
    communication library can take the control for handling incoming data from the
    iOS connected device.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环函数中，必须调用`pollACI`函数，以便通信库可以接管控制以处理从iOS连接的设备接收到的数据。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**poolACI**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**poolACI**'
- en: If you have a long and complex program, you may need to add many `poolACI` calls
    across the code in order to frequently allow the library to take control to handle
    communication. Otherwise, you can experience data loss.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个长而复杂的程序，你可能需要在代码中添加许多`poolACI`调用，以便频繁地允许库接管控制以处理通信。否则，你可能会遇到数据丢失。
- en: 'The core algorithm is in the following lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 核心算法在以下几行中：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the door has not been manually locked, the light is above the `LIGHT_THRESHOLD`,
    the temperature is between `LOW_TEMPERATURE_THRESHOLD` and `HIGH_TEMPERATURE_THRESHOLD`,
    the servo motor can be moved to the `UNLOCKED_POSITION` with the instruction:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果门没有被手动锁定，灯光强度高于`LIGHT_THRESHOLD`，温度在`LOW_TEMPERATURE_THRESHOLD`和`HIGH_TEMPERATURE_THRESHOLD`之间，可以使用以下指令将伺服电机移动到`UNLOCKED_POSITION`：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, it is moved to the `LOCKED_POSITION`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将被移动到`LOCKED_POSITION`：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**DeMorgan''s theorem**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**德摩根定理**'
- en: This theorem is very useful for coding if-then-else statements in any programming
    language. Don't ever forget it!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定理在用任何编程语言编写if-then-else语句时非常有用。永远不要忘记它！
- en: not (A or B) = not A and not B
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: not (A or B) = not A and not B
- en: or
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: not (A and B) = not A or not B
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: not (A and B) = not A or not B
- en: The opposite condition of "A or B" is "not A **and** not B", the opposite condition
    of "A and B" is "not A **or** not B.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"A或B"的对立条件是"非A **且** 非B"，"A和B"的对立条件是"非A **或** 非B"。'
- en: 'The following two functions are quite self-explanatory:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数相当直观：
- en: '`aboveThreshold`(…)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aboveThreshold`(…)'
- en: '`betweenThresholds`(….)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`betweenThresholds`(….)'
- en: Take a look at the downloaded code for more details.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下载的代码以获取更多详细信息。
- en: 'If `manuallyLocked` is true, light and temperature readings are ignored. This
    variable is set by a message received from the iOS device in the `rxCallback`
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`manuallyLocked`为真，则忽略光和温度读数。此变量在`rxCallback`函数中通过从iOS设备接收到的消息设置：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remember that the nRF8001 library automatically calls the `rxCallback` function
    when data sent from the iOS device are ready for processing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，nRF8001库在从iOS设备发送的数据准备好处理时自动调用 `rxCallback` 函数。
- en: The iOS device sends only one byte with the ASCII character 1 if the door has
    to be locked, or the ASCII character 0 otherwise.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果门需要上锁，iOS设备将发送带有ASCII字符1的一个字节，否则发送ASCII字符0。
- en: The ASCII character 0 has code 48, so to transform it to a Boolean value false
    (0) you need to subtract 48 (or the character '0' which is the same). Subtracting
    48 from the ASCII character 1, we get the Boolean value true (1).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符0的代码是48，因此要将它转换为布尔值false（0），你需要减去48（或字符'0'，它们是相同的）。从ASCII字符1减去48，我们得到布尔值true（1）。
- en: Back to the main function. If `iOSConnected` is true, an iOS device is connected
    to Arduino, and some data has to be transferred to it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 返回主函数。如果 `iOSConnected` 为真，iOS设备已连接到Arduino，并且需要向其传输一些数据。
- en: 'Data are sent to iOS with the following format:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以以下格式发送到iOS：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `latch_position` informs the iOS device if the latch is opened or closed,
    whereas `temperature` is the external temperature.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`latch_position` 通知iOS设备闩锁是开启还是关闭，而 `temperature` 是外部温度。
- en: 'To send data to iOS we use the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据发送到iOS，我们使用以下代码：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function `snprintf` creates a buffer formatted as required, which is then
    sent to iOS with the function `uart.write((uint8_t *)buffer, strlen(buffer))`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `snprintf` 创建一个按需格式化的缓冲区，然后通过函数 `uart.write((uint8_t *)buffer, strlen(buffer))`
    发送到iOS。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**snprintf**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**snprintf**'
- en: This function never writes more characters than that indicated by the second
    parameter. This is very important to write safe code. In fact, if you write more
    characters than the buffer size, it is likely that you write somewhere in a memory
    location which is used for other purposes causing a microprocessor crash. After
    a crash, the microprocessor restarts the program execution from the setup function.
    For more details, visit [http://bit.ly/1E021no](http://bit.ly/1E021no) and [http://bit.ly/1LijDx5](http://bit.ly/1LijDx5).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数永远不会写入比第二个参数指示的更多字符。这对于编写安全代码非常重要。实际上，如果你写入的字符多于缓冲区大小，很可能会在用于其他目的的内存位置写入，导致微处理器崩溃。崩溃后，微处理器将从
    `setup` 函数重新启动程序执行。更多详情请访问 [http://bit.ly/1E021no](http://bit.ly/1E021no) 和 [http://bit.ly/1LijDx5](http://bit.ly/1LijDx5)。
- en: '**dtostrf**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**dtostrf**'
- en: 'Unfortunately, on Arduino, `snprintf` doesn''t work with floating numbers,
    so we need to use `dtostrf` to transform the temperature (which is a float) to
    a string and then using it in the `snprintf`. The second parameter of `dtostrf`
    is the number of decimal digits to use in the conversion. For more details, visit:
    [http://bit.ly/1fmj9HV](http://bit.ly/1fmj9HV).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Arduino上，`snprintf` 无法处理浮点数，因此我们需要使用 `dtostrf` 将温度（一个浮点数）转换为字符串，然后再在 `snprintf`
    中使用它。`dtostrf` 的第二个参数是转换中使用的十进制位数。更多详情请访问：[http://bit.ly/1fmj9HV](http://bit.ly/1fmj9HV)。
- en: 'The last thing that we have to code is managing connections and disconnections
    of the iOS device. This is done in the `aciCallback` function. The nRF8001 library
    calls this function each time one of the following events happen: the device starts
    advertizing itself in order to be discovered by other Bluetooth devices, an external
    device connects, or a connected device disconnects.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要编写的代码是管理iOS设备的连接和断开。这是在 `aciCallback` 函数中完成的。nRF8001库在以下事件发生时调用此函数：设备开始广播以被其他蓝牙设备发现，外部设备连接，或连接的设备断开。
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Testing and tuning the Arduino side
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和调整Arduino端
- en: 'Once you have uploaded the code to Arduino (for more details: [http://bit.ly/1JPNAn3](http://bit.ly/1JPNAn3)
    or [http://bit.ly/1KsUhqv](http://bit.ly/1KsUhqv)), you can start testing it.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将代码上传到Arduino（更多详情：[http://bit.ly/1JPNAn3](http://bit.ly/1JPNAn3) 或 [http://bit.ly/1KsUhqv](http://bit.ly/1KsUhqv)），你就可以开始测试它了。
- en: If enough light reaches the photoresistor and the temperature is between 2 degree
    Celsius and 33 degree Celsius, the servo should move to the open position and
    the latch should be completely retracted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果足够的光线到达光敏电阻，并且温度在2摄氏度到33摄氏度之间，伺服应该移动到开启位置，并且闩锁应该完全缩回。
- en: Then, when you cover the photoresistor, the latch should close. In order to
    test the temperature sensor you can use a hairdryer to get the temperature over
    3 degree Celsius and an ice pack to get it below 2 degree Celsius. In both cases
    the latch should close.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你覆盖光敏电阻时，闩锁应该关闭。为了测试温度传感器，你可以使用吹风机将温度提高到3摄氏度以上，或者使用冰袋将其降低到2摄氏度以下。在这两种情况下，闩锁都应该关闭。
- en: 'You can easily change the temperature thresholds by changing these defines:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改这些定义轻松更改温度阈值：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The light threshold likely requires some more tuning, since the values read
    by the photoresistor highly depend on the photoresistor characteristics, the mounting
    positioning and orientation. Anyway, change:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 光阈值可能需要更多的调整，因为光敏电阻读取的值高度依赖于光敏电阻的特性、安装定位和方向。无论如何，更改：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should be able to find the value that is right for your needs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够找到适合你需求的值。
- en: 'You may also need to adjust the servo motor positions for opening and closing
    the latch because of the way you have assembled everything. To adjust the positions
    you can change:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要根据你组装的方式调整伺服电机的开合位置。为了调整位置，你可以更改：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This represents the position in degrees of the motor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示电机的位置角度。
- en: iOS code
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS代码
- en: In this chapter, we are going to write the iOS application through which we
    can connect to the Arduino, know if the pet door is locked or not, read the external
    temperature, and eventually manually lock it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写iOS应用程序，通过该应用程序我们可以连接到Arduino，了解宠物门是否锁定，读取外部温度，并最终手动锁定它。
- en: 'The full code of this project can be downloaded from here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的完整代码可以从这里下载：
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
- en: To better understand the explanations in the next paragraphs, you should open
    the downloaded code while reading.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，你应该在阅读时打开下载的代码。
- en: The main tool for writing the application is Xcode provided by Apple. We can
    start it from Launchpad or entering the **Applications** folder in **Finder**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编写应用程序的主要工具是苹果公司提供的Xcode。我们可以从Launchpad启动它，或者在Finder中的**应用程序**文件夹中打开它。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Start developing iOS apps today**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**今天开始开发iOS应用程序**'
- en: 'A useful guide to iOS developing provided by Apple can be found at this link:
    [http://apple.co/MtP2Aq](http://apple.co/MtP2Aq).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司提供的iOS开发的有用指南可以在以下链接中找到：[http://apple.co/MtP2Aq](http://apple.co/MtP2Aq)。
- en: '**Objective-C**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'The language used for developing iOS applications is Objective-C. It is similar
    to C++ and you can find an introduction to this language at the following link:
    [http://apple.co/19FWxfQ](http://apple.co/19FWxfQ).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 开发iOS应用程序使用的语言是Objective-C。它与C++类似，你可以在以下链接中找到该语言的介绍：[http://apple.co/19FWxfQ](http://apple.co/19FWxfQ)。
- en: Creating the Xcode project
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Xcode项目
- en: The first step is to create a new project. Xcode provides many different project
    templates; we are going to use the Tabbed Application, which has two tabs. We
    are going to use the first tab as the main application panel, and the second to
    scan the nRF8001 device. This operation is required only once, when the application
    is started for the first time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新项目。Xcode提供了许多不同的项目模板；我们将使用Tabbed Application，它有两个标签。我们将使用第一个标签作为主应用程序面板，第二个用于扫描nRF8001设备。此操作仅在应用程序首次启动时进行一次。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Xcode overview**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xcode概述**'
- en: 'You can find everything you need to work with Xcode at the following link:
    [http://apple.co/1UQnMtS](http://apple.co/1UQnMtS).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到所有与Xcode相关的工作所需信息：[http://apple.co/1UQnMtS](http://apple.co/1UQnMtS)。
- en: 'To create the new project we can follow these steps (see the following screenshots):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新项目，我们可以按照以下步骤进行（见以下截图）：
- en: Go to **File** | **New** | **Project …**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件** | **新建** | **项目 …**。
- en: In the left panel, select **iOS** | **Application**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，选择**iOS** | **应用程序**。
- en: In the right panel, select **Tabbed Application** and then click on **Next**.![Creating
    the Xcode project](img/image00165.jpeg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板中，选择**Tabbed Application**，然后点击**下一步**。![创建Xcode项目](img/image00165.jpeg)
- en: 'In the next screen, enter the required information:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏中，输入所需信息：
- en: '**Product Name**: `PetDoorLocker`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品名称**: `PetDoorLocker`'
- en: '**Organization Name**: `Your Name`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织名称**: `Your Name`'
- en: '**Organization Identifier**: `yourname` (this information is relevant only
    for publishing the application to the iTunes Store and selling it. It can be ignored)'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织标识符**: `yourname`（此信息仅与将应用程序发布到iTunes Store并销售有关。可以忽略）'
- en: '**Language**: **Objective-C**'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**：**Objective-C**'
- en: '**Devices**: **Universal** (we are going to create an application that can
    run on an iPhone and iPad)'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：**通用**（我们将创建一个可以在iPhone和iPad上运行的应用程序）'
- en: '![Creating the Xcode project](img/image00166.jpeg)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建Xcode项目](img/image00166.jpeg)'
- en: Click on the **Next** button.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮。
- en: Select a folder where you want to store the project (leave Source Control unchecked).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要存储项目的文件夹（取消选中源代码控制）。
- en: That's all!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！
- en: We are now ready to start writing the new application. The first thing to do
    is rename the two view controllers (FirstViewController and SecondViewController).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写新的应用程序了。首先要做的是重命名两个视图控制器（FirstViewController和SecondViewController）。
- en: Select `FirstViewController.h` in the left panel, this will open the file in
    the right panel.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择`FirstViewController.h`，这将打开右侧面板中的文件。
- en: 'Select `FirstViewController` in the line `@interface FirstViewController :
    UIViewController`, by double clicking on `FirstViewController`.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在行`@interface FirstViewController : UIViewController`中选择`FirstViewController`，通过双击`FirstViewController`。'
- en: Right Click and select **Refactor** | **Rename …**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**重构** | **重命名 …**。
- en: 'Enter the new name of the view controller: `PetDoorLockerViewController`.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入视图控制器的新的名称：`PetDoorLockerViewController`。
- en: Click preview and then save.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击预览然后保存。
- en: Select `SecondViewController.h`, and with the same procedure rename it as `BLEConnectionViewController`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`SecondViewController.h`，按照相同的步骤将其重命名为`BLEConnectionViewController`。
- en: 'What''s a View Controller? The Apple documentation says:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是视图控制器？苹果文档说：
- en: '*View controllers are a vital link between an app''s data and its visual appearance.
    Whenever an iOS app displays a user interface, the displayed content is managed
    by a view controller or a group of view controllers coordinating with each other.
    Therefore, view controllers provide the skeletal framework on which you build
    your apps.*'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*视图控制器是应用程序数据与其视觉外观之间的重要联系。每当iOS应用程序显示用户界面时，显示的内容都由视图控制器或一组相互协调的视图控制器管理。因此，视图控制器提供了构建应用程序的骨骼框架。*'
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Design Patterns**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**'
- en: 'Before going any further, we suggest you read the information on the following
    link: [http://apple.co/1hkUDbU](http://apple.co/1hkUDbU).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们建议您阅读以下链接上的信息：[http://apple.co/1hkUDbU](http://apple.co/1hkUDbU)。
- en: Now we are ready to design the GUI of the new application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好设计新应用程序的GUI。
- en: Designing the application user interface for BLEConnectionViewController
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为BLEConnectionViewController设计应用程序用户界面
- en: 'To design the app user interface, let''s open the `Main.storyboard`. This file
    contains everything about the GUI. Once opened, you should see something as shown
    in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计应用程序用户界面，让我们打开`Main.storyboard`。此文件包含有关GUI的所有内容。一旦打开，您应该看到以下截图所示的内容：
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00167.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![为BLEConnectionViewController设计应用程序用户界面](img/image00167.jpeg)'
- en: Let's start from the `BLEConnectionViewController`, which will be used for scanning
    the nRF8001 device.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`BLEConnectionViewController`开始，它将被用于扫描nRF8001设备。
- en: Double click on the view controller to select it.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击视图控制器以选择它。
- en: Click on the label **Second View** and delete it, then select **Loaded by the
    SecondViewController** and delete it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**第二视图**标签并删除它，然后选择**由SecondViewController加载**并删除它。
- en: 'Open the Utilities panel on the right: **View** | **Utilities** | **Show Utilities**.
    (To open this panel you can also use the green circled icon in the following screenshot).'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧打开实用工具面板：**视图** | **实用工具** | **显示实用工具**。（要打开此面板，您也可以使用以下截图中的绿色圆形图标）。
- en: Select **Label** in the Tool Navigator and drop it to the free area (see the
    following screenshot).![Designing the application user interface for BLEConnectionViewController](img/image00168.jpeg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具导航器中选择**Label**并将其拖放到空白区域（见以下截图）。![为BLEConnectionViewController设计应用程序用户界面](img/image00168.jpeg)
- en: Rename the label, by double clicking **Label** and entering `Device`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击**Label**并输入`Device`来重命名标签。
- en: 'Now we have to set the Auto Layout constraints that will lock the label in
    the desired position:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须设置将锁定标签在所需位置的自动布局约束：
- en: Click on the Auto Layout Pin icon (it's circled in red in the previous screenshot).
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击自动布局固定图标（在之前的截图中以红色圆形标记）。
- en: Enter `20` for the Leading Space from Superview, and `30` for Top Space to Superview
    as shown in the following screenshot.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“从父视图的Leading空间”中输入`20`，在“到父视图的Top空间”中输入`30`，如以下截图所示。
- en: Enter `53` as **Width**.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`53`作为**宽度**。
- en: Click on **Add 3 Constraints**.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加3个约束**。
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00169.jpeg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![为BLEConnectionViewController设计应用程序用户界面](img/image00169.jpeg)'
- en: 'Drop a new instance of **Label** next to the previous and add Auto Layout Constraints
    to it:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个标签旁边放置一个新的**标签**实例，并为其添加自动布局约束：
- en: Select both labels (clicking on them with the *Command* button pressed).
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个标签（按下**命令**按钮点击它们）。
- en: Click on the Align icon (it's circled in green in the previous screenshot).
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击对齐图标（在之前的截图中被圈出绿色）。
- en: Select **Vertical Centers** and then **Add 1 Constraint**.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**垂直居中**然后**添加1个约束**。
- en: Select only the new label and click on the Auto Layout Pin.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择新的标签并点击自动布局固定点。
- en: Enter `20` for both the Leading Space and Trailing Space.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**前导空间**和**尾随空间**都输入为`20`。
- en: For **Update Frames**, select **All frames in Container**.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**更新框架**，选择**容器中的所有框架**。
- en: Click on **Add 2 Constraints**.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加2个约束**。
- en: Select the new label again, and select **View** | **Utilities** | **Show Attributes
    Inspector** (or click on the icon circled in red in the next screenshot).
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择新的标签，并选择**视图** | **实用工具** | **显示属性检查器**（或点击下一张截图中圈出的红色图标）。
- en: Change the font size to `13` and **Alignment** to center (see area circled green
    in the next screenshot).
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字体大小更改为`13`并将**对齐**设置为居中（见下一张截图中圈出的绿色区域）。
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00170.jpeg)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![为BLEConnectionViewController设计应用程序用户界面](img/image00170.jpeg)'
- en: The new label will show the UUID of the nRF8001 once detected. Now we have to
    add a button to start scanning for nRF8001 devices nearby.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新标签将显示检测到的nRF8001的UUID。现在我们必须添加一个按钮来开始扫描附近的nRF8001设备。
- en: 'Drag a button into the container, double click on it, and enter `Scan`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮拖入容器中，双击它，并输入`Scan`：
- en: Select the button and click on the Auto Layout Pin.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮并点击自动布局固定点。
- en: Enter `45` for **To Space** and click on **Add 1 Constraint**.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**到空间**输入为`45`并点击**添加1个约束**。
- en: Select the button, click on the Align icon, select Horizontal Center in the
    Container, for **Update Frames**, select **All frames in Container**, and then
    click on **Add 1 Constraint**.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮，点击对齐图标，在容器中选择水平居中，对于**更新框架**，选择**容器中的所有框架**，然后点击**添加1个约束**。
- en: Now we have to link the GUI components with the code in order to manipulate
    them programmatically.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们必须将GUI组件与代码链接起来，以便程序化地操作它们。
- en: Select the **BLEConnectionViewController**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**BLEConnectionViewController**。
- en: Click on **View** | **Assistant Editor**. A new panel opens with the `BLEConnectionViewController.h`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**视图** | **辅助编辑器**。一个新的面板打开，显示`BLEConnectionViewController.h`。
- en: Close the Utilities panel to have more space (click on **View** | **Utilities**
    | **Hide Utilities**).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭实用工具面板以获得更多空间（点击**视图** | **实用工具** | **隐藏实用工具**）。
- en: Make sure that in the red circled area of the following screenshot, you read
    **BLEConnectionViewController.m**, otherwise click on it and change to the desired
    file.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在下一张截图的红色圈出区域中，你看到的是**BLEConnectionViewController.m**，如果不是，请点击它并更改为所需的文件。
- en: Select the label **Label** and keeping the *Command* button pressed, drag the
    label to the code on the right between `@interface BLEConnectionViewController
    ()` and `@end` (see picture below).![Designing the application user interface
    for BLEConnectionViewController](img/image00171.jpeg)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择标签**标签**，保持**命令**按钮按下，将标签拖到右侧的代码中，在`@interface BLEConnectionViewController
    ()`和`@end`之间（见下图画）。![为BLEConnectionViewController设计应用程序用户界面](img/image00171.jpeg)
- en: When a dialog appears, enter the **Name** as `deviceUUIDLabel` (see picture
    below) and then click **Connect**.![Designing the application user interface for
    BLEConnectionViewController](img/image00172.jpeg)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现对话框时，将**名称**输入为`deviceUUIDLabel`（见下图画）然后点击**连接**。![为BLEConnectionViewController设计应用程序用户界面](img/image00172.jpeg)
- en: This creates a property (`deviceUUIDLabel`), which can be used for changing
    the label properties, such as its text.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个属性（`deviceUUIDLabel`），可以用来更改标签属性，例如其文本。
- en: Tip
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**ARC and strong versus weak**'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ARC和强与弱**'
- en: 'The `strong` attribute indicates to the compiler that the memory associated
    to the property has to be kept allocated until the class in which it is defined
    is allocated. Properties that are not defined strong (but weak) are automatically
    deallocated as soon as the code block in which they are defined is completed.
    In short, as long as there is a strong reference pointer to the object, that object
    will not be deallocated. Memory management under iOS has been simplified since
    the introduction of **Automatic Counting Reference** (**ARC**) but is still an
    issue for most people. A good introduction can be found here: [http://apple.co/1MvuNgw](http://apple.co/1MvuNgw).
    It is for Swift (the last programming language that Apple has made available)
    but it is worth reading.'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`strong`属性指示编译器，与属性关联的内存必须保留分配，直到定义它的类被分配。未定义为强引用（而是弱引用）的属性将在它们定义的代码块完成后自动释放。简而言之，只要有一个强引用指针指向对象，该对象就不会被释放。自引入**自动引用计数（ARC**）以来，iOS下的内存管理已经简化，但仍对大多数人来说是一个问题。一篇好的介绍可以在以下链接找到：[http://apple.co/1MvuNgw](http://apple.co/1MvuNgw)。它是为Swift（苹果最新推出的编程语言）编写的，但值得一读。'
- en: Tip
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Atomic versus nonatomic**'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**原子与非原子**'
- en: The `atomic` attribute will ensure that a whole value is always returned from
    the getter or set by the setter of the property, regardless of setter activity
    on any other thread. That is, if thread A is in the middle of the getter while
    thread B calls the setter, an actual viable value will be returned to the caller
    in A.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`atomic`属性将确保从getter或setter返回的整个值始终是完整的，无论其他线程上的setter活动如何。也就是说，如果线程A正在getter的中间，而线程B调用setter，线程A将返回一个实际有效的值给调用者。'
- en: 'The Apple documentation says: *Property atomicity is not synonymous with an
    object''s thread safety*.'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 苹果文档指出：“属性的原子性并不等同于对象的线程安全性”。
- en: 'Accessing a strong property is slower than accessing a nonatomic one. More
    details here: [http://apple.co/1JeBIdb](http://apple.co/1JeBIdb).'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问强属性比访问非原子属性要慢。更多详情请参阅：[http://apple.co/1JeBIdb](http://apple.co/1JeBIdb)。
- en: 'We now link the **Scan** button to have a method that is called when the button
    is tapped:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将**扫描**按钮链接到一个当按钮被点击时调用的方法：
- en: Select the **Scan** button and, keeping *Control* pressed, drop it to the right
    pane.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**扫描**按钮，并按住**控制**键，将其拖到右侧面板。
- en: Enter `startScanning` as the name and select **UIButton** for **Type** (see
    picture below). This creates a new method, which is called when the button is
    pressed.![Designing the application user interface for BLEConnectionViewController](img/image00173.jpeg)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称输入为`startScanning`，并将**类型**选择为**UIButton**（见下图）。这创建了一个新方法，当按钮被按下时会被调用。![为BLEConnectionViewController设计应用程序用户界面](img/image00173.jpeg)
- en: 'To complete the design, we have to set the name of the view controller, which
    appears in the toolbar:'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了完成设计，我们必须设置视图控制器的名称，该名称将出现在工具栏中：
- en: Open the Tool Navigator again (**View** | **Utilities** | **Show Utilities**).
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开工具导航器（**视图** | **实用工具** | **显示实用工具**）。
- en: Select the icon at the bottom side of the container (a small square with second
    label under it).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择容器底部的图标（一个带有第二个标签的小正方形）。
- en: Show Attribute Inspector (**View** | **Utilities** | **Attribute Inspector**).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示属性检查器（**视图** | **实用工具** | **属性检查器**）。
- en: In the **Title** field, enter `Configuration`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**标题**字段中，输入`Configuration`。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You could also choose an icon from the Image list box. To do that, you should
    add the icon to the project, dropping it into the Supporting Files group in the
    left panel. The icon should be 32 × 32 pixels.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从图像列表框中选择一个图标。为此，您应该将图标添加到项目中，将其拖到左侧面板中的“支持文件”组。图标应为32 × 32像素。
- en: At the very end, your View Controller should look like the next picture.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您的视图控制器应该看起来像下一张图片。
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00174.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![为BLEConnectionViewController设计应用程序用户界面](img/image00174.jpeg)'
- en: Designing the application user interface for PetDoorLockerViewController
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PetDoorLockerViewController设计应用程序用户界面
- en: In this section we will design the interface for the first view controller (PetDoorLockerViewController).
    We will only describe how to add components not shown in the previous chapter.
    Refer to the next picture for the global layout of the view.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设计第一个视图控制器（PetDoorLockerViewController）的界面。我们只会描述如何添加前一章中没有显示的组件。请参考下一张图片以查看视图的全局布局。
- en: Add a label, rename it as `Door Status` and add to it the Auto Layout constraints.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个标签，将其重命名为`Door Status`，并添加自动布局约束。
- en: Enter `UIView` in the search field of the right panel and drop the view near
    the label. You can resize the view dragging the small white squares on its borders.
    In the Attribute Inspector, select a light gray color for the background.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板的搜索字段中输入`UIView`，并将视图拖到标签附近。你可以通过拖动视图边框上的小白色方块来调整视图大小。在属性检查器中，选择浅灰色作为背景颜色。
- en: Select both the label and the view and click on Align icon. Select **Vertical
    Centers** and click on **Add 1 Constraint**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择标签和视图，然后点击对齐图标。选择**垂直居中**，然后点击**添加1个约束**。
- en: Select the view and click on the Align icon. Select **Horizontal Center** in
    the **Container** and click on **Add 1 Constraint**.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择视图并点击对齐图标。在**容器**中选择**水平居中**，然后点击**添加1个约束**。
- en: Select the Pin icon, enter `48` for height and width, for **Update Frames**,
    select **All frames in Container** and then click on **Add 2 Constraints**.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择固定图标，输入`48`作为高度和宽度，对于**更新框架**，选择**容器中的所有框架**，然后点击**添加2个约束**。
- en: Add a new label `Temperature`, and add to it the Auto Layout constraints.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的标签`温度`，并将自动布局约束添加到它上面。
- en: Add another label near **Temperature** and the Auto Layout constraints to vertically
    center it with **Temperature** and horizontally center it in the container's view.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**温度**附近添加另一个标签，并将自动布局约束添加到它上面，以使其垂直居中对齐**温度**，并在容器视图中水平居中。
- en: Then add a label, `Lock`, and add Auto Layout constraints.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个标签`锁`，并添加自动布局约束。
- en: Add a switch near **Lock** and the Auto Layout constraints to vertically center
    it with **Lock** and horizontally center it in the container's view.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**锁**附近添加一个开关，并添加自动布局约束以使其垂直居中对齐**锁**，并在容器视图中水平居中。
- en: At the bottom of the container, add a button (called **Connect**) and the Auto
    Layout constraints to vertically center it with **Lock** and horizontally center
    it in the container's view.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器的底部添加一个按钮（称为**连接**），并添加自动布局约束以使其垂直居中对齐**锁**，并在容器视图中水平居中。
- en: You should end with something like what is shown in the following picture. The
    **Connect** button is useful in case you lose connection to the nRF8001 device,
    and you need to manually reconnect to it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该结束于以下图片所示的内容。**连接**按钮在失去与nRF8001设备的连接时很有用，你需要手动重新连接到它。
- en: '![Designing the application user interface for PetDoorLockerViewController](img/image00174.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![为PetDoorLockerViewController设计应用程序用户界面](img/image00174.jpeg)'
- en: 'Once all the components have been added, you can link them to the code finishing
    with:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了所有组件，你可以通过以下方式将它们链接到代码：
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And with the function `reconnect` to intercept when the **Connect** button is
    tapped.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用`reconnect`函数来拦截当**连接**按钮被点击时。
- en: In case of doubts, you can use the downloaded code as reference.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，可以使用下载的代码作为参考。
- en: We are eventually ready to write the code for both the view controllers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终准备好为两个视图控制器编写代码。
- en: Writing code for BLEConnectionViewController
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为BLEConnectionViewController编写代码
- en: The purpose of this controller is to get the unique identifier of the nRF8001
    device, so that it can be used to connect to the device as needed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器的作用是获取nRF8001设备的唯一标识符，以便它可以按需连接到该设备。
- en: 'To handle communication with a Bluetooth 4.0 device, we need to use the class
    `CBCentralManager` that we add to the interface of the view controller:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理与蓝牙4.0设备的通信，我们需要使用我们添加到视图控制器接口中的类`CBCentralManager`：
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Xcode class reference**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xcode类参考**'
- en: If you need to know more about a class, you can press *Option* + click the class
    name for direct access to the documentation. Conversely, *Command* + click will
    bring you to the source file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要了解更多关于一个类的信息，你可以按*Option* + 点击类名以直接访问文档。相反，*Command* + 点击将带你到源文件。
- en: The instantiation of the class is in the `viewDidAppear` method, which is called
    every time the view associated with the view controller is shown on the device
    screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实例化在`viewDidAppear`方法中，每当与视图控制器关联的视图在设备屏幕上显示时都会调用。
- en: '[PRE29]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To work with `CBCentralManager`, we need to implement a few delegate methods,
    but first we have to instruct the controller about that; we open the `BLEConnectionViewController.h`
    file and we change it as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`CBCentralManager`一起工作，我们需要实现一些代理方法，但首先我们必须通知控制器这一点；我们打开`BLEConnectionViewController.h`文件，并按以下方式更改它：
- en: '[PRE30]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we are ready to write two delegate methods:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们准备好编写两个代理方法：
- en: '`centralManagerDidUpdateState`: This method is called when the state of the
    iOS Bluetooth subsystem changes. This method has only an informative purpose in
    this view controller, but it is very useful in more complex projects where the
    status of the Bluetooth subsystem needs to be monitored. See the downloaded code
    to get more details about this method.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centralManagerDidUpdateState`: 当iOS蓝牙子系统的状态发生变化时调用此方法。在此视图控制器中，此方法仅具有信息性目的，但在需要监控蓝牙子系统状态的更复杂项目中非常有用。查看下载的代码以获取有关此方法的更多详细信息。'
- en: '`didDiscoverPeripheral`: This method is called when a new peripheral is discovered:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didDiscoverPeripheral`: 当发现新的外设时调用此方法：'
- en: '[PRE31]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each time a new Bluetooth peripheral is discovered (the nRF8001 board hooked
    up to Arduino in our case) the method is called providing information on the peripheral.
    We will show the identifier of the peripheral on the screen:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发现新的蓝牙外设（在我们的例子中是nRF8001板连接到Arduino）时，都会调用该方法，提供有关外设的信息。我们将在屏幕上显示外设的标识符：
- en: '[PRE32]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And we store it in `userDefaults` with the key `PetDoorLockerDevice` so that
    we can retrieve it as needed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其存储在`userDefaults`中，键为`PetDoorLockerDevice`，以便在需要时检索它。
- en: Tip
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**User preferences**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户偏好设置**'
- en: 'Preferences are information that you store persistently, and use to configure
    your app. They can be accessed using the `NSUserDefaults` class. More details
    can be found here: [http://apple.co/1qRYb3o](http://apple.co/1qRYb3o).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 预设是您存储的持久信息，用于配置您的应用程序。您可以使用`NSUserDefaults`类访问它们。更多详细信息请参阅[此处](http://apple.co/1qRYb3o)。
- en: 'Later on, we''ll get back to explaining:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将回到解释：
- en: '[PRE33]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The **Scan** button activates the method `startScanning` when the user needs
    to detect the available device.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**扫描**按钮在用户需要检测可用设备时激活`startScanning`方法。'
- en: '[PRE34]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the state of the `centralManager` is not `CBCentralManagerStatePoweredOn`
    nothing can be done. Otherwise the scanning is started by calling `scanForPeripheralsWithServices`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`centralManager`的状态不是`CBCentralManagerStatePoweredOn`，则无法执行任何操作。否则，通过调用`scanForPeripheralsWithServices`开始扫描。
- en: Each Bluetooth 4.0 device has one or more services uniquely identified; we look
    for the service identifier of the nRF8001 board (NRF8001BB_SERVICE_UUID).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 每个蓝牙4.0设备都有一个或多个唯一标识的服务；我们寻找nRF8001板的服务标识符（NRF8001BB_SERVICE_UUID）。
- en: Tip
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**nRF8001 service and characteristics**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**nRF8001服务和特征**'
- en: 'A Bluetooth peripheral can provide more services and, for each service, more
    characteristics that the user can read and/or write. The nRF8001 board has only
    one service (UUID: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E), one characteristic to
    receive data (UUID: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E) and one for sending
    data (UUID: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个蓝牙外设可以提供更多服务，并且对于每个服务，用户都可以读取和/或写入更多特征。nRF8001板只有一个服务（UUID：6E400001-B5A3-F393-E0A9-E50E24DCCA9E），一个用于接收数据的特征（UUID：6E400002-B5A3-F393-E0A9-E50E24DCCA9E）和一个用于发送数据的特征（UUID：6E400003-B5A3-F393-E0A9-E50E24DCCA9E）。
- en: 'The value NRF8001BB_SERVICE_UUID is defined at the beginning of the view controller''s
    code: `#define NRF8001BB_SERVICE_UUID @"6E400001-B5A3-F393-E0A9-E50E24DCCA9E"`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: NRF8001BB_SERVICE_UUID的值在视图控制器代码的开头定义：`#define NRF8001BB_SERVICE_UUID @"6E400001-B5A3-F393-E0A9-E50E24DCCA9E"`。
- en: 'Once a device with that service has been found, the iOS calls `didDiscoverPeripheral`
    and the iOS device stops scanning. Unfortunately, the scanning process runs until
    a device is found. So in case the peripheral has not been found, the iOS device
    keeps draining the batteries. To overcome this issue, we need a timer. It is defined
    into the view controller interface:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到具有该服务的服务器，iOS将调用`didDiscoverPeripheral`，iOS设备停止扫描。不幸的是，扫描过程会一直运行，直到找到设备。因此，如果外设未找到，iOS设备会持续消耗电量。为了克服这个问题，我们需要一个计时器。它定义在视图控制器接口中：
- en: '[PRE35]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And instantiated with:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过以下方式实例化：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If not halted, the timer will call the method `scanningTimedOut` after 5 seconds.
    In this method we can stop `centralManager` from scanning and draining the batteries:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有停止，计时器将在5秒后调用`scanningTimedOut`方法。在此方法中，我们可以停止`centralManager`的扫描和耗电：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If a peripheral, with the desired service, is found, the iOS calls the `didDiscoverPeripheral`
    method:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到具有所需服务的外设，iOS将调用`didDiscoverPeripheral`方法：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have to halt the `scanningTimer` that is the purpose of this line `[_scanningTimer
    invalidate];` and save the UUID of the peripheral in User Defaults.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须停止`scanningTimer`，这是此行`[_scanningTimer invalidate];`的目的，并将外设的UUID保存到用户默认设置中。
- en: Now it's time to run the app on your device.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在你的设备上运行应用程序了。
- en: Tip
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Run your app**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行您的应用程序**'
- en: 'All the information for running your app both on the simulator and on the physical
    device can be found here: [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到运行应用程序所需的所有信息，无论是在模拟器上还是在物理设备上：[https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html)。
- en: Power on the Arduino board and start the app, then tap on the configuration
    tab and then on the **Scan** button. In a few seconds you should see a long string
    of letters and numbers near the device label. That is the UUID of the nRF8001
    device. The setup configuration has been completed!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Arduino板电源并启动应用程序，然后点击配置标签，然后点击**扫描**按钮。几秒钟后，您应该在设备标签附近看到一个由字母和数字组成的长字符串。这就是nRF8001设备的UUID。设置配置已完成！
- en: 'If something goes wrong, the message **no device is in range** appears. In
    that case, double check the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，将显示消息**没有设备在范围内**。在这种情况下，请仔细检查以下内容：
- en: The nRF8001 is properly wired to Arduino.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: nRF8001已正确连接到Arduino。
- en: You have uploaded the correct code to Arduino.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已将正确的代码上传到Arduino。
- en: The Arduino board is powered up.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Arduino板已上电。
- en: The IDE console shows the messages **Setup Completed** and **Advertising started**.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE控制台显示消息**设置完成**和**开始广播**。
- en: Bluetooth is activated on your iOS device (tap Settings and then Bluetooth to
    activate it).
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的iOS设备上激活了蓝牙（轻触设置，然后蓝牙以激活它）。
- en: Writing code for PetDoorLockerViewController
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写PetDoorLockerViewController的代码
- en: In this section, we will write the main part of the application, which allows
    you to monitor if the pet door is locked or unlocked, read the external temperature,
    and lock the pet door if you need it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写应用程序的主体部分，该部分允许您监控宠物门是否锁定或解锁，读取外部温度，并在需要时锁定宠物门。
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the code of this view controller is more complex and we want to save space
    for other subjects, we are going to explain the entire code but we are not going
    to guide you on writing it step-by-step. Please, refer to the downloaded code
    to see the code in its entirety.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此视图控制器的代码较为复杂，并且我们希望为其他主题节省空间，因此我们将解释整个代码，但不会逐步指导您编写它。请参阅下载的代码以查看代码的完整内容。
- en: 'We need three defines and some additional properties in the view controller''s
    interface:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在视图控制器接口中添加三个定义和一些额外的属性：
- en: '[PRE39]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need to add a delegate `@interface PetDoorLockerViewController : UIViewController
    <CBCentralManagerDelegate, CBPeripheralDelegate>` in the `PetDoorLockerViewController.h`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要在`PetDoorLockerViewController.h`中添加一个代理`@interface PetDoorLockerViewController
    : UIViewController <CBCentralManagerDelegate, CBPeripheralDelegate>`。'
- en: Setting up the `CBCentralManager` instance is exactly like we did in the previous
    controller.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`CBCentralManager`实例与我们在上一个控制器中所做的方式完全相同。
- en: 'The method `centralManagerDidUpdateState` is quite different:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`centralManagerDidUpdateState`相当不同：
- en: '[PRE40]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As soon as the Bluetooth subsystem is ready (its state is `CBCentralManagerStatePoweredOn`)
    the app starts trying to connect to the nRF8001 board, calling `[self connect]`
    which is a method that we'll show you very soon.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦蓝牙子系统准备就绪（其状态为`CBCentralManagerStatePoweredOn`），应用程序开始尝试连接到nRF8001板，调用`[self
    connect]`，这是一个我们很快就会向您展示的方法。
- en: 'The connection is also started from `viewDidAppear` each time the view controller
    is shown on the screen:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 每次视图控制器在屏幕上显示时，连接都是从`viewDidAppear`开始的：
- en: '[PRE41]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The connection is closed as soon as the view disappears from the screen to
    reduce draining of the batteries:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦视图从屏幕消失，连接就会关闭，以减少电池的消耗：
- en: '[PRE42]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now let's take a closer look at the connection method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看连接方法。
- en: '[PRE43]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If `arduinoDevice` is not initialized, we retrieve it using the UUID that has
    been stored in the user preferences during the scanning phase. It''s important
    that the peripheral delegate is set, because we have to discover the peripheral''s
    characteristics and they are returned through delegate methods. The method `connectPeripheral`
    actually connects to the peripheral. If the connection is successful, the delegate
    method `didConnectPeripheral` is called, and we can start discovering the service
    that the device provides:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`arduinoDevice`未初始化，我们将使用在扫描阶段存储在用户偏好设置中的UUID检索它。外围代理委托的设置很重要，因为我们必须发现外围设备的特征，它们通过代理方法返回。`connectPeripheral`方法实际上连接到外围设备。如果连接成功，将调用代理方法`didConnectPeripheral`，然后我们可以开始发现设备提供的服务：
- en: '[PRE44]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Discovering all services**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**发现所有服务**'
- en: 'In certain cases you may need to discover all the services that a peripheral
    provides. To do that, you use: `[peripheral discoverServices:nil];`.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要发现外围设备提供的所有服务。为此，您使用：`[peripheral discoverServices:nil];`。
- en: 'Once iOS discovers the peripheral''s service, it calls the method `didDiscoverServices`
    and we can start discovering the characteristics of the service:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦iOS发现外围设备的服务，它将调用`didDiscoverServices`方法，然后我们可以开始发现服务的特征：
- en: '[PRE45]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For each service provided, the iOS calls the method `didDiscoverCharacteristicsForService`
    (please see downloaded code). In this method we store the characteristic for sending
    data to the nRF8001 device in the property `sendCharacteristic`, and we call this
    method:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个提供的服务，iOS会调用`didDiscoverCharacteristicsForService`方法（请参阅下载的代码）。在这个方法中，我们将发送数据到nRF8001设备的特征存储在属性`sendCharacteristic`中，并调用此方法：
- en: '[PRE46]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, we'll use the characteristic for receiving data as parameter. Now each
    time the characteristic changes (data are sent from the nRF80001 device), the
    method `didUpdateValueForCharacteristic` is called and the available data are
    received (please, see downloaded code).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用接收数据的特征作为参数。现在每次特征发生变化（从nRF80001设备发送数据）时，都会调用`didUpdateValueForCharacteristic`方法，并接收可用数据（请参阅下载的代码）。
- en: 'When incoming data are available, the `dataReceived` method is called and received
    data can be processed:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当有可用数据时，会调用`dataReceived`方法，并处理接收到的数据：
- en: '[PRE47]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can receive two kinds of messages:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接收两种类型的消息：
- en: m:0|1
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m:0|1
- en: s:0|1; t:temperature
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: s:0|1; t:temperature
- en: 'When the iOS device connects to Arduino, it receives the first message, which
    informs you if the door has been manually locked (m:1) or not (m:0). With this
    information we can set the position of the manual switch:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当iOS设备连接到Arduino时，它会接收到第一条消息，告知您门是否已被手动锁定（m:1）或未锁定（m:0）。有了这个信息，我们可以设置手动开关的位置：
- en: '[PRE48]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The second message contains two types of information: if the latch is open
    (s:1) or closed (s:0) and the external temperature. The first is used to change
    the background color of the `doorStatus` view:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条消息包含两种类型的信息：如果闩锁是打开的（s:1）或关闭的（s:0）以及外部温度。第一种用于更改`doorStatus`视图的背景颜色：
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The temperature information is used to set the value of the `temperature` label:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 温度信息用于设置`temperature`标签的值：
- en: '[PRE50]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When the switch `manualLockSwitch` is tapped, the method `switchChanged` is
    called and there we can transmit data to Arduino:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下`manualLockSwitch`开关时，会调用`switchChanged`方法，在那里我们可以向Arduino传输数据：
- en: '[PRE51]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To send data to a Bluetooth device, we write to the appropriate characteristic
    using the method `writeValue`. Since it accepts `NSData` values, we have to convert
    the string `"0"` or `"1"` to `NSData` using the method `dataUsingEncoding`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要向蓝牙设备发送数据，我们使用`writeValue`方法写入适当的特征。由于它接受`NSData`值，我们必须使用`dataUsingEncoding`方法将字符串`"0"`或`"1"`转换为`NSData`。
- en: We have almost completed the application. Once the iOS application is connected
    to Arduino, we need that it disconnects when it is sent to the background (for
    saving batteries). When it is brought to the foreground again, it automatically
    reconnects to Arduino.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了应用程序。一旦iOS应用程序连接到Arduino，我们需要它在发送到后台时断开连接（以节省电池）。当它再次被带到前台时，它会自动重新连接到Arduino。
- en: 'To do that we make the `connect` method public and we write a new `disconnect`
    public method. To make the methods public we add a couple of lines to `PetDoorLockerViewController.h`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们使`connect`方法公开，并编写一个新的公开`disconnect`方法。为了使方法公开，我们在`PetDoorLockerViewController.h`中添加了几行代码：
- en: '[PRE52]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `disconnect` method is very simple:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`disconnect`方法非常简单：'
- en: '[PRE53]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Setting the background color of the `doorStatus` view to light gray, we can
    visually know if the iOS is connected to Arduino or not.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 将`doorStatus`视图的背景颜色设置为浅灰色，我们可以直观地知道iOS是否已连接到Arduino。
- en: 'The very last method we have to write is `reconnect`, which doesn''t require
    any explanation:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写的最后一个方法是`reconnect`，它不需要任何解释：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the `AppDelegate.m` file there are two methods, which are respectively called
    when the app enters in the background or gets back to the foreground:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppDelegate.m`文件中，有两个方法，分别是在应用程序进入后台或返回前台时调用的：
- en: '`applicationDidEnterBackground`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicationDidEnterBackground`'
- en: '`applicationWillEnterForeground`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicationWillEnterForeground`'
- en: In these methods we need a reference to the `PetDoorLockerViewController`. We
    can get it through the main application window.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，我们需要一个对`PetDoorLockerViewController`的引用。我们可以通过主应用程序窗口来获取它。
- en: '[PRE55]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Testing the iOS app
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试iOS应用程序
- en: Now the application is completed and we can run it again on our iOS device.
    As soon as it starts, it should connect to Arduino and the door status indicator
    should turn to red if the door is locked, or to green if it is unlocked and you
    should see the temperature measured from the Arduino sensor.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经完成，我们可以在iOS设备上再次运行它。一旦启动，它应该连接到Arduino，如果门是锁着的，门状态指示器应该变成红色，如果门是开着的，应该变成绿色，你应该看到从Arduino传感器测量的温度。
- en: When you tap on the lock switch, the door should immediately close and ignore
    light and temperature.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击锁开关时，门应该立即关闭并忽略光和温度。
- en: How to go further
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何更进一步
- en: 'The application we have developed can be improved in many ways; these are some
    suggested improvements that you can try yourself:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的应用程序可以通过许多方式改进；以下是一些你可以尝试的建议改进：
- en: Checking the presence of your pet in the house by counting door openings and
    their directions. A couple of magnetic switches should do the job of detecting
    the opening direction of the pet door.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算门的开闭次数和方向来检查你的宠物是否在家。一对磁开关应该能够检测宠物门的开启方向。
- en: Detect your own pet using an RFID tag attached to their collar to avoid other
    pets being able to get into your house.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在宠物的项圈上附加RFID标签来检测你的宠物，以避免其他宠物进入你的房子。
- en: Setting light threshold and temperature thresholds directly from the iOS device
    using a slider (UISliderView).
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滑块（UISliderView）直接从iOS设备设置光阈值和温度阈值。
- en: Replace the temperature numeric indication with a more appealing graphical indicator
    like a gauge or a thermometer.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将温度的数字指示替换为更吸引人的图形指示器，如仪表或温度计。
- en: Notify you when your pet goes through the pet door.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的宠物通过宠物门时通知你。
- en: Show temperature in Celsius and Fahrenheit.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示摄氏度和华氏度温度。
- en: Different types of sensors
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的传感器类型
- en: Before ending this chapter we would like to give an overview of the existing
    type of sensors, their communication protocols with Arduino, and the pros and
    cons of using them.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我们想概述一下现有的传感器类型，它们与Arduino的通信协议，以及使用它们的优缺点。
- en: Sensors can be categorized into two major families (analog and digital) based
    on the kind of signal they provide. An analog sensor usually provides a voltage,
    which is proportional to the quantity it is measuring. This voltage has to be
    converted in a number using an ADC. Arduino provides six analog pins and each
    of them has its own ADC. The photoresistor that we are using in our project is
    a typical analog sensor. Conversely, a digital sensor directly provides a numeric
    representation of the measured quantity, which can be directly used. The temperature
    sensor, which we are using in this project, is an example of a digital sensor.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器可以根据它们提供的信号类型分为两大类（模拟和数字）。模拟传感器通常提供电压，该电压与其测量的量成正比。这个电压必须通过ADC转换成数字。Arduino提供了六个模拟引脚，每个引脚都有自己的ADC。我们在项目中使用的光敏电阻是一个典型的模拟传感器。相反，数字传感器直接提供测量量的数值表示，可以直接使用。我们在本项目中使用的温度传感器就是一个数字传感器的例子。
- en: Analog sensors are easier to use and cheaper, but they are very sensitive to
    power voltage fluctuations and electrical noise in the circuit. For these reasons
    the readings change a lot and it is usually needed to implement digital filters
    in code to smooth out the readings.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟传感器更容易使用且更便宜，但它们对电源电压波动和电路中的电气噪声非常敏感。因此，读数会有很大变化，通常需要在代码中实现数字滤波器来平滑读数。
- en: Digital sensors instead provide very stable readings and they are usually more
    precise. Unfortunately, they communicate with the microprocessor using different
    low-level protocols, which are more complex to handle. In the majority of the
    cases, protocol complexities are hidden by software libraries specialized for
    each type of sensor, but this makes coding more complex and libraries usually
    lead to a greater memory consumption which is a very precious resource on a microprocessor.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 数字传感器提供非常稳定的读数，并且通常更精确。不幸的是，它们使用不同的低级协议与微处理器通信，这些协议更复杂。在大多数情况下，协议的复杂性被针对每种类型传感器的专用软件库所隐藏，但这使得编码更加复杂，库通常会导致更大的内存消耗，这在微处理器上是一个非常宝贵的资源。
- en: The most used low-level protocols are **Serial Peripheral Interface** (**SPI**)
    and **Inter-integrated Circuit** (**I2C**). Another low-level protocol largely
    used for temperature sensors is the 1-Wire, which has been adopted for this project.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的低级协议是**串行外设接口**（**SPI**）和**集成电路间接口**（**I2C**）。另一个广泛用于温度传感器的低级协议是 1-Wire，该项目已经采用了这种协议。
- en: A complete comparison between these protocols is out of the scope of this project,
    but you can get an idea of them by referring to the following table.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议的完整比较超出了本项目的范围，但你可以通过参考以下表格来了解它们。
- en: '| Protocol | Architecture | Signals needed | Multi- master | Data rate | Full
    duplex |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 架构 | 所需信号 | 多主 | 数据速率 | 全双工 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| SPI | Two shared uni-directional data signals and a shared clock | SCK, MISO,
    MOSI, and one CS for each device on the board | Possible, but not standard | 1
    Mbps | Yes |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| SPI | 两个共享的单向数据信号和共享时钟 | SCK、MISO、MOSI 和板上每个设备的 CS | 可能，但不是标准 | 1 Mbps |
    是 |'
- en: '| I2C | Shared data signal and a shared clock signal | SDA and SCL | Yes |
    100 kbps, 400 kbps, and 3.2 Mbps | No |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| I2C | 共享数据信号和共享时钟信号 | SDA 和 SCL | 是 | 100 kbps、400 kbps 和 3.2 Mbps | 否 |'
- en: '| 1-Wire | One data signal | Data | No | 15 kbps | No |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 1-Wire | 一个数据信号 | 数据 | 否 | 15 kbps | 否 |'
- en: Summary
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well done! You made it to the end of the chapter and you have built a project
    from scratch!
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经到达了本章的结尾，并且从头开始构建了一个项目！
- en: You have built the hardware, along with the electronic circuit, and written
    the software for both Arduino and iOS.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了硬件，包括电子电路，并为 Arduino 和 iOS 编写了软件。
- en: On Arduino, you have learned how to use analog and digital sensors (1-Wire),
    how to write the code for reading them, how to control a servo motor, and how
    to handle the communication with the iOS devices.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arduino 上，你学习了如何使用模拟和数字传感器（1-Wire），如何编写读取它们的代码，如何控制伺服电机，以及如何处理与 iOS 设备的通信。
- en: On iOS, you have learned how to write an application with a simple user interface
    and that the application's communication with Arduino via Bluetooth 4.0.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，你学习了如何编写一个具有简单用户界面的应用程序，以及该应用程序通过蓝牙 4.0 与 Arduino 进行通信。
- en: We eventually discussed analog and digital sensors and some of the most used
    low-level communication protocols for exchanging data with Arduino.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终讨论了模拟和数字传感器以及与 Arduino 交换数据时最常用的低级通信协议。
- en: In the next chapter, we will build another project, which uses Wi-Fi instead
    of Bluetooth to transfer data. In that project, Arduino will accept different
    commands and react to it. The iOS application will have a table view, which is
    one of the most useful components provided by the UIKit.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建另一个项目，该项目使用 Wi-Fi 而不是蓝牙来传输数据。在那个项目中，Arduino 将接受不同的命令并对之做出反应。iOS 应用将有一个表格视图，这是
    UIKit 提供的最有用的组件之一。
