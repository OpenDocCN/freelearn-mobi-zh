- en: Chapter 7. Writing Safer Code with Availability and Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：使用可用性和错误处理编写更安全的代码
- en: When I first started writing iOS and OS X applications with Objective-C, one
    of the most noticeable *deficiencies* was the lack of exception handling when
    working with the Cocoa and Cocoa Touch frameworks. Most modern programming languages
    such as Java and C# use `try-catch` blocks or something similar to handle exceptions.
    While Objective-C did have the `try-catch` block, it wasn't used within the Cocoa
    frameworks themselves and it never felt like a true part of the language. I do
    have significant experience with C, so I was able to understand how the Cocoa
    and Cocoa Touch frameworks received and responded to errors, and to be honest,
    I actually preferred this method, even though I had grown accustom to exception
    handling with Java and C#. When Swift was first introduced, I was hoping that
    Apple would put true error handling into the language, so we would have the option
    of using it; however, it was not in the initial release of Swift. Now with Swift
    2, Apple has added error handling to Swift. While this error handling may look
    similar to exception handling in Java and C#, there are some very significant
    differences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开始用 Objective-C 编写 iOS 和 OS X 应用程序时，最明显的 *缺陷* 是在处理 Cocoa 和 Cocoa Touch 框架时缺乏异常处理。大多数现代编程语言，如
    Java 和 C#，都使用 `try-catch` 块或类似机制来处理异常。虽然 Objective-C 确实有 `try-catch` 块，但它并没有在
    Cocoa 框架内部使用，并且它从未感觉像是语言的一部分。我确实有丰富的 C 语言经验，所以我能够理解 Cocoa 和 Cocoa Touch 框架如何接收和响应错误，并且坦白说，我实际上更喜欢这种方法，尽管我已经习惯了使用
    Java 和 C# 进行异常处理。当 Swift 首次推出时，我希望能看到 Apple 将真正的错误处理集成到语言中，这样我们就有选择使用它的选项；然而，它并没有包含在
    Swift 的初始版本中。现在随着 Swift 2 的推出，Apple 已经将错误处理添加到了 Swift 中。虽然这种错误处理看起来可能类似于 Java
    和 C# 中的异常处理，但有一些非常显著的不同之处。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: How to use the `do-catch` block in Swift
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Swift 中使用 `do-catch` 块
- en: How to represent errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示错误
- en: How to use the availability attribute
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用可用性属性
- en: Error handling prior to Swift 2.0
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2.0 之前的错误处理
- en: Error handling is the process of responding to and recovering from error conditions
    within our applications. Prior to Swift 2.0, error reporting followed the same
    pattern as Objective-C; however, with Swift, we did have the added benefit of
    using optional return values, where returning a nil would indicate an error within
    the function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是我们应用程序中响应和恢复错误条件的过程。在 Swift 2.0 之前，错误报告遵循与 Objective-C 相同的模式；然而，随着 Swift
    的推出，我们确实有使用可选返回值的额外好处，其中返回 nil 会指示函数中存在错误。
- en: 'In the simplest form of error handling, the return value from the function
    would indicate whether it was successful or not. This return value could be something
    as simple as a Boolean true/false value or something more complex such as an enum,
    whose values indicated what actually went wrong if the function was unsuccessful.
    If we needed to report additional information about the error that occurred, we
    could add an `NSError` out parameter of the `NSErrorPointer` type, but this wasn''t
    the easiest of approaches and these errors tended to be ignored by developers.
    The following example illustrates how errors were generally handled prior to Swift
    2.0:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的错误处理形式中，函数的返回值将指示其是否成功。这个返回值可以是简单的布尔值 true/false，也可以是更复杂的枚举，其值表示如果函数失败，实际上发生了什么。如果我们需要报告关于发生的错误的附加信息，我们可以添加一个
    `NSError` 输出参数，其类型为 `NSErrorPointer`，但这并不是最容易的方法，并且这些错误往往被开发者忽略。以下示例说明了在 Swift
    2.0 之前通常是如何处理错误的：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While handling errors in this manner works well and can be modified to suit
    most needs, it definitely is not the perfect solution. There are a couple of issues
    with this solution, with the biggest being that it is easy for developers to ignore
    both the value that is returned and the error itself. While most experienced developers
    will be very careful to check all the errors, sometimes, it is hard for novice
    developers to understand what and when to check, especially if the function does
    not contain an `NSError` parameter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以这种方式处理错误效果良好，并且可以根据大多数需求进行修改，但它绝对不是完美的解决方案。这个解决方案有几个问题，其中最大的问题是开发者很容易忽略返回的值以及错误本身。虽然大多数经验丰富的开发者都会非常小心地检查所有错误，但有时，对于新手开发者来说，很难理解应该检查什么以及何时检查，尤其是如果函数不包含
    `NSError` 参数的话。
- en: In addition to using `NSError`, we could also raise and catch exceptions using
    the `NSException` class; however, very few developers actually use this method.
    Even within the Cocoa and Cocoa Touch frameworks, this method of exception handling
    was rarely ever used.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `NSError`，我们还可以使用 `NSException` 类来抛出和捕获异常；然而，实际上很少开发者使用这种方法。即使在 Cocoa 和
    Cocoa Touch 框架中，这种异常处理方法也很少被使用。
- en: While using the `NSError` class and return values to handle errors does work
    well, there were many people, including me, who were disappointed that Apple did
    not include additional error handling when Swift was originally released. Well,
    now with Swift 2.0, we do have native error handling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `NSError` 类和返回值来处理错误是可行的，但包括我在内很多人对 Apple 在 Swift 最初发布时没有包含额外的错误处理功能感到失望。然而，现在随着
    Swift 2.0 的发布，我们确实有了本地的错误处理功能。
- en: Error handling in Swift 2
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2 中的错误处理
- en: Languages such as Java and C# generally refer to the error handling process
    as *exception handling*; within the Swift documentation, Apple refers to this
    process as *error handling*. While on the outside, the Java and C# exception handling
    may look very similar to Swift's error handling, there are some significant differences
    that those familiar with exception handling in the other language will notice
    throughout this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Java 和 C# 这样的语言通常将错误处理过程称为 *异常处理*；在 Swift 文档中，Apple 将这个过程称为 *错误处理*。虽然从外观上看，Java
    和 C# 的异常处理可能与 Swift 的错误处理非常相似，但熟悉其他语言异常处理的开发者会在本章中注意到一些显著的不同之处。
- en: Representing errors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示错误
- en: Before we can really understand how error handling works in Swift, we must first
    see how we would represent an error. In Swift, errors are represented by values
    of types that conform to the `ErrorType` protocol. Swift's enums are very well-suited
    to modeling the error conditions because generally, we have a finite number of
    error conditions to represent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正理解 Swift 中的错误处理机制之前，我们首先需要了解我们如何表示一个错误。在 Swift 中，错误是通过符合 `ErrorType` 协议的类型值来表示的。Swift
    的枚举非常适合于建模错误条件，因为通常我们只需要表示有限数量的错误条件。
- en: 'Let''s look at how we would use an enum to represent an error. For this, we
    will define a fictitious error named `MyError` with three error conditions: `Minor`,
    `Bad`, and `Terrible`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用枚举来表示一个错误。为此，我们将定义一个虚构的错误名为 `MyError`，包含三个错误条件：`Minor`、`Bad` 和 `Terrible`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we define that the `MyError` enum conforms to the `ErrorType`
    protocol. We then define the three error conditions: `Minor`, `Bad`, and `Terrible`.
    We can also use the associated values with our error conditions. Let''s say that
    we wanted to add a description to one of the error conditions; we would do it
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义 `MyError` 枚举符合 `ErrorType` 协议。然后我们定义三个错误条件：`Minor`、`Bad` 和 `Terrible`。我们还可以使用关联值来表示错误条件。假设我们想要给其中一个错误条件添加一个描述；我们可以这样做：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Those who are familiar with exception handling in Java and C# can see that representing
    errors in Swift is a lot cleaner and easier. Another advantage that we have is
    it is very easy to define multiple error conditions and group them together, so
    all the related error conditions are of one type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Java 和 C# 中的异常处理的开发者来说，他们可能会发现 Swift 中的错误表示要干净得多，也更容易。我们拥有的另一个优点是定义多个错误条件并将它们分组在一起非常容易，因此所有相关的错误条件都属于同一类型。
- en: 'Now let''s see how we would model errors in Swift. For this example, let''s
    look at how we would assign numbers to players in a baseball team. In a baseball
    team, every new player who is called up is assigned a unique number for that team.
    This number also must be within a certain range of numbers. In this case, we would
    have three error conditions: number is too large, number is too small, or number
    is not unique. The following example shows how we might represent these error
    conditions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在 Swift 中建模错误。为了这个例子，让我们看看我们如何为一个棒球队分配球员号码。在棒球队中，每个被召回的新球员都会被分配一个唯一的号码，这个号码也必须在一定的号码范围内。在这种情况下，我们会遇到三个错误条件：号码太大、号码太小或号码不唯一。以下示例展示了我们如何表示这些错误条件：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the `PlayerNumberError` type, we define three very specific error conditions
    that tell us exactly what was wrong. These error conditions are also grouped together
    in one type since they are all related to assigning player's numbers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PlayerNumberError` 类型，我们定义了三个非常具体的错误条件，这些条件可以确切地告诉我们出了什么问题。这些错误条件也分组在同一个类型中，因为它们都与分配玩家号码相关。
- en: This method of defining errors allows us to define very specific errors that
    let our code know exactly what went wrong if an error condition occurs and, as
    we see in our example, it also lets us group our errors, so all of the related
    errors can be defined in the same type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义错误的方法允许我们定义非常具体的错误，让我们的代码在发生错误条件时确切地知道出了什么问题，正如我们在示例中看到的那样，它还允许我们将错误分组，因此所有相关的错误都可以在同一个类型中定义。
- en: Now that we know how to represent errors, let's look at how we would throw errors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何表示错误，让我们看看我们如何抛出错误。
- en: Throwing errors
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出错误
- en: When an error occurs in a function, the code that called the function must be
    made aware of it; this is called **throwing the error**. When a function throws
    an error, it assumes that the code that called the function, or some code further
    up the chain, will catch and recover appropriately from the error.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数中发生错误时，调用函数的代码必须知道这一点；这被称为**抛出错误**。当函数抛出错误时，它假设调用函数的代码，或者链中的某些代码，将捕获并适当地从错误中恢复。
- en: To throw an error from a function we use the `throws` keyword. This keyword
    lets the code that called it know that an error may be thrown from the function.
    Unlike exception handling in other languages, we do not list the specific errors
    types that may be thrown.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要从函数中抛出错误，我们使用`throws`关键字。这个关键字让调用它的代码知道函数可能会抛出错误。与其它语言的异常处理不同，我们不需要列出可能抛出的具体错误类型。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we do not list the specific error types that may be thrown from a function
    within the function's definition, it would be good practice to list them in the
    documentation and comment for the function so that other developers who use our
    function know what error types to catch.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不在函数定义中列出可能抛出的具体错误类型，因此在文档和注释中列出这些错误类型是一种良好的实践，这样其他使用我们函数的开发者就会知道应该捕获哪些错误类型。
- en: 'Let''s look at how we would throw errors, but first, let''s add a fourth error
    to our `PlayerNumberError` type that we defined earlier. This error condition
    is thrown if we are trying to retrieve a player by his or her number but no player
    is assigned that number. The new `PlayerNumberError` type will now look similar
    to this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何抛出错误，但首先，让我们向之前定义的`PlayerNumberError`类型中添加一个第四个错误。如果尝试通过球员的号码检索球员但未分配该号码，则抛出此错误条件。新的`PlayerNumberError`类型现在看起来类似于以下内容：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To demonstrate how to throw errors, we will begin by creating a `BaseballTeam`
    struct that will contain a list of player for a given team. These players will
    be stored in a dictionary object named `players` and will use the player''s number
    as the key. The `BaseballPlayer` type, which will be used to represent a single
    player, will be a `typealias` for a tuple type and is defined like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何抛出错误，我们将首先创建一个`BaseballTeam`结构体，它将包含一个给定队伍的球员列表。这些球员将存储在一个名为`players`的字典对象中，并使用球员的号码作为键。用于表示单个球员的`BaseballPlayer`类型，将是一个元组类型的`typealias`，其定义如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this `BaseballTeam` struct, we will have two methods. The first one will
    be named `addPlayer()`. This will have one parameter of the `BaseballPlayer` type
    and will attempt to add the player to the team. This method could throw one of
    the three error conditions: `NumberTooHigh`, `NumberTooLow`, or `NumberAlreadyExists`.
    Here is how we would write this method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`BaseballTeam`结构体中，我们将有两个方法。第一个方法将被命名为`addPlayer()`。这个方法将有一个`BaseballPlayer`类型的参数，并尝试将球员添加到队伍中。这个方法可能会抛出三种错误条件之一：`NumberTooHigh`、`NumberTooLow`或`NumberAlreadyExists`。以下是这个方法的实现方式：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the method's definition, we see that the `throws` keyword is added. The `throws`
    keyword lets any code that calls this method know that it may throw an error and
    the errors must be handled. We then use the three `guard` statements. These `guard`
    statements are used to verify that the number is not too large, not too small,
    and is unique in the `players` dictionary. If any of the conditions are not met,
    we throw the appropriate error using the `throw` keyword.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法定义中，我们看到添加了`throws`关键字。`throws`关键字让调用此方法的任何代码都知道它可能会抛出错误，并且必须处理这些错误。然后我们使用了三个`guard`语句。这些`guard`语句用于验证数字不是太大、不是太小，并且在`players`字典中是唯一的。如果任何条件不满足，我们将使用`throw`关键字抛出适当的错误。
- en: If we make it through all the three checks, the player is added to the `players`
    dictionary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了所有三个检查，球员将被添加到`players`字典中。
- en: 'The second method that we will be adding to the `BaseballTeam` struct is the
    `getPlayerByNumber()` method. This method will attempt to retrieve the baseball
    player that is assigned a given number. If no player is assigned that number,
    this method will throw a `PlayerNumberError.NumberDoesNotExist` error. The `getPlayerByNumber()`
    method will look similar to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到 `BaseballTeam` 结构体的第二个方法是 `getPlayerByNumber()` 方法。这个方法将尝试检索被分配了给定编号的棒球运动员。如果没有球员被分配了这个编号，这个方法将抛出
    `PlayerNumberError.NumberDoesNotExist` 错误。`getPlayerByNumber()` 方法将看起来像这样：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this method definition, we see that it can throw an error because we use
    the `throws` keyword within the definition. The `throws` keyword must be placed
    before the `return` type in the method definition.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法定义中，我们看到它可以抛出错误，因为我们使用了定义中的 `throws` 关键字。`throws` 关键字必须放在方法定义中的 `return`
    类型之前。
- en: Within the method, we attempt to retrieve the baseball player with the number
    that is passed into the method. If we are able to retrieve the player, we return
    it; otherwise, we throw the `PlayerNumberError.NumberDoesNotExist` error. Notice
    that if we throw an error from a method that has a `return` type, we do not need
    to return a value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中，我们尝试检索传递给方法编号的棒球运动员。如果我们能够检索到球员，我们就返回它；否则，我们抛出 `PlayerNumberError.NumberDoesNotExist`
    错误。注意，如果我们从一个具有 `return` 类型的方法中抛出错误，我们不需要返回一个值。
- en: Now let's see how we would catch an error with Swift.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何用 Swift 捕获一个错误。
- en: Catching errors
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获错误
- en: 'When an error is thrown from a function, we need to catch it in the code that
    called the function; this is done using the `do-catch` block. The `do-catch` block
    takes the following syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数中抛出错误时，我们需要在调用函数的代码中捕获它；这是通过使用 `do-catch` 块来完成的。`do-catch` 块采用以下语法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If an error is thrown, it is propagated out until it is handled by a `catch`
    clause. The `catch` clause consists of the `catch` keyword, followed by a pattern
    to match the error against. If the error matches the pattern, the code within
    the `catch` block is executed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出错误，它将传播出去，直到被 `catch` 子句处理。`catch` 子句由 `catch` 关键字组成，后跟一个用于匹配错误的模式。如果错误与模式匹配，则执行
    `catch` 块内的代码。
- en: 'Let''s look at how we would use the `do-catch` block by calling both the `getPlayerByNumber()`
    and `addPlayer()` methods of the `BaseballTeam` struct. Let''s look at the `getPlayerByNumber()`
    method first since it only throws one error condition:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们如何通过调用 `BaseballTeam` 结构体的 `getPlayerByNumber()` 和 `addPlayer()` 方法来使用
    `do-catch` 块。首先让我们看看 `getPlayerByNumber()` 方法，因为它只抛出一个错误条件：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Within this example, the `do-catch` block calls the `getPlayerByNumber()` method
    of the `BaseballTeam` struct. This method will throw the `PlayerNumberError.NumberDoesNotExist`
    error condition if no player on the team has been assigned this number; therefore,
    we attempt to match that error in our `catch` statement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`do-catch` 块调用了 `BaseballTeam` 结构体的 `getPlayerByNumber()` 方法。如果队中没有球员被分配了这个号码，该方法将抛出
    `PlayerNumberError.NumberDoesNotExist` 错误条件；因此，我们在 `catch` 语句中尝试匹配这个错误。
- en: Anytime an error is thrown within a `do-catch` block, the remainder of the code
    within the block is skipped and the code within the `catch` block, which matches
    the error, is executed. Therefore, in our example, if the `PlayerNumberError.NumberDoesNotExist`
    error is thrown by the `getPlayerByNumber()` method, then the `print()` function
    is never reached.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候在 `do-catch` 块中抛出错误，块内的其余代码将被跳过，并且执行与错误匹配的 `catch` 块内的代码。因此，在我们的例子中，如果 `getPlayerByNumber()`
    方法抛出 `PlayerNumberError.NumberDoesNotExist` 错误，那么 `print()` 函数永远不会被执行。
- en: 'We do not have to include a pattern after the `catch` statement. If a pattern
    is not included after the `catch` statement or we put an underscore, the `catch`
    statement will match all error conditions. For example, either one of the following
    two `catch` statements will catch all errors:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在 `catch` 语句后包含一个模式。如果 `catch` 语句后没有包含模式或者我们放置一个下划线，`catch` 语句将匹配所有错误条件。例如，以下两个
    `catch` 语句中的任何一个都将捕获所有错误：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to capture the error, we can use the `let` keyword, as shown in
    the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要捕获错误，我们可以使用 `let` 关键字，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s look at how we could use the `catch` statement, similar to a `switch`
    statement, to catch different error conditions. For this, we will call the `addPlayer()`
    method of our `BaseballTeam` struct:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何使用 `catch` 语句，类似于 `switch` 语句，来捕获不同的错误条件。为此，我们将调用我们的 `BaseballTeam`
    结构体的 `addPlayer()` 方法：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we have three `catch` statements. Each `catch` statement has
    a different pattern to match; therefore, they will each match a different error
    condition. If we recall, the `PlayerNumberError.NumberToHigh` and `PlayerNumberError.NumberToLow`
    error conditions have associated values. To retrieve the associated value, we
    use the `let` statement within the parentheses, as shown in the example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有三个`catch`语句。每个`catch`语句都有一个不同的模式来匹配；因此，它们将分别匹配不同的错误条件。如果我们回想一下，`PlayerNumberError.NumberToHigh`和`PlayerNumberError.NumberToLow`错误条件都有关联的值。要检索关联的值，我们可以在括号内使用`let`语句，就像示例中那样。
- en: 'It is always good practice to make your last `catch` statement an empty `catch`
    so that it will `catch` any error that did not match any of the patterns in the
    previous `catch` statements. Therefore, the previous example should be rewritten
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总是好的做法是将你的最后一个`catch`语句留空，这样它就能捕获之前`catch`语句中未匹配到的任何错误。因此，之前的例子应该这样重写：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also let the errors propagate out rather than immediately catch them.
    To do this, we just need to add the `throws` keyword to the function definition.
    For instance, in the following example, rather than catching the error, we let
    it propagate out to the code that calls the function rather than handling the
    error within the function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让错误传播出去而不是立即捕获它们。要做到这一点，我们只需要在函数定义中添加`throws`关键字。例如，在以下示例中，我们不是捕获错误，而是让它传播到调用函数的代码中，而不是在函数内部处理错误：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we are certain that an error will not be thrown, we can call the function
    using a forced-try expression, which is written as `try`!. The forced-try expression
    disables error propagation and wraps the function call in a runtime assertion
    that no error will be thrown from this call. If an error is thrown, we will get
    a runtime error, so be very careful when using this expression.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定不会抛出错误，我们可以使用强制-尝试表达式来调用函数，该表达式写作`try`!。强制-尝试表达式禁用了错误传播，并将函数调用包裹在一个运行时断言中，断言该调用不会抛出错误。如果抛出错误，我们将得到运行时错误，所以使用这个表达式时要非常小心。
- en: 'When I am working with exceptions in languages such as Java and C#, I see a
    lot of empty `catch` blocks. This is where we need to catch the exception because
    one might be thrown; however, we do not want to do anything with it. In Swift,
    the code would look something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在使用Java和C#等语言处理异常时，我看到很多空的`catch`块。这就是我们需要捕获异常的地方，因为可能会抛出异常；然而，我们并不想对它做任何事情。在Swift中，代码看起来可能像这样：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Seeing code like this is one of the things that I dislike about exception handling.
    Well, the Swift developers have an answer for this: the `try?` keyword. The `try?`
    keyword attempts to perform an operation that may throw an error. If the operation
    succeeds, the results are returned in the form of an optional; however, if the
    operation fails with an error being thrown, the operation returns a nil and the
    error is discarded.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这样的代码是我对异常处理不喜欢的事情之一。嗯，Swift开发者对此有一个答案：`try?`关键字。`try?`关键字尝试执行可能会抛出错误的操作。如果操作成功，结果以可选的形式返回；然而，如果操作失败并抛出错误，操作返回nil，并且错误被丢弃。
- en: 'Since the results of the `try?` keyword are returned in the form of an optional,
    we would normally want to use this keyword with optional binding. We could rewrite
    the previous example like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`try?`关键字的结果以可选的形式返回，我们通常希望使用可选绑定来使用这个关键字。我们可以将之前的例子重写如下：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the `try?` keyword makes our code much cleaner and easier to
    read.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`try?`关键字使我们的代码更加简洁和易于阅读。
- en: 'If we need to perform some clean up action, regardless of if we had any errors
    or not, we can use the `defer` statement. We use the `defer` statement to execute
    a block of code just before code execution leaves the current scope. The following
    example shows how we would use the `defer` statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行一些清理操作，无论是否有错误，我们都可以使用`defer`语句。我们使用`defer`语句在代码执行离开当前作用域之前执行一段代码。以下示例显示了如何使用`defer`语句：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we called this function, the first line that is printed to the console is—`Function
    started`. The execution of the code would skip over the `defer` block and `Function
    finished` would be printed to the console next. Finally, the `defer` block of
    code would be executed just before we leave the function''s scope, and we would
    see the message, `In defer block`. The following is the output from this function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用此函数，控制台打印的第一行是—`函数开始`。代码的执行将跳过 `defer` 块，接下来控制台会打印 `Function finished`。最后，在离开函数的作用域之前，会执行
    `defer` 块中的代码，我们会看到消息，`在 defer 块中`。以下是从该函数输出的内容：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `defer` block will always be called before execution leaves the current
    scope, even if an error is thrown. The `defer` block is very useful when we need
    to perform some clean up functions prior to leaving a function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 块将在执行离开当前作用域之前始终被调用，即使抛出错误。当我们需要在离开函数之前执行一些清理函数时，`defer` 块非常有用。'
- en: The `defer` statement is very useful when we want to make sure we perform all
    the necessary clean up, even if an error is thrown. For example, if we successfully
    open up a file to write to, we will always want to make sure we close that file,
    even if we have an error during the write operation. We could then put the file
    closed functionality in a `defer` block to make sure that the file is always closed
    prior to leaving the current scope.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要确保执行所有必要的清理操作，即使抛出错误时，`defer` 语句非常有用。例如，如果我们成功打开一个文件进行写入，我们总是想确保关闭该文件，即使写入操作期间出现错误。然后我们可以将文件关闭功能放在
    `defer` 块中，以确保文件在离开当前作用域之前始终关闭。
- en: Now let's look at how we would use the new availability attribute with Swift.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 Swift 中的新可用性属性。
- en: The availability attribute
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性属性
- en: Using the latest SDK gives us access to all of the latest features for the platform
    that we are developing for; however, there are times when we want to also target
    older platforms. Swift allows us to use the availability attribute to safely wrap
    code to run only when the correct version of the operating system is available.
    The availability was first introduced in Swift 2.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新的 SDK 可以让我们访问为我们正在开发的平台提供的所有最新功能；然而，有时我们还想针对旧平台。Swift 允许我们使用可用性属性来安全地包装代码，以确保只有在正确的操作系统版本可用时才运行。可用性属性首次在
    Swift 2 中引入。
- en: The availability blocks essentially lets us say, "If we are running the specified
    version of the operating system or higher, run this code. Otherwise, run some
    other code." There are two ways in which we can use the `availability` attribute.
    The first way allows us to execute a specific block of code and can be used with
    an `if` or `guard` statement. The second way allows us to mark a method or type
    as available only on certain platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性块基本上允许我们说，“如果我们正在运行指定的操作系统版本或更高版本，则运行此代码。否则，运行其他代码。”我们可以使用 `availability`
    属性的两种方式。第一种方式允许我们执行特定的代码块，并且可以与 `if` 或 `guard` 语句一起使用。第二种方式允许我们将方法或类型标记为仅在特定平台上可用。
- en: 'The `availability` attribute accepts up to five comma-separated arguments that
    allow us to define the minimum version of the operating system or application
    extension needed to execute our code. These arguments are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`availability` 属性接受最多五个以逗号分隔的参数，允许我们定义执行我们的代码所需的操作系统或应用程序扩展的最小版本。这些参数是：'
- en: '`iOS`: This is the minimum iOS version that is compatible with our code'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iOS`: 这是与我们的代码兼容的最小 iOS 版本'
- en: '`OSX`: This is the minimum OS X version that is compatible with our code'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSX`: 这是与我们的代码兼容的最小 OS X 版本'
- en: '`watchOS`: This is the minimum watchOS version that is compatible with our
    code'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchOS`: 这是与我们的代码兼容的最小 watchOS 版本'
- en: '`iOSApplicationExtension`: This is the minimum iOS application extension that
    is compatible with our code'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iOSApplicationExtension`: 这是与我们的代码兼容的最小 iOS 应用程序扩展'
- en: '`OSXApplicationExtension`: This is the minimum OS X application extension that
    is compatible with our code'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSXApplicationExtension`: 这是与我们的代码兼容的最小 OS X 应用程序扩展'
- en: 'After the argument, we specify the minimum version that is required. We only
    need to include the arguments that are compatible with our code. As an example,
    if we are writing an iOS application, we only need to include the `iOS` argument
    in the `available` attribute. We end the argument list with an `*` (asterisk).
    Let''s look at how we would execute a specific block of code only if we meet the
    minimum requirements:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数之后，我们指定所需的最低版本。我们只需要包含与我们的代码兼容的参数。例如，如果我们正在编写iOS应用程序，我们只需要在`available`属性中包含`iOS`参数。我们用`*`（星号）结束参数列表。让我们看看我们如何仅在我们满足最低要求时执行特定的代码块：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, the `if #available(iOS 9.0, OSX 10.10, watchOS 2, *)` line
    of code prevents the block of code form executing when the application is run
    on a system that does not meet the specified minimum operating system version.
    In this example, we also use the `else` statement to execute a separate block
    of code if the operating system did not meet the minimum requirements.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，`if #available(iOS 9.0, OSX 10.10, watchOS 2, *)`这一行代码阻止了当应用程序在不符合指定最低操作系统版本的系统上运行时执行代码块。在这个示例中，我们还使用了`else`语句，如果操作系统未满足最低要求，将执行一个单独的代码块。'
- en: 'We can also restrict access to a function or a type. In the previous code,
    the `available` attribute was prefixed with the `#` (pound) character. To restrict
    access to a function or type, we prefix the available attribute with an `@` (at)
    character. The following example shows how we would restrict access to a type
    and function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以限制对函数或类型的访问。在前面的代码中，`available`属性以`#`（井号）字符为前缀。要限制对函数或类型的访问，我们用`@`（在号）字符作为`available`属性的前缀。以下示例展示了我们如何限制对类型和函数的访问：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the previous example, we specify that the `testAvailability()` function
    and the `testStruct()` type can only be accessed if the code is run on a device
    that has iOS version 9 or above. In order to use the `@available` attribute to
    block access to a function or type, we must wrap the code that calls that function
    or type with the `#available` attribute. The following example shows how we would
    call the `testAvailability()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们指定了只有在代码在具有iOS 9或更高版本的设备上运行时，才能访问`testAvailability()`函数和`testStruct()`类型。为了使用`@available`属性来阻止对函数或类型的访问，我们必须使用`#available`属性将调用该函数或类型的代码包裹起来。以下示例展示了我们如何调用`testAvailability()`函数：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, the `testAvailability()` function is only called if the application
    is running on a device that has iOS version 9 or above.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，只有当应用程序在具有iOS 9或更高版本的设备上运行时，才会调用`testAvailability()`函数。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the new error-handling features and `availability`
    attribute that were added in Swift 2\. These two features can help us write safer
    code and make our applications more stable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Swift 2中添加的新错误处理功能和`availability`属性。这两个功能可以帮助我们编写更安全的代码，并使我们的应用程序更加稳定。
- en: The error-handling feature of Swift 2 significantly changes the way Swift programmers
    handle errors. While we are not required to use this new feature in our custom
    types, it does give us a uniform manner to handle and respond to error. Apple
    has also started to use this error handling in the Cocoa and Cocoa Touch frameworks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2的错误处理功能显著改变了Swift程序员处理错误的方式。虽然我们不需要在我们的自定义类型中使用这个新功能，但它确实为我们提供了一种统一的方式来处理和响应错误。苹果公司也开始在Cocoa和Cocoa
    Touch框架中使用这种错误处理。
- en: The new `availability` attribute allows us to develop applications that take
    advantage of the latest features of our target operating systems while still allowing
    our applications to run on older versions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`availability`属性允许我们开发能够利用目标操作系统的最新功能的应用程序，同时仍然允许我们的应用程序在旧版本上运行。
- en: In the next chapter, we will look at how to create and parse XML and JSON documents.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建和解析XML和JSON文档。
