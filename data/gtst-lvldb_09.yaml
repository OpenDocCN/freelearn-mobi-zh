- en: Chapter 9. A Document Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。文档数据库
- en: This chapter is going to take some of the theory we just discussed in the previous
    chapters and show the use of richer record structures and multiple keys for a
    document database. It uses the extended APLevelDBSS framework for these searches
    and building keys, including a word index.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示我们在前几章中讨论的一些理论，并展示如何使用更丰富的记录结构和多个键来构建文档数据库。它使用扩展的APLevelDBSS框架进行这些搜索和构建键，包括单词索引。
- en: This is a fairly simple document database but would be enough to keep track
    of a range of books and publications as well as local PDF or other files. The
    process of building lists of each and entering their details is very similar to
    what we covered in the `Sample06` GUI used in the previous chapter. One GUI technique
    for OS X that is new to this application is how to get references to files by
    dragging and dropping them on our window, so the details behind that are discussed
    in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的文档数据库，但足以记录各种书籍和出版物，以及本地的PDF或其他文件。构建每个项目的列表并输入其详细信息的过程与我们之前章节中提到的`Sample06`
    GUI中所覆盖的过程非常相似。对于OS X，这个应用程序引入了一种新的GUI技术，即如何通过将文件拖放到我们的窗口上来获取文件引用，因此本章将讨论这一过程的细节。
- en: The samples so far haven't covered how to handle more than one database. We
    used fixed paths to a known database location. Opening others is covered here
    including discussing the package idiom of iOS and OS X that treats folders as
    documents.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例尚未涵盖如何处理多个数据库。我们使用了指向已知数据库位置的固定路径。本章将介绍如何打开其他数据库，包括讨论iOS和OS X的包惯用语，它将文件夹视为文档。
- en: Key design for searching the document database
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索文档数据库的关键设计
- en: We want to retrieve documents by title, keyword, and author so have keys for
    each as shown in the following diagram.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过标题、关键词和作者检索文档，因此为每个都显示了以下图示中的键。
- en: '![Key design for searching the document database](img/1015OS_09_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![搜索文档数据库的关键设计](img/1015OS_09_01.jpg)'
- en: Typical NoSQL-style data and relationships in the document database
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文档数据库中的典型NoSQL风格的数据和关系
- en: In a relational database, more tables would be used to track the authors, making
    it easier to work out co-authoring, but that is not the only pattern that can
    be used.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，会使用更多的表来跟踪作者，这使得确定共同作者变得更容易，但这并不是唯一可以使用的模式。
- en: Storing multiple values nested inside a JSON or other encoded value is a typical
    noSQL pattern and helps simplify the keys. This schema also simplifies a little
    by ignoring identical author names that are actually different people. Note that
    we don't have any explicit keys to track that people are co-authors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON或其他编码值内部存储多个嵌套值是典型的NoSQL模式，有助于简化键。此模式还通过忽略实际上是不同人的相同作者姓名而稍微简化了一些。请注意，我们没有任何明确的键来跟踪共同作者。
- en: Defining the schema using APLevelDBSS
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用APLevelDBSS定义模式
- en: 'The schema definition matching the previous diagram is shown in the following
    code, using a property for each key to define the parts of keys. The `docKey`
    also defines the `valueFields` which define the minimum content for the record
    to support keys and our GUI. Unlike classical relational schemas, there may be
    more fields in any individual record than we define:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了与之前图示相匹配的模式定义，使用每个键的属性来定义键的部分。`docKey`还定义了`valueFields`，这些字段定义了记录支持键和我们的GUI所需的最小内容。与经典的关系模式不同，任何单个记录中可能包含的域可能比我们定义的要多：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The schema handling of APLevelDBSS will reconcile the key definitions so anything
    with a `partFromPath` will use the path string to navigate to the original data,
    mapping `doc.desc` to the `doc` key and then a `desc` field within.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: APLevelDBSS的模式处理将协调键定义，因此任何具有`partFromPath`的项都将使用路径字符串导航到原始数据，将`doc.desc`映射到`doc`键，然后在其中创建一个`desc`字段。
- en: 'You can see the `wordKey` has a `valueGenerator` block that generates multiple
    values, using the `uniqueWordsFromString` shown in the following code. We regard
    all keys as potentially generating zero or multiple values either from a block
    or as a side effect of their path such as `doc.authors.name` matching a list of
    names:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`wordKey`有一个`valueGenerator`块，它生成多个值，使用以下代码中的`uniqueWordsFromString`。我们将所有键视为可能从块生成零个或多个值，或者作为它们路径的副作用，例如`doc.authors.name`与姓名列表匹配：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding word generator is vastly simpler than a production-quality generator
    that would use **stemming** to match words with the same base, such as plurals.
    It should also have a **stop-word list** to skip words rather than just checking
    `length >=3` characters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的单词生成器远比一个生产质量的生成器简单，后者会使用**词干提取**来匹配具有相同基词的单词，例如复数形式。它还应该有一个**停用词列表**来跳过某些单词，而不仅仅是检查`length
    >=3`个字符。
- en: The field of extracting text for indexing has a huge body of work. You can read
    about stemming algorithms and download BSD-licensed source for the Snowball algorithm,
    successor to the classic Porter algorithm, at [http://snowball.tartarus.org/index.php](http://snowball.tartarus.org/index.php).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提取文本进行索引的字段有一大批研究成果。你可以阅读有关词干算法的内容，并下载BSD许可的Snowball算法源代码，它是经典Porter算法的后继者，在[http://snowball.tartarus.org/index.php](http://snowball.tartarus.org/index.php)。
- en: 'Two major open source projects that use text indexing are Sphinx and Solr;
    part of Lucene. Packt Publishing have many books covering them including: [http://www.packtpub.com/sphinx-search-beginners-guide/book](http://www.packtpub.com/sphinx-search-beginners-guide/book)
    and [http://www.packtpub.com/apache-solr-4-cookbook/book](http://www.packtpub.com/apache-solr-4-cookbook/book).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本索引的两个主要开源项目是Sphinx和Solr；Lucene的一部分。Packt Publishing有许多关于它们的书籍，包括：[http://www.packtpub.com/sphinx-search-beginners-guide/book](http://www.packtpub.com/sphinx-search-beginners-guide/book)
    和 [http://www.packtpub.com/apache-solr-4-cookbook/book](http://www.packtpub.com/apache-solr-4-cookbook/book)。
- en: Database fields for tracking documents
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于跟踪文档的数据库字段
- en: 'Documents are identified by a URL that might be referring externally to an
    Internet resource or to a local file. As far as the database is concerned, this
    is just another string value. The OS X sample allows you to drag a document and
    drop it on the window, by registering to handle the `NSURLPboardType` and adding
    two handler methods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文档通过一个URL来识别，这个URL可能指向外部互联网资源或本地文件。就数据库而言，这只是一个字符串值。OS X示例允许你拖动一个文档并将其拖放到窗口上，通过注册处理`NSURLPboardType`并添加两个处理方法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the preceding code sets the text field `docURL` we use it with the database
    as if it were a string value the user had typed into an entry field.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码设置了文本字段`docURL`，我们就将其与数据库一起使用，就像用户在输入字段中输入的字符串值一样。
- en: Databases as documents via packages
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过包将数据库作为文档
- en: Our previous database samples created a database in a temporary location. Most
    applications need a database that behaves more like a document itself, which allows
    us to copy it around and open multiple databases. `Sample09` is such an `NSDocument`
    application, supporting independent collections of authors and other documents.
    Remember, we use a property to track our database—nothing prevents an application
    having multiple such properties and open databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的数据库示例在临时位置创建了一个数据库。大多数应用程序需要一个更像文档本身的数据库，这样我们就可以将其复制到其他地方并打开多个数据库。"Sample09"就是这样的一个`NSDocument`应用程序，支持独立作者的集合和其他文档。记住，我们使用一个属性来跟踪我们的数据库——没有任何东西阻止应用程序拥有多个这样的属性和打开的数据库。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unlike a typical document-based app, we must have the database operating as
    soon as we have a new window—we will save continuously rather than on-demand.
    To ensure this happens, the `NSWindowController` can trigger the **Save As** panel
    with `[[self document] saveDocumentAs:self]` to get to choose a location for the
    database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与典型的基于文档的应用程序不同，我们一旦打开新窗口就必须让数据库开始运行——我们将持续保存而不是按需保存。为了确保这一点，`NSWindowController`可以通过`[[self
    document] saveDocumentAs:self]`触发**另存为**面板，以便选择数据库的位置。
- en: The complication occurs in how to handle the fact that a database is really
    stored in a directory of many files. Apple's *Bundle Programming Guide* describes
    how to create a **Document Package** which is a way of treating a specially named
    directory as if it were a single document. We use `leveldb` as an extension but
    you can choose your own.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性在于如何处理数据库实际上存储在许多文件目录中的事实。Apple的*Bundle编程指南*描述了如何创建**文档包**，这是一种将特别命名的目录视为单个文档的方法。我们使用`leveldb`作为扩展，但你也可以选择自己的。
- en: 'First edit the `xxx-info.plist` file and add two entries to `CFBundleDocumentTypes`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编辑`xxx-info.plist`文件，并向`CFBundleDocumentTypes`添加两个条目：
- en: Add a `LSTypeIsPackage` set to `True`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`LSTypeIsPackage`设置为`True`。
- en: Add a `CFBundleTypeExtensions` with the desired extension, `leveldb`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`CFBundleTypeExtensions`，指定所需的扩展名，`leveldb`。
- en: 'If you compile and run that program, you will find that any directory named
    with that extension, such as `blah.leveldb`, will now appear as a single item
    in the finder and you have to right-click and choose **Show Package Contents**
    to navigate within. Hooking up the `NSDocument` subclass to open a database within
    that directory needs two overrides:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行该程序，你会发现任何以该扩展名命名的目录，例如`blah.leveldb`，现在在查找器中都会显示为一个单独的项目，你必须右键单击并选择**显示包内容**来导航其中。将`NSDocument`子类连接到打开该目录中的数据库需要两个重写：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In both of the preceding methods, we end up getting a full path from an OS X
    function that supplied the user with a GUI for selecting a file or **Save as**
    location. Inside OS X that may be a sandboxed location—we were just handed back
    a usable path as a string.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两种方法中，我们最终都得到了一个从OS X函数提供的GUI中选择的文件或**另存为**位置的完整路径。在OS X中，这可能是一个沙盒位置——我们只是被返回了一个可用的路径字符串。
- en: Summary
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learnt another key design exercise with the schema including two sources
    of multiple keys—word indexing and multiple authors. Typical drag-and-drop desktop
    behavior was shown to add file links in OS X, so you could see how a file URL
    becomes just a string value in a database. We finally saw how to have multiple
    databases opened and treated as single document on desktop, rather than being
    in fixed locations. Now, we will delve deeper into LevelDB and learn more about
    design trade-offs and settings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过包括两个多个键来源的架构学习到了另一个关键的设计练习——单词索引和多个作者。典型的拖放桌面行为在OS X中展示了添加文件链接，因此你可以看到文件URL如何成为数据库中的一个字符串值。我们最终看到了如何在桌面上打开多个数据库并将它们作为单个文档处理，而不是在固定位置。现在，我们将更深入地探讨LevelDB，并了解更多关于设计权衡和设置的信息。
