- en: Chapter 5. A Modern Paradigm – Closures and Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 现代范式 – 闭包和函数式编程
- en: So far, we have been programming using the paradigm called **object-oriented
    programming**, where everything in a program is represented as an object that
    can be manipulated and passed around to other objects. This is the most popular
    way to create apps because it is a very intuitive way to think about software
    and it goes well with the way Apple has designed their frameworks. However, there
    are some drawbacks to this technique. The biggest one is that the state of data
    can be very hard to track and reason about. If we have a thousand different objects
    floating around in our app, all with different information, it can be hard to
    track down where the bugs occurred and it can be hard to understand how the whole
    system fits together. Another paradigm of programming that can help with this
    problem is called **functional programming**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用被称为**面向对象编程**的范式进行编程，其中程序中的所有内容都表示为可以操作并传递给其他对象的实体。这是创建应用程序最流行的方式，因为它是一种非常直观的思考软件的方式，并且与苹果设计的框架非常契合。然而，这种技术有一些缺点。最大的缺点是数据的状态可能非常难以跟踪和推理。如果我们有成千上万的不同的对象在我们的应用程序中漂浮，每个对象都有不同的信息，那么找到错误发生的地方可能很困难，理解整个系统如何结合在一起也可能很困难。另一种可以帮助解决这个问题的编程范式被称为**函数式编程**。
- en: 'Some programming languages are designed to use only functional programming,
    but Swift is designed primarily as an object-oriented language with the ability
    to use functional programming concepts. In this chapter, we will explore how to
    implement these functional programming concepts in Swift and what they are used
    for. To do this, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言被设计为仅使用函数式编程，但Swift主要被设计为一种面向对象的语言，具有使用函数式编程概念的能力。在本章中，我们将探讨如何在Swift中实现这些函数式编程概念以及它们的应用。为此，我们将涵盖以下主题：
- en: Functional programming philosophy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程哲学
- en: Closures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Building blocks of functional programming in Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift中函数式编程的构建块
- en: Lazy evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Example
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例
- en: Functional programming philosophy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程哲学
- en: Before we jump into writing code, let's discuss the ideas and motivations behind
    functional programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们讨论一下函数式编程背后的思想和动机。
- en: State and side effects
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态和副作用
- en: Functional programming makes it significantly easier to think of each component
    in isolation. This includes things such as types, functions, and methods. If we
    can wrap our minds around everything that is input into these code components
    and everything that should be returned from them, we could analyze the code easily
    to ensure that there are no bugs and it performs well. Every type is created with
    a certain number of parameters and each method and function in a program has a
    certain number of parameters and return values. Normally, we think about these
    as the only inputs and outputs, but the reality is that often there are more.
    We refer to these extra inputs and outputs as **state**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程使得单独思考每个组件变得容易得多。这包括类型、函数和方法等。如果我们能够理解输入到这些代码组件中的所有内容以及从它们返回的所有内容，我们就可以轻松地分析代码，以确保没有错误并且性能良好。每个类型都使用一定数量的参数创建，程序中的每个方法和函数都有一定数量的参数和返回值。通常，我们认为这些是唯一的输入和输出，但现实情况是，往往还有更多。我们将这些额外的输入和输出称为**状态**。
- en: 'In a more general sense, state is any stored information, however temporary,
    that can be changed. Let''s consider a simple `double` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在更广泛的意义上，状态是任何可以更改的存储信息，无论其是暂时的。让我们考虑一个简单的`double`函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a great example of a **stateless** function. No matter what else is
    happening in the entire universe of the program, this method will always return
    the same value, if it is given the same input. An input of `2` will always return
    `4`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**无状态**函数的绝佳例子。无论程序中的整个宇宙发生什么，只要提供相同的输入，这个方法总是会返回相同的值。输入`2`总是会返回`4`。
- en: 'Now, let''s look at a method with state:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个有状态的方法：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you call this method repeatedly, with the same input on the same `Ball` instance,
    you will get a different result every time. This is because there is an additional
    input in this method, which is the instance it is being called on. It is otherwise
    referred to as `self`. `self` is actually both an input and an output of this
    method, because the original value of radius affects the output and `radius` is
    changed by the end of the method. This is still not very difficult to reason about,
    as long as you keep in mind that `self` is always another input and output. However,
    you can imagine that with a more complex data structure, it can be hard to track
    every possible input and output from a piece of code. As soon as that starts to
    happen, it becomes easier for bugs to get created, because we will almost certainly
    have, unexpected inputs causing unexpected outputs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你反复调用这个方法，在同一个`Ball`实例上使用相同的输入，每次都会得到不同的结果。这是因为这个方法中有一个额外的输入，即它被调用的实例。它通常被称为`self`。实际上，`self`既是这个方法的输入也是输出，因为原始的半径值会影响输出，而`radius`在方法结束时会被改变。只要记住`self`总是另一个输入和输出，这仍然不是很难理解。然而，你可以想象，对于一个更复杂的数据结构，跟踪代码中每一个可能的输入和输出可能会很困难。一旦这种情况开始发生，就更容易产生错误，因为我们几乎肯定会遇到意外的输入导致意外的输出。
- en: '**Side effects** are an even worse type of extra input or output. They are
    the unexpected changes to state, seemingly unrelated to the code being run. If
    we simply rename our preceding method to something a little less clear, its effect
    on the instance becomes unexpected:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**是更糟糕的一种额外输入或输出的类型。它们是对状态的意外更改，看似与正在运行的代码无关。如果我们简单地将前面的方法重命名为一个稍微不那么清晰的名字，它对实例的影响就会变得意外：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on its name, you wouldn't expect this method to change the actual value
    of `radius`. This means that if you didn't see the actual implementation, you
    would expect this method to keep returning the same value if called with the same
    amount on the same instance. Unpredictability is a terrible thing to have as a
    programmer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其名称，你不会期望这个方法会改变`radius`的实际值。这意味着，如果你没有看到实际的实现，你会期望这个方法在同一个实例上以相同的数量调用时保持返回相同的值。不可预测性对于程序员来说是一件可怕的事情。
- en: In its strictest form, functional programming eliminates all state and therefore
    side effects. We will never go that far in Swift, but we will often use functional
    programming techniques to reduce state and side effects to increase the predictability
    of our code, drastically.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最严格的形式中，函数式编程消除了所有状态和副作用。我们永远不会在Swift中走那么远，但我们会经常使用函数式编程技术来减少状态和副作用，以极大地提高代码的可预测性。
- en: Declarative versus imperative code
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式代码与命令式代码
- en: 'Besides predictability, the other effect that functional programming has on
    our code is that it becomes more **declarative**. This means that the code shows
    us how we expect information to flow through our application. This is in contrast
    to what we have been doing with object-oriented programming, which we call **imperative
    code**. This is the difference between writing a code that loops through an array
    to add only certain elements to a new array and running a filter on the array.
    The former would look similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可预测性之外，函数式编程对我们代码的另一个影响是它变得更加**声明式**。这意味着代码向我们展示了我们期望信息如何通过我们的应用程序流动。这与我们使用面向对象编程所做的是相反的，我们称之为**命令式代码**。这是编写一个循环遍历数组以将某些元素添加到新数组中的代码与在数组上运行过滤器的区别。前者可能看起来像这样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running a filter on the array would look similar to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上运行过滤器看起来可能像这样：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't worry if you don't understand the second example yet. This is what we
    are going to cover in the rest of this chapter. The general idea is that with
    imperative codes, we are going to issue a series of commands with the intent of
    the code as a secondary, subtler idea. To understand that we are creating a copy
    of `originalArray` with only elements greater than `3`, we have to read the code
    and mentally step through what is happening. In the second example, we are stating
    in the code itself that we are filtering the original array. Ultimately, these
    ideas exist on a spectrum and it is hard to have something be 100% declarative
    or imperative, but the principles of each are important.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不理解第二个例子，不要担心。这是我们将在本章的其余部分中要涵盖的内容。一般想法是，在命令式代码中，我们将发出一系列命令，其中代码的意图是次要的、微妙的想法。为了理解我们正在创建一个只包含大于`3`的元素的`originalArray`的副本，我们必须阅读代码并在心理上逐步通过正在发生的事情。在第二个例子中，我们在代码本身中声明我们正在过滤原始数组。最终，这些想法存在于一个光谱上，很难有100%的声明式或命令式，但每个原则都很重要。
- en: So far, with our imperative code, most of it just defines what our data should
    look like and how it can be manipulated. Even with high quality abstractions,
    understanding a section of code can often involve jumping between lots of methods,
    tracing the execution. In declarative code, logic can be more centralized and
    often more easily read, based on well-named methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的命令式代码中，大部分只是定义了我们的数据应该看起来像什么以及如何操作它。即使有高质量的抽象，理解一段代码通常也涉及到在许多方法之间跳转，追踪执行过程。在声明式代码中，逻辑可以更加集中，并且通常更容易阅读，基于命名良好的方法。
- en: You can also think of imperative codes as if it were as a factory where each
    person makes a car in its entirety while thinking of declarative code as if it
    were a factory with an assembly line. In order to understand what the person is
    doing in a non-assembly line factory, you have to watch the whole process unfold
    one step at a time. They will probably be pulling in all kinds of tools at different
    times and it will be hard to follow. In a factory with an assembly line, you can
    determine what is happening by looking at each step in the assembly line one at
    a time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将命令式代码想象成一个工厂，其中每个人都在思考着如何完整地制作一辆车，而将声明式代码想象成一个拥有装配线的工厂。为了理解在一个非装配线工厂中人们正在做什么，你必须一步一步地观察整个过程展开。他们可能会在不同时间拉入各种工具，这会很难跟上。在一个装配线工厂中，你可以通过观察装配线上的每一个步骤来确定正在发生什么。
- en: Now that we understand some of the motivations of functional programming, let's
    look at the Swift features that make it possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些函数式编程的动机，让我们来看看使它成为可能的 Swift 特性。
- en: Closures
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: In Swift, functions are considered first-class citizens, which means that they
    can be treated the same as any other type. They can be assigned to variables and
    be passed in and out of other functions. When treated this way, we call them **closures**.
    This is an extremely critical piece to write more declarative code because it
    allows us to treat functionalities like objects. Instead of thinking of functions
    as a collection of code to be executed, we can start to think about them more
    like a recipe to get something done. Just like you can give just about any recipe
    to a chef to cook, you can create types and methods that take a closure to perform
    some customizable behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，函数被视为一等公民，这意味着它们可以像任何其他类型一样被对待。它们可以被分配给变量，并可以在其他函数之间传递。当这样处理时，我们称它们为**闭包**。这是编写更多声明式代码的一个极其关键的部分，因为它允许我们将功能视为对象。我们不再将函数视为要执行的代码集合，而是可以开始更多地将其视为完成某事的配方。就像你可以把几乎任何食谱交给厨师来烹饪一样，你可以创建接受闭包以执行某些可定制行为的类型和方法。
- en: Closures as variables
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包作为变量
- en: 'Let''s take a look at how closures work in Swift. The simplest way to capture
    a closure in a variable is to define the function and then use its name to assign
    it to a variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Swift 中闭包是如何工作的。在变量中捕获闭包的最简单方法是在定义函数后，使用其名称将其分配给变量：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `doubleClosure` can be used just like the normal function name
    after being assigned. There is actually no difference between using `double` and
    `doubleClosure`. Note that we can now think of this closure as an object that
    will double anything passed to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`doubleClosure`在被分配后可以像普通函数名一样使用。实际上，使用`double`和使用`doubleClosure`之间没有区别。请注意，我们现在可以将这个闭包视为一个对象，它将加倍任何传递给它的东西。
- en: If you look at the type of `doubleClosure` by holding the option key and click
    on the name, you will see that the type is defined as `(Int) -> Int`. The basic
    type of any closure is `(ParamterType1, ParameterType2, …) -> ReturnType`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按住选项键并单击 `doubleClosure` 的名称，你会看到类型被定义为 `(Int) -> Int`。任何闭包的基本类型是 `(ParameterType1,
    ParameterType2, …) -> ReturnType`。
- en: 'Using this syntax, we can also define our closure inline, such as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，我们还可以直接定义我们的闭包，例如：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We begin and end any closure with curly brackets (`{}`). Then, we follow the
    opening curly bracket with the type for the closure, which will include input
    parameters and a return value. Finally, we separate the type definition from the
    actual implementation with the `in` keyword.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以花括号 `{}` 开始和结束任何闭包。然后，我们在开括号后面跟闭包的类型，这将包括输入参数和返回值。最后，我们使用 `in` 关键字将类型定义与实际实现分开。
- en: 'An absence of a return type is defined as `Void` or `()`. Even though you may
    see that some programmers use parentheses, `Void` is preferred for return declarations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型的不存在被定义为 `Void` 或 `()`。尽管你可能看到一些程序员使用括号，但 `Void` 更适合用于返回声明：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Essentially, `()` is an empty tuple meaning it holds no value and it is more
    commonly used for the input parameters, in case the closure doesn''t take any
    parameters at all:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`()` 是一个空的元组，意味着它不包含任何值，它更常用于输入参数，以防闭包根本不接受任何参数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So far, even though we can change our thinking about the block of code by making
    it into a closure, it is not terribly useful. To really make closures useful,
    we need to start passing them into other functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，尽管我们可以通过将其转换为闭包来改变我们对代码块的想法，但这并不特别有用。要真正使闭包有用，我们需要开始将它们传递给其他函数。
- en: Closures as parameters
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包作为参数
- en: 'We can define a function to take a closure as a parameter, using the same type
    syntax we saw previously:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前看到的相同类型语法定义一个函数，以闭包作为参数：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we have a function that can find the first number in an array that passes
    some arbitrary test. The syntax at the end of the function declaration may be
    confusing but it should be clear if you work from the inside out. The type for
    `passingTest` is `(number: Int) -> Bool`. That is then the second parameter of
    the whole `firstInNumbers` function, which returns an `Int?`. If we want to use
    this function to find the first number greater than three, we can create a custom
    test and pass that into the function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们有一个函数，它可以找到数组中通过某些任意测试的第一个数字。函数声明末尾的语法可能令人困惑，但如果你从内向外工作，它应该很清楚。`passingTest`
    的类型是 `(number: Int) -> Bool`。这是整个 `firstInNumbers` 函数的第二个参数，它返回一个 `Int?`。如果我们想使用这个函数来找到大于三的第一个数字，我们可以创建一个自定义测试并将其传递给函数：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are essentially passing a little bundle of functionality to the `firstInNumbers:`
    function that lets us drastically enhance what a single function can normally
    do. This is an incredibly useful technique. Looping through an array to find an
    element can be very verbose. Instead, we can use this function to find an element
    showing only the important part of the code: the test.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上是将一小块功能传递给 `firstInNumbers:` 函数，这使我们能够极大地增强单个函数通常能做的事情。这是一个极其有用的技术。通过遍历数组来查找元素可能非常冗长。相反，我们可以使用这个函数来查找元素，只显示代码的重要部分：测试。
- en: 'We can even define our test right in a call to the function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以直接在函数调用中定义我们的测试：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even though this is more concise, it's pretty complex; hence, Swift allows us
    to cut out some of the unnecessary syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这更简洁，但它相当复杂；因此，Swift 允许我们省略一些不必要的语法。
- en: Syntactic sugar
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法糖
- en: 'First, we can make use of type inference for the type of `number`. The compiler
    knows that number needs to be `Int` based on the definition of `firstInNumbers:passingTest:`.
    It also knows that the closure has to return `Bool`. Now, we can rewrite our call,
    as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以利用类型推断来推断 `number` 的类型。编译器知道根据 `firstInNumbers:passingTest:` 的定义，数字需要是
    `Int`。它还知道闭包必须返回 `Bool`。现在，我们可以重写我们的调用，如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This looks cleaner, but the parentheses around `number` are not required; we
    could leave those out. In addition, if we have closure as the last parameter of
    a function, we can provide the closure outside the parentheses for the function
    call:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来更简洁，但括号围绕 `number` 的部分不是必需的；我们可以省略这些。此外，如果我们把闭包作为函数的最后一个参数，我们可以在函数调用外提供闭包：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the closing parenthesis for the function parameters moved from being
    after the closure to before it. This is looking pretty great, but we can go even
    further. For a single line closure, we don''t even have to write the `return`
    keyword because it is implied:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数参数的闭包括号从闭包之后移动到了闭包之前。这看起来相当不错，但我们还可以更进一步。对于单行闭包，我们甚至不需要写 `return` 关键字，因为它已经隐含了：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we don''t always need to give a name to the parameters of closures.
    If you leave out the names altogether, each parameter can be referenced using
    the syntax `$<ParemterIndex>`. Just like with arrays, the index starts at `0`.
    This helps us write this call very concisely in a single line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们并不总是需要给闭包的参数命名。如果你完全省略了名称，每个参数都可以使用语法 `$<ParameterIndex>` 来引用。就像数组一样，索引从
    `0` 开始。这有助于我们非常简洁地在单行中编写这个调用：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is a long way from our original syntax. You can mix and match all of these
    different techniques to make sure that your code is as understandable as possible.
    As we have discussed before, understandability is a balance between being concise
    and clear. It is up to you in each circumstance to decide how much syntax you
    want to cut out. To me, it is not immediately clear what the closure is without
    it having a name. My preferred syntax for this is to use the parameter name in
    the call:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的原始语法相去甚远。你可以混合使用所有这些不同的技术，以确保你的代码尽可能易于理解。正如我们之前讨论过的，可理解性是在简洁和清晰之间取得平衡。在每种情况下，都取决于你决定省略多少语法。对我来说，如果没有名称，闭包并不立即清晰。我首选的语法是在调用中使用参数名称：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes it clear that the closure is a test to see which number we want to
    pull out of the list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明闭包是一个测试，看看我们想要从列表中提取哪个数字。
- en: Now that we know what a closure is and how to use one, we can discuss some of
    the core features of Swift that allow us to write a functional style code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了闭包是什么以及如何使用它，我们可以讨论一些 Swift 的核心特性，这些特性允许我们编写函数式风格的代码。
- en: Building blocks of functional programming in Swift
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 中函数式编程的构建块
- en: The first thing to realize is that Swift is not a functional programming language.
    At its core, it will always be an object-oriented programming language. However,
    since functions in Swift are first-class citizens, we can use some of the core
    techniques. Swift provides some built-in methods to get us started.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要意识到的是，Swift 不是一个函数式编程语言。在其核心，它始终是一个面向对象编程语言。然而，由于 Swift 中的函数是一等公民，我们可以使用一些核心技术。Swift
    提供了一些内置方法来帮助我们入门。
- en: Filter
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The first method we are going to discuss is called **filter**. As the name
    suggests, this method is used to filter elements in a list. For example, we can
    filter our `numbers` array to include only even numbers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个方法被称为 **filter**。正如其名称所暗示的，这个方法用于过滤列表中的元素。例如，我们可以过滤 `numbers` 数组，只包含偶数：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The closure we provide to filter will be called once for each element in the
    array. It is tasked with returning `true` if the element needs to be included
    in the result and `false` otherwise. The preceding closure takes advantage of
    the implied return value and simply returns `true` if the number has a remainder
    of zero when being divided by two.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的用于过滤的闭包将对数组中的每个元素调用一次。它的任务是如果元素需要包含在结果中则返回 `true`，否则返回 `false`。前面的闭包利用了隐含的返回值，如果数字除以二有余数则简单地返回
    `true`。
- en: Note that the filter does not change the `numbers` variable; it simply returns
    a filtered copy. Changing the value will modify the state, which we want to avoid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，过滤不会改变 `numbers` 变量；它只是返回一个过滤后的副本。改变值将修改状态，这是我们想要避免的。
- en: This method provides us with a concise way to filter a list in virtually any
    way we want. It is also the beginning of building up a vocabulary of transformations,
    which we can perform on data. One could argue that all applications just transform
    data from one form to another, so this vocabulary helps us achieve the maximum
    functionality we want in any app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为我们提供了一种简洁的方式来以我们想要的方式过滤列表。它也是构建一个可以应用于数据的转换词汇表的开始。有人可能会争论，所有应用只是将数据从一种形式转换为另一种形式，所以这个词汇表帮助我们实现任何应用中我们想要的最高功能。
- en: Reduce
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少
- en: Swift also provides a method called **reduce**. The purpose of reduce is to
    condense a list down to a single value. Reduce works by iterating over every value
    and combining it with a single value that represents all previous elements. This
    is just like mixing a bunch of ingredients in a bowl for a recipe. We will take
    one ingredient at a time and combine it in the bowl until we are left with just
    a single bowl of ingredients.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还提供了一个名为 **reduce** 的方法。reduce 的目的是将列表缩减为单个值。reduce 通过遍历每个值并将其与代表所有前元素的单一值组合来工作。这就像为食谱在碗中混合一堆配料一样。我们将一次取一个配料，并将其放入碗中，直到我们只剩下一个装有所有配料的碗。
- en: 'Let''s take a look at what the reduce function looks like in our code. We can
    use it to sum up the values in our number array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 reduce 函数在代码中的样子。我们可以使用它来计算数字数组中的值总和：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, reduce takes two parameters. The first parameter is a value
    with which to start combining each item in the list. The second is a closure that
    will do the combining. Similar to filter, this closure is called once for each
    element in the array. The first parameter of the closure is the value after combing
    each of the previous elements with the initial value. The second parameter is
    the next element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，reduce 函数接受两个参数。第一个参数是用于开始组合列表中每个项的值。第二个是一个闭包，它将执行组合。与 filter 类似，这个闭包对数组中的每个元素调用一次。闭包的第一个参数是在将每个前一个元素与初始值组合后的值。第二个参数是下一个元素。
- en: So the first time the closure is called, it is called with `0` (the initial
    value) and `1` (the first element of the list); it then returns `1`. This means
    that it is then called again with `1` (the value from the last call) and `2` (the
    next element in the list) returning `3`. This will continue until it is combining
    the running sum of `10`, with the last element `5`, returning a final result of
    `15`. It becomes very simple once we break it down.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当闭包第一次被调用时，它使用的是 `0`（初始值）和 `1`（列表中的第一个元素）；然后返回 `1`。这意味着它随后再次使用 `1`（上一次调用的值）和
    `2`（列表中的下一个元素）返回 `3`。这个过程会一直持续，直到它将运行总和 `10` 与最后一个元素 `5` 结合，得到最终结果 `15`。一旦我们将其分解，它就变得非常简单。
- en: '**Reduce** is another great vocabulary item to add to our skill-set. It can
    reduce any list of information into a single value by analyzing data to generate
    a document from a list of images and much more.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reduce** 是另一个可以添加到我们的技能集的优秀词汇。它可以通过分析数据将任何信息列表缩减为单个值，例如从图像列表生成文档等。'
- en: 'Also, we can start to chain our functions together. If we want to find the
    sum of all the even numbers in our list, we can run the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以开始将我们的函数串联起来。如果我们想找到列表中所有偶数的总和，我们可以运行以下代码：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can actually do one more thing to shorten this. Every arithmetic operation,
    including addition (`+`) is really just another function or closure. Addition
    is a function that takes two values of the same type and returns their sum. This
    means that we can simply pass the addition function as our combine closure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以做一件事情来缩短这个过程。每个算术运算，包括加法（`+`），实际上只是另一个函数或闭包。加法是一个接受相同类型的两个值并返回它们的和的函数。这意味着我们可以简单地将加法函数作为我们的组合闭包传递：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we are getting fancy!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始变得复杂了！
- en: 'Also, keep in mind that the combined value does not need to be the same type
    that is in the original list. Instead of summing the values, we could combine
    them all into one string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，组合的值不需要与原始列表中的类型相同。而不是求和值，我们可以将它们全部组合成一个字符串：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here I am using string interpolation to create a string that starts with the
    running value and ends with the next element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用字符串插值来创建一个以运行值开始并以下一个元素结束的字符串。
- en: Map
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map
- en: '**Map** is a method to transform every element in a list to another value.
    For example, we can add one to every number in the list:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Map** 是一个将列表中的每个元素转换成另一个值的方法。例如，我们可以给列表中的每个数字加一：'
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can probably guess, the closure that map takes is called once for each
    element in the list. As a parameter, it takes the element and is expected to return
    the new value to be added to the resulting array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许能猜到的，map 函数所采用的闭包对列表中的每个元素只调用一次。作为一个参数，它接受元素并期望返回要添加到结果数组中的新值。
- en: 'Just like with reduce, the transformed type does not need to match. We can
    convert all of our numbers to strings:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 reduce 一样，转换后的类型不需要匹配。我们可以将所有的数字都转换为字符串：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Map is incredibly versatile. It can be used to convert a list of data into a
    list of views to display the data, convert a list of image paths to their loaded
    images, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 非常灵活。它可以用来将数据列表转换为视图列表以显示数据，将图像路径列表转换为加载的图像，等等。'
- en: The map method is a great choice to perform calculations on each element of
    a list, but it should be used only when it makes sense to put the result of the
    calculation back into a list. You could technically use it to iterate through
    a list and perform some other action, but in that case, a for-in loop is more
    appropriate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 方法是一个对列表中的每个元素执行计算的绝佳选择，但它只应该在将计算结果放回列表中合理时使用。技术上，你可以用它来遍历列表并执行其他操作，但在那种情况下，for-in
    循环更为合适。'
- en: Sort
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'The last built-in functional method we will discuss is called **sorted**. As
    the name suggests, sorted allows you to change the order of a list. For example,
    if we want to reorder our numbers list to go from largest to smallest:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个内置函数式方法是称为 `sorted`。正如其名所示，`sorted` 允许你改变列表的顺序。例如，如果我们想将我们的数字列表重新排序，从大到小：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The closure that is passed into sorted is called `isOrderedBefore`. This means
    that it takes two elements in the list as input and it should return `true` if
    the first element is to be ordered before the second element. We cannot rely on
    the closure to be called a certain number of times, nor the elements it will be
    called with, but it will be called until the sorting algorithm has enough knowledge
    to come up with a new order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `sorted` 的闭包称为 `isOrderedBefore`。这意味着它接受列表中的两个元素作为输入，如果第一个元素应该在第二个元素之前排序，则应返回
    `true`。我们无法依赖闭包被调用一定次数，也不能依赖它将被调用的元素，但它将一直被调用，直到排序算法有足够的信息来提出新的顺序。
- en: In our case, we return `true` any time the first argument is greater than the
    second argument. This results in larger elements always coming before smaller
    elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，当第一个参数大于第二个参数时，我们返回 `true`。这导致较大的元素始终出现在较小的元素之前。
- en: This is a great method because sorting is a very common task and often data
    will need to be sorted in multiple ways, depending on the user's interaction.
    Using this method, you could design multiple sorting closures and change the one
    being used based on the user's interaction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的方法，因为排序是一个非常常见的任务，并且数据通常需要根据用户的交互以多种方式排序。使用这种方法，你可以设计多个排序闭包，并根据用户的交互更改正在使用的闭包。
- en: How these affect the state and nature of code
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些如何影响代码的状态和本质
- en: There are more built-in functional methods and we will learn to write our own
    in the next chapter on generics, but these are a core few to help you start thinking
    about certain problems in a functional way. So how do these methods help us avoid
    state?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多内置的功能方法，我们将在下一章关于泛型的章节中学习如何编写自己的方法，但这些都是核心的几个方法，可以帮助你以函数式的方式思考某些问题。那么，这些方法是如何帮助我们避免状态的？
- en: These methods, along with others, can be combined in infinite ways to transform
    data and perform actions. No matter how complex the combination is, there is no
    way to interfere with each individual step. There are no side effects because
    the only inputs are the result of the preceding step and the only outputs are
    what will be passed on to the next step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法以及其他方法可以以无限的方式组合起来，以转换数据和执行操作。无论组合多么复杂，都无法干扰每个单独的步骤。因为没有副作用，唯一的输入是前一步的结果，唯一的输出是传递给下一步的内容。
- en: You can also see that complex transformations can all be declared in a concise
    and centralized place. A reader of the code doesn't need to trace the changing
    values of many variables; they can simply look at the code and see what processes
    it will go through.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，复杂的转换都可以在一个简洁且集中的地方声明。代码的读者不需要追踪许多变量的变化值；他们只需查看代码，就可以看到它将经历哪些过程。
- en: Lazy evaluation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟评估
- en: A powerful feature of Swift is the ability to make these operations lazily evaluated.
    This means that, just like a lazy person would do, a value is only calculated
    when it is absolutely necessary and at the latest point possible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的一个强大功能是能够使这些操作延迟评估。这意味着，就像一个懒惰的人会做的那样，只有在绝对必要且尽可能晚的时候才会计算值。
- en: 'First, it is important to realize the order in which these methods are executed.
    For example, what if we only want the first element of our numbers to be mapped
    to strings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要意识到这些方法的执行顺序。例如，如果我们只想将我们的数字列表的第一个元素映射到字符串：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This works well, except that we actually converted every number to a string
    to get to just the first one. That is because each step of the chain is completed
    in its entirety before the next one can be executed. To prevent this, Swift has
    a built-in method called **lazy**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但事实上我们实际上将每个数字都转换为字符串，只是为了得到第一个。这是因为链的每一步都必须在执行下一步之前完成。为了防止这种情况，Swift有一个内置的名为**lazy**的方法。
- en: Lazy creates a new version of a container that only pulls specific values from
    it when it is specifically requested. This means that lazy essentially allows
    each element to flow through a series of functions one at a time, as it is needed.
    You can think about it like a lazy version of a worker. If you ask someone lazy
    to look up the capital of Cameroon, they aren't going to compile a list of the
    capitals of all countries before they get the answer. They are only going to do
    the work necessary to get that specific answer. That work may involve multiple
    steps, but they would only have to do those steps for the specific countries you
    ask for.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载创建了一个新的容器版本，它仅在特定请求时从其中提取特定值。这意味着懒加载本质上允许每个元素一次通过一系列函数，正如它所需的那样。你可以把它想象成一个懒版本的工人。如果你让一个懒人查找喀麦隆的首都，他们不会在得到答案之前编译所有国家的首都列表。他们只会做得到那个特定答案所必需的工作。这项工作可能涉及多个步骤，但他们只需为你要询问的特定国家做这些步骤。
- en: 'Now, let''s look at what lazy looks like in code. You use it to convert a normal
    list into a lazy list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码中懒加载的样子。你使用它将普通列表转换为懒列表：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, instead of calling map directly on `numbers`, we called it on the lazy
    version of `numbers`. This makes it so that every time a value is requested from
    the result, it only processes a single element out of the input array. In our
    preceding example, the `map` method will only have been performed once.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再直接在`numbers`上调用`map`，而是在`numbers`的懒加载版本上调用它。这使得每次从结果请求值时，它只处理输入数组中的一个元素。在我们的前一个例子中，`map`方法只执行了一次。
- en: 'This even applies to looping through a result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至适用于遍历结果：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each number is converted to a string only upon the next iteration of the for-in
    loop. If we were to break out of that loop early, the rest of the values would
    not be calculated. This is a great way to save processing time, especially on
    large lists.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数只有在for-in循环的下一个迭代中才会被转换为字符串。如果我们提前退出循环，其余的值将不会被计算。这是一种节省处理时间的好方法，尤其是在大型列表上。
- en: Example
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: Let's take a look at what this looks like in practice. We can use some of the
    techniques we learned in this chapter to write a different and possibly better
    implementation of our party inviter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在实践中这看起来是什么样子。我们可以使用本章学到的某些技术来编写不同的，可能更好的派对邀请者实现。
- en: 'We can start by defining the same input data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先定义相同的输入数据：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this implementation, we are making the invitees list, which is just a constant
    list of names and the shows by genre dictionary variable. This is because we are
    going to be mapping our invitees list to a list of invitation text. As we do the
    mapping, we will have to pick a random genre to assign to the current invitee,
    and in order to avoid assigning the same genre more than once, we can remove the
    genre from the dictionary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们正在创建一个邀请者列表，它只是一个常量列表的名字和按类型分类的节目字典变量。这是因为我们将把我们的邀请者列表映射到邀请文本列表。当我们进行映射时，我们必须为当前受邀者选择一个随机类型，为了避免重复分配同一个类型，我们可以从字典中移除该类型。
- en: 'So let''s write the random `genre` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写随机的`genre`函数：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start by creating an array of just the keys of the shows by genre dictionary.
    Then, if there are no genres left, we simply return nil. Otherwise, we pick out
    a random genre, remove it from the dictionary, and return it and the show example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个只包含按类型分类的节目字典的键的数组。然后，如果没有剩余的类型，我们简单地返回nil。否则，我们随机选择一个类型，从字典中移除它，并返回它和节目示例。
- en: 'Now we can use that function to map the invitees to a list of invitations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个函数将受邀者映射到邀请列表：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we try to pick a random genre. If we can't, we return an invitation saying
    that the invitee should just bring themselves. If we can, we return an invitation
    saying what genre they should bring with the example show. The one new thing to
    note here is that we are using the sequence `"\n"` in our string. This is a newline
    character and it signals that a new line should be started in the text.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试随机选择一个流派。如果我们做不到，我们就返回一个邀请，告诉被邀请者只需带上自己。如果我们能做到，我们就返回一个邀请，告诉他们应该带上什么流派，以示例演出为例。这里需要注意的新事物是我们正在使用字符串中的序列
    `"\n"`。这是一个换行符，它表示文本中应该开始新的一行。
- en: 'The last step is to print out the invitations. To do that, we can print out
    the invitations as a string joined by newline characters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是打印出邀请函。为了做到这一点，我们可以将邀请函作为由换行符连接的字符串打印出来：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works pretty well but there is one problem. The first invitees we listed
    will always be assigned a genre because the order they are processed in never
    changes. To fix this, we can write a function to shuffle the invitees before we
    begin to map the function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得相当好，但有一个问题。我们列出的第一个被邀请者总是会分配一个流派，因为它们被处理的顺序永远不会改变。为了解决这个问题，我们可以在开始映射函数之前编写一个函数来打乱被邀请者：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to shuffle an array, we go through three steps: First, we map the
    array to a tuple with the original element and a random number. Second, we sort
    the tuples based on those random numbers. Finally, we map the tuples back to just
    their original elements.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打乱一个数组，我们通过三个步骤进行：首先，我们将数组映射到一个元组中，包含原始元素和一个随机数。其次，我们根据这些随机数对元组进行排序。最后，我们将元组映射回它们的原始元素。
- en: 'Now, all we have to do is add a call to this function to our sequence:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在我们的序列中添加对这个函数的调用：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This implementation is not necessarily better than our previous implementations,
    but it definitely has its advantages. We have taken steps towards reducing the
    state by implementing it as a series of data transformations. The big hiccup in
    that is that we are still maintaining state in the genre dictionary. We can certainly
    do more to eliminate that as well, but this gives you a good idea of how we can
    start to think about problems in a functional way. The more ways in which we can
    think about a problem, the higher our odds of coming up with the best solution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式并不一定比我们之前的实现更好，但它确实有其优势。我们通过将其实现为一系列数据转换来减少状态。其中的大问题是我们在流派字典中仍然维护状态。我们当然可以做更多来消除这一点，但这也给你一个很好的想法，了解我们如何开始以函数式方式思考问题。我们可以以更多方式思考一个问题，我们找到最佳解决方案的机会就越高。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have had to shift the way we think about code. At the very
    least, this is a great exercise so we don't get set in our programming ways. We
    have covered the philosophy behind functional programming and how it differs from
    object-oriented programming. We have looked into the specifics of closures and
    how they enable functional programming techniques in Swift. Lastly, we explored
    some of the specific functional methods that Swift has built in.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们不得不改变我们思考代码的方式。至少，这是一个很好的练习，这样我们就不会陷入编程习惯。我们已经涵盖了函数式编程背后的哲学以及它与面向对象编程的不同之处。我们探讨了闭包的具体内容以及它们如何在Swift中启用函数式编程技术。最后，我们探索了一些Swift内置的特定函数式方法。
- en: The sign of a truly great programmer is not someone who knows a lot about one
    tool, but one who knows which tool to use when. We get there by learning and practicing
    using lots of different tools and techniques without ever becoming too attached
    to a specific one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正伟大程序员的标志不是对一种工具了解很多，而是知道何时使用哪种工具。我们通过学习和练习使用大量不同的工具和技术来实现这一点，而从不过分依赖任何一种。
- en: Once you are comfortable with the concepts of closures and functional programming,
    you are ready to move on to our next topic, generics. Generics is our first opportunity
    to make the strongly typed nature of Swift really work for us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对闭包和函数式编程的概念感到舒适，你就可以继续学习我们的下一个主题，泛型。泛型是我们第一次有机会让Swift的强类型特性真正为我们所用。
