- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Network Calls with Kotlin Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin协程进行网络调用
- en: Most of the apps we use on our phones fetch data that is hosted online on a
    server. As such, we developers have to understand how to request and send data
    to the servers too. In this chapter, we will learn how to send and request data
    that is hosted online and display it in our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在手机上使用的多数应用程序都是从服务器上托管的数据。因此，作为开发者，我们必须了解如何向服务器请求数据和发送数据。在本章中，我们将学习如何发送和请求在线托管的数据，并在我们的应用程序中显示它。
- en: In this chapter, we will learn how to perform network calls with a networking
    library, **Retrofit**. We will learn how to consume **application programming
    interfaces** (**APIs**) using this library. Moreso, we will learn how to take
    advantage of **Kotlin coroutines** to perform asynchronous network requests in
    our app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用网络库**Retrofit**执行网络调用。我们将学习如何使用此库消费**应用程序编程接口**（**API**）。更重要的是，我们将学习如何利用**Kotlin协程**在我们的应用程序中执行异步网络请求。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up Retrofit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Retrofit
- en: Introduction to Kotlin coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin协程简介
- en: Using Kotlin coroutines for network calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kotlin协程进行网络调用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载Android Studio Hedgehog或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix)找到本章的代码。
- en: Setting up Retrofit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Retrofit
- en: Retrofit is a type-safe REST client for Android, Java, and Kotlin developed
    by Square. The library provides a powerful framework for authenticating and interacting
    with APIs and sending network requests with OkHttp. In this book, we will be using
    Retrofit to perform our network requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit是由Square开发的Android、Java和Kotlin的Type-safe REST客户端。该库提供了一个强大的框架，用于验证和与API交互，以及使用OkHttp发送网络请求。在本书中，我们将使用Retrofit来执行我们的网络请求。
- en: 'To begin with, we will add the Retrofit dependencies using our newly created
    version catalog. Let’s define the versions in the `libs.versions.toml` file as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用我们新创建的版本目录添加Retrofit依赖项。让我们在`libs.versions.toml`文件中定义版本，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let’s define the libraries in the `libs.versions.toml` file in the libraries
    section of our versions catalog as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在版本目录的库部分中定义`libs.versions.toml`文件中的库，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are adding these dependencies to our project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将以下依赖项添加到我们的项目中：
- en: '**Retrofit**: As mentioned earlier, we will use Retrofit to perform our network
    requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retrofit**：如前所述，我们将使用Retrofit来执行我们的网络请求。'
- en: '**Retrofit serialization**: This is a converter that uses **Kotlinx serialization**
    to convert Kotlin objects to and from JSON.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retrofit序列化**：这是一个使用**Kotlinx serialization**将Kotlin对象转换为JSON并从JSON转换回来的转换器。'
- en: '**Coroutines**: We will use Kotlin coroutines to perform our network requests
    asynchronously. We will be learning more about coroutines shortly.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：我们将使用Kotlin协程来异步执行我们的网络请求。我们很快就会了解更多关于协程的内容。'
- en: '**Kotlinx serialization JSON**: This is a Kotlin serialization library for
    JSON. We will use this to parse our JSON responses. We have other serialization
    libraries, such as Moshi and Gson, but we used the Kotlinx serialization library
    for the following reasons:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kotlinx serialization JSON**：这是一个用于JSON的Kotlin序列化库。我们将使用它来解析我们的JSON响应。我们还有其他序列化库，如Moshi和Gson，但我们选择使用Kotlinx
    serialization库的原因如下：'
- en: '**Kotlin-centric development**: Kotlinx serialization is designed with Kotlin
    in mind, providing seamless integration and native support for Kotlin serialization.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以Kotlin为中心的开发**：Kotlinx serialization是针对Kotlin设计的，提供无缝集成和原生支持，以便进行Kotlin序列化。'
- en: '**Declarative syntax**: Kotlinx serialization uses a declarative syntax, leveraging
    Kotlin’s language features for concise and readable serialization code.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式语法**：Kotlinx serialization使用声明式语法，利用Kotlin的语言特性来编写简洁且易于阅读的序列化代码。'
- en: '**Compile-time safety**: Compile-time safety is a key feature, catching serialization-related
    errors during the compilation phase and reducing the likelihood of runtime errors.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时安全性**：编译时安全性是一个关键特性，在编译阶段捕获与序列化相关的错误，并减少运行时错误的可能性。'
- en: '**Custom serialization strategies**: We have the flexibility to define custom
    serialization strategies for specific types or scenarios, offering fine-grained
    control over the serialization process.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义序列化策略**：我们有灵活性为特定类型或场景定义自定义序列化策略，提供对序列化过程的精细控制。'
- en: '**Seamless integration with Kotlin ecosystem**: Being part of the Kotlin ecosystem,
    Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks,
    contributing to a cohesive development experience.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与 Kotlin 生态系统的无缝集成**：作为 Kotlin 生态系统的一部分，Kotlinx 序列化与其它 Kotlin 库和框架无缝集成，有助于提供一致的开发体验。'
- en: '**OkHttp**: This is an HTTP client that is used to make network requests. It
    provides some utilities for working with Retrofit.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OkHttp**：这是一个用于发送网络请求的 HTTP 客户端。它为使用 Retrofit 提供了一些实用工具。'
- en: 'All these dependencies will be added together, so this is a chance for us to
    group them in our `libs.versions.toml` file, add this bundle below our Koin bundle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些依赖项都将一起添加，因此这是我们可以在我们的 `libs.versions.toml` 文件中将它们分组的机会，在 Koin 包下面添加此包：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we create a new bundle called `networking` and add all the dependencies
    that we specified earlier on. We have to sync the project for our changes to be
    added to the project. Tap on `libs.versions.toml` file. After syncing, let us
    start setting up the plugins and dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `networking` 的新包，并添加了之前指定的所有依赖项。我们必须同步项目，以便将我们的更改添加到项目中。点击 `libs.versions.toml`
    文件。同步后，让我们开始设置插件和依赖项。
- en: 'First, in our project-level `build.gradle.kts` file, we need to add the Kotlinx
    serialization plugin. Open the project-level `build.gradle.kts` file and on the
    plugins block add the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的项目级别 `build.gradle.kts` 文件中，我们需要添加 Kotlinx 序列化插件。打开项目级别的 `build.gradle.kts`
    文件，并在插件块中添加以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We define the Kotlinx serialization plugin and specify the version to use.
    This will set up the Kotlinx serialization plugin for us. The plugin generates
    Kotlin code for serializable classes. We will use this plugin to generate our
    models. Next, let us set up the plugin in our app module. Open the app-level `build.gradle.kts`
    file and add the following in the plugins block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 Kotlinx 序列化插件并指定了要使用的版本。这将为我们设置 Kotlinx 序列化插件。该插件为可序列化类生成 Kotlin 代码。我们将使用此插件来生成我们的模型。接下来，让我们在我们的应用模块中设置此插件。打开应用级别的
    `build.gradle.kts` 文件，并在插件块中添加以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This ensures our module is set up to use the Kotlinx serialization plugin.
    Next, we will add our `networking` bundle to our app module. In the app-level
    `build.gradle.kts` file, add the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们的模块已设置好以使用 Kotlinx 序列化插件。接下来，我们将添加我们的 `networking` 包到我们的应用模块中。在应用级别的 `build.gradle.kts`
    文件中，添加以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will add all the dependencies that we have specified in our `networking`
    bundle. Having done all these, our project is set up to use Retrofit. We will
    be using Koin to create a Retrofit instance that will be injected into classes
    that need it. Let us head over to the `Module.kt` file and add the `PetsViewModel`
    definition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加我们在 `networking` 包中指定的所有依赖项。完成所有这些后，我们的项目已设置好以使用 Retrofit。我们将使用 Koin 创建一个
    Retrofit 实例，该实例将被注入到需要它的类中。让我们转到 `Module.kt` 文件并添加 `PetsViewModel` 定义：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we created a Retrofit instance using the Retrofit builder.
    We also added a converter factory that uses Kotlinx serialization to convert Kotlin
    objects to and from JSON. We also specified the base URL for our API. We are using
    the `CatsAPI.kt` and add the following method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 Retrofit 构建器创建了 Retrofit 实例。我们还添加了一个使用 Kotlinx 序列化来将 Kotlin 对象转换为
    JSON 并从 JSON 转换回 Kotlin 对象的转换器工厂。我们还指定了我们的 API 的基本 URL。我们使用 `CatsAPI.kt` 并添加以下方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we use the `@GET` annotation to specify that we will
    be using the `GET` HTTP method for this request. Inside the method, we are also
    specifying a path that will be appended to our base URL to make the full URL for
    our request. Using the `GET` method means our method will only request data. We
    have the following built-in HTTP annotations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `@GET` 注解来指定我们将使用 `GET` HTTP 方法进行此请求。在方法内部，我们还指定了一个将被附加到我们的基本 URL
    的路径，以形成请求的完整 URL。使用 `GET` 方法意味着我们的方法将只请求数据。我们有以下内置的 HTTP 注解：
- en: '**POST**: This is used when we want to send data to the server'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：当我们想要向服务器发送数据时使用'
- en: '**PUT**: This is used when we want to update data on the server'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**: 这用于当我们想要在服务器上更新数据时'
- en: '**DELETE**: This is used when we want to delete data from the server'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**: 这用于当我们想要从服务器删除数据时'
- en: '**HEAD**: This method asks for a response identical to the one that would correspond
    to a **GET** request but without the response body'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**: 此方法请求与**GET**请求相对应的响应，但不包含响应体'
- en: '**PATCH**: This is used when we want to update data partially on the server'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**: 这用于当我们想要在服务器上部分更新数据时'
- en: '**OPTIONS**: This method requests permitted communication options for the target
    resource'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPTIONS**: 此方法请求目标资源的允许通信选项'
- en: 'Back to our `fetchCats()` function, you can notice that we use the `@Query`
    annotation to specify the query parameter for our request. We use the `tag` query
    parameter to specify the type of cat we want to fetch. We also use the `suspend`
    keyword to specify that this method will be called from a coroutine or another
    `suspend` function. We will learn more about coroutines shortly in the *Introduction
    to Kotlin coroutines* section of this chapter. We also use the `Response` class
    to wrap up our response. This class is provided by Retrofit and it contains the
    HTTP response metadata such as response code, headers, and the raw response body.
    We also specify that the response will be a list of `Cat` objects. Retrofit will
    map the response to a list of `Cat` objects. To resolve the error for the `Cat`
    `data class`, let us create it. Create a new Kotlin data class inside the data
    package called `Cat.kt` and add the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`fetchCats()`函数，你可以注意到我们使用了`@Query`注解来指定请求的查询参数。我们使用`tag`查询参数来指定我们想要获取的猫的类型。我们还使用了`suspend`关键字来指定这个方法将从协程或另一个`suspend`函数中被调用。我们将在本章的*Kotlin协程简介*部分稍后了解更多关于协程的内容。我们还使用了`Response`类来封装我们的响应。这个类由Retrofit提供，它包含了HTTP响应元数据，如响应代码、头信息和原始响应体。我们还指定响应将是一个`Cat`对象的列表。Retrofit会将响应映射到一个`Cat`对象的列表。为了解决`Cat`数据类的错误，让我们创建它。在数据包内创建一个新的Kotlin数据类，命名为`Cat.kt`，并添加以下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Cat` data class has the fields that correspond to the JSON response from
    the Cat as a Service API. It is also annotated with the `@Serializable` annotation.
    This annotation is provided by Kotlinx Serialization and it is used to mark a
    class as serializable. This annotation is required for all the classes that we
    want to serialize or deserialize. We have used the `@SerialName` annotation before
    each variable in our data class. The `@SerialName` is an annotation used to customize
    the mapping between Kotlin property names and the corresponding names used in
    the serialized form, such as JSON or other data interchange formats. This annotation
    allows you to specify a different name for a property when it is serialized or
    deserialized, providing flexibility in handling naming conventions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cat`数据类具有与Cat as a Service API的JSON响应相对应的字段。它还注解了`@Serializable`注解。这个注解由Kotlinx
    Serialization提供，它用于标记一个类为可序列化。这个注解对于所有我们想要序列化或反序列化的类都是必需的。我们在数据类的每个变量之前使用了`@SerialName`注解。`@SerialName`是一个用于自定义Kotlin属性名与序列化形式（如JSON或其他数据交换格式）中相应名称之间映射的注解。这个注解允许你在序列化或反序列化时为属性指定不同的名称，从而在处理命名约定时提供灵活性。'
- en: 'In our project, we are using Koin for dependency injection. So, we now need
    to create an instance of our `CatsAPI` class in our Koin modules. Let us head
    back to the `Module.kt` file and below the Retrofit instance add the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用Koin进行依赖注入。因此，我们现在需要在我们的Koin模块中创建`CatsAPI`类的实例。让我们回到`Module.kt`文件，并在Retrofit实例下面添加以下内容：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we get our Retrofit instance and use it to create an instance of our `CatsAPI`
    class, which we use to make the actual network requests. With that, our project
    is ready to make the network requests. But before that, let us learn more about
    Kotlin coroutines as we are going to modify our repository to use coroutines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取我们的Retrofit实例，并使用它来创建我们的`CatsAPI`类的实例，我们使用它来执行实际的网络请求。有了这个，我们的项目就准备好执行网络请求了。但在那之前，让我们更多地了解Kotlin协程，因为我们将修改我们的仓库以使用协程。
- en: Introduction to Kotlin coroutines
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin协程简介
- en: 'Coroutines, introduced by JetBrains for Kotlin, provide a way to write asynchronous
    code in a more readable and synchronous manner. We can use them to perform background
    tasks and they are a great way to perform network requests and long-running tasks
    such as reading and writing to a database. They do these tasks off the main thread
    and ensure that we don’t block our main thread while performing these operations.
    The main benefits of using coroutines are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains 为 Kotlin 引入的协程提供了一种以更可读和同步的方式编写异步代码的方法。我们可以使用它们来执行后台任务，它们是执行网络请求和长时间运行任务（如读取和写入数据库）的绝佳方式。它们在主线程之外执行这些任务，并确保我们在执行这些操作时不会阻塞主线程。使用协程的主要好处如下：
- en: They are lightweight and easy to use.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们轻量级且易于使用。
- en: They have built-in cancellation support.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们内置了取消支持。
- en: They lower the chances of apps having memory leaks.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们降低了应用出现内存泄漏的可能性。
- en: As mentioned in earlier chapters, Jetpack libraries also support and use coroutines.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前几章所述，Jetpack 库也支持并使用协程。
- en: We have already added the core and Android coroutines libraries in our app.
    Let us understand some coroutines basics before proceeding to use coroutines in
    our project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将核心和 Android 协程库添加到我们的应用中。在继续在项目中使用协程之前，让我们先了解一些协程基础知识。
- en: Coroutine basics
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程基础
- en: 'In this section, we will be looking at different terms and concepts used in
    Kotlin coroutines:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在 Kotlin 协程中使用的不同术语和概念：
- en: '**suspend**: This is a keyword that is used to mark a function. A **suspend**
    function is a function that can be paused and resumed at a later time. We have
    already used this keyword in our **CatsAPI** class to mark the **fetchCats()**
    function as a **suspend** function. A **suspend** function can only be called
    from another **suspend** function or from a coroutine.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：这是一个用于标记函数的关键字。**挂起**函数是可以暂停并在稍后恢复的函数。我们已经在**CatsAPI**类中使用此关键字将**fetchCats()**函数标记为**挂起**函数。**挂起**函数只能从另一个**挂起**函数或从协程中调用。'
- en: '**Coroutine builders**: These are functions that are used to create coroutines.
    We have the **launch** and **async** coroutine builders. **launch** is used to
    create a coroutine that does not return a result while **async** is used to create
    a coroutine that returns a result. The result is a **Deferred** object and we
    can use the **await()** method to get the result. Both of these builders return
    a **Job** object that we can use to check if the coroutine is still active or
    if it has been canceled. We can also use the job to wait for the coroutine to
    finish. A job ends when it’s completed or canceled.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程构建器**：这些是用于创建协程的函数。我们有**启动**和**异步**协程构建器。**启动**用于创建不返回结果的协程，而**异步**用于创建返回结果的协程。结果是**延迟**对象，我们可以使用**await()**方法来获取结果。这两个构建器都返回一个**作业**对象，我们可以用它来检查协程是否仍然活跃或已被取消。我们还可以使用作业来等待协程完成。作业在完成或取消时结束。'
- en: '**Jobs**: A job is a coroutine instance with a **life cycle** and can be canceled.
    We can use the job to check if the coroutine is still active or if it has been
    canceled. We can also use the job to wait for the coroutine to finish. A job ends
    when it’s completed or canceled. As mentioned earlier, both the **launch** and
    **async** coroutine builders return a **Job** object which we use to manage the
    coroutine life cycle. We have a normal **Job** and **SupervisorJob**. A normal
    **Job** is canceled when any of its children fail. **SupervisorJob** is not canceled
    when any of its children fail. It is recommended to use **SupervisorJob** when
    we have multiple coroutines running concurrently.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：作业是一个具有**生命周期**的协程实例，可以被取消。我们可以使用作业来检查协程是否仍然活跃或已被取消。我们还可以使用作业来等待协程完成。作业在完成或取消时结束。如前所述，**启动**和**异步**协程构建器都返回一个**作业**对象，我们使用它来管理协程的生命周期。我们有一个普通的**作业**和一个**监督作业**。当任何子作业失败时，普通的**作业**会被取消。**监督作业**在子作业失败时不会被取消。当有多个协程同时运行时，建议使用**监督作业**。'
- en: '**Coroutine scope**: This keeps track of all the coroutines we create using
    the **launch** or **async** builders. It is responsible for knowing how long a
    coroutine will live. Every coroutine builder is defined as an extension function
    of scope. Coroutines cannot be launched without a scope. We have **GlobalScope**,
    which is a scope that is not tied to any life cycle. It is not recommended to
    use this scope as it can lead to memory leaks. In Android, the KTX libraries provide
    **viewModelScope**, which is a scope that is tied to **ViewModel**. We can use
    this scope to launch coroutines that will be canceled when **ViewModel** is destroyed.
    We also have **lifecycleScope**, which is a scope that is tied to an activity
    or fragment life cycle. We can use this scope to launch coroutines that will be
    canceled when the life cycle is destroyed. We can also create our own custom scopes
    if we want to launch coroutines that will be canceled when a custom life cycle
    is destroyed.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程作用域（Coroutine scope）**：这跟踪我们使用**launch**或**async**构建器创建的所有协程。它负责知道协程将存活多久。每个协程构建器都被定义为作用域的扩展函数。没有作用域就无法启动协程。我们有**GlobalScope**，这是一个与任何生命周期无关的作用域。不建议使用此作用域，因为它可能导致内存泄漏。在Android中，KTX库提供了**viewModelScope**，这是一个与**ViewModel**相关联的作用域。我们可以使用此作用域来启动当**ViewModel**被销毁时将取消的协程。我们还有**lifecycleScope**，这是一个与活动或片段生命周期相关联的作用域。我们可以使用此作用域来启动当生命周期被销毁时将取消的协程。我们还可以创建自己的自定义作用域，如果我们想启动当自定义生命周期被销毁时将取消的协程。'
- en: '**Coroutine context**: This is a collection of many elements. **CoroutineContext**
    defines the behavior of our coroutines using elements such as the following:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程上下文（Coroutine context）**：这是一个包含许多元素的集合。**CoroutineContext**使用如下元素等定义了我们的协程的行为：'
- en: '**Job**: This manages the life cycle of the coroutine.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业（Job）**：这管理协程的生命周期。'
- en: '**CoroutineDispatcher**: This defines the thread on which the coroutine will
    run.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程调度器（CoroutineDispatcher）**：这定义了协程将在哪个线程上运行。'
- en: '**CoroutineName**: This defines the name of the coroutine.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程名称（CoroutineName）**：这定义了协程的名称。'
- en: '**CoroutineExceptionHandler**: This handles uncaught exceptions in the coroutine.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程异常处理器（CoroutineExceptionHandler）**：这用于处理协程中的未捕获异常。'
- en: '`withContext()` function to switch between different dispatchers. `withContext()`
    is a `suspend` function that switches the context of the coroutine.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withContext()`函数用于在不同调度器之间切换。`withContext()`是一个**挂起**函数，它切换协程的上下文。'
- en: '**Flows**: Suspend functions only return single values. Flows are a type of
    asynchronous data stream that can return multiple values. We can use flows to
    return multiple values from a **suspend** function. We can also use flows to perform
    asynchronous operations. Flows are **cold streams**. This means that they only
    start emitting values when they are collected. We can use the **collect()** function
    to collect values from a flow. We have **StateFlow** and **SharedFlow**, which
    are types of flows. **StateFlow** is a flow that emits the current value to new
    collectors and emits new values to existing collectors. **SharedFlow** is a flow
    that emits new values to all collectors. We will be learning more about flows
    in the next chapter. In Android, we will normally use the two types of flows to
    emit data to our UI. We will see the usage of **StateFlow** in **ViewModel** as
    we refactor it to use coroutines.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流（Flows）**：挂起函数仅返回单个值。流是一种可以返回多个值的异步数据流。我们可以使用流从**挂起**函数返回多个值。我们还可以使用流来执行异步操作。流是**冷流**。这意味着它们只有在被收集时才开始发出值。我们可以使用**collect()**函数从流中收集值。我们有**StateFlow**和**SharedFlow**，它们是流的一种类型。**StateFlow**是一种流，它将当前值发送给新的收集器，并将新值发送给现有的收集器。**SharedFlow**是一种将新值发送给所有收集器的流。我们将在下一章中学习更多关于流的内容。在Android中，我们通常使用这两种类型的流将数据发射到我们的UI。我们将看到**StateFlow**在**ViewModel**重构时使用协程的用法。'
- en: With this understanding of the basics, in the next section, we will be refactoring
    our repository to use coroutines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对基础知识的理解，在下一节中，我们将重构我们的仓库以使用协程。
- en: Using Kotlin coroutines for network calls
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin协程进行网络调用
- en: In this section, we will refactor our repository to use coroutines. We will
    use `StateFlow` to emit data from `ViewModel` to the view layer. We will also
    use the `Dispatchers.IO` dispatcher to perform our network requests on a background
    thread.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构我们的仓库以使用协程。我们将使用`StateFlow`从`ViewModel`向视图层发射数据。我们还将使用`Dispatchers.IO`调度器在后台线程上执行我们的网络请求。
- en: 'Let us start by creating a `NetworkResult` `sealed class`, which will represent
    the different states of our network request:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个`NetworkResult`密封类，它将表示我们的网络请求的不同状态：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `NetworkResult` class is a sealed class that has two subclasses. We have
    the `Success` data class that will be used to represent a successful network request.
    It has a data property that will be used to hold the data returned from the network
    request. We also have the `Error` class, which will be used to represent a failed
    network request. It has an `error` property that will be used to hold the error
    message returned from the network request. The sealed class encapsulates a generic
    data type `T`, which makes it easier for us to reuse the class in all our network
    calls. The `Success` data class also has a generic parameter for the same purpose.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkResult`类是一个密封类，有两个子类。我们有`Success`数据类，它将用于表示成功的网络请求。它有一个数据属性，将用于存储从网络请求返回的数据。我们还有`Error`类，它将用于表示失败的网络请求。它有一个`error`属性，将用于存储从网络请求返回的错误信息。密封类封装了一个泛型数据类型`T`，这使得我们更容易在所有网络调用中重用该类。`Success`数据类也有一个泛型参数，出于相同的目的。'
- en: 'Next, let us modify `PetsRepository` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式修改`PetsRepository`：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have updated the interface to use the `NetworkResult` class. We have also
    marked the `getPets()` function as a `suspend` function. We will use this method
    to fetch the cats from the API. Next, let us modify `PetsRepositoryImpl` to add
    the changes from `PetsRepository`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更新界面以使用`NetworkResult`类。我们还将`getPets()`函数标记为`suspend`函数。我们将使用此方法从API获取猫。接下来，让我们修改`PetsRepositoryImpl`以添加来自`PetsRepository`的更改：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have changed a number of things here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们更改了许多事情：
- en: First, we added a constructor that takes in an instance of our **CatsAPI** class,
    which we will use to make our network requests. It also has a **dispatcher** parameter,
    which will be used to specify the dispatcher that we will use to perform our network
    requests. We will use the **Dispatchers.IO** dispatcher to perform our network
    requests on a background thread.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个构造函数，它接受我们的**CatsAPI**类的实例，我们将使用它来发出网络请求。它还有一个**dispatcher**参数，它将用于指定我们将用于执行网络请求的调度器。我们将使用**Dispatchers.IO**调度器在后台线程上执行我们的网络请求。
- en: We have also changed the return type of the **getPets()** function to **NetworkResult<List<Cat>>**.
    This is because we will return a **NetworkResult** object from this method.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将`getPets()`函数的返回类型更改为`NetworkResult<List<Cat>>`。这是因为我们将从这个方法返回一个`NetworkResult`对象。
- en: We use the **withContext()** function to switch the context of the coroutine
    to the **Dispatchers.IO** dispatcher. This ensures that the network request is
    performed on a background thread.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**withContext()**函数将协程的上下文切换到**Dispatchers.IO**调度器。这确保了网络请求是在后台线程上执行的。
- en: We have also wrapped our network request in a **try-catch** block. This is to
    ensure we catch all the errors that might occur during the network request.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将在**try-catch**块中包装我们的网络请求。这是为了确保我们捕获网络请求过程中可能发生的所有错误。
- en: Inside our **try** block, we are making the network request using our **CatsAPI**
    instance. We use the **fetchCats()** method to make the request. We pass in the
    **cute** tag to specify the type of cats we want to fetch. We check if the response
    is successful. If it is, we return a **NetworkResult.Success** object with the
    response body. If it is not, we return a **NetworkResult.Error** object with the
    error message.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的**try**块内部，我们使用我们的**CatsAPI**实例发出网络请求。我们使用**fetchCats()**方法发出请求。我们传递**cute**标签来指定我们想要获取的猫的类型。我们检查响应是否成功。如果是，我们返回一个包含响应体的**NetworkResult.Success**对象。如果不是，我们返回一个包含错误信息的**NetworkResult.Error**对象。
- en: Lastly, we catch all the exceptions that might occur during the network request
    and return a **NetworkResult.Error** object with the error message.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们捕获网络请求过程中可能发生的所有异常，并返回一个包含错误信息的**NetworkResult.Error**对象。
- en: 'In our Koin modules, we also need to change how we instantiate our repository.
    Let us head over to `Module.kt` and update the `PetsRepository` definition as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Koin模块中，我们还需要更改我们实例化我们的仓库的方式。让我们转到`Module.kt`并更新`PetsRepository`定义如下：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We inject the `CatsAPI` instance and the `dispatcher` into our repository.
    We also declare the dispatcher as a single instance. Now we need to modify our
    `PetsViewModel` to accommodate these changes. To begin with, we need to create
    a state class that holds the state of our network request and exposes it to our
    view. Create a new Kotlin data class inside the `view` package called `PetsUIState.kt`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `CatsAPI` 实例和 `dispatcher` 注入到我们的仓库中。我们还声明 `dispatcher` 为一个单例实例。现在我们需要修改我们的
    `PetsViewModel` 以适应这些更改。首先，我们需要创建一个状态类来保存我们的网络请求状态并将其暴露给我们的视图。在 `view` 包中创建一个新的
    Kotlin 数据类，命名为 `PetsUIState.kt`：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `PetsUIState` class is a data class that holds the state of our network
    request. It has three properties:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetsUIState` 类是一个数据类，用于保存我们的网络请求状态。它有三个属性：'
- en: '**isLoading**: This is a Boolean that is used to indicate whether the network
    request is loading or not.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isLoading**：这是一个布尔值，用于指示网络请求是否正在加载。'
- en: '**pets**: This is a list of cats that will be returned from the network request.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pets**：这是一个将从网络请求返回的猫的列表。'
- en: '**error**: This is a string that will be used to hold the error message returned
    from the network request.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：这是一个字符串，将用于保存从网络请求返回的错误信息。'
- en: 'Next, in `PetsViewModel`, let us create a variable that will hold the state
    of our network request:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `PetsViewModel` 中，让我们创建一个变量来保存我们的网络请求状态：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use the `MutableStateFlow` class to hold the state of our network request.
    `MutableStateFlow` allows us to update the value of the state. We initialize it
    with an empty `PetsUIState` object. Next, let us update the `getPets()` method
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `MutableStateFlow` 类来保存我们的网络请求状态。`MutableStateFlow` 允许我们更新状态的值。我们用空的 `PetsUIState`
    对象初始化它。接下来，让我们更新 `getPets()` 方法如下：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we will break down the preceding code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将分解前面的代码：
- en: We update the value of the **petsUIState** variable to indicate that the network
    request is loading.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新 **petsUIState** 变量的值以指示网络请求正在加载。
- en: We use **viewModelScope** to launch a coroutine. This ensures that the coroutine
    is canceled when the **ViewModel** is destroyed.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 **viewModelScope** 来启动一个协程。这确保了当 **ViewModel** 被销毁时，协程将被取消。
- en: There is a **when** statement, which is a Kotlin pattern-matching feature to
    check the result of the network request. If the result is a **NetworkResult.Success**
    object, we update the value of **petsUIState** to indicate that the network request
    was successful and passed in the list of cats. If the result is a **NetworkResult.Error**
    object, we update the value of **petsUIState** to indicate that the network request
    failed and pass in the error message.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 **when** 语句，这是 Kotlin 的模式匹配功能，用于检查网络请求的结果。如果结果是 **NetworkResult.Success**
    对象，我们将更新 **petsUIState** 的值以指示网络请求成功，并传入猫的列表。如果结果是 **NetworkResult.Error** 对象，我们将更新
    **petsUIState** 的值以指示网络请求失败，并传入错误信息。
- en: 'In `PetsViewModel`, let us add a new `init` block that will call the `getPets()`
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PetsViewModel` 中，让我们添加一个新的 `init` 块，该块将调用 `getPets()` 函数：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will ensure that the `getPets()` function is called when `ViewModel` is
    created. We now need to update our `PetList` composable to accommodate these changes,
    too. We will also add more UI components since we need to show the loading state,
    images, and error messages. Let us start by adding a library that allows us to
    load images from a URL. We will use Coil ([https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/)),
    which is an image-loading library. In the versions catalog, let’s add the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在创建 `ViewModel` 时调用 `getPets()` 函数。我们现在需要更新我们的 `PetList` 可组合组件以适应这些更改，我们还将添加更多的
    UI 组件，因为我们需要显示加载状态、图片和错误信息。让我们首先添加一个允许我们从 URL 加载图片的库。我们将使用 Coil ([https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/))，这是一个图像加载库。在版本目录中，让我们添加以下内容：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will also add the `coil-compose` dependency to our `compose` bundle so that
    it can be provided alongside other compose libraries. The updated compose bundle
    will be as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向 `compose` 包添加 `coil-compose` 依赖项，以便它可以与其他 compose 库一起提供。更新的 `compose`
    包将如下所示：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us now create a new composable that displays an image and tags for each
    cat inside the `view` package called `PetListItem.kt` and add the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在名为 `PetListItem.kt` 的 `view` 包中创建一个新的可组合组件，用于显示每只猫的图片和标签，并添加以下内容：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This composable takes in a `Cat` object and displays the image and tags for
    the cat. We use the `AsyncImage` composable from the Coil library to load the
    image from the URL. We also use the `FlowRow` composable to display the tags for
    the cat. We use the `SuggestionChip` composable to display each tag. We display
    the image and tags in the `ElevatedCard` composable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此可组合组件接受一个`Cat`对象，并显示猫咪的图片和标签。我们使用Coil库中的`AsyncImage`可组合组件从URL加载图片。我们还使用`FlowRow`可组合组件显示猫咪的标签。我们使用`SuggestionChip`可组合组件显示每个标签。我们在`ElevatedCard`可组合组件中显示图片和标签。
- en: 'Next, let us update our `PetList` composable to accommodate these changes.
    In the `PetList.kt` file, update the `PetList` composable as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新我们的`PetList`可组合组件以适应这些更改。在`PetList.kt`文件中，更新`PetList`可组合组件如下：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the breakdown of the preceding code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的分解：
- en: Same as before, we use the **koinViewModel()** function to get an instance of
    **PetsViewModel**.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前一样，我们使用**koinViewModel()**函数来获取**PetsViewModel**的一个实例。
- en: We use the **collectAsStateWithLifecycle()** function to collect the state of
    our network request. This function is provided by the **lifecycle-runtime-compose**
    library. It is used to collect the state of a flow and automatically cancel the
    collection when the life cycle is destroyed. We use the **petsUIState** property
    of **PetsViewModel** to get the state of our network request.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**collectAsStateWithLifecycle()**函数来收集我们的网络请求状态。此函数由**lifecycle-runtime-compose**库提供。它用于收集流的状态，并在生命周期被销毁时自动取消收集。我们使用**PetsViewModel**的**petsUIState**属性来获取我们的网络请求状态。
- en: We have a **Column** composable that contains three **AnimatedVisibility** composables.
    The first one is used to display a **CircularProgressIndicator** when the network
    request is loading. The second one is used to display the list of cats when the
    network request is successful. The last one is used to display an error message
    when the network request fails.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个**列**可组合组件，它包含三个**动画可见性**可组合组件。第一个用于在网络请求加载时显示**CircularProgressIndicator**。第二个用于在网络请求成功时显示猫咪列表。最后一个用于在网络请求失败时显示错误信息。
- en: 'The `collectAsStateWithLifecycle()` shows an error since we have not added
    its dependency. Let us add it to our libraries section in the versions catalog
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectAsStateWithLifecycle()`显示了一个错误，因为我们还没有添加其依赖项。让我们将其添加到版本目录中的库部分，如下所示：'
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will also add it to our `compose` bundle so that it can be provided alongside
    other compose libraries. The updated compose bundle will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将将其添加到我们的`compose`包中，以便它可以与其他`compose`库一起提供。更新后的`compose`包如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Do a Gradle sync and the IDE will prompt you to add imports for the `collectAsStateWithLifecycle()`
    function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Gradle同步，IDE将提示您为`collectAsStateWithLifecycle()`函数添加导入。
- en: 'We have completed updating all our layers to use the new coroutines approach.
    Good work so far! One last thing: since our app is now fetching these items from
    an API hosted online, we need to add the `INTERNET` permission to our app. Open
    the `AndroidManifest.xml file` and add the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有层的更新，以使用新的协程方法。到目前为止做得很好！最后一件事：由于我们的应用现在是从在线托管API中获取这些项目，我们需要向我们的应用添加`INTERNET`权限。打开`AndroidManifest.xml`文件，并添加以下内容：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the app and see if everything is working as expected. We can see a list
    of cute cats with their tags being displayed. We can also see the loading indicator
    when the network request is loading and the error message when the network request
    fails. We have successfully refactored our app to use coroutines.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并查看一切是否按预期工作。我们可以看到显示标签的可爱猫咪列表。我们还可以看到网络请求加载时的加载指示器以及网络请求失败时的错误信息。我们已经成功重构了我们的应用以使用协程。
- en: '![Figure 6.1 – Cute cats](img/B19779_06_01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 可爱的猫咪](img/B19779_06_01.jpg)'
- en: Figure 6.1 – Cute cats
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 可爱的猫咪
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to perform network calls with Retrofit. Moreso,
    we learned how to take advantage of Kotlin coroutines to perform asynchronous
    network requests in our app and refactored our app to fetch some cute cats with
    Kotlin coroutines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Retrofit执行网络调用。更重要的是，我们学习了如何利用Kotlin协程在我们的应用中执行异步网络请求，并使用Kotlin协程重构了我们的应用以获取一些可爱的猫咪。
- en: In the next chapter, we will be looking at another Jetpack library, **Jetpack
    Navigation**, to handle navigation in our app.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个Jetpack库，**Jetpack Navigation**，以处理我们的应用中的导航。
