- en: Chapter 8. Integrating with Objective-C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。与 Objective-C 集成
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Calling a cab
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叫车
- en: Hiring a van
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 租赁货车
- en: Porting your code from one language to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码从一个语言移植到另一个语言
- en: Replacing the user interface classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换用户界面类
- en: Upgrading the app delegate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级应用程序代理
- en: Creating your own custom framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的自定义框架
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Swift 2 is out, and we can see that it is going to replace Objective-C on iOS
    development sooner or later, however how should you migrate your Objective-C app?
    Is it necessary to rewrite everything again?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 已经发布，我们可以看到它迟早会取代 Objective-C 在 iOS 开发中的应用，然而你应该如何迁移你的 Objective-C 应用程序？是否需要重新编写一切？
- en: Of course you don't have to rewrite a whole application in Swift from scratch,
    you can gradually migrate it. Imagine a four year old app developed by 10 developers,
    it would take a long time to be rewritten.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必从头开始用 Swift 重新编写整个应用程序，你可以逐步迁移它。想象一下，一个由 10 个开发者开发的四岁应用程序，重新编写将花费很长时间。
- en: Actually, you've already seen that some of the codes we've used in this book
    have some kind of "old Objective-C fashion". The reason is that not even Apple
    computers could migrate the whole Objective-C code into Swift.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你已经看到我们在这本书中使用的一些代码具有某种“旧的 Objective-C 风格”。原因是即使是苹果电脑也无法将整个 Objective-C
    代码迁移到 Swift。
- en: This chapter will help you migrate from Objective-C to Swift, step by step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你逐步从 Objective-C 迁移到 Swift。
- en: Calling a cab
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叫车
- en: Let's imagine that we work for a taxi company, which already has an app that
    allows the clients to call a taxi from it. As you may imagine, the company can
    start giving additional services rather than only using traditional cars, for
    example, let's imagine that now they want to offer hiring a van for people that
    have a lot of luggage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们为一家出租车公司工作，该公司已经有一个应用程序，允许客户从该应用程序中叫出租车。正如你可能想象的那样，公司可以开始提供额外的服务，而不仅仅是使用传统的汽车，例如，让我们想象一下，现在他们想要为携带大量行李的人提供租赁货车的服务。
- en: In this recipe we are going to start with a pure Objective-C application, after
    which we are going to modify it for being prepared to add a Swift code in the
    future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从一个纯 Objective-C 应用程序开始，然后我们将对其进行修改，以便为将来添加 Swift 代码做好准备。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s start by creating a project called `Chapter 8 Cab`, but in this case
    select Objective-C instead of Swift as the programming language:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `Chapter 8 Cab` 的项目开始，但在这个案例中，选择 Objective-C 而不是 Swift 作为编程语言：
- en: '![Getting ready](img/00095.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00095.jpeg)'
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: First, create a new file to your project, select **Cocoa Touch Class,** which
    is located on the upper right-hand side of the iOS source:![How to do it…](img/00096.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的项目中创建一个新文件，选择右上角的 iOS 源中的 **Cocoa Touch Class**：![如何做到这一点…](img/00096.jpeg)
- en: Then create a file called `Car`, which should be a subclass of `NSObject`:![How
    to do it…](img/00097.jpeg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个名为 `Car` 的文件，它应该是 `NSObject` 的子类：![如何做到这一点…](img/00097.jpeg)
- en: You will see that two files are created, one is called `Car.h` and the other
    one is called `Car.m`.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到创建了两个文件，一个是 `Car.h`，另一个是 `Car.m`。
- en: 'Click on the header file (`Car.h`) and add the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击头文件（`Car.h`）并添加以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the class interface is created, we have to implement this class, so click
    on the file `Car.m` and type the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了类接口，我们必须实现这个类，因此点击文件 `Car.m` 并输入以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The model part is done, now we need to create the view part.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型部分已完成，现在我们需要创建视图部分。
- en: Let's do something very straightforward, just add a table view onto the storyboard,
    and then link it with the view controller as an attribute, as a data source, and
    as a delegate.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们做一些非常直接的事情，只需将一个表格视图添加到故事板中，然后将其与视图控制器作为属性、数据源和代理链接。
- en: 'As you have to modify the header file (usually called `ViewController.h`),
    add an auxiliary attribute called `vehicles` of type `NSArray`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你必须修改头文件（通常称为 `ViewController.h`），请添加一个名为 `vehicles` 的辅助属性，其类型为 `NSArray`：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To add some functionality to this app, go to the message file (usually called
    `ViewController.m`).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向此应用程序添加一些功能，请转到消息文件（通常称为 `ViewController.m`）。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Switching from the header file to its implementation or vice versa can be done
    using ** + *^* + up arrow.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从头文件切换到其实施或反之亦然可以使用 ** + *^* + 上箭头。
- en: 'First let''s import the `Car.h` file:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入 `Car.h` 文件：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add the data source content:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加数据源内容：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you have to initialize the vehicle''s attributes. Of course, here, we
    are going to use just some hard code, otherwise we would have a huge amount of
    code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须初始化车辆的属性。当然，在这里，我们只是使用一些硬编码，否则我们会有一大堆代码：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last thing we need to do is create an event for the user for letting him
    choose a car for booking:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是为用户创建一个事件，让他可以选择预订的汽车：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now test this app just to see that it is working. The next step is preparing
    this app to receive some Swift code. Before adding any Swift file we need to modernize
    this code; fortunately Xcode offers an option that does it automatically, so click
    on the **Edit** menu, then choose **Refactor**, and finally **Convert to Modern
    Objective-C Syntax…**:![How to do it…](img/00098.jpeg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试这个应用程序，只是为了看看它是否在正常工作。下一步是为这个应用程序准备接收一些 Swift 代码。在我们添加任何 Swift 文件之前，我们需要更新这段代码；幸运的是，Xcode
    提供了一个自动执行此操作的选项，所以点击 **编辑** 菜单，然后选择 **重构**，最后选择 **转换为现代 Objective-C 语法…**:![如何操作…](img/00098.jpeg)
- en: Tip
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before you start modernizing your code, it's a good idea to commit your code
    on the version control system, if you are using one.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开始更新你的代码之前，如果你使用版本控制系统，提交你的代码是一个好主意。
- en: When a dialog appears with some introduction text, press **Next**, then check
    every target that appears on the next dialog, usually they are checked but just
    in case make sure of it. On the next screen, you will see some options to modernize
    your Objective-C code, you can leave all of them with their default values, but
    it is a better idea to make sure that every option is marked "yes":![How to do
    it…](img/00099.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现一个带有一些介绍文本的对话框时，按 **下一步**，然后在下一个对话框中检查出现的每个目标，通常它们是勾选的，但以防万一，请确保这一点。在下一个屏幕上，你会看到一些用于现代化你的
    Objective-C 代码的选项，你可以保留所有选项的默认值，但更好的做法是确保每个选项都标记为“是”![如何操作…](img/00099.jpeg)
- en: After that, you will see another dialog displaying the differences between the
    original code and the one that is going to be updated. Check the differences of
    each file by clicking on the filenames on the left-hand side:![How to do it…](img/00100.jpeg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你会看到一个显示原始代码和将要更新的代码之间差异的另一个对话框。通过点击左侧的文件名来检查每个文件的差异：![如何操作…](img/00100.jpeg)
- en: Tip
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid modernizing your code without checking the differences between the old
    and the new code, sometimes you will find modifications that are not conceptually
    right.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免在不检查旧代码和新代码之间差异的情况下更新你的代码，有时你会发现一些概念上不正确的修改。
- en: Press **Save** and you will see a new dialog asking if you would like to enable
    automatic snapshots:![How to do it…](img/00101.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **保存**，你将看到一个新对话框询问你是否想启用自动快照：![如何操作…](img/00101.jpeg)
- en: Now check that your project has the code changed and it still works as before.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查你的项目代码已更改，并且仍然像以前一样工作。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you migrate your Objective-C application to Swift, the first thing that
    you need to do is convert your code to Modern Objective-C Syntax. Thanks to this
    your code will be ready for being compatible with Swift integration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将你的 Objective-C 应用程序迁移到 Swift 时，你需要做的第一件事是将你的代码转换为现代 Objective-C 语法。多亏了这一点，你的代码将准备好与
    Swift 集成兼容。
- en: You can see that after modernizing your code, that part of your code is modified,
    for example, ID is replaced with `instancetype`, initializers receive the modifier
    `NS_DESIGNATED_INITIALIZER`, and some functions are converted into property, mainly
    those functions that start with get or set.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在更新你的代码后，代码的这一部分被修改了，例如，ID 被替换为 `instancetype`，初始化器接收 `NS_DESIGNATED_INITIALIZER`
    修饰符，并且一些函数被转换为属性，主要是那些以 get 或 set 开头的函数。
- en: Usually this kind of change is considered a massive change, which of course
    has the risk of needing to roll back to the previous state. This is the reason
    why Xcode recommends you to create a snapshot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这种改变被认为是一次巨大的改变，这当然有需要回滚到之前状态的风险。这就是为什么 Xcode 建议你创建一个快照。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'In this recipe we learned how to get an existing Objective-C app and prepare
    it for using its code with Swift. Of course, sometimes you can do it automatically
    and sometimes you have to change it manually. It is a good idea to check the modern
    Objective-C documentation. You can do it by visiting the website: [https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何获取现有的 Objective-C 应用程序并为其准备使用 Swift 代码。当然，有时你可以自动完成它，有时你必须手动更改它。查看现代
    Objective-C 文档是个好主意。你可以通过访问以下网站来完成此操作：[https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html).
- en: Hiring a van
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 招聘一辆货车
- en: In this recipe we are going to give more functionality to the cab application,
    in this case we are going to assume that the application won't call only cars,
    but also a van service will be available. In this case the van needs to specify
    its capacity, as we are modernizing the code, we will do it using Swift. Of course,
    there will always be some code to type in Objective-C, bear that in mind.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为驾驶舱应用程序添加更多功能，在这种情况下，我们将假设应用程序不仅会调用汽车，还会提供货车服务。在这种情况下，货车需要指定其容量，因为我们正在更新代码，我们将使用
    Swift 来完成。当然，你总是需要在 Objective-C 中输入一些代码，请记住这一点。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we are going to continue with the previous app, so make a copy
    of the previous recipe and open the project copy. If you want to rename the app
    from `Chapter 8 Car` to `Chapter 8 Vehicles`, it would be good to differentiate
    them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用之前的应用程序，所以复制之前的菜谱并打开项目副本。如果你想将应用程序从 `第 8 章 汽车` 重命名为 `第 8 章 车辆`，这将有助于区分它们。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, click on the project navigator, then on the group that contains the source
    code, and add a new Swift file called `Van.swift`. Check that after trying to
    add it, a new dialog appears asking whether you would like to create a bridge
    file. Click on **Yes**, otherwise you will have to create a header file by yourself:![How
    to do it…](img/00102.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击项目导航器，然后点击包含源代码的组，添加一个名为 `Van.swift` 的新 Swift 文件。检查在尝试添加后，是否出现一个新对话框询问你是否想要创建一个桥接文件。点击
    **是**，否则你将不得不自己创建一个头文件：![如何操作…](img/00102.jpeg)
- en: Once you have accepted it, go to building settings, type `bridging` on the search
    field and check that there is a file set on the option **Objective-C Bridging
    Header**:![How to do it…](img/00103.jpeg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你接受了它，前往构建设置，在搜索字段中输入 `bridging` 并检查是否在选项 **Objective-C Bridging Header**
    上设置了一个文件：![如何操作…](img/00103.jpeg)
- en: 'After that, check that there is a new file on the project navigator called
    `Chapter 8 Vehicles-Bridge-Header.h`, and its contents are basically empty (only
    a few comments), so let''s import the file `Car.h`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检查项目导航器上是否有一个名为 `Chapter 8 Vehicles-Bridge-Header.h` 的新文件，并且其内容基本上是空的（只有一些注释），所以让我们导入文件
    `Car.h`：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, click on `Car.h` and let''s add the last modifications, and create a property
    called `image`, this way we can differentiate one car from one van:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 `Car.h` 并添加最后的修改，创建一个名为 `image` 的属性，这样我们就可以区分一辆汽车和一辆货车：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You are going to receive an error because `Car.h` doesn''t import the UIKit,
    so go to the top of this file and add the following import instruction:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将收到一个错误，因为 `Car.h` 没有导入 UIKit，所以请前往此文件顶部并添加以下导入指令：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that you will have to click on `Car.m` to initialize this new property,
    so add the following code in both initializers:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你必须点击 `Car.m` 来初始化这个新属性，所以在两个初始化器中添加以下代码：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can click back on the Swift file and create a class that represents
    a van. In this case, we will add an attribute called `capacity`, which will represent
    the space, measured in square meters. As you may imagine, this class will be a
    subclass of a car:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以点击回 Swift 文件并创建一个代表货车的类。在这种情况下，我们将添加一个名为 `capacity` 的属性，它将表示空间，以平方米为单位。正如你可能想象的那样，这个类将是汽车的一个子类：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we need two images for helping the user to visualize when it
    is a car and when it is a van. Drag the corresponding images from the `Resources`
    folder of this book into the **Supporting Files** group.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所见，我们需要两张图片来帮助用户可视化何时是汽车，何时是货车。将相应的图片从本书的 `Resources` 文件夹拖动到 **Supporting
    Files** 组中。
- en: 'It is obvious that we can''t stop here, we have to change the view controller
    for letting the new class be represented with its specific information. Click
    on the `ViewController.m` file and make the following changes: first change the
    method `cellForRowAtIndexPath`, it will be displayed in a more complete way:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很明显，我们不能止步于此，我们必须更改视图控制器，以便让新类能够以特定的信息表示。点击`ViewController.m`文件并做出以下更改：首先更改方法`cellForRowAtIndexPath`，它将以更完整的方式显示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the compiler is going to complain about the `Van` class, the reason is
    that you need to import it. How can we import a Swift file in Objective-C? The
    answer is very simple, just import a file called the same as your project name
    and concatenating the suffix `-Swift.h`. If your project has whitespace in its
    name, replace it with underscores:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译器将会对`Van`类提出抱怨，原因是你需要导入它。我们如何在Objective-C中导入一个Swift文件？答案是极其简单，只需导入一个与你的项目名称相同并附加后缀`-Swift.h`的文件。如果你的项目名称中包含空格，请将其替换为下划线：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then you have to add one more element to the vehicles array, so go to the `viewDidLoad`
    and add a van object after car number 4:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你必须向车辆数组中添加一个额外的元素，所以前往`viewDidLoad`并在第4辆车之后添加一个货车对象：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now our first migration is done, press play and you will see that your application
    is still working, but with the possibility of hiring a van:![How to do it…](img/00104.jpeg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的第一次迁移已经完成，按播放键，你会看到你的应用程序仍然在运行，但有了雇佣货车的可能性：![如何操作…](img/00104.jpeg)
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you mix Swift with Objective-C you have to create a bridge file in case
    of using Swift code in the Objective-C part. Usually you are guided by a wizard,
    which creates the bridge file and sets it into the building settings, but bear
    in mind that you may need to do it if the wizard doesn't appear.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你混合Swift和Objective-C时，如果你在Objective-C部分使用Swift代码，你必须创建一个桥接文件。通常你将由向导引导，它会创建桥接文件并将其设置在构建设置中，但请记住，如果向导没有出现，你可能需要自己完成这项工作。
- en: You have to import every header file that you want to use in Swift. In this
    case you had to import `Car.h`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须导入你想要在Swift中使用的每个头文件。在这种情况下，你必须导入`Car.h`。
- en: Swift classes can inherit from Objective-C classes, however, the opposite is
    not allowed, meaning that if you start adding Swift code into your project you
    need to be sure that you are not going to continue developing classes with Objective-C.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Swift类可以继承自Objective-C类，然而，反之则不允许，这意味着如果你开始在项目中添加Swift代码，你需要确保你不会继续使用Objective-C开发类。
- en: As you've just seen, you can treat the Swift class as an Objective-C class,
    even if you need to use methods such as `isKindOfClass`, and also the Objective-C
    was converted to Swift with its philosophy, such as creating an initializer, like
    `init(fare:Float)`, when in Objective-C its original name was `initWithFare`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以将Swift类视为Objective-C类，即使你需要使用`isKindOfClass`等方法，而且Objective-C也被转换为Swift，遵循其哲学，例如创建一个初始化器，如`init(fare:Float)`，在Objective-C中其原始名称是`initWithFare`。
- en: Porting your code from one language to another
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的代码从一种语言迁移到另一种语言
- en: In the previous recipe we learned how to add a new code into an existing Objective-C
    project, however, you shouldn't only add new code but also, as far as possible,
    you should migrate your old code to the new Swift language.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们学习了如何将新代码添加到现有的Objective-C项目中，然而，你不仅应该添加新代码，而且尽可能地将你的旧代码迁移到新的Swift语言中。
- en: If you would like to keep your application core on Objective-C, that's OK, but
    remember that new features are going to be added to Swift and it will be difficult
    keeping two languages on the same project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保持你的应用程序核心为Objective-C，那没问题，但请记住，新的功能将被添加到Swift中，并且保持同一项目中的两种语言将变得困难。
- en: In this recipe we are going to port part of the code, which is written in Objective-C
    to Swift.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将把部分代码从Objective-C迁移到Swift。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make a copy of the previous recipe. If you are using any version control it's
    a good time for committing your changes. If you are not using a version control
    system, check [Chapter 1](part0014_split_000.html#DB7S1-bba3081a9dc049b7aa5e4f7cc42ef8bb
    "Chapter 1. Getting Started with Xcode and Swift"), *Getting Started with Xcode
    and Swift*, to see how to add it to your project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 复制之前的食谱。如果你在使用任何版本控制系统，现在是提交你的更改的好时机。如果你没有使用版本控制系统，查看[第1章](part0014_split_000.html#DB7S1-bba3081a9dc049b7aa5e4f7cc42ef8bb
    "第1章. 使用Xcode和Swift入门")，*使用Xcode和Swift入门*，了解如何将其添加到你的项目中。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open the project and add a new file called `Setup.swift`, here we are going
    to add a new class with the same name (Setup):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目并添加一个名为 `Setup.swift` 的新文件，在这里我们将添加一个具有相同名称的新类（Setup）：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have this car array generator we can call it on the `viewDidLoad`
    method replacing the previous code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个汽车数组生成器，我们可以在 `viewDidLoad` 方法中调用它，替换之前的代码：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, press play and check that the application is still working.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，按播放并检查应用程序是否仍然工作。
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The reason we had to create a class instead of creating a function is that you
    can only export to Objective-C classes, protocols, properties, and subscripts.
    Bear that in mind in case of developing with the two languages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个类而不是创建一个函数的原因是，你只能导出 Objective-C 类、协议、属性和索引。如果你在用两种语言开发时，请记住这一点。
- en: If you would like to export a class to Objective-C you have two choices. The
    first one is inheriting from `NSObject` and the other one is adding the `@objc`
    attribute before your class, protocol, property, or subscript.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将类导出为 Objective-C，你有两种选择。第一个是继承自 `NSObject`，另一个是在你的类、协议、属性或索引之前添加 `@objc`
    属性。
- en: If you paid attention, our method returns a Swift array converted to an NSArray,
    but as you might know, they are different kinds of array. Firstly because Swift
    arrays are mutable and NSArrays are not, and the other reason is that their methods
    are different.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我们的方法返回的是一个转换成 NSArray 的 Swift 数组，但正如你可能知道的，它们是不同类型的数组。首先，因为 Swift 数组是可变的，而
    NSArray 不是，另一个原因是它们的方法不同。
- en: Can we use NSArray in Swift? The answer is yes, but I would recommend avoiding
    it; imagine once finished migrating to Swift your code still follows the old way,
    it would be another migration.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否在 Swift 中使用 NSArray？答案是肯定的，但我建议避免使用它；想象一下，一旦完成迁移到 Swift，你的代码仍然遵循旧的方式，这将是一次另一次的迁移。
- en: There's more…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Migrating from Objective-C is something that you should do with care. Don't
    try to change the whole application at once, remember that some Swift objects
    behave differently from Objective-C, for example, dictionaries in Swift have the
    key and the value types specified, but in Objective-C they can be of any type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Objective-C 迁移是一件需要谨慎处理的事情。不要试图一次性改变整个应用程序，记住一些 Swift 对象的行为与 Objective-C 不同，例如，Swift
    中的字典指定了键和值的类型，但在 Objective-C 中它们可以是任何类型。
- en: Replacing the user interface classes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换用户界面类
- en: At this moment you know how to migrate the model part of an application, however
    in real life we also have to replace the graphical classes. Doing it is not complicated
    but it could be a bit full of details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你知道如何迁移应用程序的模型部分，然而在现实生活中，我们还需要替换图形类。这样做并不复杂，但可能会有些细节。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Continuing with the previous recipe, make a copy of it or just commit the changes
    you have and let's continue with our migration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用之前的配方，复制它或只是提交你的更改，然后继续我们的迁移。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First create a new file called `MainViewController.swift` and start importing
    the UIKit:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为 `MainViewController.swift` 的新文件，并开始导入 UIKit：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is creating a class called `MainViewController`. This class must
    inherit from `UIViewController` and implement the protocols `UITableViewDataSource`
    and `UITableViewDelegate`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为 `MainViewController` 的类。这个类必须继承自 `UIViewController` 并实现 `UITableViewDataSource`
    和 `UITableViewDelegate` 协议：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add the attributes we had in the previous view controller, keeping the
    same name you used before:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加我们在之前的视图控制器中拥有的属性，保持你之前使用的相同名称：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to implement the methods; let''s start with the table view data
    source methods:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现方法；让我们从表格视图数据源方法开始：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that this conversion is not 100% equivalent. The fare, for example, isn't
    going to be shown with two digits of precision. There is an explanation later
    for why we are not going to fix this now.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这种转换并不完全等效。例如，费用不会以两位数的精度显示。稍后会有解释为什么我们现在不修复这个问题。
- en: 'The next step is adding the event; in this case we have to do the action when
    the user selects a car:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加事件；在这种情况下，我们必须在用户选择一辆车时执行操作：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, we need only do one more step to complete our code. In this
    case it''s the view `didLoad`. Notice that another difference from Objective-C
    and Swift is that in Swift you have to specify that you are overloading an existing
    method:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所见，我们只需要再进行一步就可以完成我们的代码。在这种情况下，它是视图的 `didLoad` 方法。请注意，Objective-C 和 Swift
    之间的另一个区别是，在 Swift 中你必须指定你正在重载一个现有方法：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our code is complete, but of course our application is still using the old code.
    To complete this operation, click on the storyboard; if the document outline isn't
    being displayed, click on the **Editor** menu and then on **Show Document Outline**:![How
    to do it…](img/00105.jpeg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码已经完成，但当然我们的应用程序仍然在使用旧的代码。要完成这个操作，点击故事板；如果文档大纲没有显示，点击**编辑**菜单，然后点击**显示文档大纲**：![如何操作…](img/00105.jpeg)
- en: Now that you can see the document outline, click on **View Controller** that
    appears next to a yellow circle with a square inside:![How to do it…](img/00106.jpeg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以看到文档大纲了，点击旁边带有方形黄色圆圈的**视图控制器**：![如何操作…](img/00106.jpeg)
- en: Then on the right-hand side, click on the identity inspector, go to the custom
    class, and change the value of the class from **ViewController** to **MainViewController**:![How
    to do it…](img/00107.jpeg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在右侧，点击身份检查器，转到自定义类，将类的值从**ViewController**更改为**MainViewController**：![如何操作…](img/00107.jpeg)
- en: After that, press play and check that your application is running, select a
    car, and check that it is working. Be sure that it is working with your new Swift
    class by paying attention to the fare value, which in this case isn't shown with
    two digits of precision.![How to do it…](img/00108.jpeg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按播放并检查你的应用程序是否正在运行，选择一辆车，并检查它是否工作。确保它使用你的新Swift类工作，注意票价值，在这种情况下，它没有以两位数的精度显示。![如何操作…](img/00108.jpeg)
- en: Is everything done? I would say no, it's a good time to save your changes. Lastly,
    delete the original Objective-C files, because you won't need them anymore.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事情都完成了吗？我会说还没有，现在是保存更改的好时机。最后，删除原始的Objective-C文件，因为你不再需要它们了。
- en: How it works…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, it's not so hard replacing an old view controller with a Swift
    one; the first thing you need to do is create a new view controller class with
    its protocols. Keep the same names you had on your old code for attributes and
    methods that are linked as `IBActions`, it will make the switch very straightforward;
    otherwise you will have to link again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，用Swift替换旧的视图控制器并不难；你需要做的第一件事是创建一个新的视图控制器类及其协议。保持你旧代码中与`IBActions`链接的属性和方法相同的名称，这将使切换变得非常直接；否则，你可能需要重新链接。
- en: Bear in mind that you need to be sure that your changes are applied and that
    they are working, but sometimes it is a good idea to have something different,
    otherwise your application can be using the old Objective-C and you didn't realize
    it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你需要确保你的更改已经应用并且正在工作，但有时拥有不同的东西是个好主意，否则你的应用程序可能会继续使用旧的Objective-C，而你却没有意识到这一点。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to modernize your code using the Swift way instead of the old Objective-C
    style, for example, nowadays it's preferable to use interpolation rather than
    using `stringWithFormat`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Swift的方式而不是旧的Objective-C风格来现代化你的代码，例如，现在使用插值而不是使用`stringWithFormat`更受欢迎。
- en: We also learned that you don't need to relink any action or outlet if you keep
    the same name. If you want to change the name of anything you might first keep
    its original name, test your app, and after that you can refactor it following
    the traditional factoring steps.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，如果你保持相同的名称，你不需要重新链接任何操作或出口。如果你想更改任何东西的名称，你可能首先保留其原始名称，测试你的应用程序，然后你可以按照传统的分解步骤重构它。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't delete the original Objective-C files until you are sure that the equivalent
    Swift file is working on every functionality.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你确信等效的Swift文件在所有功能上都能正常工作之前，不要删除原始的Objective-C文件。
- en: There's more…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This application had only one view controller, however applications usually
    have more than one view controller. In this case, the best way you can update
    them is one by one instead of all of them at the same time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序只有一个视图控制器，然而应用程序通常有多个视图控制器。在这种情况下，最好的更新方式是逐个更新它们，而不是同时更新所有。
- en: Upgrading the app delegate
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级应用程序代理
- en: As you know, there is an object that controls the events of an application,
    which is called application delegate. Usually you shouldn't have much code here,
    but a few of them you might have. For example, you may deactivate the camera or
    the GPS requests when your application goes to the background, and reactivate
    them when the app returns to active.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，有一个控制应用程序事件的对象，这被称为应用程序代理。通常你这里不应该有太多代码，但你可能有一些。例如，当你的应用程序进入后台时，你可能需要禁用相机或GPS请求，当应用程序返回活动状态时，重新激活它们。
- en: Certainly it is a good idea to update this file even if you don't have any new
    code on it, so it won't be a problem in the future.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在这个文件上没有添加任何新代码，更新这个文件也是一个好主意，这样将来就不会有问题。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you are using the version control system, commit your changes from the last
    recipe or, if you prefer, just copy your application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用版本控制系统，请从上一个菜谱提交你的更改，或者如果你更喜欢，只需复制你的应用程序。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Open the previous application recipe and create a new Swift file called `ApplicationDelegate.swift`,
    then create a class with the same name.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一个应用程序菜谱，创建一个名为 `ApplicationDelegate.swift` 的新 Swift 文件，然后创建一个具有相同名称的类。
- en: 'As in our previous class, we don''t have any code on the application delegate,
    so we can differentiate it by printing on the log console. Add this traditional
    application delegate on your Swift file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前的类一样，我们在应用程序代理中没有代码，所以我们可以通过在日志控制台上打印来区分它。在你的 Swift 文件中添加这个传统的应用程序代理：
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now go to your project navigator and expand the **Supporting Files** group.
    After that, click on the `main.m` file:![How to do it…](img/00109.jpeg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到你的项目导航器，展开 **支持文件** 组。之后，点击 `main.m` 文件：![如何操作…](img/00109.jpeg)
- en: 'In this file we are going to import the magic file, the Swift header file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将导入魔法文件，Swift 头文件：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that we have to specify that the application delegate is the new class
    we have, so replace the `AppDelegate` class on the `UIApplicationMain` call with
    `ApplicationDelegate`. Your main function should be like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须指定应用程序代理是我们拥有的新类，所以将 `UIApplicationMain` 调用中的 `AppDelegate` 类替换为 `ApplicationDelegate`。你的主函数应该是这样的：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's time to press play and check whether the application is working or not.
    Press the home button, or the combination *shift* + *command* + *H* if you are
    using the simulator, and again open your application. Check that you have some
    messages on your log console:![How to do it…](img/00110.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候按播放键检查应用程序是否正常工作了。按主页按钮，或者如果你使用的是模拟器，按 *shift* + *command* + *H* 组合键，然后再次打开你的应用程序。检查你的日志控制台是否有消息：![如何操作…](img/00110.jpeg)
- en: Now that you are sure that your Swift code is working, remove the original app
    delegate and its importation on the `main.m`. Test your app just in case.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经确认你的 Swift 代码正在工作，请从 `main.m` 中移除原始的应用程序代理及其导入。测试你的应用程序以确认无误。
- en: 'You could consider that we had finished this part, but actually we still have
    another step to do: removing the `main.m` file. Now, it is very easy: just click
    on the `ApplicationDelegate.swift` file, and before the class declaration, add
    the attribute `@UIApplicationMain`, then right click on the `main.h` and choose
    to delete it. Test it and your application is done.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以考虑我们已经完成了这一部分，但实际上我们还有另一个步骤要做：移除 `main.m` 文件。现在，这非常简单：只需点击 `ApplicationDelegate.swift`
    文件，在类声明之前添加属性 `@UIApplicationMain`，然后右键点击 `main.h` 并选择删除它。测试它，你的应用程序就完成了。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The application delegate class has always been specified at the start of an
    application. In Objective-C, it follows the C start point, which is a function
    called `main`. In iOS, you can specify the class that you want to use as an application
    delegate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代理类始终在应用程序开始时指定。在 Objective-C 中，它遵循 C 的起点，即一个名为 `main` 的函数。在 iOS 中，你可以指定你想要用作应用程序代理的类。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you program for OS X, the procedure is different; you have to go to your
    `nib` file and change its class name to the new one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 OS X 编程，程序不同；你必须转到你的 `nib` 文件，并将其类名更改为新的一个。
- en: Why did we have to change the main function and then eliminate it? The reason
    is that you should avoid massive changes. If something goes wrong you won't know
    the step where you failed, so you will probably have to rollback everything again.
    If you do your migration step by step ensuring that it is still working, it means
    that in case of finding an error, it will be easier to solve it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们必须更改主函数然后消除它？原因是你应该避免大规模的更改。如果出了问题，你不知道失败的具体步骤，所以你可能不得不再次回滚所有内容。如果你一步一步地进行迁移，确保它仍然工作，这意味着在发现错误的情况下，解决它将更容易。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid making massive changes on your project; changing step by step will be
    easier to solve issues.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在项目中进行大规模更改；逐步更改将更容易解决问题。
- en: There's more…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we learned the last steps of how to migrate an app from Objective-C
    to Swift code, however we have to remember that programming is not only about
    applications; you can also have a framework. In the next recipe, we are going
    to learn how to create our own framework compatible with Swift and Objective-C.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何将应用程序从Objective-C迁移到Swift代码的最后一步，然而我们必须记住，编程不仅仅是关于应用程序；你还可以有一个框架。在下一个菜谱中，我们将学习如何创建与Swift和Objective-C兼容的自定义框架。
- en: Creating your own custom framework
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的自定义框架
- en: As you know, sometimes we have code that is to be shared between applications,
    and the best way to do this is by creating a framework. In this case we are going
    to create a framework that should contain a customized view.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，有时我们有一些需要在应用程序之间共享的代码，而最好的方式是通过创建一个框架。在这种情况下，我们将创建一个包含自定义视图的框架。
- en: For this recipe, we are going to add only one view. This view will be painted
    with a gradient; this way you can change your application's background easily.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们只添加一个视图。这个视图将以渐变的形式绘制；这样你可以轻松地更改应用程序的背景。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create a new project called `CustomViewsFramework`. To do it click on **File**
    | **New** | **Project** and then choose the section **Framework and Library**;
    after that choose the option **Cocoa Touch Framework**:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomViewsFramework`的新项目。要做到这一点，请点击**文件** | **新建** | **项目**，然后选择**框架和库**部分；之后选择**Cocoa
    Touch 框架**选项：
- en: '![Getting ready](img/00111.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00111.jpeg)'
- en: Select **Swift** as the project language.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Swift**作为项目语言。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Start adding a new file to your project, in this case you can choose from the
    **Source** section, the option **Cocoa Touch Class**:![How to do it…](img/00112.jpeg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始向你的项目中添加一个新文件，在这种情况下，你可以从**源**部分选择**Cocoa Touch 类**选项：![如何操作…](img/00112.jpeg)
- en: After that you have to write the new class name; let's call it `CVGradientView`.
    Also, make sure that is selected to be a subclass of `UIView` and its language
    is Swift:![How to do it…](img/00113.jpeg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你必须编写新的类名；让我们称它为`CVGradientView`。同时，确保它被选为`UIView`的子类，并且其语言是Swift：![如何操作…](img/00113.jpeg)
- en: 'Once the file is created and opened you can remove the comments that come by
    default, then you have to add the attribute `@IBDesignable` before the class declaration:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件创建并打开后，你可以移除默认的注释，然后必须在类声明之前添加属性`@IBDesignable`：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to add some attributes; in this case we will use properties with
    an observer that will refresh the gradient view every time a property is changed:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加一些属性；在这种情况下，我们将使用带有观察者的属性，每次属性发生变化时都会刷新渐变视图：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you noticed, we have to implement the `refresh()` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们必须实现`refresh()`方法：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we need to specify some information about the gradient layer; this information
    is done following the core animation framework:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要指定一些关于梯度层的信息；这些信息是按照核心动画框架进行的：
- en: '[PRE29]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we need the last part of this method, that is, the initializer:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要这个方法的最后一部分，即初始化器：
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once it is done, we need to identify our module by going to our target build
    settings and searching for the word `module`. Now, change the **Module Identifier**
    to **CustomViewsFrameWork**:![How to do it…](img/00114.jpeg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们需要通过访问我们的目标构建设置并搜索单词`module`来识别我们的模块。现在，将**模块标识符**更改为**CustomViewsFrameWork**：![如何操作…](img/00114.jpeg)
- en: The class is complete, so generate the project with ** + *b*. Now, we need
    to check that it is working, so let's create another project called `Chapter 8
    Testing Views`. Once it is created, click on the project navigator, then click
    on the target `Chapter 8 Testing Views`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类已经完成，所以使用** + *b*生成项目。现在，我们需要检查它是否正常工作，所以让我们创建另一个名为`Chapter 8 Testing Views`的项目。创建后，点击项目导航器，然后点击目标`Chapter
    8 Testing Views`。
- en: Here you have to select the **Build Settings** tab and change the field **Embedded
    Content Contains Swift Code** to **Yes**:![How to do it…](img/00115.jpeg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你必须选择**构建设置**选项卡，并将字段**嵌入式内容包含Swift代码**更改为**是**：![如何操作…](img/00115.jpeg)
- en: Next, select the **General** tab and go to the **Embedded Binaries** section,
    click on the plus button, and when a dialog appears just click on the button with
    the phrase **Add other…**. Here, it is asking for your framework, so go to the
    build product of your framework (it should be inside a folder called `DerivedData/CustomsViewsFramework/Build/Products/Debug-iphonesimulator/`),
    select it (the file called `CustomsViewsFramework.framework`), and press **OK**.
    Check that the linked frameworks sections will also show it:![How to do it…](img/00116.jpeg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**常规**选项卡，转到**嵌入的二进制文件**部分，点击加号按钮，当对话框出现时，只需点击带有短语**添加其他…**的按钮。在这里，它正在询问你的框架，所以转到你的框架的构建产品（它应该在名为`DerivedData/CustomsViewsFramework/Build/Products/Debug-iphonesimulator/`的文件夹中），选择它（名为`CustomsViewsFramework.framework`的文件），然后按**确定**。检查链接的框架部分也会显示它：![如何操作…](img/00116.jpeg)
- en: Now that your app knows about this framework, you can click on the storyboard,
    then click on the only view you have (not on the view controller), go to the identity
    inspector, and change the **Class** name field to **CVGradientView** and its **Module**
    name to **CustomViewsFramework**:![How to do it…](img/00117.jpeg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在既然你的应用已经了解了这个框架，你可以点击故事板，然后点击你拥有的唯一视图（不是视图控制器），转到身份检查器，将**类**名称字段更改为**CVGradientView**，并将其**模块**名称更改为**CustomViewsFramework**：![如何操作…](img/00117.jpeg)
- en: 'Press play and check that your background has changed. If you want you can
    even change your background programmatically; just click on the view controller
    file and start importing your framework:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按播放键并检查你的背景是否已更改。如果你想，甚至可以程序化地更改你的背景；只需点击视图控制器文件并开始导入你的框架：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, change, for example, the background colors on the view did load:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，例如，更改视图加载后的背景颜色：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Press play again and see that your background is different.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按播放键，你会看到你的背景已经不同了。
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The reason we named this project differently than the others is that frameworks
    can't have white spaces in their names. In the case of creating a project with
    white spaces in its name, you have to go to build settings and change the product
    name to something without white spaces.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个项目命名为与其他项目不同的原因是因为框架的名称中不能有空格。在创建名称中包含空格的项目的情况下，你必须转到构建设置，并将产品名称更改为没有空格的名称。
- en: The attribute `@IBDesignable` lets interface builder know that it should render
    the view directly in the canvas, but remember that this attribute can only be
    used if you are developing a framework; it won't work on traditional applications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`@IBDesignable`让界面构建器知道它应该直接在画布中渲染视图，但请记住，只有在你开发框架时才能使用此属性；它不会在传统应用上工作。
- en: The other attribute (`@IBInspectable`) means that this property can be viewed
    and set by interface builder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个属性（`@IBInspectable`）意味着这个属性可以通过界面构建器查看和设置。
- en: Notice that we had to mark our class and some attribute and methods as public.
    The reason is that we want them to be accessed by external modules. If we don't
    do this, it means that only our framework can access this class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不将我们的类和一些属性和方法标记为公共的。原因是我们希望它们可以被外部模块访问。如果我们不这样做，这意味着只有我们的框架可以访问这个类。
