- en: Chapter 8. Threading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 线程
- en: iOS is what is known as a multithreading system, and understanding how threads
    can be used within an app can be advantageous.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: iOS被称为多线程系统，理解如何在应用中使用线程可能会有所帮助。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: A brief introduction to threading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的简要介绍
- en: The main UI thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要UI线程
- en: A Daughter thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子线程
- en: The AppDelegate class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppDelegate类
- en: Threading Concepts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程概念
- en: Let's discuss an easy way to learn threading.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一种学习线程的简单方法。
- en: A single-thread environment can be considered in the same way as going to your
    local college. There are a number of routes you can take, but you end up there
    at some point and the process will take a finite amount of time; you set off,
    you travel, you arrive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将单线程环境视为去你当地的大学一样。你可以选择多条路线，但最终你都会到达那里，这个过程需要一定的时间；你出发，你旅行，你到达。
- en: A multithreaded environment needs to be thought of as the college itself with
    each thread being a student. All students start off at 9 a.m. and go until 12
    p.m. What they do in between that time may or may not interfere with each other;
    they will all be doing a task or co-operating on a task to speed up the delivery
    of an answer. Thirty different threads, all working at once and at different speeds,
    but at 12 p.m., they all manage to converge and terminate their activities with
    the jobs done. They repeat the process from 1 p.m. to 4 p.m., and again, there
    is organized chaos between those hours, but at 4 p.m. everything converges. The
    lecturer is the one controlling who does what, and in terms of the threading model,
    is the control thread. *Simple!*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程环境需要被视为大学本身，每个线程都是一个学生。所有学生都是从早上9点开始，一直持续到中午12点。他们在那段时间里可能互相干扰，也可能不干扰；他们都会执行一个任务或合作完成任务以加快答案的交付。30个不同的线程，同时以不同的速度工作，但到了中午12点，他们都能成功收敛并结束他们的活动，任务完成。他们从下午1点到4点重复这个过程，同样，在这些小时里，也存在有组织的混乱，但到了下午4点，一切都会收敛。讲师是控制谁做什么的人，在线程模型中，是控制线程。*简单！*
- en: In terms of iOS development, the lecturer would be classed as the UI thread;
    it is the one that can start new threads and, at the end of the day, the one where
    all information needs to be fed back.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中，讲师会被归类为UI线程；它是可以启动新线程的线程，最终，所有信息都需要反馈到这个线程上。
- en: The main UI thread
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要UI线程
- en: As the name suggests, the UI thread controls the UI. It is usually the hungriest
    in terms of resources and processor time. Not everything runs on the UI thread.
    For example, if the UI calls a method and that method cannot be run on the UI
    thread (such as the SQLite example listed in [Chapter 11](../Text/part0051.html#page
    "Chapter 11. Handling Data"), *Handling Data*), then that is what will happen.
    The code is executed and the flow continues once the method has returned.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，UI线程控制着用户界面。它通常在资源和使用处理器时间方面需求最大。并非所有操作都在UI线程上运行。例如，如果UI调用一个方法，而这个方法不能在UI线程上运行（例如，在[第11章](../Text/part0051.html#page
    "第11章. 处理数据")中列出的SQLite示例，*处理数据*），那么就会发生这种情况。一旦方法返回，代码就会执行，流程继续。
- en: The UI thread should not be mistaken as a single task; *it's not*. A single
    task would prohibit any other application running, which we know is not the case
    (for example, you could be playing Angry Worms and still receive a text message).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: UI线程不应被误认为是单一任务；*它不是*。单一任务会阻止其他应用程序运行，我们知道这不是情况（例如，你可以在玩愤怒的小鸟的同时收到短信）。
- en: '`Xamarin.iOS` allows non-UI calls to simply jump back onto the UI thread.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.iOS`允许非UI调用简单地跳回UI线程。'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, if a reference to the thread can''t be found (such as being out of scope
    or in a non-UI thread class), use the following line of code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果找不到线程的引用（例如超出范围或在非UI线程类中），可以使用以下代码行：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Deadlocking
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: Something may have crossed your mind over the description of the multithreaded
    system. What happens if all the students don't come back when they should? What
    happens then? It's a good question as it's something that if you're not careful
    can hit when dealing with a multithreaded environment. It is known as a deadlock
    and, literally, it can lock the app and potentially the device (though this is
    rare). Another problem is threads overwriting the same memory location (think
    of this as two or more people talking to the lecturer at once; only one voice
    will be remembered).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程系统的描述中，你可能在想，如果所有学生应该在的时候没有回来会怎样？那时会发生什么？这是一个好问题，因为它是在处理多线程环境时，如果不小心可能会遇到的问题。这被称为死锁，字面上说，它可能会锁定应用程序甚至设备（尽管这种情况很少发生）。另一个问题是线程覆盖相同的内存位置（想象一下这是两个人或更多人同时与讲师交谈；只有一种声音会被记住）。
- en: In this example, if the two threads are run within a second of each other, they
    will both have time to grab the first lock before anyone gets to the inner lock.
    Without the `Sleep()` call, one of the threads would most likely have time to
    get and release both locks before the other thread even got started.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果两个线程几乎同时运行，它们都有时间在任何人到达内部锁之前获取第一个锁。如果没有`Sleep()`调用，其中一个线程很可能在另一个线程甚至开始之前就有时间获取并释放两个锁。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Avoiding deadlocks for synchronized accessors
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免同步访问器的死锁
- en: A simple way to avoid this form of deadlock is for each holding class to have
    its own private deadlock. The problem along with its solution is described well
    on MSDN ([http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx](http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种形式死锁的一个简单方法是为每个持有类拥有它自己的私有死锁。这个问题及其解决方案在MSDN上描述得很好([http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx](http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx))。
- en: Starting a new thread from the main UI thread
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从主UI线程启动新线程
- en: A new thread coming from an existing thread is known as a daughter thread.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有线程中产生的新线程被称为子线程。
- en: A very simple way to add a daughter thread on an iOS device is like this. I
    have first created a simple UI to show what is happening. The top label is called
    thread 1, the bottom label is called thread 2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS设备上添加子线程的一个非常简单的方法是这样的。我首先创建了一个简单的UI来显示正在发生的事情。顶部的标签称为线程1，底部的标签称为线程2。
- en: '![Starting a new thread from the main UI thread](img/00038.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![从主UI线程启动新线程](img/00038.jpeg)'
- en: 'The code also shows `InvokeOnMainThread` in action—without it the app fails:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还展示了`InvokeOnMainThread`的作用——没有它，应用程序将失败：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And when run, the simulator gives the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，模拟器给出以下输出：
- en: '![Starting a new thread from the main UI thread](img/00039.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![从主UI线程启动新线程](img/00039.jpeg)'
- en: Run this a number of times and you get a number of different results. The threads
    are performing operations on the UI at different times; this shows the problem
    with threading quite well. If the UI was waiting for thread 1 to finish but thread
    2 finishes, then it's not going to know what is going on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行几次，你会得到不同的结果。线程在不同的时间在UI上执行操作；这很好地展示了线程的问题。如果UI正在等待线程1完成，但线程2完成了，那么它将不知道发生了什么。
- en: In this case, the code can be sanitized by using a lock.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以通过使用锁来清理代码。
- en: Using locks
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用锁
- en: Be careful when using locks is probably the first thing that needs to be said.
    A lock is used to synchronize the threads and obtain a far saner output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用锁时要小心，可能是需要说的第一件事。锁用于同步线程并获得一个更加合理的输出。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time when the app is run, the threads are synchronized and the result is
    always the same. Using this locking system, the app is free to use as many threads
    as it needs to get whatever done off the UI thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当应用程序运行时，线程是同步的，结果总是相同的。使用这个锁定系统，应用程序可以自由地使用它需要的任何数量的线程来从UI线程完成任何工作。
- en: '![Using locks](img/00040.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用锁](img/00040.jpeg)'
- en: The AppDelegate class
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppDelegate类
- en: It may seem odd having the `AppDelegate` class described here, but it fits.
    The `AppDelegate` class is known as a singleton class. It's used once and once
    only with everything coming from it. Consider it as the über thread; without it,
    nothing else happens.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述`AppDelegate`类可能看起来有些奇怪，但它很合适。`AppDelegate`类被称为单例类。它只使用一次，并且所有内容都来自它。将其视为超级线程；没有它，其他什么都不会发生。
- en: I've given the `AppDelegate` class a more thorough handling in [Chapter 5](../Text/part0031.html#page
    "Chapter 5. UI Controls"), *UI Controls* and, after reading this chapter, you
    should have a clearer idea of its importance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第5章](../Text/part0031.html#page "第5章. UI控件")中对`AppDelegate`类进行了更详尽的处理，*UI控件*，阅读完这一章后，你应该对其重要性有更清晰的认识。
- en: Summary
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Threading within an iOS application can make up for a more responsive user experience,
    but at the same time, for the developer it can be the reason for many a late nights
    trying to figure out why something is crashing at random times or just seizes
    up for no real reason. Be careful with threads, they can be both a pain and a
    pleasure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS应用程序中，多线程可以使用户体验更加响应，但与此同时，对于开发者来说，它也可能是导致许多夜晚晚归的原因，试图弄清楚为什么某些东西会在随机的时间崩溃，或者没有任何真正原因地突然停止工作。对待线程要小心，它们既可以是一种痛苦，也可以是一种乐趣。
