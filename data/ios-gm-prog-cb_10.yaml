- en: Chapter 10. 3D Game Programming with OpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用OpenGL进行3D游戏编程
- en: 'In this chapter, we will focus on the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下食谱：
- en: Introducing OpenGL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OpenGL
- en: Building a mini three-dimensional animation game using OpenGL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL构建一个迷你三维动画游戏
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapters, you learned about the anatomy of physics simulation
    in depth. Now, we will explore the most interesting part of the game, which is
    to add three-dimensional objects to your games. In this chapter, we will start
    exploring the basics of OpenGL. Then, step-by-step, we will explore OpenGL in
    depth by crafting some three-dimensional models. In this chapter, we will start
    learning by using the two-dimensional model project, and then we will enhance
    the project to accommodate three-dimensional models.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你深入学习了物理模拟的结构。现在，我们将探索游戏中最有趣的部分，即向你的游戏中添加三维对象。在本章中，我们将开始探索OpenGL的基础知识。然后，我们将通过制作一些三维模型逐步深入探索OpenGL。在本章中，我们将通过使用二维模型项目开始学习，然后我们将增强项目以适应三维模型。
- en: Introducing OpenGL
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenGL
- en: OpenGL stands for Open Graphics Library. This is a widely used library for visualizing
    two-dimensional and three-dimensional objects. This is a standard multipurpose
    two-dimensional and three-dimensional content creation graphics library. It is
    used in various streams, such as mechanical design, architectural design, gaming,
    prototyping, flight simulation, and many more. OpenGL is used to configure and
    submit three-dimensional graphics data to the device. All the data is prepared
    in the form of matrices and they are transformed to vertices, which are transformed
    and assembled to produce two-dimensional rasterized images. Two-dimensional graphics
    have two axes, which are x and y; however, in the case of three-dimensional graphics,
    we have three-dimensional axes, which are x, y, and z, where z is the depth.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL代表开放图形库。这是一个广泛使用的库，用于可视化二维和三维对象。这是一个标准的多功能二维和三维内容创建图形库。它在各种领域中使用，如机械设计、建筑设计、游戏、原型设计、飞行模拟等。OpenGL用于配置和提交三维图形数据到设备。所有数据都以矩阵的形式准备，并转换为顶点，这些顶点被转换和组装以生成二维光栅化图像。二维图形有两个轴，即x轴和y轴；然而，在三维图形的情况下，我们有三维轴，即x轴、y轴和z轴，其中z轴是深度轴。
- en: This library is designed to compile normal function calls into graphical commands,
    which will get executed on the graphics rendering hardware. All the graphics hardware
    is designed to execute the graphics commands. OpenGL draws and renders views very
    fast.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库旨在将普通函数调用编译成图形命令，这些命令将在图形渲染硬件上执行。所有图形硬件都设计用来执行图形命令。OpenGL以非常快的速度绘制和渲染视图。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Xcode provides a built-in OpenGL-ES project template; still, we think it will
    be confusing for beginners to start with that template. A typical approach is
    to write the code step-by-step, in order to understand how the code works and
    the functionality of each function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode提供了一个内置的OpenGL-ES项目模板；然而，我们认为对于初学者来说，从该模板开始可能会感到困惑。一种典型的方法是逐步编写代码，以便理解代码的工作方式和每个函数的功能。
- en: 'Here, we will write all the code from scratch, which will help you to understand
    the nitty-gritty of each and every line of code written to render views using
    OpenGL. To add frameworks, perform the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头开始编写所有代码，这将帮助你理解使用OpenGL渲染视图时每行代码的细节。要添加框架，请执行以下步骤：
- en: Start up Xcode. Make a single-view application and click on **Next**. Name your
    project OpenGLSample, click on **Next**, choose a folder to save it in, and click
    on **Create**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Xcode。创建一个单视图应用程序，点击**下一步**。将你的项目命名为OpenGLSample，点击**下一步**，选择一个文件夹来保存它，然后点击**创建**。
- en: Now, we will add all the required frameworks in the project. To add the frameworks,
    the first step is to add the two required frameworks for our OpenGL project. They
    are `OpenGLES.frameworks` and `GLKit.framework`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向项目中添加所有必需的框架。要添加框架，第一步是添加我们OpenGL项目所需的两个框架。它们是`OpenGLES.frameworks`和`GLKit.framework`。
- en: To add these frameworks in Xcode 6, click on your OpenGLSample project in the
    Groups & Files tree, and select the **OpenGLSample** target. Expand the **Link
    Binary with the Libraries** section, click on the plus button, and select **OpenGLES.framework**.
    Repeat for **GLKit.framework** as well, as shown in the following screenshot:![Getting
    ready](img/00157.jpeg)
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Xcode 6中添加这些框架，请单击Groups & Files树中的OpenGLSample项目，并选择**OpenGLSample**目标。展开**Link
    Binary with the Libraries**部分，单击加号按钮，并选择**OpenGLES.framework**。同样，为**GLKit.framework**也重复此操作，如下所示：![准备就绪](img/00157.jpeg)
- en: How to do it
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'To create three-dimensional textures in our app, perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中创建三维纹理，请执行以下步骤：
- en: Open the `Main.storyboard` file and select the view controller. You will see
    a view already added in the view controller.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Main.storyboard`文件并选择视图控制器。您将看到在视图控制器中已经添加了一个视图。
- en: Select the view, open the Identity inspector, and set the view's class to `GLKView`,
    as shown in the following screenshot:![How to do it](img/00158.jpeg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择视图，打开Identity检查器，并将视图的类设置为`GLKView`，如下所示：![如何操作](img/00158.jpeg)
- en: 'Open `ViewController.h`, import `GLKit`/`GLKit.h`, and change the ViewController''s
    parent class from `UIViewController` to `GLKViewController`. `GLKViewController`
    provides the OpenGL render loop in addition to all native view controller functionalities.
    The code will be as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewController.h`，导入`GLKit`/`GLKit.h`，并将视图控制器的主类从`UIViewController`更改为`GLKViewController`。`GLKViewController`除了提供所有原生视图控制器功能外，还提供了OpenGL渲染循环。代码如下：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `viewController.m`. Add the following code to `viewDidLoad`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`viewController.m`。在`viewDidLoad`中添加以下代码：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following methods:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line of the code calls `glClearColor`, which effectively tells OpenGL
    that the clear color should be set to the RGBA value (0.0, 0.5, 0.0, 1.0)—that
    is, fully opaque, dark green. The next line instructs OpenGL to actually clear
    the color buffer—that is, it fills the entire screen with the clear color that
    was set on the previous line.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的第一行调用`glClearColor`，这实际上告诉OpenGL将清除颜色设置为RGBA值（0.0，0.5，0.0，1.0）——即完全不透明，深绿色。下一行指示OpenGL实际清除颜色缓冲区——即，它用上一行设置的清除颜色填充整个屏幕。
- en: Now, compile and run the project. You should see something similar to the following
    screenshot:![How to do it](img/00159.jpeg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目。您应该会看到以下截图类似的内容：![如何操作](img/00159.jpeg)
- en: Now, it's time to create OpenGL context. Drawing triangles in OpenGL is easier
    than drawing squares because triangles are always coplanar, that is, all of the
    points in the shape are on the same plane. So, to draw a square, we first draw
    two triangles that share an edge.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候创建OpenGL上下文了。在OpenGL中绘制三角形比绘制正方形更容易，因为三角形总是共面的，也就是说，形状中的所有点都在同一个平面上。因此，要绘制一个正方形，我们首先绘制两个共享边的三角形。
- en: 'To inform OpenGL about where the vertices are, we use a structure for vertices
    and for making an array. This will later show on `GLView` as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通知OpenGL顶点的位置，我们使用一个结构体来表示顶点和数组。这将稍后在`GLView`中显示如下：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we need to define which triangle uses which vertices. In OpenGL, we do
    this by numbering each vertex, and then describing triangles by giving OpenGL
    three numbers at a time:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义哪个三角形使用哪个顶点。在OpenGL中，我们通过为每个顶点编号，然后每次给出三个数字来描述三角形：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, `Glubyte` is the type in which the first triangle uses vertices
    `0`, `1`, and `2`, and the second triangle uses vertices `2`, `3`, and `0`. Note
    that both triangles use vertices `0` and `2`. This means that they share an edge,
    which means that there won't be any gap between the two triangles.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，`Glubyte`是第一个三角形使用顶点`0`、`1`和`2`，第二个三角形使用顶点`2`、`3`和`0`的类型。请注意，两个三角形都使用了顶点`0`和`2`。这意味着它们共享一条边，这意味着两个三角形之间不会有任何间隙。
- en: 'Both the `SquareVertices` and `SquareTriangles` arrays need to be stored in
    a buffer so that OpenGL can use them for rendering as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SquareVertices`和`SquareTriangles`数组都需要存储在缓冲区中，以便OpenGL可以使用它们进行渲染，如下所示：'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we set up the `GLKView` with an OpenGL context, as shown in the following
    code. Because, if we don't do this, none of our OpenGL commands will do anything.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用OpenGL上下文设置`GLKView`，如下所示。因为，如果我们不这样做，我们的所有OpenGL命令都不会有任何作用。
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create the buffers starting with the vertex buffer:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从顶点缓冲区开始创建缓冲区：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The vertex buffer is then filled with the vertex information:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将顶点缓冲区填充顶点信息：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The same thing is then done for the index buffer, which you''ll recall stores
    information on which vertices the two triangles will use:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后对索引缓冲区做同样的事情，你可能还记得它存储了两个三角形将使用哪些顶点的信息：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once this is done, all of the information has been passed to OpenGL. GLKit provide
    several effects, which are the objects that contain information such as color,
    position, orientation, and so on. In this activity, we will make one square to
    be red and to be present it in the middle of the screen.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦完成，所有信息都已传递给OpenGL。GLKit提供了一些效果，这些是包含颜色、位置、方向等信息的对象。在这个活动中，我们将使一个正方形变成红色，并将其显示在屏幕中间。
- en: 'The first step is to create the effect object, and then provide it with a projection
    matrix. The projection matrix controls the overall sizes of things on the screen.
    In this case, we create a projection matrix that uses the aspect ratio of the
    screen and uses a 60 degrees field of view:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建效果对象，然后向其提供一个投影矩阵。投影矩阵控制屏幕上物体的整体大小。在这种情况下，我们创建了一个使用屏幕宽高比和60度视场的投影矩阵：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to provide a model view matrix. The model view matrix controls
    the position of the object, relative to the camera:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个模型视图矩阵。模型视图矩阵控制对象相对于摄像机的位置：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the `drawInRect` method after the `viewDidLoad` method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`viewDidLoad`方法之后创建`drawInRect`方法：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual work of rendering is done in the `glkView:drawInRect` method. The
    first thing that happens in this is that the view is cleared, by filling the screen
    with black:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的渲染工作是在`glkView:drawInRect`方法中完成的。在这个过程中发生的第一件事是清除视图，通过用黑色填充屏幕：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now call `prepareToDraw`. It configures OpenGL in such a way that anything
    we draw will use the effect''s setting:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调用`prepareToDraw`。它以这种方式配置OpenGL，使得我们绘制的任何内容都将使用效果的设置：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We first tell OpenGL that we''re going to be working with positions, and then
    tell OpenGL where to find the position information in the vertex data:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先告诉OpenGL我们将要处理位置，然后告诉OpenGL在顶点数据中找到位置信息的位置：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to know how many vertices we''re asking OpenGL to draw. This
    can be figured out by taking the size of the entire index array, and dividing
    that by the size of one element in that array:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要知道我们要求OpenGL绘制多少个顶点。这可以通过取整个索引数组的大小，并将其除以该数组中一个元素的大小来得出：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, our final implementation class probably looks like the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的最终实现类可能看起来像以下代码：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the project, and you will see the red square box on the black screen, as
    shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，你将在黑色屏幕上看到红色的正方形框，如下面的截图所示：
- en: '![How to do it](img/00160.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/00160.jpeg)'
- en: Building a mini 3D animation game using OpenGL
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL构建一个迷你3D动画游戏
- en: In this recipe, we will load a texture and apply it to the square. Later, we
    will make a cube, and finally we will learn how to implement three-dimensional
    animation by rotating our cube in three-dimensions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将加载一个纹理并将其应用到正方形上。稍后，我们将制作一个立方体，最后我们将学习如何通过在三维空间中旋转我们的立方体来实现三维动画。
- en: How to do it
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now we will start from the place we have left before and will load all the
    textures. To load the textures, follow the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从之前留下的地方开始，并加载所有纹理。要加载纹理，请遵循以下步骤：
- en: 'First, in our vertex structure, we need to include texture coordinate information:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的顶点结构中，我们需要包含纹理坐标信息：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add an image (any) in our project, rename it as `Texture.png`, and then
    add the following code in `viewDidLoad`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的项目中添加一个图像（任何图像），将其重命名为`Texture.png`，然后在`viewDidLoad`中添加以下代码：
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To modify the earlier square color, remove the following lines:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修改之前正方形的颜色，请删除以下行：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, when rendering in `glkView:drawInRect`, we indicate to OpenGL where
    to find texture coordinates in the vertex information:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`glkView:drawInRect`中渲染时，我们指示OpenGL在顶点信息中找到纹理坐标的位置：
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the square is rendered, you''ll see your image appear on it, as shown
    in the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当正方形被渲染时，你会在其上看到你的图像，如下面的截图所示：
- en: '![How to do it](img/00161.jpeg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/00161.jpeg)'
- en: Now we will make it as a cube. The cube is made up of eight vertices, so we
    need to provide information for each vertex, including its position and texture
    coordinates. From now on, rename `SquareVertices` to `CubeVertices` to follow
    a better naming convention.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将其制作成一个立方体。立方体由八个顶点组成，因此我们需要为每个顶点提供信息，包括其位置和纹理坐标。从现在开始，将`SquareVertices`重命名为`CubeVertices`以遵循更好的命名约定。
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step is a purely aesthetic one: the cube will be rotated, in order
    to illustrate that it is in fact a three-dimensional object.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤完全是出于美观考虑：立方体将会旋转，以展示它实际上是一个三维物体。
- en: 'Select the following lines:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择以下行：
- en: '[PRE23]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace them with the following:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换为以下内容：
- en: '[PRE24]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, to draw our cube, a depth buffer needs to be added and enabled. The
    depth buffer is needed to provide a three-dimensional and more realistic look
    to the object.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，为了绘制我们的立方体，需要添加并启用深度缓冲区。深度缓冲区是提供三维和更逼真外观的对象所必需的。
- en: 'Add the following code immediately after the call to EAGLContext''s `setCurrentContext`
    method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 EAGLContext 的 `setCurrentContext` 方法后立即添加以下代码：
- en: '[PRE25]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, replace the `glClear(GL_COLOR_BUFFER_BIT);` line with the `glClear(GL_COLOR_BUFFER_BIT
    | GL_DEPTH_BUFFER_BIT);` line.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `glClear(GL_COLOR_BUFFER_BIT);` 行替换为 `glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);`
    行。
- en: Compile and run the project to see the cube in three-dimensions, as shown in
    the following screenshot:![How to do it](img/00162.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行项目以查看三维立方体，如图所示：![如何操作](img/00162.jpeg)
- en: 'Now we will take it to the next level by adding a code to rotate a cube. Now
    we will animate movement in a view, such as rotation. Add the following instance
    variable to the `ViewController` class in the interface part:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将把它提升到下一个层次，通过添加代码来旋转一个立方体。现在我们将动画化视图中的移动，例如旋转。在接口部分将以下实例变量添加到 `ViewController`
    类中：
- en: '[PRE26]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, add the following method to the class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下方法添加到类中：
- en: '[PRE27]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the update function should look something similar to the following screenshot:![How
    to do it](img/00163.jpeg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新函数应该看起来类似于以下截图：![如何操作](img/00163.jpeg)
- en: Now compile and run the application. You will find your cube rotating at the
    angle we have specified, as shown in the following screenshot:![How to do it](img/00164.jpeg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行应用程序。您会发现您的立方体以我们指定的角度旋转，如图所示：![如何操作](img/00164.jpeg)
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: So far we have learned various ways to create two-dimensional and three-dimensional
    models using OpenGL. OpenGL serves as the backbone of the three-dimensional game
    programming, and hence is a very vast topic to dive into. We have just taken a
    glance of OpenGL, to know more about it, you can refer to [https://developer.apple.com/opengl/](https://developer.apple.com/opengl/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用 OpenGL 创建二维和三维模型的各种方法。OpenGL 是三维游戏编程的骨架，因此是一个非常广泛的主题。我们只是对 OpenGL
    进行了简要的浏览，要了解更多信息，您可以参考 [https://developer.apple.com/opengl/](https://developer.apple.com/opengl/)。
