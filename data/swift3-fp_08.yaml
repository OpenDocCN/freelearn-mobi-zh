- en: Chapter 8. Functional Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 函数式数据结构
- en: 'We are familiar with imperative data structures. In fact, there are lots of
    references for imperative data structures in different programming languages.
    In contrast, there aren''t many references for declarative data structures or
    functional data structures. This is because functional programming languages are
    not as mainstream as imperative programming languages. Additionally, designing
    and implementing functional data structures is more difficult in comparison to
    imperative counterparts because of the following reasons:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉命令式数据结构。实际上，在多种编程语言中都有许多关于命令式数据结构的参考资料。相比之下，关于声明式数据结构或函数式数据结构的参考资料并不多。这是因为函数式编程语言不像命令式编程语言那样主流。此外，由于以下原因，与命令式对应物相比，设计实现函数式数据结构更困难：
- en: Mutability is not recommended in functional programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程中不建议使用可变性
- en: Functional data structures are expected to be more flexible than their imperative
    counterparts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式数据结构预计比它们的命令式对应物更灵活
- en: Imperative data structures rely heavily on mutability and assignments and making
    them immutable needs extra development effort. Whenever we change an imperative
    data structure, we basically override the previous version; however, this is not
    the case with declarative programming as we expect that both the previous and
    new versions of the functional data structure will continue to survive and be
    utilized.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式数据结构严重依赖于可变性和赋值，使它们不可变需要额外的开发工作。每次我们更改命令式数据结构时，我们基本上都会覆盖之前的版本；然而，这与声明式编程不同，我们期望功能数据结构的旧版本和新版本都将继续存在并被使用。
- en: 'We might think why bother with functional data structures as they are more
    difficult to design and implement? There are two answers to this question: first
    of all, functional data structures are efficient and immutable data structures.
    Secondly, they support functional programming paradigms. We have already seen
    an example of these when we were introduced to algebraic data types in [Chapter
    4](ch04.html "Chapter 4. Enumerations and Pattern Matching"), *Enumerations and
    Pattern Matching*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想，为什么要在函数式数据结构上费心，因为它们的设计和实现更困难？这个问题有两个答案：首先，函数式数据结构是高效的不可变数据结构。其次，它们支持函数式编程范式。当我们介绍到代数数据类型时，我们已经看到了这些例子，那就是在第4章[第4章](ch04.html
    "第4章. 枚举和模式匹配")，*枚举和模式匹配*。
- en: In this chapter, we will further explore functional data structures with coding
    examples. The content of this chapter is heavily inspired by *Purely Functional
    Data Structures*, *Chris Okasaki*, *Cambridge University Press*, which is a great
    reference on this topic to date and has various examples with ML and Haskell programming
    languages. Reading Okasaki's book is highly recommended for functional programmers.
    In this chapter, we will cover the topic and explore some of the examples in Okasaki's
    book in Swift.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过编码示例进一步探索函数式数据结构。本章内容深受*纯函数式数据结构*、*Chris Okasaki*、*剑桥大学出版社*的启发，这是迄今为止该主题的一个很好的参考，其中包含各种ML和Haskell编程语言的示例。强烈推荐函数式程序员阅读Okasaki的书籍。在本章中，我们将涵盖这个主题，并探索Okasaki书籍中的一些示例，使用Swift实现。
- en: 'Particularly, we will utilize structs and enumerations to implement the following
    functional data structures:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将利用结构体和枚举来实现以下函数式数据结构：
- en: Semigroup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半群
- en: Monoid
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幂集
- en: Binary Search Tree
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: Linked list
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Stack
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Lazy list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰列表
- en: Coding examples for these data structures serve as a presentation of functional
    programming paradigms and techniques and they are not going to be complete.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据结构的编码示例作为函数式编程范式和技术展示，它们不会是完整的。
- en: We know that immutability is the most important property of functional data
    structures. To design and implement immutable data structures, we will not change
    a functional data structure and instead create a new version that lives along
    with the previous version. In fact, we will copy the parts that need to be changed
    without touching the original version of the data structure. So we will use value
    types such as structs and enumerations to be able to achieve this. In addition,
    as we will not change the original data structure directly, we will be able to
    share the original data structure parts with the new structure without being worried
    about how changing one version would affect the other version. Let's examine how
    we will achieve this by implementing different functional data structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道不可变性是函数式数据结构最重要的属性。为了设计和实现不可变数据结构，我们不会改变函数式数据结构，而是创建一个新的版本，它与旧版本一起存在。实际上，我们将复制需要更改的部分，而不触及数据结构的原始版本。因此，我们将使用值类型，如结构体和枚举，以便能够实现这一点。此外，由于我们不会直接更改原始数据结构，我们将能够在新结构中共享原始数据结构的部分，而不用担心更改一个版本会如何影响另一个版本。让我们通过实现不同的函数式数据结构来检查我们将如何实现这一点。
- en: Semigroup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半群
- en: In computer science, a Semigroup is an algebraic structure that has a set and
    a binary operation that takes two elements in the set and returns a Semigroup
    that has an associative operation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，半群是一个代数结构，它有一个集合和一个二元运算，该运算接受集合中的两个元素并返回一个具有结合运算的半群。
- en: 'To start, we need to have a set and a specific binary operation, or we can
    make this behavior generic and define a protocol as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要有一个集合和特定的二元运算，或者我们可以使这种行为通用，并定义以下协议：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any type that conforms to this protocol requires to implement the `operation`
    method. Here, `self` presents the type that is conforming to this protocol. For
    instance, we can extend `Int` to conform to the Semigroup protocol and provide
    a summation on itself:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何符合此协议的类型都需要实现`operation`方法。在这里，`self`代表符合此协议的类型。例如，我们可以扩展`Int`以符合半群协议，并为其提供求和操作：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can test this as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样测试：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This test does not ensure the associativity of the binary operations. Let''s
    try this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试并不能确保二元运算的结合律。让我们尝试这个：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code ensures that our binary operator is associative; therefore,
    our Semigroup is verified. It does not look very nice though; let''s implement
    an operator for our operation to make it look better and more math friendly:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码确保我们的二元运算符是结合的；因此，我们的半群得到了验证。但这看起来并不太美观；让我们实现一个操作符来使它看起来更好，更符合数学风格：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s rewrite our test with the `<>` operator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`<>`运算符重写我们的测试：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So far, we extended only `Int` but we can extend any type. Let''s extend arrays
    as an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只扩展了`Int`，但我们可以扩展任何类型。让我们以数组为例进行扩展：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `operation` method is very similar to what we have for `Int`. The only
    difference is in the type, which is an array in this case:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`operation`方法与我们为`Int`所拥有的非常相似。唯一的区别在于类型，在这种情况下是一个数组：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Furthermore we can extend String as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以如下扩展`String`：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have established a general principle of composition (two objects combining
    into one) using a protocol. This pattern can be used for different purposes. For
    instance, we can implement a shorter version of reduce for arrays over Semigroups:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用协议建立了一个组合的一般原则（两个对象结合成一个）。这种模式可以用于不同的目的。例如，我们可以为半群上的数组实现reduce的简短版本：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `sconcat` function name stands for semigroup concat; we can test it as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sconcat`函数名代表半群连接；我们可以这样测试它：'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our last `sconcat` example works like `flatMap` and flattens elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的`sconcat`示例像`flatMap`一样工作，它会展平元素。
- en: 'Finally, our Semigroup becomes the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的半群变成了以下形式：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A Semigroup is a great example of a simple data structure but it is not as popular
    as a Monoid, which we will examine in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 半群是一个简单的数据结构的绝佳例子，但它不像幂集那样受欢迎，我们将在下一节中探讨。
- en: Monoid
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂集
- en: 'In computer science, a Monoid is a set, a binary operation, and an element
    of the set with the following rules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，幂集是一个集合、一个二元运算以及集合中的一个元素，遵循以下规则：
- en: Associativity of binary operations
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元运算的结合律
- en: The element is the identity
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该元素是单位元
- en: 'Simply put, a structure is Monoid if the structure is a Semigroup with an element
    that is the identity. So let''s define a new protocol that extends our Semigroup
    protocol:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个结构是 Monoid，如果这个结构是一个 Semigroup，并且有一个是恒等元的元素。所以让我们定义一个新的协议，它扩展了我们的 Semigroup
    协议：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can test our structure as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样测试我们的结构：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As Monoid has an element, we can use this as an initial and simplify our `reduce`
    method as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Monoid 有一个元素，我们可以使用这个元素作为初始值，并简化我们的 `reduce` 方法如下：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s test this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Trees
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: In computer science, a Tree is a very popular **abstract data type** (**ADT**)
    or a data structure implementing this ADT that simulates a hierarchical tree structure
    with a root value and subtrees of the children with a parent node, represented
    as a set of linked nodes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，树是一个非常流行的 **抽象数据类型**（**ADT**）或实现此 ADT 的数据结构，它模拟了一个具有根值和子树以及父节点的层次树结构，这些子树和父节点由一组链接的节点表示。
- en: A tree data structure can be defined recursively (locally) as a collection of
    nodes (starting at a root node), where each node is a data structure consisting
    of a value, together with a list of references to nodes (the *children*) with
    the constraints that no reference is duplicated and none point to the root.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 树数据结构可以递归地（局部地）定义为从根节点开始的节点集合，其中每个节点是一个包含值以及指向节点（*子节点*）的引用列表的数据结构，约束条件是没有任何引用是重复的，也没有指向根节点。
- en: 'Alternatively, a tree can be defined abstractly as a whole (globally) as an
    ordered tree, with a value assigned to each node. Both these perspectives are
    useful: while a tree can be analyzed mathematically as a whole, when actually
    represented as a data structure, it is usually represented and worked separately
    by a node (rather than as a list of nodes and an adjacency list of edges between
    nodes, as one may represent a digraph, for instance). For example, looking at
    a tree as a whole, one can talk about the *parent* node of a given node, but in
    general as a data structure, a given node only contains the list of its children
    but not a reference to its parent (if any).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个树可以抽象地定义为一个整体（全局）有序树，每个节点都分配了一个值。这两种观点都很有用：虽然树可以作为一个整体进行数学分析，但实际上作为数据结构表示时，通常是由节点单独表示和处理的（而不是像表示有向图那样，作为节点列表和节点之间边的关系列表）。例如，将树作为一个整体来看，可以谈论给定节点的
    *父节点*，但在一般情况下，作为一个数据结构，一个给定的节点只包含其子节点的列表，但不包含对其父节点的引用（如果有的话）。
- en: 'In a previous chapter, we implemented a generic binary tree in Swift. The following
    is an improved version of that:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们实现了 Swift 中的泛型二叉树。以下是一个改进版本：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We define the `Tree` as an `enum` with three different cases:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Tree` 定义为一个具有三个不同情况的 `enum`：
- en: '**Leaf**: If we are at the end of a branch of the `Tree`; simply put, if a
    node does not have any children, then it is a `Leaf`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶子节点**：如果我们处于 `Tree` 的一个分支的末端；简单来说，如果一个节点没有任何子节点，那么它就是一个 `Leaf`'
- en: '**Node**: A structure that has a left-hand side and right-hand side to it'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：一个具有左右两侧的结构'
- en: 'The following figure presents an example `Tree`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个示例 `Tree`：
- en: '![Trees](img/image_08_001.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![树](img/image_08_001.jpg)'
- en: A `Tree` is generic and the elements in it are comparable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tree` 是一个泛型，其中的元素是可以比较的。'
- en: 'Using this `Tree` is as simple as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Tree` 的方法如下所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `functionalTree` is immutable or, in other words, it is persistent. It
    has a leaf as `lhs` and a node with two leaves as `rhs`. As this structure is
    immutable, we will not be worried whether it is going to change or not and we
    will be able to share this tree with other trees:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `functionalTree` 是不可变的，换句话说，它是持久的。它有一个作为 `lhs` 的叶子节点和一个包含两个叶子节点的节点作为 `rhs`。由于这个结构是不可变的，我们不必担心它是否会改变，并且我们可以与其他树共享这个树：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding examples, we used our first `Tree` called `functionalTree`
    as a part of `secondFT` and `thirdFT`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了我们的第一个 `Tree`，即 `functionalTree`，作为 `secondFT` 和 `thirdFT` 的一部分。
- en: Contains
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含
- en: 'This `Tree` is far from complete and needs lots of functionality. For instance,
    we may need to check whether the `Tree` contains a specific value. To be able
    to do this, we need to add the following method to our `Tree`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Tree` 还远未完善，需要很多功能。例如，我们可能需要检查 `Tree` 是否包含特定的值。为了能够做到这一点，我们需要向我们的 `Tree`
    添加以下方法：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can test contains method as the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样测试 `contains` 方法：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Binary Search Tree
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: Our assumption in our simple `Tree` was that only leaves contain a value. This
    is not always true. In fact, there are different types of trees with different
    utilities and a **Binary Search Tree** (**BST**) is one of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简单的 `Tree` 假设中，只有叶子节点包含值。这并不总是正确的。事实上，存在不同类型的树，它们具有不同的效用，而 **二叉搜索树（BST**）
    就是其中之一。
- en: 'In computer science, binary search trees, sometimes called ordered or sorted
    binary trees, are a particular type of container: data structures that store *items*
    (such as numbers, names, and so on) in memory. They allow fast lookup, the addition
    and removal of items, and implementation of either dynamic sets of items or lookup
    tables that allow finding an item by its key (for example, finding the phone number
    of a person by name).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，二叉搜索树，有时称为有序或排序二叉树，是一种特定的容器：数据结构，它们在内存中存储 *项目*（如数字、名称等）。它们允许快速查找、添加和删除项目，并实现动态项目集或查找表，允许通过其键（例如，通过姓名查找某人的电话号码）来查找项目。
- en: 'BSTs keep their keys in sorted order so that lookup and other operations can
    use the principle of binary search: when looking for a key in a tree (or a place
    to insert a new key), they traverse the tree from root to leaf, making comparisons
    to keys stored in the nodes of the tree and deciding, based on the comparison,
    whether to continue searching in the left or right subtrees. On an average, this
    means that each comparison allows the operations to skip about half of the tree
    so that each lookup, insertion, or deletion takes time proportional to the logarithm
    of the number of items stored in the tree. This is much better than the linear
    time required to find items by key in an (unsorted) array, but slower than the
    corresponding operations on hash tables.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: BSTs 将它们的键按排序顺序存储，以便查找和其他操作可以使用二分搜索的原则：当在树中查找一个键（或插入新键的位置）时，它们从根节点遍历到叶子节点，将树节点中存储的键进行比较，并根据比较结果决定是否在左子树或右子树中继续搜索。平均而言，这意味着每次比较都允许操作跳过大约一半的树，因此每次查找、插入或删除的时间与树中存储的项目数量的对数成比例。这比在（未排序的）数组中通过键查找项目所需的线性时间要好得多，但比哈希表上的相应操作要慢。
- en: 'Let''s improve our simple tree and convert it to a BST:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的简单树并将其转换为 BST：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `BinarySearchTree` tree is very similar to the previous `Tree` and the
    only difference is that `node` contains the `element` and not the `leaf`. Using
    it is as simple as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchTree` 树与之前的 `Tree` 非常相似，唯一的区别是 `node` 包含 `element` 而不是 `leaf`。使用它的方法如下：'
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we create a BST as values stored in `lhs` are smaller than the root and
    values stored in `rhs` are larger than the root. In this example, `lhs` is a BST
    with `1` as value. Root has the value of `5` and `rhs` is a BST with `9` as value
    which is larger than root value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 BST，因为存储在 `lhs` 中的值小于根节点，而存储在 `rhs` 中的值大于根节点。在这个例子中，`lhs` 是一个值为
    `1` 的 BST。根节点的值为 `5`，而 `rhs` 是一个值为 `9` 的 BST，这个值大于根节点的值。
- en: Contains
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含
- en: 'Additionally, our `contains` method requires to be modified as it will search
    only in leaves. Let''s improve this, assuming that our Tree is a BST:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的 `contains` 方法需要修改，因为它将仅在叶子节点中搜索。让我们改进它，假设我们的树是一个 BST：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method searches for a specific `element` and returns `true` if it finds
    it in `node`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法搜索特定的 `element`，如果它在 `node` 中找到它，则返回 `true`。
- en: 'The following presents an example usage of this method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了此方法的示例用法：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `isFound` variable is going to be `true` in this case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`isFound` 变量在这种情况下将被设置为 `true`。'
- en: Size
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小
- en: 'To make this BST a little more complete, let''s implement a property to check
    for its size:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个 BST 更完整，让我们实现一个属性来检查它的大小：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This computed property is going to provide the size of the BST and we can use
    it as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算属性将提供 BST 的大小，我们可以如下使用它：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Elements
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素
- en: 'It would be great to be able to generate an array from BST elements. This can
    be done as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从 BST 元素生成一个数组将是非常棒的。这可以如下完成：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Empty
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空的
- en: 'We can implement a helper method to generate empty BSTs as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施一个辅助方法来生成空二叉搜索树（BST），如下所示：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is a computed property to check whether the BST is empty:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个计算属性，用于检查 BST 是否为空：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s test these functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这些函数：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we created an empty BST and checked whether it is empty
    using the `isEmpty` property. Obviously, the result is going to be `true`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个空的 BST 并使用 `isEmpty` 属性检查它是否为空。显然，结果将是 `true`。
- en: This BST implementation is far from complete and requires to be improved by
    implementing methods to check whether it is a BST.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 BST 实现远未完成，需要通过实现检查它是否为 BST 的方法来改进。
- en: 'At the end, our BST becomes the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的二叉搜索树（BST）变成了以下这样：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even though it does not represent a full implementation of a BST, we were able
    to develop it in a functional style, and we will be able to share and reuse the
    tree among other trees because they are immutable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它并不代表 BST 的完整实现，但我们能够以函数式风格开发它，并且我们将在其他树之间共享和重用这棵树，因为它们是不可变的。
- en: Lists
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lists
- en: There are multiple types of lists including linked lists, doubly linked lists,
    multiple linked lists, circular linked lists, queues, and stacks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有多种类型，包括链表、双向链表、多重链表、循环链表、队列和栈。
- en: In this section, we will present a simple linked list that is one of the simplest
    and most popular data structures in imperative programming languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一个简单的链表，这是命令式编程语言中最简单且最受欢迎的数据结构之一。
- en: 'A linked list is a linear collection of data elements called nodes pointing
    to the next node using pointers. Linked lists contain their data in a linear and
    sequential manner. Simply, each node is composed of data and a reference to the
    next node in the sequence:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是由称为节点的数据元素线性集合，这些节点使用指针指向下一个节点。链表以线性顺序方式存储其数据。简单地说，每个节点由数据和指向序列中下一个节点的引用组成：
- en: '![Lists](img/image_08_002.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Lists](img/image_08_002.jpg)'
- en: 'Let''s start with a simple version:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单版本开始：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our approach is similar to our BST implementation approach. The difference resides
    in the `node` case that has a `data` element and a pointer to its next element,
    which is also a `LinkedList`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法与我们的 BST 实现方法类似。区别在于 `node` 情况具有 `data` 元素和指向其下一个元素的指针，该指针也是一个 `LinkedList`。
- en: Empty LinkedList
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Empty LinkedList
- en: 'Our `LinkedList` needs a method to create it as empty:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LinkedList` 需要一个方法来创建它为空：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is as simple as returning `.end`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像返回 `.end` 一样简单。
- en: Cons
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cons
- en: 'We need to have a way to append items to `LinkedList`, so we implement it as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一种方法来向 `LinkedList` 添加项目，所以我们按照以下方式实现它：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This simple method appends the data to the front of `LinkedList`; in other
    words, it is like a push operation to a stack. We can test it as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法将数据追加到 `LinkedList` 的前面；换句话说，它就像对栈的推操作。我们可以如下测试它：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result of this operation should be the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的最终结果应该是以下这样：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Functional programming languages such as Haskell and Scala have operators for
    cons. It is `:` in Haskell and `::` in Scala. As we cannot use `:` in Swift to
    define an infix operator, we are going to use `<|` instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言，如 Haskell 和 Scala，有 cons 操作符。在 Haskell 中是 `:`，在 Scala 中是 `::`。由于我们无法在
    Swift 中使用 `:` 来定义中缀操作符，我们将使用 `<|` 代替：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will be able to test it as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下测试它：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This statement produces the exact same result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句会产生完全相同的结果。
- en: 'Again, this `LinkedList` is far from complete but we already achieved great
    reusability as it is functional. We can use/share our `functionalLinkedList` with
    other linked lists without worrying about changes and inconsistencies. Let''s
    examine the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个 `LinkedList` 远未完成，但我们已经实现了很高的可重用性，因为它是以函数式实现的。我们可以使用/共享我们的 `functionalLinkedList`
    与其他链表，而不用担心变化和不一致性。让我们检查以下内容：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding examples, we use `functionalLinkedList` and add a new item
    (`4`) to it to obtain `secondLL` and `5` to obtain `thirdLL`. Also, we use `secondLL`
    to create `fourthLL`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `functionalLinkedList` 并向其中添加一个新项目（`4`）以获得 `secondLL`，以及 `5` 以获得
    `thirdLL`。我们还使用 `secondLL` 来创建 `fourthLL`。
- en: Contains
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Contains
- en: 'To make this `LinkedList` a little more interesting, we will develop a contains
    method similar to the one that we developed for the BST:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个 `LinkedList` 更有趣，我们将开发一个类似于为 BST 开发的包含方法：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This method recursively checks for a specific element in `LinkedList` and returns
    `true` if it finds the element:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法递归地在 `LinkedList` 中检查特定元素，如果找到该元素则返回 `true`：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The result of this expression is going to be `true`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的结果是 `true`。
- en: Size
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Size
- en: 'We can implement a computed `size` property to calculate the size of linked
    list as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个计算出的 `size` 属性来计算链表的大小如下：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This method recursively goes through `LinkedList` and counts the number of
    nodes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法递归地遍历 `LinkedList` 并计算节点数：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The result is going to be `3` in this example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，结果将是 `3`。
- en: Elements
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elements
- en: 'We can implement a computed property to provide an array of elements as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施一个计算属性来提供一个元素数组如下：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we recur through LinkedList and return an array of data. We will be able
    to use this property as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们递归遍历 LinkedList 并返回一个数据数组。我们将能够使用这个属性如下：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This statement prints `[3, 2, 1]`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句打印 `[3, 2, 1]`。
- en: isEmpty
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: isEmpty
- en: 'Another common operation that `LinkedList` requires is a way to check whether
    it is empty. We can easily implement it in the following way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList` 需要的另一个常见操作是检查它是否为空。我们可以轻松地以下方式实现它：'
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To test this computed property, we will create an empty `LinkedList` as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个计算属性，我们将创建一个空的 `LinkedList` 如下：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, the first `print` statement results in `true` and
    the second results in `false`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个 `print` 语句的结果是 `true`，第二个结果是 `false`。
- en: map, filter, and reduce
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map, filter, 和 reduce
- en: You may have wondered if we are going to be able to apply higher-order functions
    such as map, filter, and reduce to our linked list. We have implemented our linked
    list with a recursive `enum` and the recursive pattern is well-suited to higher-order
    functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是否能够将高阶函数如 map、filter 和 reduce 应用到我们的链表上。我们已经使用递归 `enum` 实现了我们的链表，递归模式非常适合高阶函数。
- en: 'Let''s start with `map`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `map` 开始：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Using this method, we will be able to transform elements in our linked list.
    Nothing fancy here; we use the same `cons` operator that we defined before. The
    following statement will test our method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们将能够转换链表中的元素。这里没有什么特别的；我们使用之前定义的相同的 `cons` 操作符。以下语句将测试我们的方法：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The result should be the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是以下这样：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So we can easily multiply elements in our linked list by `2`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以轻松地将链表中的元素乘以 `2`。
- en: 'Let''s continue with the `filter` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续 `filter` 方法：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we check whether the `predicate` yields a result first. If it does, then
    we apply our `cons` operator to the data and recursively `filter` the next element.
    Otherwise, we just recursively apply `filter` to the next element. We can test
    this method as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查 `predicate` 是否产生结果。如果产生了，然后我们将我们的 `cons` 操作符应用于数据，并递归地 `filter` 下一个元素。否则，我们只是递归地应用
    `filter` 到下一个元素。我们可以如下测试这个方法：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding code example, we `filter` our linked list to the ones that
    are even. This statement results in the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们 `filter` 我们链表中的偶数元素。这个语句的结果如下：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is great to be able to `map` and `filter` our linked list, but we need to
    have a `reduce` method as well. Let''s implement this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 能够对链表进行 `map` 和 `filter` 是很棒的，但我们还需要一个 `reduce` 方法。让我们来实现这个：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding code example, we go through the linked list''s elements recursively
    and `reduce` the values to a single value. The following code presents a usage
    example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们递归遍历链表的元素并将值 `reduce` 到单个值。以下代码展示了使用示例：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result of this expression is going to be `6`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的结果是 `6`。
- en: 'At the end, our `LinkedList` becomes the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的 `LinkedList` 变成以下形式：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Stacks
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is a collection that is based on the **Last In First Out** (**LIFO**)
    policy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种基于 **后进先出**（**LIFO**）策略的集合。
- en: 'The following figure presents a sample stack:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了示例栈：
- en: '![Stacks](img/image_08_003.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![栈](img/image_08_003.jpg)'
- en: 'To implement a simple functional stack, we need to provide `push`, `pop`, `isEmpty`,
    and `size` operations. We implemented a functional `LinkedList` in the previous
    section, which can be used to implement a simple functional stack with the following
    operations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个简单的函数式栈，我们需要提供 `push`、`pop`、`isEmpty` 和 `size` 操作。我们在前面的部分实现了一个函数式 `LinkedList`，它可以用来实现一个简单的函数式栈，具有以下操作：
- en: '**push**: The `cons` operation in `LinkedList`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push**: `LinkedList` 中的 `cons` 操作'
- en: '**pop**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop**'
- en: '**isEmpty**: The `isEmpty` operation in `LinkedList`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty**: `LinkedList` 中的 `isEmpty` 操作'
- en: '**size**: The `size` method in `LinkedList`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**: `LinkedList` 中的 `size` 方法'
- en: 'As seen here, the only operation that is missing is `pop`. Let''s implement
    that:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如此看来，唯一缺少的操作是 `pop`。让我们来实现它：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To test this, we can execute the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们可以执行以下操作：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result of the first `print` will be `3` and the result of the second `print`
    will be the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 的结果将是 `3`，第二个 `print` 的结果将是以下这样：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is just an example implementation, and we utilize `Optional` Tuple as a
    return to obtain the popped element as well as the resulting new linked list.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例实现，我们使用 `Optional` Tuple 作为返回值以获取弹出的元素以及结果新的链表。
- en: One more thing that we need to do is to change the name of our `enum` to something
    more generic, such as list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做的一件事是将我们的 `enum` 名称更改为更通用的名称，例如 list。
- en: Finally, our stack becomes very similar to the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的栈变得与列表非常相似。
- en: Lazy list
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性列表
- en: So far, we implemented a linked list and a stack as a list. One of the key concepts
    in functional programming is the concept of lazy evaluation. We can make our list
    lazy so that the elements will be evaluated once we access them. We need to change
    `node` in such a way that it will return a function containing List as next, instead
    of the list itself. The function will be evaluated when it is called; therefore,
    our list will be lazy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个链表和一个栈作为列表。函数式编程中的一个关键概念是惰性评估的概念。我们可以使我们的列表成为惰性的，这样元素将在我们访问它们时才被评估。我们需要以这种方式修改
    `node`，使其返回一个包含 List 的函数作为 `next`，而不是列表本身。该函数将在调用时进行评估；因此，我们的列表将是惰性的。
- en: 'We start with modifying our `node` case. In our `LinkedList` example, `next`
    was of the `LinkedList<Element>` type. To make our list lazy, we will modify `next`
    to be a function that returns our List:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先修改我们的 `node` 情况。在我们的 `LinkedList` 示例中，`next` 是 `LinkedList<Element>` 类型。为了使我们的列表成为惰性的，我们将修改
    `next` 以使其成为一个返回我们的 List 的函数：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we can see in the preceding code, our `Node` case is not defined as indirect
    because `next` is not of the `LazyList` type and is a reference to a function
    that returns `LazyList`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们的 `Node` 情况并没有定义为间接的，因为 `next` 不是 `LazyList` 类型，而是返回 `LazyList`
    的函数的引用。
- en: 'We need to accommodate this change into our properties and methods. It is going
    to be as easy as changing any `next` to `next()`. For example, our `size` property
    becomes the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将此更改纳入我们的属性和方法中。这就像将任何 `next` 改为 `next()` 一样简单。例如，我们的 `size` 属性变为以下内容：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we followed the code and changed it properly, we would see that our `map`
    and `filter` do not compile. We need to change the operator as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循代码并正确修改它，我们会看到我们的 `map` 和 `filter` 无法编译。我们需要按照以下方式更改操作符：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we change our `rhs` to a function type that matches our LazyList's `next`.
    This change did not fix our `map` and `filter` problems. It seems that the right-hand
    side of the `infix` operator is evaluated before being passed to it and we do
    not want this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `rhs` 更改为与我们的 LazyList 的 `next` 匹配的函数类型。这种更改并没有解决我们的 `map` 和 `filter`
    问题。看起来 `infix` 操作符的右侧在传递给它之前就被评估了，而我们不希望这样。
- en: 'This is because we do not pass a closure to our operator in the `map` and `filter`
    methods:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在 `map` 和 `filter` 方法中并没有将闭包传递给我们的操作符：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In our `map` method example, `next().map(transform)` is not a closure. If we
    wrap it in `{ }`, then it becomes a closure. We can modify our `infix` operator
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `map` 方法示例中，`next().map(transform)` 不是一个闭包。如果我们将其包裹在 `{ }` 中，那么它就变成了一个闭包。我们可以按照以下方式修改我们的
    `infix` 操作符：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `@autoclosure` attribute creates an automatic closure around the expression.
    So when we write an expression such as `next().map(transform)`, it is automatically
    wrapped in a closure to become `{ next().map(transform) }` before it is passed
    to our `infix` operator.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`@autoclosure` 属性在表达式周围创建一个自动闭包。因此，当我们编写 `next().map(transform)` 这样的表达式时，它会在传递给我们的
    `infix` 操作符之前自动包裹在一个闭包中，成为 `{ next().map(transform) }`。'
- en: Starting in Swift 1.2, `autoclosure` defaults to `noescape`. This attribute
    ensures that parameters are not stored for later execution and will not outlive
    the lifetime of the call. The `noescape` implementation adds minor performance
    optimizations and bypasses the need to annotate properties and methods with `self`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swift 1.2 开始，`autoclosure` 默认为 `noescape`。此属性确保参数不会被存储以供稍后执行，并且不会超出调用范围的生命周期。`noescape`
    实现添加了轻微的性能优化，并绕过了对属性和方法使用 `self` 进行注解的需要。
- en: The `escaping` annotation in brackets is necessary in order to signify that
    the closure will last longer than the lifetime of the scope that it is declared
    in.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的 `escaping` 注解是必要的，以便表示闭包的持续时间将超过其声明的范围的生命周期。
- en: 'Finally, we need to change our `cons` method by wrapping `self` in `{ }` as
    follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过以下方式将 `cons` 方法包裹在 `{ }` 中进行更改：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s test our `LazyList` and see if it works properly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的 `LazyList` 并看看它是否正常工作：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our lazy list now becomes as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们惰性列表现在如下所示：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the concept of functional data structures and explored
    examples of data structures implemented in a functional way, such as Semigroup,
    Monoid, BST, linked list, stack, and lazy list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数式数据结构的概念，并探讨了以函数方式实现的数据结构示例，例如 Semigroup、Monoid、BST、链表、栈和惰性列表。
- en: Even though none of the data structures are complete, they serve as structures
    that present functional programming paradigms and techniques. It would also be
    beneficial to examine the performance of any of these data structures.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些数据结构都不完整，但它们作为展示函数式编程范式和技术结构的例子是有用的。检查这些数据结构中的任何一个的性能也将是有益的。
- en: In the following chapter, we will cover the importance of immutability by examining
    its benefits. We will also examine an example of a mutable versus an immutable
    implementation as well as the means to get and set immutable objects in a functional
    way, such as copy constructors and lenses.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过考察其益处来探讨不可变性的重要性。我们还将检查可变与不可变实现的例子，以及以函数式方式获取和设置不可变对象的方法，例如复制构造函数和透镜。
