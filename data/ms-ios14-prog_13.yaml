- en: '*Chapter 13*: Working with the Combine Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 13 章*：使用 Combine 框架'
- en: With the launch of **Combine**, Apple provided developers with a new way of
    handling events in their code; a functional and declarative approach, where developers
    can implement streams and publisher/subscriber paradigms easily, without the need
    for external libraries. Centralizing event processing in your apps with the help
    of Combine makes your code easier to understand than using other traditional methods
    like nested closures or callbacks all around your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **Combine** 的推出，苹果为开发者提供了一种处理代码中事件的新方法；一种函数式和声明式的方法，开发者可以轻松实现流和发布者/订阅者范式，而无需外部库。借助
    Combine 在你的应用中集中处理事件，可以使你的代码比使用其他传统方法（如嵌套闭包或回调）更容易理解。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: 'Understanding the Combine framework: We will review the basic components of
    the framework with code samples – publishers, subscribers, subjects, and operators.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Combine 框架：我们将通过代码示例回顾框架的基本组件——发布者、订阅者、主题和操作符。
- en: 'Combining publishers, subscribers, and operators: We will build a small feature
    in an example app mixing all these concepts together.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合发布者、订阅者和操作符：我们将在示例应用中构建一个小功能，将所有这些概念混合在一起。
- en: 'Using operators to build error-proof streams: We will use `flatMap` and `catch`
    to create streams that can deal properly with errors in a real-world example app.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符构建无错误流：我们将在一个实际示例应用中使用 `flatMap` 和 `catch` 创建可以正确处理错误的流。
- en: By the end of the chapter, you should be able to use Combine in multiple parts
    of your own apps to produce simple, effective, and easy to understand declarative
    code that will help your app's code be easy to understand, extend, and maintain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够在你自己的应用的多个部分中使用 Combine，以生成简单、有效且易于理解的声明式代码，这将有助于你的应用代码易于理解、扩展和维护。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code bundle for this chapter includes two starter projects called **CombineExample_start**
    and **PublishersAndSubscribers_start**. You can find them in the code bundle repository:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包括两个起始项目，分别称为 **CombineExample_start** 和 **PublishersAndSubscribers_start**。你可以在代码包仓库中找到它们：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Understanding the Combine framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Combine 框架
- en: Apple released the Combine framework in 2019, and they defined it as a framework
    that provides a declarative Swift API for processing values over time. There are
    **publishers**, which produce those values, and **subscribers**, which consume
    them. These values that change over time may represent different asynchronous
    events.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在 2019 年发布了 Combine 框架，并将其定义为提供一个声明式 Swift API 以处理随时间变化的值的框架。存在 **发布者**，它们产生这些值，以及
    **订阅者**，它们消费这些值。这些随时间变化的值可能代表不同的异步事件。
- en: Let's see an overview of the Publisher and Subscriber protocol definitions to
    understand their key concepts in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中 Publisher 和 Subscriber 协议定义的概述，以了解它们的关键概念。
- en: Understanding Publisher
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解发布者
- en: 'As mentioned before, publishers are used in Combine to produce values over
    time. Let''s dig into the Swift protocol that defines them to understand the key
    concepts. The `Publisher` definition in Swift looks as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，发布者在 Combine 中用于随时间生成值。让我们深入了解定义它们的 Swift 协议，以了解关键概念。Swift 中的 `Publisher`
    定义如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s explain each numbered comment in more detail:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释每个编号的注释：
- en: Every `Publisher` instance has an associated type, `Output`. This defines the
    type of values that the publisher will generate over time.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `Publisher` 实例都有一个关联的类型，`Output`。这定义了发布者将在随时间生成值的类型。
- en: At the same time, the `Publisher` can also generate errors, and the associated
    type `Failure` is used to define the type of those errors. If a `Publisher` never
    generates errors, the `Failure` can be defined as type `Never`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，`Publisher` 也可以生成错误，并且相关的类型 `Failure` 用于定义这些错误的类型。如果一个 `Publisher` 永远不会生成错误，则
    `Failure` 可以定义为类型 `Never`。
- en: Finally, a `Publisher` allows `Subscriber` entities to `subscribe` to it to
    receive the values that are being produced over time. Note that to generate a
    valid subscription, the publisher's `Output` type must match the subscriber's
    `Input` type. In the same way, the `Failure` type of both must match too.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`发布者`允许`订阅者`实体`订阅`它，以接收随时间产生的值。请注意，为了生成一个有效的订阅，发布者的`Output`类型必须与订阅者的`Input`类型匹配。同样，两者的`Failure`类型也必须匹配。
- en: 'The following figure shows a summary of the **Publisher**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了`发布者`的概要：
- en: '![Figure 13.1 – Publisher summary'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – 发布者概要'
- en: '](img/Figure_13.1_B14717.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B14717.jpg)'
- en: Figure 13.1 – Publisher summary
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 发布者概要
- en: Now that we have an initial description of the critical concepts of a publisher,
    let's do the same with the `Subscriber` protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对发布者的关键概念有了初步描述，让我们对`订阅者`协议也做同样的处理。
- en: Understanding Subscriber
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解订阅者
- en: 'We have seen that `Publisher` entities produce values over time. Now let''s
    see how `Subscriber` entities can consume those values. `Publisher` and `Subscriber`
    work closely together in Combine, so let''s see their internal details. The `Subscriber`
    protocol in Swift looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`发布者`实体会随着时间的推移产生值。现在让我们看看`订阅者`实体如何消费这些值。在Combine中，`发布者`和`订阅者`紧密协作，所以让我们看看它们的内部细节。Swift中的`订阅者`协议看起来是这样的：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, let''s review each numbered line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们回顾每一条编号的行：
- en: A `Subscriber` entity is going to receive values over time. The associated type
    `Input` defines the type of those values.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订阅者`实体将随着时间的推移接收值。关联类型`Input`定义了这些值的类型。'
- en: At the same time, the `Subscriber` can also receive errors, and the associated
    type `Failure` is used to define the type of those errors. If a `Subscriber` never
    receives errors, the `Failure` can be defined as type `Never`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，`订阅者`也可以接收错误，关联类型`Failure`用于定义这些错误的类型。如果一个`订阅者`永远不会收到错误，则`Failure`可以定义为类型`Never`。
- en: This method informs the `Subscriber` that the subscription to the `Publisher`
    is successful and it may start requesting elements.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法通知`订阅者`，对`发布者`的订阅成功，它可能开始请求元素。
- en: Informs the `Subscriber` that the `Publisher` has produced a new item.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知`订阅者`，`发布者`已产生一个新项目。
- en: Some subscriptions may end over time. In those scenarios, this method is called
    to inform the `Subscriber` that it will not receive any more values. It allows
    us to execute a completion block before finishing.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些订阅可能在一段时间后结束。在这些情况下，此方法被调用以通知`订阅者`它将不再接收任何值。它允许我们在完成之前执行一个完成块。
- en: 'The following figure shows a summary of the **Subscriber**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了`订阅者`的概要：
- en: '![Figure 13.2 – Subscriber summary'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – 订阅者概要'
- en: '](img/Figure_13.2_B14717.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B14717.jpg)'
- en: Figure 13.2 – Subscriber summary
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 订阅者概要
- en: 'If we put together both Publisher and Subscriber figures, we have the following
    schema:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将发布者和订阅者图结合起来，我们得到以下架构：
- en: '![Figure 13.3 – Publisher and Subscriber schemas'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 发布者和订阅者架构'
- en: '](img/Figure_13.3_B14717.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B14717.jpg)'
- en: Figure 13.3 – Publisher and Subscriber schemas
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 发布者和订阅者架构
- en: Notice how the output-input and the failure types of the publisher and the subscriber
    must be equal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意发布者和订阅者的输出-输入类型和失败类型必须相等。
- en: 'Now that we have a basic idea of what a publisher and a subscriber look like,
    let''s see how they communicate. There are three steps, pictured in the following
    figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对发布者和订阅者的基本概念有了了解，让我们看看它们是如何进行通信的。这里有三个步骤，如下图中所示：
- en: '![Figure 13.4 – Publisher and Subscriber communication process'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – 发布者和订阅者通信过程'
- en: '](img/Figure_13.4_B14717.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B14717.jpg)'
- en: Figure 13.4 – Publisher and Subscriber communication process
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 发布者和订阅者通信过程
- en: 'The following list describes the process in more detail:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表更详细地描述了这个过程：
- en: In the first step, the `Subscriber` tells the `Publisher` that it wants to subscribe.
    The `Publisher` sends back a subscription. The `Subscriber` uses that subscription
    to start requesting elements. The subscriber can request from N to unlimited values.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，`订阅者`告诉`发布者`它想要订阅。`发布者`发送回一个订阅。`订阅者`使用该订阅开始请求元素。订阅者可以从N个值请求到无限值。
- en: Now the `Publisher` is free to send those values over time. The `Subscriber`
    will receive those inputs.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`发布者`可以自由地随时间发送这些值。`订阅者`将接收这些输入。
- en: In subscriptions that are not expecting unlimited values, a completion event
    is sent to the `Subscriber`, so it is aware that the subscription is over.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不期望无限值的订阅中，会向 `Subscriber` 发送一个完成事件，使其知道订阅已结束。
- en: 'Now we have a basic idea of what a publisher is and what a subscriber is. We
    also know the steps involved in their communication. That is enough theory! Here
    is a practical example of a single publisher sending the values of an array to
    a subscriber. You can open a new Xcode playground and try the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对发布者和订阅者有了基本的概念，也知道它们通信的步骤。这就足够理论了！这里有一个单发布者向订阅者发送数组值的实际示例。你可以在新的 Xcode
    playground 中尝试以下代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first comment, we create an array of integers from 1 to 4, and we use
    the convenience instance property `publisher` from the Sequence protocol to wrap
    it inside a new `Publisher` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个注释中，我们创建了一个包含从 1 到 4 的整数的数组，并使用 Sequence 协议的便利实例属性 `publisher` 将其包装在一个新的
    `Publisher` 实例中。
- en: In the second comment, we use the method `sink` to attach a subscriber to the
    publisher, defining inside its completion block an action to perform over each
    value received over time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个注释中，我们使用 `sink` 方法将订阅者附加到发布者上，并在其完成块中定义了一个在接收到的每个值上执行的操作。
- en: 'If you execute this code, the output will be like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，输出将如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The initial array contained the numbers from 1 to 4, and that is what we printed.
    But what if we just want to print the even numbers? How can we transform the data
    between the producer and the subscriber? Luckily for us, Combine provides **Operators**
    to help us. Let's see more about them next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数组包含从 1 到 4 的数字，这就是我们打印的内容。但如果我们只想打印偶数呢？我们如何转换生产者和订阅者之间的数据？幸运的是，Combine 提供了
    **操作符** 来帮助我们。让我们接下来了解更多关于它们的信息。
- en: Understanding Operators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解操作符
- en: An `filter`, `map`, `reduce`, `scan`, `combineLatest`, `merge`, and `zip`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`、`map`、`reduce`、`scan`、`combineLatest`、`merge` 和 `zip`。'
- en: Using filter
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `filter`
- en: The `filter` operator is used to just remove values matching some condition
    out of the stream.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 操作符用于从流中移除匹配某些条件的值。'
- en: 'Let''s see a fundamental example using the `filter` operator. Imagine that
    from the previous array (`[1,2,3,4]`), we only want to print the even numbers
    of the array. We do it as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 `filter` 操作符的基本示例来看看。想象一下，从之前的数组 `[1,2,3,4]` 中，我们只想打印数组的偶数。我们这样做：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how the `filter` operator sits between the publisher and the subscriber,
    and defines a modification of the elements in a declarative way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `filter` 操作符位于发布者和订阅者之间，并以声明式的方式定义了元素的修改。
- en: 'If you run this code, you will obtain the following result in the console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将在控制台获得以下结果：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's see another example of how operators can be handy when working with
    Combine. Remember that the first rule of the subscriber and publisher is that
    the `Input` of the subscriber must be equal to the `Output` of the publisher.
    What happens when they are not equal? Well, operators can help us to transform
    the `Output` of a publisher to adapt it to the proper `Input` type of the subscriber.
    One of the operators that helps us is `map`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一个示例，说明操作符在处理 Combine 时是多么有用。记住，订阅者和发布者的第一条规则是订阅者的 `Input` 必须等于发布者的
    `Output`。当它们不相等时会发生什么？嗯，操作符可以帮助我们将发布者的 `Output` 转换为适应订阅者适当的 `Input` 类型。帮助我们的一个操作符是
    `map`。
- en: Using map
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `map`
- en: The `map` operator helps us to apply a certain operation to every value of the
    stream, transforming it into a different type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作符帮助我们应用某种操作到流中的每个值，将其转换为不同的类型。'
- en: 'The following code uses the `map` operator to transform the `Output` of a publisher
    (`int` values) into the `Input` that our subscriber needs (`User` instances):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 `map` 操作符将发布者的 `Output`（整数值）转换为订阅者需要的 `Input`（`User` 实例）：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `map` operator is transforming a stream of `Int` values [`1,2,3,4`] into
    a stream of `User` instances. When we use the `sink`, we can call the `description()`
    method of those users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作符将一个 `Int` 值流 `[''1,2,3,4'']` 转换为一个 `User` 实例流。当我们使用 `sink` 时，我们可以调用这些用户的
    `description()` 方法。'
- en: '![Figure 13.5 – Using map to transform outputs on the stream'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – 使用 `map` 在流上转换输出'
- en: '](img/Figure_13.5_B14717.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B14717.jpg)'
- en: Figure 13.5 – Using map to transform outputs on the stream
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 使用 `map` 在流上转换输出
- en: The previous figure represents how `map` changes the **Output** type (while
    the **Failure** type, in this case, keeps being the same). When working with Combine,
    using this kind of graph (on a document or just in your mind) can be really helpful
    to work with the proper types at every step of the stream.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图表示了`map`如何改变**输出**类型（而在这个例子中，**失败**类型保持不变）。当使用Combine工作时，使用这种类型的图（在文档中或在心中）对于在流的每个步骤中处理正确的类型非常有帮助。
- en: There are more operators available rather than just `filter` and `map`. Let's
    see other useful ones like `reduce`, `scan`, `combineLatest`, `merge`, and `zip`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的算子不仅限于`filter`和`map`。让我们看看其他有用的算子，如`reduce`、`scan`、`combineLatest`、`merge`和`zip`。
- en: Using reduce
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用reduce
- en: The `reduce` operator returns the result of combining all the values of the
    stream using a given operation to apply.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`算子返回使用给定操作应用的所有流值的组合结果。'
- en: 'You can try out the following examples in an Xcode playground. Go ahead and
    check this example of `reduce`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Xcode playground中尝试以下示例。继续并检查`reduce`的以下示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you execute this code, the output in the console is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，控制台中的输出如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you have used the regular `reduce` function from the Swift standard library,
    the `reduce` version from Combine should be easy to understand. It works the same
    but using values that come from a publisher. What `reduce` does is apply an operation
    and accumulate the result for the next value, starting with a given value. In
    our example, `1, { $0 * $1 }`, the first param is the initial value, hence `1`,
    and the following param is the operation to perform: multiply the current value
    (stored as `$0`) by the next incoming value (`$1`), and keep it for the next iteration.
    So, if our input is `[1,2,3,4]` and our starting value is `1`, what `reduce` is
    doing is *1 x 1 x 2 x 3 x 4 = 24*. The next operator that we are going to explain
    is very similar to reduce. Let''s jump into `scan`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用了Swift标准库中的常规`reduce`函数，那么Combine中的`reduce`版本应该很容易理解。它的工作方式相同，但使用来自发布者的值。`reduce`所做的是应用一个操作并累积下一个值的累积结果，从给定的值开始。在我们的例子中，`1,
    { $0 * $1 }`，第一个参数是初始值，因此是`1`，接下来的参数是要执行的操作：将当前值（存储为`$0`）乘以下一个传入的值（`$1`），并保留它以供下一次迭代。因此，如果我们的输入是`[1,2,3,4]`并且我们的起始值是`1`，那么`reduce`所做的是*1
    x 1 x 2 x 3 x 4 = 24*。我们将要解释的下一个算子与`reduce`非常相似。让我们跳到`scan`。
- en: Using scan
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用scan
- en: 'An operator very much related to `reduce` is `scan`. The `scan` operator does
    exactly the same as `reduce` but it emits the result at each step. Check this
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`reduce`非常相关的算子是`scan`。`scan`算子与`reduce`完全相同，但它会在每个步骤中发出结果。查看以下代码：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, executing this will result in the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行此操作将产生以下输出：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, it is giving us the same final result as `reduce` (`scan` emits
    a value in each step, not just at the end. So, with `scan`, we get the following
    values over time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它给出了与`reduce`相同的最终结果（`scan`在每个步骤中发出一个值，而不是仅在结束时。因此，使用`scan`，我们得到以下随时间变化的值：
- en: 1x1 = **1**
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1x1 = **1**
- en: 1x2 = **2**
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1x2 = **2**
- en: 2x3 = **6**
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2x3 = **6**
- en: 6x4 = **24**
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6x4 = **24**
- en: 'These operators (`filter`, `map`, `reduce`, and `scan`) helped us to transform
    the values coming from another publisher. But some operators combine multiple
    publishers'' input into one single stream output. Let''s see some of them: `combineLatest`,
    `merge`, and `zip`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算子（`filter`、`map`、`reduce`和`scan`）帮助我们转换来自另一个发布者的值。但一些算子将多个发布者的输入组合成一个单一的流输出。让我们看看其中的一些：`combineLatest`、`merge`和`zip`。
- en: Using combineLatest
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用combineLatest
- en: It is a publisher that combines the latest values from two other publishers.
    Both publishers must have the same failure type. The downstream subscriber will
    receive a tuple of the most recent elements from the upstream publishers when
    any of them emit a new value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将两个其他发布者的最新值组合在一起的发布者。这两个发布者必须具有相同的失败类型。当任何一个发布者发出新值时，下游订阅者将接收到一个元组，包含来自上游发布者的最新元素。
- en: 'Try the following code in a playground:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在playground中尝试以下代码：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output on the console is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出如下：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we don't have any output until `("a", 1).`, which means that `combineLatest`
    doesn't produce any output until all the inputs send an initial value. After that,
    it will produce a value every time an input sends a new value, sending the latest
    from each of the inputs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到`("a", 1)`之前我们没有任何输出，这意味着`combineLatest`在所有输入发送初始值之前不会产生任何输出。之后，每当输入发送新的值时，它将产生一个值，发送每个输入的最新值。
- en: 'There are also other versions of `combineLatest` to combine three or even four
    inputs, instead of just two: `combineLatest3`, `combineLatest4`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他版本的 `combineLatest` 可以合并三个或四个输入，而不仅仅是两个：`combineLatest3`、`combineLatest4`。
- en: What if we only want to have the latest output of any of the input publishers
    (meaning just a value, not a tuple)? For those cases, we can use `merge`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取任何输入发布者的最新输出（意味着只是一个值，而不是一个元组）怎么办？对于这些情况，我们可以使用 `merge`。
- en: Using merge
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用合并
- en: 'With `merge`, we will aggregate multiple input publishers into a single stream,
    and the output will be just the latest value from any of them. Check out this
    code in a playground:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `merge`，我们将多个输入发布者聚合到一个单个流中，输出将是它们中的任何一个的最新值。查看游乐场中的此代码：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the output is one value at a time, which differs from the tuple
    with all the latest values from all the inputs that we got with `combineLatest`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出一次只有一个值，这与我们从 `combineLatest` 获得的包含所有输入最新值的元组不同。
- en: There is another useful method to work with multiple publishers. Let's see what
    `zip` can do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个有用的方法可以处理多个发布者。让我们看看 `zip` 能做什么。
- en: Using zip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 zip
- en: '`zip` is a publisher that emits a pair of elements when both input publishers
    have emitted a new value. Let''s see how it differs from `combineLatest` with
    the same example. Execute the following code in a playground:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 是一个发布者，当两个输入发布者都发出新值时，它会发出一对元素。让我们看看它如何与 `combineLatest` 的相同示例不同。在游乐场中执行以下代码：'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check out the comments under each line, representing what `combineLatest` and
    `zip` will output every given time. Notice how `zip` doesn't send a new pair of
    values downstream until both of the publishers have emitted a new value. And when
    that happens, it will send a tuple with the oldest non-emitted values of both
    of them. `CombineLatest` will use the most recent and will emit a tuple every
    time one of the publishers emits a single new value (it will not wait to have
    both publishers emitting!). That is the main difference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查看每行下的注释，表示 `combineLatest` 和 `zip` 每次给出的输出。注意 `zip` 不会在两个发布者都发出新值之前向下游发送新的值对。当这种情况发生时，它将发送一个包含两者最老的非发出值的元组。`CombineLatest`
    将使用最新的，并且每次一个发布者发出单个新值时（它不会等待两个发布者都发出！）就会发出一个元组。这是主要区别。
- en: 'With the basics about publisher, subscriber, and operator entities explained,
    let''s see another useful entity in Combine in the next section: **Subject**.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了发布者、订阅者和操作符实体之后，让我们在下一节中看看 Combine 中的另一个有用实体：**主题**。
- en: Understanding Subject
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解主题
- en: 'As per the Apple documentation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据苹果文档：
- en: '"A subject is a publisher that exposes a method for outside callers to publish
    elements."'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"主题是一个发布者，它公开了一个方法，允许外部调用者发布元素。"'
- en: The definition is pretty straightforward. Subjects are like publishers, but
    they have a method, `send(_:)`, which you can use to inject new elements into
    their stream. A single `Subject` allows multiple subscribers to be connected at
    the same time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义相当直接。主题就像发布者一样，但它们有一个方法，`send(_:)`，你可以用它将新元素注入它们的流中。单个 `Subject` 允许多个订阅者同时连接。
- en: 'There are two types of built-in subjects: `CurrentValueSubject` and `PassthroughSubject`.
    Let''s see the differences between them.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种内置的主题类型：`CurrentValueSubject` 和 `PassthroughSubject`。让我们看看它们之间的区别。
- en: Working with CurrentValueSubject
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 CurrentValueSubject 一起工作
- en: This is a subject that holds an initial value. It broadcasts the current value
    every time it changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含初始值的主题。每次它改变时，它都会广播当前值。
- en: 'When a subscriber connects to a `CurrentValueSubject`, it will receive the
    current value, and the next ones when it changes. This means that a `CurrentValueSubject`
    has state. Here is an example (you can try this code in a playground):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅者连接到 `CurrentValueSubject` 时，它将接收当前值，以及当它改变时的下一个值。这意味着 `CurrentValueSubject`
    有状态。以下是一个示例（您可以在游乐场中尝试此代码）：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you execute this code, the output looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码，输出将如下所示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the interesting bits:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的部分：
- en: When we initialize the subject, we need to pass an initial value.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们初始化主题时，我们需要传递一个初始值。
- en: When the subscriber subscribes, it gets the current value that is held in the
    subject. Note how in the console output, the subscriber has printed `first value`
    even though we subscribed to the subject after that value was generated.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订阅者订阅时，它会获取主题中持有的当前值。注意在控制台输出中，即使我们在该值生成后订阅了主题，订阅者仍然打印了 `first value`。
- en: Every time we call `send(_:)`, the subscribers get the next value.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们调用 `send(_:)`，订阅者都会接收到下一个值。
- en: Now, let's see the other built-in type of subject, `PassthroughSubject`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种内置的主题类型，`PassthroughSubject`。
- en: Working with PassthroughSubject
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PassthroughSubject
- en: 'The main difference between `PassthroughSubject` and `CurrentValueSubject`
    is that `PassthroughSubject` doesn''t hold any state. Check the following code
    (you can try it out in a playground):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassthroughSubject` 和 `CurrentValueSubject` 之间的主要区别在于 `PassthroughSubject`
    不保留任何状态。检查以下代码（你可以在游乐场中尝试它）：'
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you execute this code, here is the output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这段代码，这里是你将得到的输出：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how the subscriber is created after the first value is sent. This first
    value is not received, because there was no subscriber connected yet. However,
    the second value is displayed in the output because it was sent after the subscription
    was established.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意订阅者在第一个值发送后是如何创建的。这个第一个值没有被接收，因为没有订阅者连接。然而，第二个值在输出中显示，因为它是在订阅建立后发送的。
- en: We have seen the basic usage of `Publisher`, `Subscriber`, `Operator`, and `Subject`.
    Let's now create a bigger and more complex example to see how to apply Combine
    concepts to real-world apps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `Publisher`、`Subscriber`、`Operator` 和 `Subject` 的基本用法。现在，让我们创建一个更大、更复杂的示例，看看如何将
    Combine 概念应用到现实世界的应用程序中。
- en: Combining Publishers, Subscribers, and Operators
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合发布者、订阅者和操作符
- en: 'In this section, we are going to mix the concepts of the previous section altogether
    in a real-world example feature. Let''s assume that we have an app that contains
    a newsletter, and we allow the users to subscribe to the newsletter by entering
    their email address, using two `UITextFields`: the **Email** and **Repeat Email**
    fields. Let''s assume that in our business logic, we need to check that the email
    is correct, and we are going to do the following checks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个现实世界的示例功能将上一节的概念全部混合在一起。假设我们有一个包含通讯录的应用程序，并且允许用户通过输入他们的电子邮件地址订阅通讯录，使用两个
    `UITextFields`：**电子邮件**和**重复电子邮件**字段。假设在我们的业务逻辑中，我们需要检查电子邮件是否正确，我们将进行以下检查：
- en: 'Local check: We will ask users to repeat the email address twice, and both
    should be the same.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地检查：我们将要求用户两次输入电子邮件地址，并且两次输入应该相同。
- en: 'Local check: The email should contain an "@".'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地检查：电子邮件应该包含一个 "@"。
- en: 'Local check: The email should be five characters long, at least.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地检查：电子邮件至少应该有五个字符长。
- en: 'Remote check: We will also assume that we have a remote method to check in
    the backend that the email is unique, meaning it doesn''t exist yet.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程检查：我们还将假设我们有一个远程方法在后台检查电子邮件是否唯一，这意味着它尚未存在。
- en: Once all these conditions match, we will enable a `UITextfield` to repeat it.
    You will also see a `combineLatest`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些条件都满足，我们将启用一个 `UITextfield` 来重复它。你也会看到一个 `combineLatest`。
- en: 'Open the `ViewController.swift` file. You will notice a couple of vars that
    are tagged with the property wrapper `@Published`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ViewController.swift` 文件。你会注意到几个被标记为属性包装器 `@Published` 的变量：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What `@Published` is doing here is creating a Publisher from the property itself.
    So, every time `initialEmail` or `repeatedEmail` values change, they will get
    published to anyone subscribed to them. You can access the publisher of `initialEmail`
    by using `$initialEmail` (prefix a `$` to the property name). Notice the two `IBActions`
    defined in the same class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Published` 在这里所做的是从属性本身创建一个发布者。所以，每次 `initialEmail` 或 `repeatedEmail` 的值发生变化时，它们都会被发布给任何订阅它们的用户。你可以通过使用
    `$initialEmail`（在属性名称前加上 `$`）来访问 `initialEmail` 的发布者。注意在同一个类中定义的两个 `IBActions`：'
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By combining `IBAction` and `@Published`, we are creating a funnel in which
    every time the user types something in the `initialEmail` `UITextField`, it will
    get published through the `$initialEmail` publisher.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 `IBAction` 和 `@Published`，我们创建了一个漏斗，每次用户在 `initialEmail` `UITextField`
    中输入一些内容时，它将通过 `$initialEmail` 发布者发布。
- en: 'Why is this handy? Remember that according to the business logic defined above,
    we need to ensure that both `initialEmail` and `repeatedEmail` are equal. Now
    we have two publishers that will emit their value every time the user types in
    either of the two text fields. How can we combine those two values to compare
    them? The Combine framework has the perfect method for this: `CombineLatest`.
    Add the following vars to the `ViewController.swift` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么方便？记住，根据上面定义的业务逻辑，我们需要确保 `initialEmail` 和 `repeatedEmail` 都相等。现在我们有两个发布者，每次用户在两个文本字段中的任何一个中输入时，都会发出它们的值。我们如何将这两个值结合起来进行比较？Combine
    框架有完美的方法来做这件事：`CombineLatest`。将以下变量添加到 `ViewController.swift` 文件中：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s analyze the code comment by comment:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析代码注释：
- en: 'First, we are using `Publishers.CombineLatest` to combine two different publishers
    into one: `$initialEmail` and `$repeatedEmail`. This will result in a new stream
    (publisher) of type `Publishers.CombineLatest<Published<String>.Publisher, Published<String>.Publisher>`.
    Don''t let the long type scare you. It means "a publisher of two string publishers."
    The magic of `CombineLatest` is that if either of the two inputs changes, you
    will get the new value, but also the latest value that the other input had, which
    is very useful for cases like this.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`Publishers.CombineLatest`将两个不同的发布者合并为一个：`$initialEmail`和`$repeatedEmail`。这将产生一个新的流（发布者）类型为`Publishers.CombineLatest<Published<String>.Publisher,
    Published<String>.Publisher>`。不要让这个长的类型吓到你。这意味着“两个字符串发布者的发布者”。`CombineLatest`的魔力在于，如果两个输入中的任何一个发生变化，你将得到新的值，同时也会得到另一个输入的最新值，这在类似这种情况中非常有用。
- en: 'Second, we are applying the `map` operator over the "publisher of two string
    publishers." By using `map`, we are unwrapping the underlaying published strings
    to be able to use the string themselves and return a different result after working
    with them. Here is where we apply our business rules: If both emails are equal,
    they include an "@" and they are longer than five characters long, we return the
    `email`. Otherwise, we return `nil`. So, with `map`, we are transforming a stream
    output type into a new one, to adapt it to what we need.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们在“两个字符串发布者的发布者”上应用`map`运算符。通过使用`map`，我们解包了底层的发布字符串，以便能够使用字符串本身，并在处理它们之后返回不同的结果。这就是我们应用业务规则的地方：如果两个电子邮件地址相等，它们包含一个“@”并且长度超过五个字符，我们返回`email`。否则，我们返回`nil`。因此，通过`map`，我们将流输出类型转换为新的类型，以适应我们的需求。
- en: 'At this point, if we inspect the type of what we have, you will see this: `Publishers.Map<Publishers.CombineLatest<Published<String>.Publisher,
    Published<String>.Publisher>, String?>`. That is quite complex to read and use.
    But Combine provides us with a way to simplify this, because what is important
    is what is inside of the publisher itself, not all the wrappers around it. By
    using `eraseToAnyPublisher`, we are changing this type to just `AnyPublisher<String?,
    Never>`. This is much easier to understand and use (and if you want to publish
    it in an API, for example, it''s much easier to digest by other developers).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，如果我们检查我们所拥有的类型的类型，你会看到这个：`Publishers.Map<Publishers.CombineLatest<Published<String>.Publisher,
    Published<String>.Publisher>, String?>`. 这非常复杂，难以阅读和使用。但是Combine为我们提供了一种简化这个的方法，因为重要的是发布者本身的内容，而不是围绕它的所有包装。通过使用`eraseToAnyPublisher`，我们将这个类型改变为仅仅是`AnyPublisher<String?,
    Never>`。这要容易理解和使用得多（如果你想在API中发布它，例如，其他开发者更容易消化）。
- en: We create a cancellable property var to use it in the following piece of code.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个可取消的属性`var`，以便在下面的代码片段中使用。
- en: This flow can be represented as follows
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程可以表示如下
- en: '![Figure 13.6 – validatedEmail stream'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 – validatedEmail流'
- en: '](img/Figure_13.6_B14717.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B14717.jpg)'
- en: Figure 13.6 – validatedEmail stream
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – validatedEmail流
- en: 'Now, add this line of code to the `viewDidLoad()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此行代码添加到`viewDidLoad()`方法中：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By calling `sink`, we are attaching a subscriber to the `validatedEmail` publisher,
    and we store it in our new `var` property `cancellable`. Every time we receive
    a new value, we will just print it into the console for testing purposes. Let's
    try it out! Execute the app and type any email address (in both fields) that fulfills
    all the conditions (for example, `abc@email.com`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`sink`，我们将一个订阅者附加到`validatedEmail`发布者上，并将其存储在我们新的`var`属性`cancellable`中。每次我们收到一个新的值时，我们只需将其打印到控制台进行测试。让我们试试！执行应用并输入任何满足所有条件的电子邮件地址（在两个字段中）（例如，`abc@email.com`）。
- en: When you type valid addresses, you will see it in the console. When the addresses
    are not valid, you will see `nil`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入有效的地址时，你会在控制台中看到它。当地址无效时，你将看到`nil`。
- en: 'We have seen a lot of new Combine concepts packed into very little code. Before
    continuing with our demo project, we are going to look at a quick summary of these
    new concepts:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了很多新的Combine概念被压缩在非常少的代码中。在我们继续我们的演示项目之前，我们将快速总结这些新概念：
- en: 'The `@Published` property wrapper: Allows us to create a Publisher from a property
    variable. We can access the publisher by prefixing `$` to the name of the property.
    It only works on class properties, not on structs.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Published`属性包装器：允许我们从属性变量创建发布者。我们可以通过在属性名称前加`$`来访问发布者。它只适用于类属性，不适用于结构体。'
- en: '`Publishers.CombineLatest`: Allows us to combine two publishers into a single
    one that will always push the latest value of each one when there is a change
    (or `nil`, if there wasn''t a previous value).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publishers.CombineLatest`：允许我们将两个发布者合并为一个，该发布者将在有变化时（或 `nil`，如果没有先前的值）始终推送每个发布者的最新值。'
- en: '`map`: Allows us to transform the stream. We apply a `map` to a publisher with
    an `Output` type and we can transform it into a new, different `Output`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：允许我们转换流。我们对具有 `Output` 类型的发布者应用一个 `map`，并将其转换成一个新的、不同的 `Output`。'
- en: '`eraseToAnyPublisher`: Allows us to erase complex types to work with easier
    `AnyPublisher<Otutput, Failure>` streams. This is very handy when publishing our
    classes as an API, for example.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eraseToAnyPublisher`：允许我们将复杂类型擦除以使用更简单的 `AnyPublisher<Output, Failure>` 流。这在将我们的类作为
    API 发布时非常有用。'
- en: 'After this little recap, we still have one feature pending to fulfill the list
    of requirements. We have implemented three local checks on the email addresses,
    but we still need to do the last one, which was this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小总结之后，我们仍然有一个功能尚未完成以满足需求列表。我们已经实现了三个电子邮件地址的本地检查，但我们还需要完成最后一个，那就是：
- en: 'Remote check: We will also assume that we have a remote method to check in
    the backend that the email is unique, meaning it doesn''t exist yet.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程检查：我们还将假设我们有一个远程方法来检查后端，以确保电子邮件是唯一的，这意味着它尚未存在。
- en: In the `ViewController.swift` file, there is a dummy method named `func emailAvailable(…)`.
    It just returns a completion block. This method is intended to represent a network
    call that returns `True` or `False` in the completion block according to whether
    the email already exists in the backend or not. For demo purposes, we are not
    going to implement the network call itself, just simulate the result.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewController.swift` 文件中，有一个名为 `func emailAvailable(…)` 的模拟方法。它只返回一个完成块。此方法旨在表示一个根据电子邮件是否已在后端存在而返回
    `True` 或 `False` 的网络调用。出于演示目的，我们不会实现网络调用本身，只是模拟结果。
- en: 'Let''s implement this feature with Combine. We are going to create a new publisher
    that will emit a Bool indicating whether the email that the user types exists
    in the backend or not, using a fake network call, `emailAvailable(…)`. Add the
    following code to the `ViewController.swift` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Combine 来实现这个功能。我们将创建一个新的发布者，该发布者将发出一个 Bool 值，指示用户输入的电子邮件是否存在于后端，使用一个模拟的网络调用，`emailAvailable(…)`。将以下代码添加到
    `ViewController.swift` 文件中：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are a lot of new concepts here, so let''s go through the numbered comments
    one by one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新的概念，所以让我们逐个查看编号注释：
- en: We are defining a new publisher, `isNewEmail`, of type `<Bool, Never>`. This
    publisher will help us to emit events that indicate whether the email that the
    user is typing exists in our database or not.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在定义一个新的发布者，`isNewEmail`，类型为 `<Bool, Never>`。这个发布者将帮助我们发出事件，指示用户输入的电子邮件是否存在于我们的数据库中。
- en: To fetch any new value that the user types in the email field, we start by using
    the published property defined earlier in the `$initialEmail` section.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取用户在电子邮件字段中输入的任何新值，我们首先使用在 `$initialEmail` 部分中定义的已发布的属性。
- en: Users can type/delete in text fields pretty fast. Our goal is to make a network
    call every time we receive a new value through the `$initialEmail` publisher (meaning
    every time the user is typing in the email field). That means that we will query
    the network a bit too much. The Combine `.debounce` method will help us to reduce
    the number of values we are processing. By using `.debounce`(`1…)`, we specify
    that from all the values that we get from `$initialEmail`, we will only process
    a value every `1` second. The rest of the values will be discarded. This is very
    helpful when working with publishers that are connected to the user interface
    and the network (text fields, buttons, search bars, and so on).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以在文本字段中非常快速地输入/删除。我们的目标是每次通过 `$initialEmail` 发布者（意味着每次用户在电子邮件字段中输入时）接收到新值时都进行网络调用。这意味着我们将对网络进行过多的查询。Combine
    的 `.debounce` 方法将帮助我们减少我们正在处理的数据量。通过使用 `.debounce(1...)`，我们指定从从 `$initialEmail`
    获取的所有值中，我们每 `1` 秒只处理一个值。其余的值将被丢弃。这对于处理与用户界面和网络（文本字段、按钮、搜索栏等）连接的发布者非常有帮助。
- en: Another useful method is `removeDuplicates()`. If the user types "`abc`" and
    then deletes the "`c`" to quickly type the "`c`" back, we will make several calls.
    But if we use `removeDuplicates()`, we will avoid this unnecessary behavior.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个有用的方法是 `removeDuplicates()`。如果用户输入了 "`abc`" 然后删除了 "`c`" 以快速重新输入 "`c`"，我们将进行多次调用。但如果我们使用
    `removeDuplicates()`，我们将避免这种不必要的操作。
- en: 'The fifth step is a bit more complicated. This is where we perform a network
    call. First, we have a `.flatMap` wrapping everything. This function transforms
    elements from a publisher into a new type of publisher. Inside the `flatMap`,
    we have a `Future`. A `Future` is a publisher that eventually emits a single value
    and then finishes (or fails). Inside the `Future`, we have a `Promise`: A `Promise`
    in Combine is a `typealias` for a closure that takes a `Result`. Now let''s describe
    the whole process again, but from inside out: The network call `emailAvailable`
    returns a result in the form of `promise.success(…)`. This Promise is wrapped
    in a Future, to become a publisher stream. That stream is a `Future<Bool, Never>`
    at this point. Now, we wrap everything with `flatMap`, so the upstream `initialEmail:
    Published<String>.Publisher` becomes `AnyPublisher<Bool, Never>` (with the help
    of `eraseToAnyPublisher` too).'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第五步稍微复杂一些。这是我们执行网络调用的地方。首先，我们有一个`.flatMap`包裹着一切。这个函数将发布者的元素转换成新的发布者类型。在`flatMap`内部，我们有一个`Future`。`Future`是一个发布者，最终会发出一个值然后完成（或失败）。在`Future`内部，我们有一个`Promise`：在Combine中，`Promise`是一个接受`Result`的闭包的`typealias`。现在让我们再次描述整个过程，但这次是从内到外：网络调用`emailAvailable`以`promise.success(…)`的形式返回一个结果。这个Promise被包裹在一个Future中，变成了一个发布者流。这个流在这个时候是一个`Future<Bool,
    Never>`。现在，我们用`flatMap`包裹一切，所以上游的`initialEmail: Published<String>.Publisher`变成了`AnyPublisher<Bool,
    Never>`（也借助了`eraseToAnyPublisher`）。'
- en: 'Here is the full flow to generate `isNewEmail`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成`isNewEmail`的完整流程：
- en: '![Figure 13.7 – isNewEmail stream'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 – isNewEmail流'
- en: '](img/Figure_13.7_B14717.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B14717.jpg)'
- en: Figure 13.7 – isNewEmail stream
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – isNewEmail流
- en: So, after all this chain of transformations, we have a publisher, `isNewEmail`,
    that will emit a `Bool` indicating whether an email address is unique or not in
    our backend every time (almost, except duplicates and debounced) the user types
    in the UI! That is pretty cool! And it's very useful for our business logic checks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，经过这一系列的转换后，我们得到了一个发布者，`isNewEmail`，它会在用户在UI中输入时（几乎每次，除了重复和防抖动的）发出一个`Bool`值，指示电子邮件地址在我们的后端是否唯一。这真的很酷！这对我们的业务逻辑检查非常有用。
- en: 'Our last step is going to be to combine the publisher of the local checks (`validatedEmail`)
    with the remote publisher (`isNewEmail`) to have a final output. The business
    logic required to enable the `String` and a `True` value, so all our conditions
    are met. What is the best way to combine the latest values of two different publishers
    and work with them? We just used it above! It is `combineLatest`. Add the following
    code to the `ViewController.swift` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是将本地检查的发布者（`validatedEmail`）与远程发布者（`isNewEmail`）结合起来，以得到最终的输出。所需的业务逻辑是启用`String`和`True`值，因此所有条件都满足。最好的方法是将两个不同发布者的最新值结合起来并处理它们是什么？我们上面已经使用了它！它是`combineLatest`。将以下代码添加到`ViewController.swift`文件中：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As detailed in the preceding code, we are using `CombineLatest` to work with
    the latest values of two different publishers. From `validatedEmail`, we get a
    valid email or a `nil` value otherwise. From `isNewEmail`, we get a `Bool` indicating
    whether the email exists in the database or not. The result of this is a new publisher,
    `finalEmail`, of type `<String?, Never>`. See the flow in the next figure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们使用`CombineLatest`来处理两个不同发布者的最新值。从`validatedEmail`中，我们得到一个有效的电子邮件地址或否则的`nil`值。从`isNewEmail`中，我们得到一个`Bool`值，指示电子邮件是否存在于数据库中。结果是一个新的发布者，`finalEmail`，类型为`<String?,
    Never>`。请查看下一张图中的流程：
- en: '![Figure 13.8 – finalEmail stream'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 – finalEmail流'
- en: '](img/Figure_13.8_B14717.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B14717.jpg)'
- en: Figure 13.8 – finalEmail stream
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – finalEmail流
- en: 'Now, how can we enable and disable the `viewDidLoad` function and let''s explain
    it in detail:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如何启用和禁用`viewDidLoad`函数，让我们详细解释一下：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this code, we start with the `finalEmail` publisher `(<String?, Never>`),
    we `map` over it, transforming the stream into `<Bool, Never>`, then we apply
    `.receive` to make sure we are executing this in the main thread (because we are
    handling the UI here, a `UIButton`). Finally, we assign the value inside the stream
    `(<Bool>`) to the `signupButton` `isEnabled` property! Check out the next figure,
    which details the steps of the stream:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从一个`finalEmail`发布者`(<String?, Never>)`开始，我们对其`map`操作，将流转换为`<Bool, Never>`，然后应用`.receive`确保我们在主线程中执行这个操作（因为我们在这里处理UI，一个`UIButton`）。最后，我们将流中的值`(<Bool>)`分配给`signupButton`的`isEnabled`属性！查看下一张图，它详细说明了流的步骤：
- en: '![Figure 13.9 – Assigning finalEmail to signUpButton'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 – 将finalEmail分配给signUpButton'
- en: '](img/Figure_13.9_B14717.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B14717.jpg)'
- en: Figure 13.9 – Assigning finalEmail to signUpButton
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 将 finalEmail 分配给 signUpButton
- en: 'And that is it[! Execute th](mailto:abc@email.com)e app, and try it yourself:
    If you type some email address that matches all the conditions (like `abc@email.com`),
    the **Sign-up** button will be enabled. Otherwise, it will be disabled.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有内容[! 执行 th](mailto:abc@email.com)e 应用程序，并亲自尝试：如果您输入的电子邮件地址符合所有条件（如 `abc@email.com`），则
    **注册** 按钮将被启用。否则，它将被禁用。
- en: In this section, we have learned about a lot of new Combine concepts and methods
    to combine different streams, transform outputs, modify the thread we are working
    on, handle user input, and so on. We used `flatMap` to transform elements of an
    upstream into a different type downstream. However, `flatMap` has more uses. One
    of them is to help streams recover from errors, with the help of `catch`. In the
    next section, we are going to see an example of how a stream can fail, and how
    to recover it using `flatMap` and `catch`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了大量的新 Combine 概念和方法，用于组合不同的流、转换输出、修改我们正在工作的线程、处理用户输入等。我们使用了 `flatMap`
    来将上游元素转换为下游的不同类型。然而，`flatMap` 有更多用途。其中之一是帮助流从错误中恢复，这得益于 `catch`。在下一节中，我们将看到一个流如何失败，以及如何使用
    `flatMap` 和 `catch` 来恢复它。
- en: Using Operators to build error-proof streams
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运算符构建无错流
- en: For this section, go ahead and open the project in the code bundle named `PublishersAndSubscribers_start`.
    Take a look at the file `ViewController.swift`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，请打开名为 `PublishersAndSubscribers_start` 的代码包中的项目。查看 `ViewController.swift`
    文件。
- en: 'This file contains a `User` struct:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含一个 `User` 结构体：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `User` struct is quite simple. It contains a `String` property `id`, and
    a `static var` named `unknown` that returns a `User` instance with `id` equal
    to `-1`. Apart from the `User` struct, the file contains the `ViewController`
    itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 结构体相当简单。它包含一个 `String` 属性 `id`，以及一个名为 `unknown` 的 `static var`，它返回一个
    `id` 等于 `-1` 的 `User` 实例。除了 `User` 结构体之外，该文件还包含 `ViewController` 本身。'
- en: 'The view controller contains two methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器包含两个方法：
- en: 'First, `postNotification()`: This just fires a notification in the Notification
    Center that contains a `User` instance with `id` equal to `123`. The name of the
    notification is `networkResult`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`postNotification()`：这只是在通知中心触发一个包含 `id` 等于 `123` 的 `User` 实例的通知。通知的名称是 `networkResult`。
- en: 'Second, `postNotificationThatFails()`: This just fires a notification in the
    Notification Center that contains random data that is Base-64 encoded, not a `User`
    instance this time. The name of the notification is `networkResult.`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，`postNotificationThatFails()`：这只是在通知中心触发一个包含随机数据（这次不是 `User` 实例）的通告，这些数据是
    Base-64 编码的。通知的名称是 `networkResult.`。
- en: We will use Combine to consume these two notifications. Both methods represent
    a dummy network call, whose result is being sent through the Notification Center
    in this way. So, think of them as the network call response that you will fetch
    from your backend when trying to query for some object (a user in this case) and
    propagate to your app with notifications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Combine 消费这两个通知。这两种方法都代表一个虚拟的网络调用，其结果以这种方式通过通知中心发送。所以，把它们想象成当你尝试查询某些对象（在这种情况下是一个用户）并使用通知将结果传播到你的应用程序时，你将从后端获取的网络调用响应。
- en: 'Now, let''s try to call `postNotification()` and consume the result using Combine.
    In the `viewDidLoad()` method, call `postNotification()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试调用 `postNotification()` 并使用 Combine 消费结果。在 `viewDidLoad()` 方法中调用 `postNotification()`：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s create a publisher that emits values from the Notification Center
    and use the `cancellable` property to consume them as a subscriber. Change the
    `viewDidLoad()` method to this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个发布者，它从通知中心发出值，并使用 `cancellable` 属性作为订阅者来消费它们。将 `viewDidLoad()` 方法更改为以下内容：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s review the comments by lines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按行回顾注释：
- en: First, we are creating a publisher that emits any value from the Notification
    Center that arrives under the name `networkResult.` This matches the notification
    name we are sending in the `postNotification()` method.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们正在创建一个发布者，它从名为 `networkResult.` 的通知中心发出任何值。这与我们在 `postNotification()` 方法中发送的通知名称相匹配。
- en: We are subscribing to the publisher created in the previous step, and we store
    the result in the `cancellable` property. We are using `sink` when creating the
    subscriber to define a completion block that will print to the console any value
    received.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在订阅之前步骤中创建的发布者，并将结果存储在 `cancellable` 属性中。在创建订阅者时，我们使用 `sink` 来定义一个完成块，该块将打印到控制台接收到的任何值。
- en: Finally, we post a notification.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们发布一个通知。
- en: 'If you execute this code and you check in the console, you should see this
    result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码并在控制台检查，你应该看到以下结果：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This means that our stream worked! We have sent a notification, our publisher
    has forwarded it, and our subscriber has printed it into the console. As you can
    see on the console output, the notification has three properties: `name`, `object`,
    and `userInfo`. We want to unwrap what is inside the `object` attribute. So, let''s
    modify our publisher with an operator to transform what our subscriber receives.
    Change the publisher code for this one:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的流工作正常！我们已经发送了一个通知，我们的发布者已经转发它，我们的订阅者已经将其打印到控制台。正如你在控制台输出中看到的那样，通知有三个属性：`name`、`object`和`userInfo`。我们想要展开`object`属性中的内容。所以，让我们用操作符修改我们的发布者。将发布者代码更改为以下代码：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute it and check the output in the console:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它并检查控制台输出：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this code, we are mapping over the notification value and sending the `object`
    content as `Data`. In the console output, you can see that our subscriber is receiving
    those bytes of data now, instead of the full notification. Great! The next step
    is going to be to transform these bytes of `Data` into a `User` instance. To do
    that, we need to decode the data. Combine has the perfect helper method for this.
    Change the publisher code to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们正在映射通知值并将`object`内容作为`Data`发送。在控制台输出中，你可以看到我们的订阅者现在正在接收这些数据字节，而不是完整的通知。太好了！下一步是将这些`Data`字节转换为`User`实例。为此，我们需要解码数据。Combine有完美的辅助方法来完成这个任务。将发布者代码更改为以下代码：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By adding the preceding highlighted line, we are using the `Data` from the
    `map` operation and decoding it into a `User` instance! All in a single line.
    But if you try to execute now, you will get a compile error in the subscriber
    `sink` line saying the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加前面的高亮行，我们正在使用`map`操作中的`Data`并将其解码为一个`User`实例！这一切都在一行中完成。但是，如果你现在尝试执行，你将在`subscriber`的`sink`行得到一个编译错误，提示如下：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means: If you inspect the method sink that we are using, you will discover
    that it requires the `Failure` type of the publisher that is consuming to be `Never`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：如果你检查我们使用的`sink`方法，你会发现它要求消费它的`Failure`类型必须是`Never`：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After adding the `decode` line, our publisher no longer has a `Never` type
    as failure, because `decode` can produce errors. So, the compiler is telling you
    that the types don''t match anymore. We need to do something that catches any
    error produced by `decode` and transforms that into a `Never`-failing operation.
    Combine has another useful operator that can help us in this scenario: `catch`.
    Change the publisher code into this new block:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`decode`行后，我们的发布者不再有`Never`类型的失败，因为`decode`可以产生错误。所以，编译器告诉你类型不再匹配。我们需要做一些可以捕获`decode`产生的任何错误并将其转换为`Never`失败操作的事情。Combine还有一个有用的操作符可以帮助我们在这个场景中：`catch`。将发布者代码更改为以下新块：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's explain `catch` in more detail. `catch` will handle any error in the upstream,
    and instead of crashing the app, it will complete/finish the publisher that produced
    the error and replace it with a new publisher (that you must provide in the `return`
    block).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释`catch`。`catch`将处理上游中的任何错误，并且不会使应用崩溃，而是完成/结束产生错误的发布者，并用一个新的发布者（你必须提供在`return`块中）替换它。
- en: 'So in this scenario, if we get an error from the `decode` operation, our notification
    publisher will finish, and it will be replaced by `Just(User.unknown)`. `Just`
    is a publisher that only emits one value and then completes. Check the next figure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，如果我们从`decode`操作中得到错误，我们的通知发布者将结束，并将被`Just(User.unknown)`替换。`Just`是一个只发出一个值然后完成的发布者。查看下一张图：
- en: '![Figure 13.10 – Catch replaces the failed stream with a new one'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.10 – Catch replaces the failed stream with a new one](img/Figure_13.10_Catch_replaces_the_failed_stream_with_a_new_one.jpg)'
- en: '](img/Figure_13.10_B14717.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.10_B14717.jpg](img/Figure_13.10_B14717.jpg)'
- en: Figure 13.10 – Catch replaces the failed stream with a new one
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.10 – Catch replaces the failed stream with a new one](img/Figure_13.10_Catch_replaces_the_failed_stream_with_a_new_one.jpg)'
- en: The top part of the previous figure shows the stream when an error happens in
    the `decode` stage and `catch` enters into action. In the bottom part of the figure,
    you can see how `catch` drops the initial publisher and replaces it with the one
    defined in the `catch` block (a `Just` publisher in this case).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图的上半部分显示了在`decode`阶段发生错误时`catch`进入行动的流。在图的下半部分，你可以看到`catch`如何丢弃初始发布者并用`catch`块中定义的（在这种情况下是一个`Just`发布者）替换它。
- en: 'Let''s try out what will happen if we provide a value that will produce an
    error in the `decode` `stage`. At the end of the `viewDidLoad()`, just after `postNotification()`,
    add this line:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，如果我们提供一个在`decode`阶段会产生错误的值会发生什么。在`viewDidLoad()`的末尾，在`postNotification()`之后，添加以下行：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, we are now sending two notifications, one with user data inside, and the
    other with a random string. The second should fail on the `decode` step. Execute
    the app; you will see this output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在发送了两个通知，一个包含用户数据，另一个包含随机字符串。第二个在`decode`步骤应该失败。执行应用；您将看到以下输出：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That is great! The first notification got decoded and transformed into a proper
    user. The second failed to be decoded, but our `catch` block recovered the stream
    with a new publisher that passed an unknown `User` struct to the receiver.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！第一个通知被解码并转换成了合适的用户。第二个在解码时失败，但我们的`catch`块使用一个新的发布者恢复了流，并将一个未知的`User`结构体传递给接收者。
- en: 'However, there is a problem with our solution. Add this line after `postNotificationThatFails()`,
    at the end of the `viewDidLoad()` method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的解决方案存在一个问题。在`viewDidLoad()`方法的末尾，在`postNotificationThatFails()`之后添加这一行：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So now we are sending three notifications: first a regular one, then one that
    fails, then another regular one. Execute the app and notice the output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在发送了三个通知：首先是一个常规通知，然后是一个失败的通知，接着是另一个常规通知。执行应用并注意输出：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What is the issue here? The issue is that we only received two values, even
    though there are three notifications being sent! What is the problem then? The
    problem is that our `catch` block is replacing the failed stream with a `Just`
    publisher. As said before, a `Just` publisher only sends one value and then completes.
    Any value sent after the failure will be lost.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是什么？问题是，我们只收到了两个值，尽管发送了三个通知！那么问题在哪里？问题是我们的`catch`块用`Just`发布者替换了失败的流。正如之前所说，`Just`发布者只发送一个值然后完成。任何在失败之后发送的值都将丢失。
- en: 'Let''s improve this solution so we can keep processing values after recovering
    from an error with the `catch` block. Replace the `publisher` block with the following
    one:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进这个解决方案，以便在从错误中恢复后继续处理值。将`publisher`块替换为以下内容：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding highlighted code, you can see that we have wrapped the `decode`
    and `catch` block in a `flatMap` + `Just` block. Check in the following figure
    the differences before and after the change:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面高亮显示的代码中，您可以看到我们将`decode`和`catch`块包裹在`flatMap` + `Just`块中。在以下图中查看更改前后的差异：
- en: '![Figure 13.11 – Flow before and after flatMap'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.11 – Flow before and after flatMap'
- en: '](img/Figure_13.11_B14717.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.11_B14717.jpg](img/Figure_13.11_B14717.jpg)'
- en: Figure 13.11 – Flow before and after flatMap
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.11 – Flow before and after flatMap'
- en: 'Notice in the new code how, inside the `flatMap`, we are now creating a new
    second flow for every new value with this piece of code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在新代码中，在`flatMap`内部，我们现在使用以下代码为每个新值创建一个新的第二个流：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is important because it means that when there is an error, and the `catch`
    replaces the stream with the `Just(User.unknown)` publisher, it will not replace
    the original stream; it will just replace the stream that we are creating for
    this specific element inside the `flatMap`. This means that for the next element
    that arrives from the Notification Center, we still have the main publisher working.
    Execute the app now and see the following results in the console:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它意味着当出现错误时，`catch`会将流替换为`Just(User.unknown)`发布者，但它不会替换原始流；它只会替换在`flatMap`内部为这个特定元素创建的流。这意味着对于从通知中心到达的下一个元素，我们仍然有主要发布者在工作。现在执行应用，并在控制台中看到以下结果：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That is great! Not only are we handling the errors, we still process new elements
    that arrive after!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们不仅处理了错误，还处理了之后到达的新元素！
- en: In this section, you have seen how to use `flatMap` and `catch` to make your
    streams error-proof. Let's wrap up the chapter now in the summary.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经看到了如何使用`flatMap`和`catch`来使您的流无错误。现在让我们总结本章内容。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned about the basics of Combine: what a publisher
    is, what a subscriber is, why we need operators, which ones are more useful, and
    how all these elements chain together to help us.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Combine的基础知识：什么是发布者，什么是订阅者，为什么我们需要操作符，哪些更有用，以及所有这些元素如何串联起来帮助我们。
- en: We have built two different apps to demonstrate how Combine can help in our
    apps, from processing user interface events, decoding, and applying business rules,
    to creating error-proof streams and methods to recover from operations that fail.
    Combine provides us with a lot of built-in functionalities that will make our
    code easy to read and maintain.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了两个不同的应用程序来展示Combine如何帮助我们在应用程序中处理，从处理用户界面事件、解码和应用业务规则，到创建无错误的数据流和从失败的操作中恢复的方法。Combine为我们提供了许多内置功能，这将使我们的代码易于阅读和维护。
- en: 'In the next chapter, we are going to learn about one of the new features of
    iOS 14: App Clips.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习iOS 14的一个新特性：应用快照。
