- en: Chapter 4. APIs Introduced in iOS 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 iOS 7 中引入的 API
- en: '**API** stands for **application programming interface**. An API is a set of
    commands, functions, sections of code, and protocols that programmers can use
    in their applications. They are predefined functions available for programmers
    to use instead of writing them from scratch. While APIs make a programmer''s task
    easier, an API is a software-to-software interface, not a user interface. With
    APIs, applications communicate with each other without any user intervention.
    Some popular APIs are Google Map APIs, Twitter APIs, YouTube APIs, and so on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**API** 代表 **应用程序编程接口**。API 是一组命令、函数、代码段和协议，程序员可以在他们的应用程序中使用。它们是程序员可用的预定义函数，而不是从头开始编写。虽然
    API 使程序员的任务变得更容易，但 API 是软件到软件的接口，而不是用户界面。使用 API，应用程序可以在没有任何用户干预的情况下相互通信。一些流行的
    API 包括 Google Map API、Twitter API、YouTube API 等。'
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using AirDrop to remotely send/receive files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AirDrop 远程发送/接收文件
- en: iOS's first native game engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 的第一个原生游戏引擎
- en: Text kit to manage your typography
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本工具管理你的排版
- en: Sample projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本项目
- en: There are a lot of major updates done by Apple for developers to incorporate
    into their app. The user interface has been completely redesigned. iOS 7 introduces
    a new animation system to create 2D and 2.5D games. Multitasking enhancements,
    peer-to-peer connectivity, and many other important features have been added.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为开发者做了很多重大更新，以便他们将其纳入他们的应用程序中。用户界面已经完全重新设计。iOS 7 引入了一个新的动画系统来创建 2D 和 2.5D
    游戏。多任务增强、对等连接以及许多其他重要功能都已添加。
- en: Using AirDrop
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AirDrop
- en: 'Apple introduced a new feature in iOS 7 called **AirDrop**. AirDrop is used
    to easily share pictures, contacts, notes, and more with other nearby iOS devices.
    It uses Bluetooth to detect nearby devices. When a connection is established via
    Bluetooth, it''ll create an ad hoc Wi-Fi network to link the two devices together.
    There is a class called `UIActivityViewController` available to integrate AirDrop
    in our apps. We just need to tell this class which objects we want to share, and
    it handles the rest. The `UIActivityViewController` class is a standard view controller
    class that provides several standard services, such as copying items to the clipboard,
    sharing content on social media sites, sending items via messages, and so on.
    In iOS 7 SDK, this class is served with the built-in AirDrop feature:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在 iOS 7 中引入了一个名为 **AirDrop** 的新功能。AirDrop 用于轻松与其他附近的 iOS 设备共享图片、联系人、笔记等。它使用蓝牙来检测附近的设备。当通过蓝牙建立连接时，它将创建一个临时的
    Wi-Fi 网络来连接两个设备。有一个名为 `UIActivityViewController` 的类可用于在我们的应用程序中集成 AirDrop。我们只需要告诉这个类我们想要分享哪些对象，它就会处理其余的事情。`UIActivityViewController`
    类是一个标准的视图控制器类，它提供了一些标准服务，例如将项目复制到剪贴板、在社交媒体网站上共享内容、通过消息发送项目等。在 iOS 7 SDK 中，这个类与内置的
    AirDrop 功能一起提供：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s understand this feature with a small activity:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小活动来了解这个功能：
- en: Open Xcode and make a new project.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode 并创建一个新的项目。
- en: Drag the image view and button into the storyboard from the interface builder.
    Our storyboard will look like the following screenshot:![Using AirDrop](img/1829OT_04_01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像视图和按钮从界面构建器拖放到故事板中。我们的故事板将如下截图所示：![使用 AirDrop](img/1829OT_04_01.jpg)
- en: Drag any image in Xcode below the class files that you want to use.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何图像拖放到 Xcode 中你想要使用的类文件下方。
- en: Select the image view from the storyboard and move to the Attribute Inspector.
    Then, in the **Image** textbox, give it the same name as that of the image we
    dragged in Xcode, as shown in the following screenshot:![Using AirDrop](img/1829OT_04_02.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从故事板中选择图像视图，并移动到属性检查器。然后，在 **Image** 文本框中，给它赋予与我们在 Xcode 中拖拽的图像相同的名称，如下截图所示：![使用
    AirDrop](img/1829OT_04_02.jpg)
- en: Now, link the image view and the button to `viewcontroller.h` and create one
    array in which we will store the content that we want to transfer from AirDrop.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将图像视图和按钮链接到 `viewcontroller.h` 并创建一个数组，我们将在此数组中存储从 AirDrop 想要传输的内容。
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot will show the content that we want to transfer:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图将展示我们想要传输的内容：
- en: '![Using AirDrop](img/1829OT_04_03.jpg)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 AirDrop](img/1829OT_04_03.jpg)'
- en: 'Move to `viewController.m` and add the following code to the `viewDidLoad`
    method:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 `viewController.m` 并在 `viewDidLoad` 方法中添加以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we created one string that we want to share and created
    one `UIImage` object that stores our image.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个我们想要分享的字符串，并创建了一个 `UIImage` 对象来存储我们的图像。
- en: 'Then, we added both of them to our defined array. Now, let''s add some code
    in our button event as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将它们两个都添加到了我们定义的数组中。现在，让我们在我们的按钮事件中添加一些代码，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we created `UIActivityViewController` with our `activityItems`
    array. With the `excludedActivityTypes` property, we excluded all the activities
    that are not needed, leaving AirDrop as the only sharing option. Finally, we presented
    the activity view controller. The following screenshot illustrates the preceding
    code snippet:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用我们的 `activityItems` 数组创建了 `UIActivityViewController`。通过 `excludedActivityTypes`
    属性，我们排除了所有不需要的活动，使得 AirDrop 成为唯一的共享选项。最后，我们展示了活动视图控制器。以下截图说明了前面的代码片段：
- en: '![Using AirDrop](img/1829OT_04_04.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 AirDrop](img/1829OT_04_04.jpg)'
- en: It is now time to compile and run our program. After execution, our simulator
    will look like the following screenshot:![Using AirDrop](img/1829OT_04_05.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是编译和运行我们的程序的时候了。执行后，我们的模拟器将看起来像以下截图：![使用 AirDrop](img/1829OT_04_05.jpg)
- en: Tap on the **Share With Air Drop** button. Our simulator will now look like
    this:![Using AirDrop](img/1829OT_04_06.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**通过 AirDrop 分享**按钮。我们的模拟器现在将看起来像这样：![使用 AirDrop](img/1829OT_04_06.jpg)
- en: Here, no options are available because we have excluded all the options except
    the AirDrop option, and the simulator does not support AirDrop. When we put this
    code on the real device, it will show us the devices that are available for sharing
    and the devices that have AirDrop.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，没有可用的选项，因为我们排除了除了 AirDrop 选项之外的所有选项，并且模拟器不支持 AirDrop。当我们将此代码放在真实设备上时，它将显示可用于共享的设备和具有
    AirDrop 的设备。
- en: SpriteKit
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpriteKit
- en: 'Apple has launched its first game engine, SpriteKit, that allows us to create
    games for iOS without being dependent on third-party game libraries. It is very
    powerful and inclined towards the traditional iOS framework approach when it comes
    to its usage. It''s also very easy to adopt and learn. In addition to this, it
    supports lots of features such as physics simulations, a texture atlas, gravity,
    restitution, and game center support. Moreover, it comes with very rich developer
    documentation at the **Apple Development Center**. It''s very useful and well
    written. You might need to understand the anatomy of game development first to
    get started in SpriteKit. So, there are two basic and most important terms here:
    one is Scenes, and the other one is Sprites. Scenes can be considered as the levels
    in the games. So, in any game, the score layer, the **HUD** (**Heads-Up Display**)
    layer, and the gameplay layer can act as different scenes. However, any object
    in the scene, such as the player or enemy, can be considered as a sprite.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果推出了其首个游戏引擎，SpriteKit，它允许我们在不依赖第三方游戏库的情况下为 iOS 创建游戏。它非常强大，并且在用法上倾向于传统的 iOS
    框架方法。它也非常容易采用和学习。此外，它支持许多功能，如物理模拟、纹理图集、重力、恢复力和游戏中心支持。此外，它还提供了非常丰富的开发者文档，位于**苹果开发者中心**。它非常有用且编写得很好。您可能需要首先了解游戏开发的解剖结构，才能开始使用
    SpriteKit。因此，这里有两个基本且最重要的术语：一个是场景（Scenes），另一个是精灵（Sprites）。场景可以被认为是游戏中的关卡。因此，在任何游戏中，得分层、**HUD**（**抬头显示**）层和游戏玩法层都可以作为不同的场景。然而，场景中的任何对象，如玩家或敌人，都可以被认为是精灵。
- en: The iOS native game framework
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS 原生游戏框架
- en: Apple has introduced its own native 2D game framework called SpriteKit. SpriteKit
    is a great 2D game engine that offers support for sprites, animations, filters,
    and masking. Most importantly, it also offers support for the physics engine to
    provide a real-world simulation for the game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果推出了其自家的原生 2D 游戏框架，称为 SpriteKit。SpriteKit 是一个出色的 2D 游戏引擎，它提供了对精灵、动画、滤镜和遮罩的支持。最重要的是，它还提供了对物理引擎的支持，为游戏提供真实世界的模拟。
- en: Apple provides a sample game called *Adventure Game* to get started with SpriteKit.
    You can check out the sample SpriteKit game project at [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture).
    This sample project provides a glimpse into the capability of this framework.
    However, the project is complicated to understand; for learning purposes, you
    just want to create something simple to understand and learn. To have a deeper
    understanding of SpriteKit-based games, we will build a bunch of mini games in
    this book. To understand the basics of SpriteKit game programming, we will build
    a mini *AntKilling* game in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司提供了一个名为 *Adventure Game* 的示例游戏，以帮助用户开始使用 SpriteKit。您可以在 [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture)
    查看示例 SpriteKit 游戏项目。这个示例项目展示了该框架的能力。然而，该项目理解起来比较复杂；为了学习目的，您只需创建一些简单易懂的内容即可。为了更深入地理解基于
    SpriteKit 的游戏，本书中将构建一系列迷你游戏。为了理解 SpriteKit 游戏编程的基础，我们将在本章中构建一个迷你 *AntKilling*
    游戏。
- en: 'Let''s start building the *AntKilling* game by performing the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始构建 *AntKilling* 游戏：
- en: Start your Xcode. Navigate to **File** | **New** | **Project**. Then, in the
    prompt window, navigate to **iOS** | **Application** | **SpriteKit Game** and
    click on **Next**, as shown in the following screenshot:![The iOS native game
    framework](img/1829OT_04_07.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Xcode。导航到 **文件** | **新建** | **项目**。然后，在提示窗口中，导航到 **iOS** | **应用程序** | **SpriteKit
    游戏** 并点击 **下一步**，如图所示：![iOS 原生游戏框架](img/1829OT_04_07.jpg)
- en: Fill in all the project details in the prompt window and enter `AntKilling`
    as **Product Name**. Also provide the name of your organization and select the
    device name as **iPhone** and **Class Prefix** as **AK**. Click on **Next** as
    shown in the following screenshot:![The iOS native game framework](img/1829OT_04_08.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示窗口中填写所有项目详细信息，并将 **产品名称** 输入为 `AntKilling`。同时提供您组织的名称，选择设备名称为 **iPhone**，并将
    **类前缀** 选择为 **AK**。点击 **下一步**，如图所示：![iOS 原生游戏框架](img/1829OT_04_08.jpg)
- en: Select a location on your drive to save the project and then click on **Create**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的驱动器上选择一个位置以保存项目，然后点击 **创建**。
- en: Then, build the sample project to check its output. Once you build and run the
    project with the Play button, you will see the following screen on your device:![The
    iOS native game framework](img/1829OT_04_09.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，构建示例项目以检查其输出。一旦您使用播放按钮构建并运行项目，您将在设备上看到以下屏幕：![iOS 原生游戏框架](img/1829OT_04_09.jpg)
- en: As you can see, the sample SpriteKit project plays a label with a background
    color. SpriteKit works on the concept of scenes, which can be understood as the
    levels or screens of the game. There can be multiple scenes working at the same
    time; for example, there can be a gameplay scene, HUD scene, and the score scene
    running at the same time in the game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，示例 SpriteKit 项目播放了一个带有背景色的标签。SpriteKit 的工作原理是场景，可以理解为游戏的关卡或屏幕。可以同时运行多个场景；例如，在游戏中可以同时运行游戏玩法场景、HUD
    场景和得分场景。
- en: 'Now, we can look at more detailed arrangements for the starter project by performing
    the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下步骤查看入门项目的更详细设置：
- en: In the main directory, you already have one scene created by default; this scene
    is called `AKMyScene`. Now, click on `AKMyScene.m` to explore the code for adding
    the label on the screen. You should see something similar to following screenshot:![The
    iOS native game framework](img/1829OT_04_10.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主目录中，您已经默认创建了一个场景；这个场景被称为 `AKMyScene`。现在，点击 `AKMyScene.m` 以探索屏幕上添加标签的代码。您应该看到类似于以下截图的内容：![iOS
    原生游戏框架](img/1829OT_04_10.jpg)
- en: Now, we have to update this file with our code to create our *AntKilling* game.
    We have to fulfill a few prerequisites to get started with the code; for example,
    we have to lock the orientation to landscape as we want a landscape-orientation
    game.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们必须更新此文件以添加我们的 *AntKilling* 游戏代码。为了开始编写代码，我们必须满足一些先决条件；例如，我们必须将方向锁定为横屏，因为我们想要一个横屏游戏。
- en: To change the orientation of the game, open the **AntKilling** project settings
    and navigate to **TARGETS** | **General**. You will see something similar to the
    following screenshot:![The iOS native game framework](img/1829OT_04_11.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改游戏的朝向，请打开**AntKilling**项目设置并导航到**目标** | **常规**。你将看到以下截图所示的内容：![iOS原生游戏框架](img/1829OT_04_11.jpg)
- en: Now, in the **General** tab, uncheck **Portrait** under the **Device Orientation**
    option so that the final settings look similar to the following screenshot:![The
    iOS native game framework](img/1829OT_04_12.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**常规**选项卡中，取消选中**设备方向**选项下的**肖像**，以便最终设置看起来类似于以下截图：![iOS原生游戏框架](img/1829OT_04_12.jpg)
- en: Now, build and run the project. You will be able to see the app started in the
    landscape orientation.![The iOS native game framework](img/1829OT_04_13.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行项目。你将能够看到应用程序以横幅方向启动。![iOS原生游戏框架](img/1829OT_04_13.jpg)
- en: Now, it's time to update `AKMyScene` to hold our ant sprites. Just download
    and open all the resources you got for this chapter and add them to your Xcode
    project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将`AKMyScene`更新为包含我们的蚂蚁精灵了。只需下载并打开你为此章节获得的所有资源，并将它们添加到你的Xcode项目中。
- en: While adding the resources to the Xcode project, make sure that the selected
    target is **AntKilling** and that the **Copy items into destination group folder**
    is checked, if needed.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将资源添加到Xcode项目时，请确保选定的目标是**AntKilling**，并且如果需要，请勾选**将项目复制到目标文件夹**。
- en: Now, delete all the existing code from `AKMyScene.m` and make it look similar
    to following screenshot:![The iOS native game framework](img/1829OT_04_14.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`AKMyScene.m`中删除所有现有代码，使其看起来类似于以下截图：![iOS原生游戏框架](img/1829OT_04_14.jpg)
- en: 'Now, here is the explanation of what we did so far:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这里是对我们迄今为止所做工作的解释：
- en: 'First, we created a private interface to declare the private variables:'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个私有接口来声明私有变量：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the `init` method, we printed a log to print the size of the screen:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`init`方法中，我们打印了一个日志来打印屏幕的大小：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We changed the screen background color to white using the following line of
    code:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码行将屏幕背景色更改为白色：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following line of code, we created a sprite object using the `spriteNodeWithImageNamed`
    method and passed the image name to it. Then, we positioned the sprite object
    to `(100, 100)` of the screen, which is in the bottom-left corner of the screen.
    Then, finally, we added it as a child method:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们使用`spriteNodeWithImageNamed`方法创建了一个精灵对象，并将图像名称传递给它。然后，我们将精灵对象定位到屏幕的`(100,
    100)`位置，这是屏幕的左下角。然后，最后，我们将其作为子方法添加：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, build and run your application. You will see something similar to the following
    screenshot:![The iOS native game framework](img/1829OT_04_15.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行你的应用程序。你将看到以下截图所示的内容：![iOS原生游戏框架](img/1829OT_04_15.jpg)
- en: 'Now, as you can see, the screen color has changed to white, but there is no
    ant on the screen. This means there is something wrong with the code. So now,
    let''s check our logs, which should print the following:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，屏幕颜色已经变成了白色，但屏幕上没有蚂蚁。这意味着代码中有些问题。所以现在，让我们检查我们的日志，它应该打印以下内容：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, we found out that the scene size is wrong; it should print `568` as the
    width and `320` as the height, and it is printing the opposite.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们发现场景大小不正确；它应该打印`568`作为宽度，`320`作为高度，但它打印的是相反的。
- en: To debug this, navigate to the `viewDidLoad` method of your `AKViewController.m`.
    This will be something similar to the one shown in the following screenshot:![The
    iOS native game framework](img/1829OT_04_16.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调试这个问题，请导航到你的`AKViewController.m`中的`viewDidLoad`方法。这将是以下截图所示的内容：![iOS原生游戏框架](img/1829OT_04_16.jpg)
- en: So, from this method, we can see that our scene absorbs the size from the bounds
    of the view, and this `viewDidLoad` method is invoked even before the view has
    been added to the view hierarchy. Thus, it has not responded to the layout changes.
    As a result of the inconsistent view bounds, our scene is getting started with
    the wrong bounds.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，从这个方法中，我们可以看到我们的场景从视图的边界中吸收大小，并且这个`viewDidLoad`方法在视图被添加到视图层次结构之前就被调用了。因此，它没有响应布局更改。由于视图边界的不一致，我们的场景以错误的边界启动。
- en: To solve this issue, we have to move the scene startup code in the `viewWillLayoutSubviews`
    method.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们必须将场景启动代码移动到`viewWillLayoutSubviews`方法中。
- en: After removing the code from the `viewDidLoad` method and pasting it to `viewWillLayoutSubviews`,
    the code file will look similar to the one shown in the following screenshot:![The
    iOS native game framework](img/1829OT_04_17.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `viewDidLoad` 方法中移除代码并将其粘贴到 `viewWillLayoutSubviews` 之后，代码文件将类似于以下截图所示：![iOS原生游戏框架](img/1829OT_04_17.jpg)
- en: Now, again, build and run the app. You will see the following output:![The iOS
    native game framework](img/1829OT_04_18.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次构建并运行应用程序。你会看到以下输出：![iOS原生游戏框架](img/1829OT_04_18.jpg)
- en: Congrats! You have fixed the issue; now, your ant has appeared on the screen
    at your given location. If you observe closely, you can see that the status bar
    is coming on the top of the game, and this is not looking great.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恭喜！你已经修复了这个问题；现在，你的蚂蚁已经出现在你指定的屏幕位置上了。如果你仔细观察，你会发现状态栏出现在游戏的顶部，这看起来并不好。
- en: To remove the status bar from the screen, open your `AntKilling-Info.plist`
    file and add the `UIViewControllerBasedStatusBarAppearance` attribute and the
    value as `NO`. Your `.plist` file should be similar to following screenshot:![The
    iOS native game framework](img/1829OT_04_19.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从屏幕上移除状态栏，打开你的 `AntKilling-Info.plist` 文件，并添加 `UIViewControllerBasedStatusBarAppearance`
    属性，并将值设置为 `NO`。你的 `.plist` 文件应该类似于以下截图：![iOS原生游戏框架](img/1829OT_04_19.jpg)
- en: Build and run your project again. You should be able to see the game without
    the status bar now, as shown in the following screenshot:![The iOS native game
    framework](img/1829OT_04_20.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行你的项目。你现在应该能够看到没有状态栏的游戏，如下面的截图所示：![iOS原生游戏框架](img/1829OT_04_20.jpg)
- en: This looks perfect now; our ant is residing on the screen as expected. So now,
    our next objective is to animate the ant when we tap on it.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在看起来很完美；我们的蚂蚁正如预期的那样驻留在屏幕上。所以，我们的下一个目标是当我们点击蚂蚁时使它动画化。
- en: 'To accomplish this, we need to add the following code in the `AKMyScene.m`
    file just below our `initWithSize` method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们需要在 `AKMyScene.m` 文件中 `initWithSize` 方法下方添加以下代码：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final code file will look similar to the one shown in the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的代码文件将类似于以下截图所示：
- en: '![The iOS native game framework](img/1829OT_04_21.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![iOS原生游戏框架](img/1829OT_04_21.jpg)'
- en: 'Let''s go through it line-by-line to understand what we have done so far:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们逐行分析，了解我们到目前为止所做的工作：
- en: To begin with, we added the `-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent
    *)event` method to the grab all the touches on the scene.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加了 `-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event` 方法来抓取场景上的所有触摸。
- en: Now, in the function the first line allowed us to grab the `UITouch *touch =
    [touches anyObject];` touch.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在函数中，第一行代码允许我们获取 `UITouch *touch = [touches anyObject];` touch。
- en: In the next line, we grabbed the touch and converted it to the `CGPoint positionInScene
    = [touch locationInNode:self];` location.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，我们抓取了触摸并将其转换为 `CGPoint positionInScene = [touch locationInNode:self];`
    位置。
- en: 'Using the following line, we fetched the sprite that was touched:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行，我们获取了被触摸的精灵：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have the sprite object, compare and check whether the selected object
    is the ant bug. If it''s the ant bug, then animate the object by adding the following
    line of code:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了精灵对象，比较并检查选定的对象是否是蚂蚁虫。如果是蚂蚁虫，那么通过添加以下代码行来使对象动画化：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, this code will animate the selected sprite. Build and run the project,
    and you will see the ant animating when we tap on it.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这段代码将使选定的精灵动画化。构建并运行项目，当你点击蚂蚁时，你会看到蚂蚁在动画化。
- en: 'You will soon notice that, on tapping on the ant, it starts animating, but
    there is no way to stop this. So, let''s add a way to stop this animation once
    you click anywhere on the scene. Go to the `- (void)touchesBegan:(NSSet *)touches
    withEvent:(UIEvent *)event` method and update it to the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会注意到，当我们点击蚂蚁时，它开始动画化，但没有办法停止它。所以，让我们添加一种方法，当你点击场景中的任何地方时停止这种动画。转到 `- (void)touchesBegan:(NSSet
    *)touches withEvent:(UIEvent *)event` 方法，并将其更新为以下代码：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you observe closely, you can see that we have added an `if`/`else` condition
    to check whether the ant animates when we tap on it and whether all actions stop
    when we tap anywhere outside the screen. To stop all the actions on the sprite,
    we can use the `removeAllActions` method on the sprite.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现我们添加了一个 `if`/`else` 条件来检查当我们点击蚂蚁时它是否动画化，以及当我们点击屏幕外的任何地方时是否停止所有动作。为了在精灵上停止所有动作，我们可以使用精灵上的
    `removeAllActions` 方法。
- en: Text Kit
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Text Kit
- en: 'The `UIKit` framework includes several classes whose purpose is to display
    text in a user''s app, such as `UITextView`, `UITextField`, `UILabel`, and `UIWebView`.
    Text views, created from the `UITextView` class, are meant to display different
    types of text on screen. `UITextView` is a powerful layout engine called **Text
    Kit**. Text Kit is built on top of **Core Text**, so it provides the same speed
    and power as that of Core Text. `UITextView` is fully integrated with Text Kit;
    it provides editing and display capabilities that enable users to input text,
    specify formatting attributes, and view the results. The other Text Kit classes
    provide text storage and layout capabilities. The following diagram shows the
    position of Text Kit among other iOS text and graphic frameworks:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIKit`框架包括几个类，其目的是在用户的App中显示文本，例如`UITextView`、`UITextField`、`UILabel`和`UIWebView`。从`UITextView`类创建的文本视图旨在在屏幕上显示不同类型的文本。`UITextView`是一个名为**Text
    Kit**的强大布局引擎。Text Kit建立在**Core Text**之上，因此它提供了与Core Text相同速度和功能。`UITextView`完全集成到Text
    Kit中；它提供编辑和显示功能，使用户能够输入文本、指定格式属性并查看结果。其他Text Kit类提供文本存储和布局功能。以下图表显示了Text Kit在iOS文本和图形框架中的位置：'
- en: '![Text Kit](img/1829OT_04_22.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![文本工具包](img/1829OT_04_22.jpg)'
- en: 'We know that Text Kit is a collection of many classes and functions. However,
    there are three primary classes of Text Kit:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Text Kit是一系列类和函数的集合。然而，Text Kit有三个主要类：
- en: '`NSTextStorage` (text storage class)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSTextStorage`（文本存储类）'
- en: '`NSLayoutManager` (layout manager class)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSLayoutManager`（布局管理类）'
- en: '`NSTextContainer` (text container class)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSTextContainer`（文本容器类）'
- en: NSTextStorage
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSTextStorage
- en: The `NSTextStorage` class is responsible for storing all text attribute-related
    information, such as font, size, or paragraph information. The `NSTextStorage`
    class is a subclass of the `NSMutableAttributedString` class, and that's why it
    is responsible for keeping all text attributes. Besides this, its role also lies
    in making sure that all the edited text attribute data will remain consistent
    throughout all the management and editing operations that might be performed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSTextStorage`类负责存储所有与文本属性相关的信息，例如字体、大小或段落信息。`NSTextStorage`类是`NSMutableAttributedString`类的子类，这就是为什么它负责保持所有文本属性。除此之外，它的作用还在于确保所有编辑过的文本属性数据在整个可能执行的管理和编辑操作中保持一致。'
- en: NSLayoutManager
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSLayoutManager
- en: The `NSLayoutManager` class, as its name implies, manages the way in which the
    text data stored in a `NSTextStorage` object will be displayed in a view. Its
    job is to handle and support any view object that the text can be displayed in
    and perform any required conversions of Unicode characters to glyphs so that each
    character properly appears on screen. An object of this class is notified by `NSTextStorage`
    about any modifications made to the text and its attributes, so every change immediately
    gets reflected in the corresponding view.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所暗示的，`NSLayoutManager`类管理存储在`NSTextStorage`对象中的文本数据在视图中显示的方式。其任务是处理并支持任何文本可以显示的视图对象，并执行任何必要的Unicode字符到符号的转换，以确保每个字符都能正确地显示在屏幕上。此类对象由`NSTextStorage`通知关于对文本及其属性所做的任何修改，因此每次更改都会立即反映在相应的视图中。
- en: NSTextContainer
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSTextContainer
- en: The `NSTextContainer` class actually specifies the view where the text will
    appear, and it handles information regarding this view (such as its frame or shape).
    However, a quite important characteristic of this class is its ability to keep
    an array of Bezier paths that define areas that should be excluded from the allowed
    region where the text will appear. This gives Text Kit the unique possibility
    of letting text flow around images or other non-text objects and allowing developers
    to display text in an impressive or demanding manner.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSTextContainer`类实际上指定了文本将出现的位置视图，并处理有关此视图的信息（例如其框架或形状）。然而，此类的一个相当重要的特性是它能够保持一个Bezier路径数组，这些路径定义了应该从文本将出现允许区域中排除的区域。这使得文本工具包具有独特的可能性，允许文本绕过图像或其他非文本对象流动，并允许开发者以令人印象深刻或要求严格的方式显示文本。'
- en: 'Text Kit is a set of classes and protocols in the `UIKit` framework that provide
    high-quality typographical services that enable apps to store, layout, and display
    text with all kinds of typesetting: kerning, ligatures, line breaking, and justification.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 文本工具包是`UIKit`框架中一系列类和协议的集合，它提供高质量的排版服务，使应用能够以各种排版存储、布局和显示文本：字距调整、连字符、换行和文本对齐。
- en: Kerning
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字距调整
- en: 'All characters have different and irregular shapes, and these shapes must be
    placed exactly adjacent to each other. Text kit layout takes this into account;
    for example, a capital letter, *T*, has a lot of free space under its "wings"
    and moves the following lowercase letters closer. This results in significantly
    improved legibility of text, especially in longer pieces of writing. The following
    screenshot illustrates kerning:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符都有不同且不规则的外形，并且这些外形必须精确地相邻放置。文本布局库考虑了这一点；例如，大写字母*T*在其“翅膀”下有很多空白空间，并将下面的小写字母移动得更近。这显著提高了文本的可读性，尤其是在较长的文本片段中。以下截图说明了字距调整：
- en: '![Kerning](img/1829OT_04_23.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![字距调整](img/1829OT_04_23.jpg)'
- en: Ligatures
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连字符
- en: This is an artistic feature of Text Kit. Some characters look nice when they
    are combined, for example when *f* is combined with *l*. These combined symbols
    are called glyphs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Text Kit的一个艺术特性。一些字符组合起来看起来很漂亮，例如当*f*与*l*组合时。这些组合符号被称为字符。
- en: '![Ligatures](img/1829OT_04_24.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![连字符](img/1829OT_04_24.jpg)'
- en: Line breaking
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行断开
- en: To create lines from a string of glyphs, the layout engine must perform line
    breaking by finding a point at which to end one line and begin the next. In the
    text system, you can specify line breaking at either word or glyph boundaries.
    In Roman text, a word broken between glyphs requires the insertion of a hyphen
    glyph at the breakpoint.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字符序列创建行，布局引擎必须通过找到一个点来结束一行并开始下一行来进行行断开。在文本系统中，您可以在单词边界或字符边界处指定行断开。在罗马文本中，如果单词在字符之间被断开，需要在断点处插入连字符字符。
- en: Justification
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐
- en: Lines of text can also be justified; for horizontal text, the lines are aligned
    on both right and left margins by varying interword and interglyph spacing, as
    shown in the following screenshot. The system performs alignment and justification,
    if requested, after the text stream has been broken into lines, hyphens have been
    added, and other glyph substitutions have been made.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文本行也可以进行对齐；对于水平文本，行通过调整单词间和字符间的间距，在左右边距上对齐，如下面的截图所示。系统在将文本流拆分成行、添加连字符和其他字符替换之后，如果需要，将执行对齐和对齐。
- en: '![Justification](img/1829OT_04_25.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![对齐](img/1829OT_04_25.jpg)'
- en: 'Let''s move to exclusion paths again. We know that Text Kit contains many classes,
    and Text Container is one of them. One great feature of it is that it can store
    an array of `UIBezierPath` and force text to flow around these paths; as they
    are excluded from the text draw region, they are called **exclusion paths**. Let''s
    understand how they work by performing the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次转向排除路径。我们知道Text Kit包含许多类，Text Container是其中之一。它的一个伟大特性是它可以存储一个`UIBezierPath`数组并强制文本绕过这些路径；由于它们被排除在文本绘制区域之外，因此被称为**排除路径**。让我们通过以下步骤来了解它们是如何工作的：
- en: Open Xcode and create a new project. Go to the storyboard, drag a **Text Field**
    to view, and edit the text as you want (as shown in the following screenshot):![Justification](img/1829OT_04_26.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xcode并创建一个新项目。转到故事板，将**文本字段**拖到视图中，并编辑您想要的文本（如下面的截图所示）：![对齐](img/1829OT_04_26.jpg)
- en: Drag an image view on the text view, as follows:![Justification](img/1829OT_04_27.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像视图拖放到文本视图中，如下所示：![对齐](img/1829OT_04_27.jpg)
- en: Add an image on the image view, as we did earlier. Drag any image in Xcode,
    as shown in the following screenshot, and give the same name to the image view
    via the Attribute Inspector as that of the dragged image:![Justification](img/1829OT_04_28.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像视图中添加一个图像，就像我们之前做的那样。将任何图像拖入Xcode，如下面的截图所示，并通过属性检查器将图像视图的名称与拖动的图像的名称相同：![对齐](img/1829OT_04_28.jpg)
- en: Compile and run the code; our simulator will look like the following screenshot.
    It's cutting our text part below the image; this is not the output that we expected.![Justification](img/1829OT_04_31.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码；我们的模拟器将如下所示。它切掉了图像下面的文本部分；这不是我们预期的输出。![对齐](img/1829OT_04_31.jpg)
- en: To implement the exclusive path text, we need to add some code. First of all,
    link the text field and image view to the `viewController.h` file, as shown in
    the following screenshot:![Justification](img/1829OT_04_29.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现专用路径文本，我们需要添加一些代码。首先，将文本字段和图像视图链接到`viewController.h`文件，如下面的截图所示：![对齐](img/1829OT_04_29.jpg)
- en: 'In the `viewController.m` file, write the following code in the `viewDidLoad`
    method:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`viewController.m`文件中，在`viewDidLoad`方法中编写以下代码：
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we first checked whether the image view is hidden or
    not (`_propertyName` is also a way to access any property other than `self.property`).
    If it''s hidden (the initial state), then we have to set the exclusion path to
    the text container object of the text view so that the text flows around the image
    view and, of course, to make the image view visible:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先检查图像视图是否隐藏（`_propertyName` 也是访问除 `self.property` 之外任何属性的一种方式）。如果它被隐藏（初始状态），那么我们必须将排除路径设置为文本视图的文本容器对象，以便文本围绕图像视图流动，当然，也要使图像视图可见：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This line is used to convert the image view coordinates from the `self.view`
    view to the text view, so both the image view and the floating text exist in the
    same area. Next, using the `bezierPathWithRect:` class method of the `UIBezierPath`
    class, we created the Bezier path by the frame specified by its parameter; in
    our case, this is the frame (converted to the text view's coordinates) of the
    image view. We added this Bezier path to `NSArray`, and finally, we set the exclusion
    path. Note that, in the `else` case, we set the exclusion path to `nil`, because
    we don't want our text to flow when the image view is not there.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码用于将图像视图坐标从 `self.view` 视图转换为文本视图，因此图像视图和浮动文本存在于同一区域。接下来，使用 `UIBezierPath`
    类的 `bezierPathWithRect:` 类方法，我们通过其参数指定的框架创建了贝塞尔路径；在我们的情况下，这是图像视图的框架（转换为文本视图的坐标）。我们将这个贝塞尔路径添加到
    `NSArray` 中，最后，我们设置了排除路径。请注意，在 `else` 情况下，我们将排除路径设置为 `nil`，因为我们不希望在图像视图不存在时文本流动。
- en: 'Our `viewController.m` file will look like the one shown in the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `viewController.m` 文件将类似于以下截图所示：
- en: '![Justification](img/1829OT_04_30.jpg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![对齐](img/1829OT_04_30.jpg)'
- en: Run the code. Now, our text will not be cut because of the image. Look at the
    following screenshot; it's not cutting our text, and our text continues after
    the image in each line. Text gives space to the image through the `UIBezierPath`
    class and makes a different class for the image view. So, now, you can try it
    for round-shaped images or other images of any shape.![Justification](img/1829OT_04_32.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。现在，我们的文本不会因为图像而被截断。看下面的截图；它没有截断我们的文本，并且每行文本都在图像之后继续。文本通过 `UIBezierPath`
    类为图像留出空间，并为图像视图创建了一个不同的类。所以，现在，你可以尝试圆形图像或其他任何形状的图像。![对齐](img/1829OT_04_32.jpg)
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a lot of interesting things, including how to create
    a game, add an image between text, and share it with AirDrop. All these APIs are
    introduced in iOS 7\. After this chapter, try to extend all the activities performed
    here. This will clarify your concepts. In the next chapter, we will learn iOS
    8 APIs, including PhotoKit, manual camera control, and the Handoff concept.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多有趣的东西，包括如何创建游戏，在文本之间添加图像，以及通过 AirDrop 分享。所有这些 API 都是在 iOS 7 中引入的。在本章之后，尝试扩展在这里执行的所有活动。这将阐明你的概念。在下一章中，我们将学习
    iOS 8 API，包括 PhotoKit、手动相机控制和 Handoff 概念。
