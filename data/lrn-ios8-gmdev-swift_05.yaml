- en: Chapter 5. Animation and Particles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 动画与粒子
- en: In the previous chapter, we created a basic game. In this chapter, we will make
    the game more lively and the characters a little more believable. Instead of just
    static images, we will add animation. We will also look at SpriteKit's inbuilt
    particle effects creator.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个基本游戏。在本章中，我们将使游戏更加生动，角色更加逼真。我们将添加动画，而不是仅仅静态图像。我们还将探讨SpriteKit内置的粒子效果创建器。
- en: For character animation, we will look at how SpriteKit creates animations and
    also at an external tool called **Texture Packer**, developed by Code'n'Web. We
    will see how it simplifies the process of animation. We will also be covering
    a concept called **sprite sheets**, which is fundamental and is used to optimize
    a game's performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角色动画，我们将探讨SpriteKit如何创建动画，以及一个名为**Texture Packer**的外部工具，由Code'n'Web开发。我们将了解它是如何简化动画过程的。我们还将介绍一个称为**精灵表**的概念，这是基础性的，用于优化游戏性能。
- en: We will first look at how SpriteKit gets an inbuilt sprite sheet generator and
    makes the animation process simpler. Then we will look at Texture Packer, which
    simplifies the process even further. So let's see what a sprite sheet is.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将了解SpriteKit如何获取内置的精灵表生成器，使动画过程更加简单。然后我们将探讨Texture Packer，它进一步简化了这一过程。所以，让我们看看什么是精灵表。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Sprite sheet animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵表动画
- en: Basic SpriteKit animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本SpriteKit动画
- en: Texture Packer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Texture Packer
- en: Creating a hero sprite sheet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建英雄精灵表
- en: Animating the hero
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画英雄
- en: Particle systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统
- en: The particle designer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子设计师
- en: Creating a particle effect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建粒子效果
- en: Adding a particle system to the game
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将粒子系统添加到游戏中
- en: Sprite sheet animation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵表动画
- en: Until now, what we were doing was using a single file for the player, enemy,
    rocket, and bullet. Every time we create a new rocket, the game goes and gets
    the memory, and finds and retrieves the image. The process is repeated every time
    a bullet is created. This is okay for a simple game such as ours, but later, when
    we start creating more complex games with a lot more enemies and bullet types,
    the process will become very taxing on the device, and the performance of the
    game will be affected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的是使用单个文件来存储玩家、敌人、火箭和子弹。每次我们创建一个新的火箭，游戏就会去获取内存，找到并检索图像。每次创建子弹时，这个过程都会重复。对于像我们这样的简单游戏来说，这没问题，但后来，当我们开始创建包含更多敌人类型和子弹的更复杂游戏时，这个过程将对设备造成很大的负担，并影响游戏性能。
- en: To solve this problem, sprite sheets are used. A sprite sheet contains all the
    images that we will use in the game in a single file, instead of 10 images sitting
    at 10 different memory locations. The sprite sheet image file will also be accompanied
    by a data file, which will contain the location and size of each of the images
    located in the sprite sheet. At the start of the game, the sprite sheet image
    and data file are loaded into the cache once. Then, every time the rocket or the
    bullet is called, the game knows where the sprite sheet is and simply loads the
    image from it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用了精灵表。精灵表包含我们在游戏中将使用的所有图像，存储在一个单独的文件中，而不是在10个不同的内存位置存储10个图像。精灵表图像文件还将附带一个数据文件，其中包含精灵表中每个图像的位置和大小。在游戏开始时，精灵表图像和数据文件被一次性加载到缓存中。然后，每次调用火箭或子弹时，游戏就知道精灵表的位置，并简单地从其中加载图像。
- en: The sprite sheet file needs to be as compact as possible, so images might be
    rotated to make it more compact. The data file will keep track of this, and when
    creating the frames in game, it will make the image upright again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表文件需要尽可能紧凑，因此图像可能会被旋转以使其更紧凑。数据文件将跟踪这一点，并在游戏中创建帧时，将图像恢复为直立。
- en: '![Sprite sheet animation](img/B04014_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![精灵表动画](img/B04014_05_01.jpg)'
- en: When animating in the game, each of the frames for the corresponding animation
    will be stored in an array and made to loop at a particular predefined speed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中进行动画时，对应动画的每一帧都将存储在数组中，并以特定的预定义速度循环。
- en: Fortunately, in SpriteKit, all you have to do is provide the frames. At runtime,
    SpriteKit automatically creates a sprite sheet, which we can use in the game.
    We will use SpriteKit's inbuilt sprite sheet creator to create the enemy animation.
    Later, we will create the player animation using Texture Packer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在SpriteKit中，我们只需要提供帧。在运行时，SpriteKit会自动创建精灵表，我们可以在游戏中使用它。我们将使用SpriteKit内置的精灵表创建器来创建敌人动画。稍后，我们将使用Texture
    Packer创建玩家动画。
- en: Basic SpriteKit animation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本SpriteKit动画
- en: To create the enemy animation, we first have to give the images to SpriteKit.
    Since we have to provide **1x** and **2x** images for each frame, we could create
    four image sets; name them `enemy1`, `enemy2`, `enemy3`, and `enemy4`; and then
    drag **1x** and **2x** for each set. Although it is absolutely possible to do
    it this way, it is highly tedious. There is an alternate, less tedious way of
    doing it. While naming each frame, for the **1x** image of a frame you can add
    the numbers `1`, `2`, `3`, and `4` at the end of the file to show the frame names.
    For the **2x** version of a frame, you need to add `@2x` at the end to tell SpriteKit
    that this file is twice the size of the original version of the image. So, for
    the first frame, the **1x** file will be `enemy_1.png`, and the filename for the
    **2x** version of the frame will be `enemy_1@2x.png` (here, I am using an underscore
    because the regular enemy image we used in the previous chapter was already named
    `enemy1.png`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建敌人动画，我们首先必须将图像提供给 SpriteKit。由于我们必须为每个帧提供 **1x** 和 **2x** 图像，我们可以创建四个图像集；命名为
    `enemy1`、`enemy2`、`enemy3` 和 `enemy4`；然后为每个集拖动 **1x** 和 **2x**。虽然以这种方式做是完全可能的，但非常繁琐。有一种更简单的方法。在命名每个帧时，对于帧的
    **1x** 图像，您可以在文件末尾添加数字 `1`、`2`、`3` 和 `4` 以显示帧名称。对于帧的 **2x** 版本，您需要在文件末尾添加 `@2x`
    以告诉 SpriteKit 此文件是原始图像版本的两倍大小。因此，对于第一帧，**1x** 文件将是 `enemy_1.png`，而帧的 **2x** 版本的文件名将是
    `enemy_1@2x.png`（在这里，我使用下划线是因为我们在上一章中使用的常规敌人图像已经命名为 `enemy1.png`）。
- en: The `@2x` bit is a keyword, so make sure that you don't name your image regularly
    with `@2x`, as it will cause some unexpected outcomes. This naming convention
    should be used only if you have a **1x** version of an image. To tell SpriteKit
    which image is the **2x**, version you add `@2x` at the end of the file to show
    that this image is twice the size of the other one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`@2x` 位是关键字，所以请确保您不要将图像常规命名为 `@2x`，因为这可能会导致一些意外的结果。这种命名约定仅在您有一个图像的 **1x** 版本时使用。为了告诉
    SpriteKit 哪个图像是 **2x** 版本，您需要在文件末尾添加 `@2x` 以表明此图像是另一个图像的两倍大小。'
- en: So, for creating the enemy animation, we will have four frames of animation.
    Thus, we will have an image for each frame. Additionally, for the **2x** version,
    we will need four more images that are twice the size, with the filename ending
    with `@2x`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建敌人动画，我们将有四个动画帧。因此，我们将为每个帧有一个图像。此外，对于 **2x** 版本，我们还需要四个额外的图像，它们的大小是两倍，文件名以
    `@2x` 结尾。
- en: 'The frames for enemy animation are provided in this chapter''s `Resources`
    folder. Get all the images and place them in a new folder on the desktop. Now,
    to tell Xcode that a sprite sheet has to be created from the images provided,
    click on the folder in which all the images are present and rename it to `enemyAnim.atlas`.
    This is very important; if you don''t do this, then the sprite sheet won''t be
    created. The folder should appear as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人动画的帧在此章节的 `Resources` 文件夹中提供。获取所有图像并将它们放置在桌面上的一个新文件夹中。现在，为了告诉 Xcode 必须从提供的图像创建精灵表，点击包含所有图像的文件夹，并将其重命名为
    `enemyAnim.atlas`。这非常重要；如果您不这样做，则不会创建精灵表。文件夹应如图所示：
- en: '![Basic SpriteKit animation](img/B04014_05_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![基本 SpriteKit 动画](img/B04014_05_02.jpg)'
- en: 'Drag and drop the folder into the project folder. When the window opens up,
    as shown in the following screenshot, make sure that the **Copy items if needed**
    box is checked and the current project is the target:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件夹拖放到项目文件夹中。当窗口打开时，如图所示，请确保已勾选 **Copy items if needed** 复选框，并且当前项目是目标：
- en: '![Basic SpriteKit animation](img/B04014_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![基本 SpriteKit 动画](img/B04014_05_03.jpg)'
- en: Click on **Finish** to continue. Now the folder will be inside the project,
    and we can start adding the code to animate the enemy character. Instead of using
    a static image when the enemy is created, we will change the `addEnemy` function,
    as follows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **完成** 继续操作。现在文件夹将位于项目中，我们可以开始添加代码来动画化敌人角色。当敌人被创建时，我们不会使用静态图像，而是更改 `addEnemy`
    函数，如下所示。
- en: 'First, let''s check whether what I said earlier is correct. If we replace the
    enemy variable with the name of the image of the first frame, the game should
    still work. So, in the place where we create an enemy, instead of passing the
    enemy image set, we will pass the first frame of the animation to the `enemyNode`
    variable. Change the line for creating the enemy node to the following in the
    `addEnemy` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查我之前所说的是否正确。如果我们用第一帧的图像名称替换敌人变量，游戏应该仍然可以工作。因此，在创建敌人的地方，我们不会传递敌人图像集，而是将动画的第一帧传递给`enemyNode`变量。在`addEnemy`函数中将创建敌人节点的行更改为以下内容：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This won't animate the character because it is still taking only the first frame
    of the animation and displaying it. But at least, we can be sure that the frame
    is loading properly. You don't have to add the extension when passing the name,
    so `.png` is not required. Neither do you have to say `@2x` to load the image
    for a higher resolution, as SpriteKit will automatically take the absence of `@2x`
    to mean the **1x** resolution, and get the `@2` image file's name for **2x** resolutions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会使角色动画化，因为它仍然只取动画的第一帧并显示它。但至少，我们可以确信帧正在正确加载。在传递名称时不需要添加扩展名，因此不需要`.png`。你也不需要说`@2x`来加载更高分辨率的图像，因为SpriteKit会自动将`@2x`的缺失视为**1x**分辨率，并为**2x**分辨率获取`@2`图像文件名。
- en: 'Now let''s go ahead and load the other frames so that we can animate the enemy.
    After the `addChild(enemyNode)` line, add the following lines of code in the `addEnemy`
    function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续加载其他帧，以便我们可以为敌人动画。在`addChild(enemyNode)`行之后，在`addEnemy`函数中添加以下代码行：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we load the sprite sheet in a constant called `textureAtlas` using the
    **texture atlas** class in SpriteKit. Wait! What is a texture atlas? Well, it
    is just another name for a sprite sheet. You can call it either, but they mean
    the same thing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用SpriteKit中的**纹理图集**类在名为`textureAtlas`的常量中加载精灵表。等等！什么是纹理图集？嗯，它只是精灵表的另一个名字。你可以叫它任何名字，但它们的意思是相同的。
- en: After loading the sprite sheet, we create an array to store all the textures,
    or the frames of the animation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载精灵表后，我们创建一个数组来存储所有纹理，即动画的帧。
- en: Since we have four animation frames to load, namely `enemy_1`, `enemy_2`, `enemy_3`,
    and `enemy_4`, we create a `for` loop and iterate from `1` to `4`. Like any array,
    we append the four files to the `textureArray` variable we created. We assign
    each texture using the `textureNamed` function of the `SkTextureAtlas` class.
    Similar to how we log things on the screen or change text dynamically, we use
    the `\()` operator to provide the names of the four files. Once the images are
    stored in the array, we create an action so that we can run through the frames
    at a certain speed. The `animateWithTextures` function of SKAction takes in an
    array of textures and a duration for which each frame should be displayed on the
    screen. So here, we give the `textureArray` variable storing all the textures,
    and give 0.2 or 200 milliseconds as the time for which each frame will be displayed.
    However, this will run the animation only once. For the animation to run again
    and again, we use the `repeatForever` action. So, we create a new constant called
    `animate` and store the `repeatForever` action in it by passing the animation
    to it. Finally, we run the action on the `enemyNode` variable. Now you can build
    and run to see the enemy character getting animated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要加载四个动画帧，即`enemy_1`、`enemy_2`、`enemy_3`和`enemy_4`，我们创建一个`for`循环并从`1`迭代到`4`。像任何数组一样，我们将这四个文件追加到我们创建的`textureArray`变量中。我们使用`SkTextureAtlas`类的`textureNamed`函数为每个纹理分配。类似于我们在屏幕上记录事物或动态更改文本的方式，我们使用`\()`运算符提供四个文件的名字。一旦图像存储在数组中，我们创建一个动作，以便我们可以以一定的速度遍历这些帧。SKAction的`animateWithTextures`函数接受一个纹理数组以及每个帧应在屏幕上显示的持续时间。因此，在这里，我们提供了存储所有纹理的`textureArray`变量，并给出0.2秒或200毫秒作为每个帧将显示的时间。然而，这将只运行一次动画。为了让动画反复运行，我们使用`repeatForever`动作。因此，我们创建一个新的常量`animate`，并通过传递动画将其存储在其中。最后，我们在`enemyNode`变量上运行这个动作。现在你可以构建并运行，以查看敌人角色正在动画化。
- en: That's all pretty good, but there is an easier way so that we don't have to
    create separate sets of frames for the **1x** and **2x** resolutions for the game.
    Moreover, while creating the array of textures, we need to know beforehand how
    many frames need to be looped through in the animation. In the case of the enemy,
    we know that there are four frames in the animation, so we looped from `1` to
    `4`. What if we are not aware of this information? It may lead to errors or the
    animation looking clunky if we loop less or more than the total number of frames
    of the animation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，但有一个更简单的方法，这样我们就不必为 **1x** 和 **2x** 分辨率的游戏创建单独的帧集。此外，在创建纹理数组时，我们需要事先知道动画中需要循环多少帧。对于敌人来说，我们知道动画中有四帧，所以我们从
    `1` 循环到 `4`。如果我们不知道这个信息怎么办？如果我们循环的帧数少于或超过动画的总帧数，可能会导致错误或动画看起来不流畅。
- en: Therefore, to animate the player, we will be using the Texture Packer way of
    animating.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了动画化玩家，我们将使用 Texture Packer 的动画方式。
- en: Exploring Texture Packer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Texture Packer
- en: Texture Packer is a very popular piece of software that is used by industry
    professionals such as Disney, Zynga, and WG Games to create sprite sheets. You
    can download it from [https://www.codeandweb.com/](https://www.codeandweb.com/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Texture Packer 是一款非常受欢迎的软件，被迪士尼、Zynga 和 WG Games 等行业专业人士用于创建精灵图集。您可以从 [https://www.codeandweb.com/](https://www.codeandweb.com/)
    下载它。
- en: '![Exploring Texture Packer](img/B04014_05_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![探索 Texture Packer](img/B04014_05_04.jpg)'
- en: This is similar to how we created the images earlier when creating enemy animations.
    To create sprite sheet animation using Texture Packer, you also have to create
    the individual frames in Photoshop or Illustrator first. I have already made them
    and have each of the images for the individual frames ready.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在创建敌人动画时创建图像的方式相似。要使用 Texture Packer 创建精灵图集动画，您也必须首先在 Photoshop 或 Illustrator
    中创建单个帧。我已经制作好了，每个单独帧的图像都已经准备好了。
- en: You can use the trial version of Texture Packer to follow along the tutorial.
    When downloading, choose the version that is suitable for your operating system.
    Fortunately, Texture Packer is available for all major operating systems, including
    Linux.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Texture Packer 的试用版来跟随教程。下载时，请选择适合您操作系统的版本。幸运的是，Texture Packer 可用于所有主要操作系统，包括
    Linux。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Once you have downloaded Texture Packer, you get three options: you can click
    to try the full version for a week, purchase the license, or click on **Essential
    version** to use a trial version. In the trial version, some professional features
    are disabled, so I recommend trying the professional features for a week.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Texture Packer 后，您有三个选项：您可以点击尝试完整版一周，购买许可证，或者点击 **基本版本** 使用试用版。在试用版中，一些专业功能被禁用，所以我建议您尝试一周的专业功能。
- en: 'Once you click on the option, you should see the interface, as shown in the
    following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击选项后，您应该会看到以下截图所示的界面：
- en: '![Exploring Texture Packer](img/B04014_05_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![探索 Texture Packer](img/B04014_05_05.jpg)'
- en: Here, you can either open an existing project by clicking on the **Open Project**
    button in the bottom-left corner of the screen, or select the framework for which
    you wish to create the sprite sheet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以通过点击屏幕左下角的 **打开项目** 按钮来打开一个现有项目，或者选择您希望创建精灵图集的框架。
- en: As you can see, Texture Packer supports a wide range of frameworks and formats,
    including Cocos2d, Unity, Corona, Swift, and many more. We need to select **Swift**
    from the list and click on **Create Project**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Texture Packer 支持广泛的框架和格式，包括 Cocos2d、Unity、Corona、Swift 以及更多。我们需要从列表中选择
    **Swift** 并点击 **创建项目**。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Texture Packer has three panels; let's start from the left. The left panel will
    display the names of all the images that you have selected to create the sprite
    sheet. Here, you can drag and drop individual images or full folders containing
    your assets. The middle panel is a preview window. It shows you how the images
    are packed. The right panel gives you options to choose where you would like to
    store the packed texture and data file to be published, and what the format of
    the packed image should be. The layout section gives a lot of flexibility to set
    up individual images in the texture packer. Finally, we have different modes for
    optimizing the sprite sheets.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Texture Packer有三个面板；让我们从左侧开始。左侧面板将显示您为创建精灵表而选定的所有图像的名称。在这里，您可以拖放单个图像或包含您的资源的完整文件夹。中间面板是一个预览窗口。它显示了图像是如何打包的。右侧面板提供了选择您希望存储打包纹理和数据文件的位置以及打包图像格式的选项。布局部分为在纹理打包器中设置单个图像提供了很多灵活性。最后，我们有不同的模式来优化精灵表。
- en: 'Let''s look at some of the key items in the settings panel on the right:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看右侧设置面板中的关键项：
- en: '![Exploring Texture Packer](img/B04014_05_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![探索纹理打包器](img/B04014_05_06.jpg)'
- en: Data
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: 'Under **Data**, we define all of the information regarding the data file to
    be exported. This includes **Data Format**, **Atlas Bundle**, and **Swift Class
    file**. The explanation of each of these fields is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在**数据**下，我们定义了有关要导出数据文件的所有信息。这包括**数据格式**、**图集包**和**Swift类文件**。以下是对每个字段的解释：
- en: '**Data Format**: As we saw earlier, each exported file creates a sprite sheet
    that has a collection of images and a data file that keeps track of the positions
    on that sprite sheet. The data format usually changes depending on the framework
    or the engine you selected. Since we selected SpriteKit initially and selected
    **Swift** as the language, the format is of type `swift`. Suppose we were using
    the Objective-C language. Then there is a separate option for that as well. So,
    be mindful while selecting the format, otherwise you will have to start over if
    you wish to develop the sprite sheet for another format.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式**：如我们之前所见，每个导出的文件都会创建一个包含图像集合和数据文件的精灵表，该数据文件跟踪精灵表上的位置。数据格式通常取决于您选择的框架或引擎。由于我们最初选择了SpriteKit并选择了**Swift**作为语言，因此格式为`swift`类型。假设我们正在使用Objective-C语言，那么也有一个针对该语言的单独选项。因此，在选择格式时要小心，否则如果您希望为另一种格式开发精灵表，您将不得不从头开始。'
- en: '**Atlas Bundle**: This is the location where you want the exported image and
    data file to be saved. So, you will get a `.png` image file and a `.plist` data
    file containing information about the sprite sheet once the file is published.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图集包**：这是您希望导出的图像和数据文件保存的位置。因此，一旦文件发布，您将获得一个`.png`图像文件和一个包含精灵表信息的`.plist`数据文件。'
- en: '**Swift Class file**: Along with the image and the data file, Texture Packer
    will also create a helper class containing information that will be imported along
    with the image and data file to make the animation code even simpler.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift类文件**：除了图像和数据文件外，Texture Packer还会创建一个包含信息的辅助类，这些信息将与图像和数据文件一起导入，以使动画代码更加简单。'
- en: Texture
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理
- en: 'In the **Texture** section, we will specify the sprite sheet image''s file
    details. This includes details regarding **Texture Format**, **Png Opt Level**,
    and **Pixel format**. The explanation of these fields is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在**纹理**部分，我们将指定精灵表图像的文件细节。这包括有关**纹理格式**、**Png Opt Level**和**像素格式**的详细信息。以下是对这些字段的解释：
- en: '**Texture Format**: The default is set to `.png`, but other formats are also
    supported. Apart from PNG, you can also use the PVR format. This format is used
    for data protections because it is easier to copy data from regular PNG files.
    Also, PVR formats provide superior image compression. However, be aware that it
    can be used only on Apple devices.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理格式**：默认设置为`.png`，但也支持其他格式。除了PNG之外，您还可以使用PVR格式。这种格式用于数据保护，因为它更容易从常规PNG文件中复制数据。此外，PVR格式提供了优越的图像压缩。但是，请注意，它只能在苹果设备上使用。'
- en: '**Png Opt Level**: This is used to set the quality of the PNG file.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Png Opt Level**：用于设置PNG文件的质量。'
- en: '**Pixel format**: This sets the RGB format to be used. Usually, you would want
    this to be set at the default value.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素格式**：这设置了要使用的RGB格式。通常，您希望将其设置为默认值。'
- en: Layout
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'Here, we specify the layout of the sprite sheet image. The following fields
    can be seen in the **Layout** section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定精灵表图像的布局。以下字段可以在**布局**部分看到：
- en: '**Max Size**: You can specify the maximum width and height of the sprite sheet,
    depending on the framework. Usually, all frameworks allow up to 4092 x 4092, but
    this mostly depends on the framework, so check the maximum size the framework
    allows before creating the sprite sheet.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大尺寸**: 您可以根据框架指定精灵图集的最大宽度和高度。通常，所有框架都允许最大为4092 x 4092，但这主要取决于框架，因此在创建精灵图集之前，请检查框架允许的最大尺寸。'
- en: '**Size constraints**: Some frameworks prefer the sprite sheets to be in the
    POT format (or the powers of 2), that is, 32 x 32, 64 x 64, 256 x 256, and so
    on. If this is the case, then you need to select accordingly. Otherwise, you can
    choose **Anysize**.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸约束**: 一些框架更喜欢精灵图集以POT格式（或2的幂）存在，即32 x 32、64 x 64、256 x 256等。如果是这种情况，那么您需要相应地选择。否则，您可以选择**任意尺寸**。'
- en: '**Scaling variants**: This is used for scaling up or scaling down the image.
    If you are going to be creating images for different resolutions, such as **1x**,
    **2x** and **3x**, then this option allows you to create resources, depending
    on the different resolutions you are developing the game for. Moreover, there
    will be no need to go into the graphics software, shrink the images, and pack
    them again for all the resolutions individually.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放变体**: 这用于放大或缩小图像。如果您打算为不同的分辨率创建图像，例如**1x**、**2x**和**3x**，那么此选项允许您根据您为不同分辨率开发的游戏创建资源。此外，您无需进入图形软件，分别缩小图像并重新打包所有分辨率的图像。'
- en: '**Algorithm**: This is the code logic that will be used to create sprite sheets,
    and it will make sure that the images are packed in the most efficient manner.
    In the Basic version, you will have to use **Basic** from the drop-down menu,
    unlike the Pro version, where you can choose **MaxRects**.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**: 这是用于创建精灵图集的代码逻辑，并确保图像以最有效的方式打包。在基本版本中，您必须从下拉菜单中选择**基本**，与专业版本不同，在专业版本中，您可以选择**MaxRects**。'
- en: '**Multipack**: If the PNG image file exceeds the maximum size, then Texture
    Packer will automatically create an additional sprite sheet and data files for
    the images that it wasn''t able to incorporate into the previous sprite sheet.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多包**: 如果PNG图像文件超过最大尺寸，则Texture Packer将自动为之前无法包含到精灵图集中的图像创建额外的精灵图集和数据文件。'
- en: Sprites
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵
- en: 'Here, we specify any special treatment for individual sprites in the sprite
    sheet. There is one field in this section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定对精灵图集中的单个精灵的任何特殊处理。本节中有一个字段：
- en: '**Trim mode**: Removes the extra alpha surrounding each image making the sprite
    sheet more compact and thereby deceasing file size even further.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裁剪模式**: 移除围绕每个图像的额外透明度，使精灵图集更加紧凑，从而进一步减小文件大小。'
- en: Creating the hero spritesheet
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建英雄精灵图集
- en: There is a folder called `heroAnim` in the `Resources` folder for this chapter.
    This folder contains another folder, which contains the individual frames for
    the hero's idle animations. Drag and drop the `heroAnim` folder into the left
    panel of Texture Packer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节的`Resources`文件夹中有一个名为`heroAnim`的文件夹。此文件夹包含另一个文件夹，其中包含英雄空闲动画的单独帧。将`heroAnim`文件夹拖放到Texture
    Packer的左侧面板中。
- en: You will see the folder structure of the `heroAnim` folder here. Under it, you
    will see the `idle` folder where you will see the individual files for the frames.
    In the preview pane, you will see the preview of the sprite sheet that will be
    created from the images provided.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在这里看到`heroAnim`文件夹的文件夹结构。在其下，您将看到`idle`文件夹，其中包含帧的单独文件。在预览窗格中，您将看到从提供的图像创建的精灵图集的预览。
- en: In the **Layout** section, click on the **Scaling variants** button. From the
    drop-down list in the pre-sets, select **SpriteKit @2x/@1x**. This will automatically
    create sprite sheets for both **2x** and **1x** resolutions by scaling down the
    image by 50 percent and saving it for the **1x** mode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在**布局**部分，点击**缩放变体**按钮。从预设的下拉列表中选择**SpriteKit @2x/@1x**。这将自动创建**2x**和**1x**分辨率的精灵图集，通过将图像缩小50%并保存为**1x**模式。
- en: '![Creating the hero spritesheet](img/B04014_05_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建英雄精灵图集](img/B04014_05_07.jpg)'
- en: Next, under the data heading, select the location where you want the sprite
    sheet image and data file to be saved. The files will be saved in the location
    inside a folder with the `.atlasc` extension, and this folder will contain the
    image and data files. Next, select the location for the class file to be saved.
    You can save it to whichever location you want, but make sure that you remember
    where you have saved it because it will be required later.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在数据标题下，选择您想要保存精灵图集图像和数据文件的存储位置。这些文件将保存在具有`.atlasc`扩展名的文件夹内部的位置，并且这个文件夹将包含图像和数据文件。接下来，选择要保存类文件的位置。您可以将其保存到任何您想要的位置，但请确保您记得保存的位置，因为稍后需要用到它。
- en: Also make sure that you save the current file at some location so that if you
    want to make some changes to the file later, you will be able to open it and make
    the changes with ease. One thing to note is that if you change the location of
    the `heroAnim` folder, then the reference will be lost and you will have to reimport
    the image. Keep the images, sprite sheet, class, and Texture Packer file in a
    separate folder so that all of the relevant data for the file is in the same directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还请确保将当前文件保存在某个位置，这样如果您稍后想要对文件进行修改，您将能够轻松地打开它并进行修改。需要注意的是，如果您更改`heroAnim`文件夹的位置，那么引用将会丢失，您将需要重新导入图像。请将图像、精灵图集、类和Texture
    Packer文件保存在单独的文件夹中，以便所有相关数据都在同一目录下。
- en: Finally, to create the sprite sheet, click on the **Publish Sprite Sheet** button
    at the top. Now we can animate the hero.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要创建精灵图集，请点击顶部的**发布精灵图集**按钮。现在我们可以为英雄动画了。
- en: Animating the hero
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为英雄动画
- en: 'To animate the hero in the game, drag the `.atlasc` folder and the Swift class
    file into the project. Then, in the `init` function, add the following code right
    after adding the hero to the scene:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中为英雄动画，将`.atlasc`文件夹和Swift类文件拖入项目。然后，在`init`函数中，在将英雄添加到场景后立即添加以下代码：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And that's all! You can build and run the game to see the hero getting animated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您可以为游戏构建和运行，以查看英雄的动画效果。
- en: Here, we first create a reference to the Swift class that was created in Texture
    Packer. Next, we create a constant called `heroIdleArray` and assign the array
    for the idle animation that is already created in the `heroAnim.swift` class.
    If this wasn't there, then we would have had to manually create an array and store
    the frames, as we did for the enemy. The next three steps are exactly the same
    as how we created the animation for the enemy. We create an animation constant,
    pass the array and the delay that we want for each frame, then create another
    action to repeat the animation over and over, and finally run the animation of
    the hero.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建对在Texture Packer中创建的Swift类的引用。然后，我们创建一个名为`heroIdleArray`的常量，并将`heroAnim.swift`类中已创建的空闲动画数组分配给它。如果没有这个，我们就必须手动创建一个数组并存储帧，就像我们为敌人做的那样。接下来的三个步骤与创建敌人动画的方法完全相同。我们创建一个动画常量，传递数组和我们想要为每个帧设置的延迟，然后创建另一个动作来重复动画，最后运行英雄的动画。
- en: So, we see that we didn't have to create two sets of images, as Texture Packer
    created them for us, and we didn't have to create an array for the idle animation
    either. This becomes even more important if we later have to create a run, walk,
    jump, or attack animation. We can't be creating an array each time. In fact, in
    other frameworks, that's what needs to be done if we want to create different
    animations. This process is so much easier using Texture Packer for SpriteKit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到我们不必创建两套图像，因为Texture Packer为我们创建了它们，而且我们也不必为空闲动画创建数组。如果我们后来需要创建跑步、行走、跳跃或攻击动画，这一点尤为重要。我们不能每次都创建数组。实际上，在其他框架中，如果我们想要创建不同的动画，就需要这样做。使用Texture
    Packer为SpriteKit创建这个过程要容易得多。
- en: 'Let''s look at the Swift class created by Texture Packer so that you can get
    a better understanding of what is happening and how the array is created. So,
    open the `heroAnim.swift` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Texture Packer创建的Swift类，以便您更好地理解正在发生的事情以及数组是如何创建的。所以，打开`heroAnim.swift`文件：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I named the class `heroAnim` while creating the file in Texture Packer, so that
    is why the name of the class is the same as what I named it. Secondly, you will
    notice that the four images that we used to create the sprite sheet are named
    `hero_idle_1`, `hero_idle_2`, `hero_idle_3`, and `hero_idle_4`. So, at the start
    of the class, it automatically creates constants for the four filenames equal
    to the string names.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Texture Packer中创建文件时，我将其命名为`heroAnim`，这就是为什么类的名称和我命名的一样。其次，你会注意到我们用来创建精灵图的四个图像分别命名为`hero_idle_1`、`hero_idle_2`、`hero_idle_3`和`hero_idle_4`。因此，在类的开始处，它会自动为这四个文件名创建等于字符串名称的常量。
- en: Then the class creates an `SKTextureAtlas` constant called `textureAtlas`. This
    texture atlas is created from the `heroAnim.atlasc` folder. So, although the name
    is the same as that of the class, this is the sprite sheet file; don't get confused.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类创建了一个名为`textureAtlas`的`SKTextureAtlas`常量。这个纹理图集是从`heroAnim.atlasc`文件夹创建的。所以，尽管名称与类的名称相同，但这实际上是精灵图文件；不要混淆。
- en: After getting the texture atlas, four functions are created to get the four
    images stored in the texture atlas with the constant names defined earlier. Then
    a new function is finally created, which adds the four images into an array and
    returns the array. This function is named similar to how we named the image files
    that were used to create the animation. This makes it convenient to know the name
    of the function to call when assigning the array while creating the animation
    action. Also remember that all of this is done automatically in Texture Packer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取纹理图集后，创建了四个函数来获取之前定义的常量名称中存储在纹理图集中的四个图像。然后最终创建了一个新函数，该函数将四个图像添加到数组中并返回该数组。这个函数的命名方式与我们命名用于创建动画的图像文件的方式相似。这使得在创建动画动作时知道要调用的函数名称变得方便。还要记住，所有这些都是在Texture
    Packer中自动完成的。
- en: Apart from the idle animation, if we have two images for the run cycle and call
    them `heroRun1.png` and `heroRun2.png`, then the function that will return the
    `run` array will be called `heroRun()`. An easy way to remember this would be
    to replace any number with open and closed brackets to get the function name and
    the array of frames.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了空闲动画之外，如果我们有两个用于跑步周期的图像，分别命名为`heroRun1.png`和`heroRun2.png`，那么将返回`run`数组的函数将被命名为`heroRun()`。记住这个方法的一个简单方式是将任何数字替换为开闭括号以获取函数名和帧数组。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'It is also important to note this: while naming your images required for creating
    the frames for animation, make sure you use the same naming convention for all
    the frames, just like the case of naming the frames. For example, while naming
    frames for animation, I usually name the files in the form of `name_action_number`.
    It can also be like `nameActionNumber`, as we named the run animation example,
    but make sure you are consistent.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点很重要：在为创建动画帧所需的图像命名时，确保你为所有帧使用相同的命名约定，就像命名帧的情况一样。例如，在为动画命名帧时，我通常将文件命名为`name_action_number`的形式。它也可以像我们命名跑步动画示例那样，命名为`nameActionNumber`，但请确保你保持一致性。
- en: It is also important to make sure that the numbering of the files is in the
    order in which you want the animation to be played. This is because when the animation
    is played, frame 1 will be played first, then frame 2, then frame 3, and so on.
    If your image is incorrectly numbered, the animation will be played in that order
    and it might look a little funny when it gets played.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是要确保文件的编号顺序是你想要动画播放的顺序。这是因为当播放动画时，首先播放帧1，然后是帧2，然后是帧3，依此类推。如果你的图像编号不正确，动画将按此顺序播放，播放时可能会显得有些奇怪。
- en: These are the only things that you need to be careful about. If you are consistent
    in naming and numbering your files, then correctly creating animations in Texture
    Packer is a breeze. Texture Packer does most of the dirty work for you and leaves
    no room for error as it mostly automates the process for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你需要注意的唯一事项。如果你在文件命名和编号上保持一致，那么在Texture Packer中正确创建动画将变得非常容易。Texture Packer为你做了大部分脏活，并且没有留下出错的空间，因为它主要为你自动化了这个过程。
- en: Now let's look at how to create particles in a game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在游戏中创建粒子。
- en: Particle systems
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: A **particle system** is a collection of sprites or particles. Each particle
    system has an emitter from where the particles will be created. A particle system
    also determines the behavior of the particles in the system. Hence it can be said
    that a particle is the smallest entity that creates the particle system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子系统**是一组精灵或粒子。每个粒子系统都有一个发射器，粒子将从那里产生。粒子系统还决定了系统中粒子的行为。因此，可以说粒子是创建粒子系统的最小实体。'
- en: A very easy example of a particle system is Rain. **Rain** is a particle system
    in which each rain drop is a particle and a cloud has a lot of emitters from where
    the droplets, or particles, are created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的一个非常简单的例子是雨。**雨**是一个粒子系统，其中每一滴雨都是粒子，而云有大量的发射器，从这些发射器中产生水滴或粒子。
- en: We create a particle system instead of creating individual particles because
    with a particle system, we can create different kinds of effects using the same
    particle. For example, we saw Rain, which is a particle system. What if we wanted
    another effect, such as water coming out of the faucet? Here, the particle is
    the same—a water droplet—but a rain droplet behaves differently. When water is
    falling from the faucet, each drop falls with a force and is created with a single
    emitter—the faucet outlet. So, we can change the particle system to have one emitter
    and give the particles an initial downward force. In this way, we will have the
    same particle behaving differently, instead of coding the system from scratch
    again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个粒子系统而不是创建单个粒子，因为使用粒子系统，我们可以使用相同的粒子创建不同类型的特效。例如，我们看到了雨，这是一个粒子系统。如果我们想有另一个效果，比如水从水龙头流出呢？在这里，粒子是相同的——水滴，但雨滴的行为不同。当水从水龙头落下时，每一滴都带有力量落下，并且由单个发射器——水龙头出口——创建。因此，我们可以将粒子系统更改为只有一个发射器，并给粒子一个初始向下的力。这样，我们将有相同的粒子以不同的方式表现，而不是从头开始编码系统。
- en: In SpriteKit, as in any other framework, each particle is an image that is controlled
    by a particle system that has one or more emitters. An **emitter** controls the
    spawning, movement, and destruction of the particle system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SpriteKit 中，就像在其他任何框架中一样，每个粒子都是一个由粒子系统控制的图像，该粒子系统有一个或多个发射器。**发射器**控制粒子系统的生成、移动和销毁。
- en: For rendering the particle system, a **SpriteKit particle file** (`.sks`) is
    created. It can contain a particle system of any size, and allows for rotation
    and scaling of the entire particle system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染粒子系统，创建了一个**SpriteKit 粒子文件**（`.sks`）。它可以包含任何大小的粒子系统，并允许整个粒子系统旋转和缩放。
- en: Designing particles
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计粒子
- en: SpriteKit has an inbuilt particle designer. This designer has a pretty good
    user interface that can be used to create your own particle systems. SpriteKit
    also includes a number of default particle systems that are already included and
    can be created by selecting the particle system that you want for your game from
    the drop-down menu.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 有一个内置的粒子设计器。这个设计器有一个相当不错的用户界面，可以用来创建您自己的粒子系统。SpriteKit 还包括一些默认的粒子系统，这些系统已经内置，可以通过从下拉菜单中选择您想要用于游戏的粒子系统来创建。
- en: To create a new particle system, go to **File** and select **New File**. You
    can also create a new file by right-clicking on the root folder of your project.
    In the **iOS** panel on the left, select **Resource**, then select **SpriteKit
    Particle File**, and click on **Next**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的粒子系统，请前往**文件**并选择**新建文件**。您也可以通过在项目的根文件夹上右键单击来创建一个新的文件。在左侧的**iOS**面板中，选择**资源**，然后选择**SpriteKit
    粒子文件**，并点击**下一步**。
- en: '![Designing particles](img/B04014_05_08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![设计粒子](img/B04014_05_08.jpg)'
- en: 'Now, from the drop-down menu, you can select from the eight default particle
    systems that come included in SpriteKit. You can select from **Bokeh**, **Fire**,
    **Fireflies**, **Magic**, **Rain**, **Smoke**, **Snow**, and **Spark**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从下拉菜单中，您可以从 SpriteKit 内置的八个默认粒子系统中进行选择。您可以从**波纹**、**火焰**、**萤火虫**、**魔法**、**雨**、**烟雾**、**雪**和**火花**中进行选择：
- en: '![Designing particles](img/B04014_05_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![设计粒子](img/B04014_05_09.jpg)'
- en: For this example, I selected **Fire**. Once you have selected the particle system
    of your choice, click on **Next**. We will have to give the particle system a
    filename that we can call it by later when we want to create that effect in the
    game, so I named it `fireParticle`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我选择了**火焰**。一旦您选择了所需的粒子系统，请点击**下一步**。我们将必须给粒子系统起一个文件名，这样我们就可以在以后创建游戏中的效果时调用它，所以我将其命名为`fireParticle`。
- en: '![Designing particles](img/B04014_05_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![设计粒子](img/B04014_05_10.jpg)'
- en: Once you're done, you will see a `fireParticle.sks` file created in your project
    and the fire particle burning bright in the editor panel. By default, it is created
    in the center of the screen. Click anywhere in the editor panel and the fire particle
    system will be moved to that location. You can also click and move the mouse around
    to see that the particle system moves along with the mouse arrow.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将在项目中看到创建的`fireParticle.sks`文件，编辑面板中的火粒子正在熊熊燃烧。默认情况下，它位于屏幕中央。在编辑面板的任何位置单击，火粒子系统将移动到该位置。你还可以单击并移动鼠标，以查看粒子系统随着鼠标箭头移动。
- en: You will also see that the **Utilities** panel has changed and a whole bunch
    of variables with changeable parameters have appeared. You can change these parameters
    to create your own custom particle system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到**工具**面板已更改，出现了一堆可更改参数的变量。你可以更改这些参数来创建自己的自定义粒子系统。
- en: Let's go through each of these basic parameters so that you can understand what
    each of these variables do and how, by changing each of the parameters, the behavior
    of the particle system can be changed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解这些基本参数，以便你可以了解每个变量做什么以及如何通过更改每个参数来改变粒子系统的行为。
- en: '![Designing particles](img/B04014_05_11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![设计粒子](img/B04014_05_11.jpg)'
- en: Name
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称
- en: If we want to refer to the particle system by name in code, we can give a name
    here so that we can refer to it later. Similar to how we gave a name to the `enemyNode`
    to check whether the node passed to the `movingSprite` class was the enemy, and
    then we perform a certain function based on that information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在代码中通过名称引用粒子系统，我们可以在这里给它一个名称，这样我们就可以稍后引用它。类似于我们给`enemyNode`命名以检查传递给`movingSprite`类的节点是否是敌人，然后根据该信息执行某些功能。
- en: Background
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: The **Background** parameter sets the color of the background. Changing it doesn't
    affect the particle. It is purely for the purpose of visibility. If your particles
    are black, you can change the background to white so that you can see clearly
    how the particle looks and behaves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景**参数设置背景颜色。更改它不会影响粒子。这纯粹是为了可见性。如果你的粒子是黑色的，你可以将背景改为白色，这样你就可以清楚地看到粒子的外观和行为。'
- en: Particle Texture
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子纹理
- en: The **Particle Texture** parameter is the texture or image that will be displayed
    for each particle. Currently `spark.png` is used as the texture. You can change
    this to the enemy, bullet, rocket, or hero image if you want to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子纹理**参数是每个粒子将显示的纹理或图像。目前使用`spark.png`作为纹理。如果你想的话，可以将其更改为敌人、子弹、火箭或英雄图像。'
- en: Particles
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子
- en: The **Particles** parameter controls the rate at which particles are emitted
    and the number of particles you want the emitter to emit. To control the rate,
    you can increase or decrease the birth rate parameter. We can decrease the rate
    of emission to decrease the value of the birth rate, or if we want the particles
    to be emitted faster, we can increase it. To cap the number of particles, we change
    the maximum value to the number of particles we want the emitter to emit. If we
    want the emitter to continuously emit particles, we keep the value at 0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子**参数控制粒子发射的速度以及你希望发射器发射的粒子数量。要控制速度，你可以增加或减少出生率参数。我们可以通过降低出生率来降低发射率，或者如果我们想让粒子更快地发射，我们可以增加它。要限制粒子数量，我们将最大值更改为我们希望发射器发射的粒子数量。如果我们想让发射器持续发射粒子，我们保持该值为0。'
- en: Lifetime
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寿命
- en: When a particle is created, **Lifetime** decides for how long it stays on the
    screen before getting deleted. Here, every particle stays on the screen for 2.5
    seconds. **Range** is used to bring in some randomness in the particles' behavior.
    Suppose we change this range value to 1\. Then some particles will be on the screen
    for 2.0 seconds while others will be there for 3.0 seconds, before getting deleted.
    So, the random value created is plus or minus half of the range value in addition
    to the initial value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当粒子被创建时，**寿命**决定了它在屏幕上停留多长时间后才被删除。在这里，每个粒子在屏幕上停留2.5秒。**范围**用于在粒子的行为中引入一些随机性。假设我们将此范围值更改为1。那么一些粒子将在屏幕上停留2.0秒，而其他粒子将停留3.0秒，然后被删除。因此，创建的随机值是范围值的一半加上初始值。
- en: 'This is how **Range** works: it takes the first value then gets a value by
    either adding or subtracting half of the range value from it so that it will look
    as if each particle has a different lifetime, as in life, not all particles behave
    in the same way.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**范围**的工作原理：它取第一个值，然后通过从它中加上或减去范围值的一半来得到一个值，这样看起来就像每个粒子都有不同的寿命，就像生活中，不是所有粒子都以相同的方式表现。
- en: Position Range
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置范围
- en: The default position at the beginning is the center of the screen. By looking
    at the **Position Range** keyword in the name of the variable, you might have
    guessed that the value that we are inputting is range value. Here, the `x` value
    is `55.65`, which means that when a particle is being spawned, it spawns anywhere
    between `-27.825` to `+27.825` in the *x* direction from the center. The emission
    point is denoted by a small green dot on the editor view. The `y` value is `5`,
    which means that from the center, the particle will be generated anywhere between
    `-2.5` and `+2.5` in the *y* direction. If you change the `X` and `Y` values to
    `0`, you will see all particles getting emitted from the green dot.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认位置在屏幕中央。通过查看变量名称中的**位置范围**关键字，你可能已经猜到我们输入的值是范围值。在这里，`x`的值是`55.65`，这意味着当一个粒子被生成时，它将在从中心向`x`方向的`-27.825`到`+27.825`之间随机生成。发射点在编辑器视图中用一个小的绿色点表示。`y`的值是`5`，这意味着从中心开始，粒子将在`y`方向的`-2.5`到`+2.5`之间随机生成。如果你将`X`和`Y`的值改为`0`，你会看到所有粒子都从绿色点发射出来。
- en: Angle
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角度
- en: The **Angle** parameter determines the angle at which the particles are created.
    Since we want the flames to start moving up in this case, the angle is approximately
    90 degrees. You can change this value to `45` as well, which will make it look
    as if there was some wind acting on the fire. To add some randomness to the initial
    angle, the range is kept at `20`. Otherwise, all particles will be going straight
    up, which will look very unnatural.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**角度**参数决定了粒子生成的角度。由于我们希望火焰在这种情况下向上移动，所以角度大约是90度。你也可以将其值改为`45`，这样看起来就像有风吹拂着火焰。为了给初始角度添加一些随机性，范围保持在`20`。否则，所有粒子都将直接向上移动，这看起来非常不自然。'
- en: Speed
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度
- en: This is the speed at which the particles will start moving when created. Here,
    they start moving at an average speed of 100\. There is a range of 50, which means
    that some will move at the minimum speed of 75 and others will move at the maximum
    of 125.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是粒子在创建时开始移动的速度。在这里，它们以平均速度100开始移动。有一个范围是50，这意味着一些粒子将以最小速度75移动，而其他粒子将以最大速度125移动。
- en: Acceleration
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速度
- en: We can accelerate a particle in the *x* and *y* directions, for example, in
    the case of a jet engine or a comet. To create this effect, you have to change
    the `X` position's range to `5` and increase the `Y` acceleration to around `500`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`x`和`y`方向上加速一个粒子，例如，在喷气发动机或彗星的情况下。为了创建这种效果，你必须将`X`位置的范围改为`5`，并将`Y`加速度增加到大约`500`。
- en: '![Acceleration](img/B04014_05_12.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![加速度](img/B04014_05_12.jpg)'
- en: Alpha
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alpha
- en: This defines the level of opacity or transparency of each particle. If the value
    of **Alpha** is zero, then the particle will be completely transparent, while
    `1` means that it will be completely visible. There is also a **Range** value
    that you can specify. The **Speed** parameter determines the rate at which the
    **Alpha** value of each particle changes per second. So, it starts visible as
    soon as it is created, and over a period of time, it becomes transparent as the
    value of **Alpha** is reduced.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了每个粒子的不透明度或透明度级别。如果**Alpha**的值为零，则粒子将完全透明，而`1`表示它将完全可见。还有一个你可以指定的**范围**值。**速度**参数决定了每个粒子的**Alpha**值每秒变化的速率。因此，粒子一旦创建就会变得可见，然后在一段时间后，随着**Alpha**值的降低，它变得透明。
- en: Scale
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: Similar to **Alpha**, the **Scale** value ranges from `0` to `1`. At `0`, the
    image is completely invisible; and at `1`, it is at its original size. Thus, at
    `0.5` the object will be half the size; and at `2.0`, it will be double the size
    in both the `x` and `y` directions. Here, the object has a start value of 0.5
    and a range of 0.4\. So, the initial start size of any particle will be between
    `0.3` and `0.7`. Since **Speed** is `-0.5`, it will slowly become smaller over
    a period of time after it has spawned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与**Alpha**类似，**缩放**值范围从`0`到`1`。在`0`时，图像完全不可见；在`1`时，它恢复到原始大小。因此，在`0.5`时，对象将是原来的一半大小；在`2.0`时，它在`x`和`y`方向上将是原来大小的两倍。在这里，对象的起始值为`0.5`，范围为`0.4`。因此，任何粒子的初始起始大小将在`0.3`和`0.7`之间。由于**速度**为`-0.5`，它将在生成后的一段时间内逐渐变小。
- en: Rotation
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: As soon as a particle is created, we can make it rotate by giving it a start
    value and a range to generate random speeds of rotation. We can also increase
    or decrease the speed of rotation over a period of time by changing the **Speed**
    parameter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个粒子，我们可以通过给它一个起始值和范围来生成随机旋转速度，使其旋转。我们还可以通过改变**速度**参数在一段时间内增加或减少旋转速度。
- en: Color Blend
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色混合
- en: Color Blend is used to blend one color with another. Here, the initial factor
    is `1` and **Range** is `0`, so we are using the original color that is assigned.
    Since we are not color blending, we have kept the **Speed** value as `0`. We can
    change the speed to `-0.125` to see that the color slowly blends to white, and
    the colors become lighter at the end of the particle's life cycle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色混合用于将一种颜色与另一种颜色混合。在这里，初始因子为`1`，**范围**为`0`，所以我们使用分配的原始颜色。由于我们不是进行颜色混合，我们已将**速度**值保持为`0`。我们可以将速度更改为`-0.125`，以看到颜色逐渐混合到白色，颜色在粒子生命周期的末尾变得更浅。
- en: Color Ramp
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色渐变
- en: Here, we can specify the color of the particle to be generated. The particle
    texture image is always kept white so that we have the liberty to change the color
    of the object in code whenever we want. So here, even though the texture or image
    color is white, the color of the flame is orange.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以指定要生成的粒子的颜色。粒子纹理图像始终保持白色，这样我们就可以在代码中随时更改对象的颜色。所以在这里，尽管纹理或图像颜色是白色，但火焰的颜色是橙色的。
- en: We can also assign different colors to the particle at different stages of its
    life.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在不同的生命周期阶段为粒子分配不同的颜色。
- en: '![Color Ramp](img/B04014_05_13.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![颜色渐变](img/B04014_05_13.jpg)'
- en: The other four variables—**Blend Mode**, **Field Mask**, **Custom Shader**,
    and **Custom Shader Uniform**—pertain to shaders and shader programming, which
    is beyond the scope of this book. Using shaders, you can create custom effects
    and behavior for the particles.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其他四个变量——**混合模式**、**场掩码**、**自定义着色器**和**自定义着色器统一变量**——与着色器和着色器编程有关，这超出了本书的范围。使用着色器，你可以为粒子创建自定义效果和行为。
- en: You can play around with **Blend Mode** a little if you know how it works, as
    it is very similar to what you see in Photoshop. If you know Photoshop, you will
    be familiar with **Add**, **Subtract**, **Multiply**, **Screen**, **Replace**,
    and **Alpha**. You can select each of these and see the effect it has on the particle
    system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解其工作原理，可以稍微玩一下**混合模式**，因为它与你在Photoshop中看到的东西非常相似。如果你了解Photoshop，你会熟悉**添加**、**减去**、**乘以**、**屏幕**、**替换**和**Alpha**。你可以选择这些中的每一个，并查看它对粒子系统产生的影响。
- en: That is all of the information required for now for designing our own particle
    system for the game. Let's now create the particle system that we will be using
    in the game.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的信息已经足够来设计我们自己的游戏粒子系统了。现在，让我们创建我们将要在游戏中使用的粒子系统。
- en: Creating particle effects
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建粒子效果
- en: For the game, we will be creating a very simple explosion particle system, and
    it will be shown every time the hero fires a rocket. We will be using our own
    custom sprite for the image. So, go to the resources folder for the chapter and
    drag and drop the `smoke.png` image into the project. Don't forget to add it as
    a copy, and make sure that the current game is the target.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏，我们将创建一个非常简单的爆炸粒子系统，并且每次英雄发射火箭时都会显示。我们将使用我们自己的自定义精灵图像。所以，转到该章节的资源文件夹，将`smoke.png`图像拖放到项目中。别忘了将其添加为副本，并确保当前游戏是目标。
- en: Now create a new particle system, name the file `explosionParticle`, and save
    it to your project. You can use fire, smoke, or any of the default particle systems.
    It doesn't matter, as we will be changing the values to our specification anyway.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的粒子系统，将文件命名为`explosionParticle`，并将其保存到你的项目中。你可以使用火焰、烟雾或任何默认的粒子系统。这无关紧要，因为我们无论如何都会更改这些值以符合我们的规格。
- en: '![Creating particle effects](img/B04014_05_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![创建粒子效果](img/B04014_05_14.jpg)'
- en: In the preceding screenshot, you can see the parameters of the particle system
    I created using the default particle as a base.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到我使用默认粒子作为基础创建的粒子系统的参数。
- en: I named it `explosionParticle` just in case I have to refer to the particle
    system in code. Then I kept the background as default, as I was still able to
    see the particle quite clearly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其命名为`explosionParticle`以防我需要在代码中引用粒子系统。然后我将背景保持为默认设置，因为我仍然能够清楚地看到粒子。
- en: I changed the texture to the smoke image file that was imported earlier, and
    replaced the default image with it. For **Birthrate**, I kept the value at approximately
    `65`; you can change it as per your needs. I kept the maximum number of particles
    at `12` so that after creating 12 particles, the emitter will stop creating any
    new particles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我将纹理更改为之前导入的烟雾图像文件，并用它替换了默认图像。对于**出生率**，我将其值保持在约`65`；你可以根据你的需求进行更改。我将粒子数的最大值保持在`12`，这样在创建了12个粒子后，发射器将停止创建任何新的粒子。
- en: The **Lifetime** parameter is kept at around `8` and **Range** at around `16`.
    You might say that some particles might be destroyed as soon as they are created.
    Well, that is true and it is also true about smoke particles in general. There
    are some particles in smoke that we don't even get to see when a gun is fired,
    so the behavior will be realistic even though it looks cartoony.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**寿命**参数保持在约`8`，**范围**保持在约`16`。你可能会说有些粒子可能一创建就被销毁。好吧，这是真的，而且这同样适用于烟雾粒子。当枪被发射时，有些烟雾中的粒子我们甚至看不到，所以即使看起来像卡通，行为也会更真实。'
- en: The **Position Range** parameter is approximately `4` along the `x` direction
    and `9` along the `y` direction. This is just to create the particle at a random
    position around the initial position specified so that all particles don't look
    as if they were emerging from the same point.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置范围**参数在`x`方向上约为`4`，在`y`方向上约为`9`。这只是为了在指定的初始位置周围随机创建粒子，这样所有的粒子看起来就不会像是从同一个点出现的。'
- en: The **Angle** parameter is kept between `0` and `360`, as we want the smoke
    particles to move in all directions around the point at which they were created.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**角度**参数保持在`0`到`360`之间，因为我们希望烟雾粒子在它们被创建的点周围的所有方向移动。'
- en: The **Speed** parameter of each particle at the start is kept at approximately
    `48`, and the **Range** is about `90`. This will make some particles move slower
    and others a lot faster. In fact, some particles may not move at all or move very
    slowly, making the behavior more realistic once again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个粒子在开始时的**速度**参数保持在约`48`，**范围**约为`90`。这将使得一些粒子移动较慢，而其他粒子则移动得很快。事实上，一些粒子可能根本不会移动或移动得非常慢，从而使行为再次更真实。
- en: The **Acceleration** parameter is kept at `0` for both the **X** and **Y** directions,
    as it is not required, but you can tinker with these values to see whether you
    like the effect.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速度**参数在**X**和**Y**方向上均保持在`0`，因为这不必要，但你也可以调整这些值来看看你是否喜欢效果。'
- en: As we want the smoke particle to fade slowly, we assign an initial value and
    range, and reduce the value of the alpha by slowly reducing its value by increasing
    the **Speed** parameter to `-1`. Since the size of the image is huge, I scaled
    it to `0.25` to make it smaller and gave it a range so that the size is randomized.
    I changed the speed value to `-0.125` so that the size of each particle slowly
    reduces over a period of time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望烟雾粒子缓慢消失，我们赋予一个初始值和范围，并通过逐渐增加**速度**参数到`-1`来缓慢减少alpha值。由于图像的大小非常大，我将它缩放到`0.25`以使其更小，并赋予一个范围，使得大小是随机的。我将速度值更改为`-0.125`，这样每个粒子的尺寸就会在一段时间内缓慢减小。
- en: The particle needs to rotate as soon as it is created, so I gave it an initial
    value and **Range**. I increased the **Speed** parameter so that the particle
    rotates faster over a period of time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子一旦被创建就需要旋转，所以我给它赋予了一个初始值和**范围**。我将**速度**参数增加，使得粒子在一段时间内旋转得更快。
- en: As I am not color blending, I kept the factor at `1` and the range and speed
    at `0`. I changed the color of the particle to a shade of light blue to make it
    look cartoony. Black would have been a little too dark and more realistic.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我没有进行颜色混合，我将因子保持在`1`，范围和速度在`0`。我将粒子的颜色改为浅蓝色，使其看起来更卡通化。黑色可能会显得有点太暗，更真实。
- en: Finally, I changed **Blend Mode** to **Alpha** because I didn't want additive
    blend mode. You can make the required changes to your particle file and press
    *command* + *S* to save the file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将**混合模式**更改为**Alpha**，因为我不想使用加法混合模式。您可以对您的粒子文件进行必要的更改，然后按*command* + *S*保存文件。
- en: Adding a particle system to the game
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将粒子系统添加到游戏中
- en: 'The file particle system is now ready to be called in to the game. So, open
    the `GameplayScene.swift` file and, in the `addRocket` function, add the following
    code right after where we added the rocket to the scene:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统文件现在已准备好被调用到游戏中。因此，打开`GameplayScene.swift`文件，在`addRocket`函数中，在我们将火箭添加到场景后立即添加以下代码：
- en: '[PRE4]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create a new constant called `explosionParticle` of the `SKEmitterNode`
    type, and pass the filename for the particle system we created earlier. Whenever
    you want to create a particle system, you will have to use `SKEmitterNode`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`explosionParticle`的新常量，其类型为`SKEmitterNode`，并传递我们之前创建的粒子系统的文件名。每次您想要创建粒子系统时，都必须使用`SKEmitterNode`。
- en: Next, we place the particle system at the nozzle of the hero's bazooka. This
    is similar to how we placed the hero's rockets. Finally, we add the particle to
    the scene.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将粒子系统放置在英雄火箭筒的喷嘴处。这与我们放置英雄火箭的方式类似。最后，我们将粒子添加到场景中。
- en: We don't have to worry about removing each particle, as the particle system
    will take care of that automatically. As each particle reaches the end of its
    lifetime, it is automatically removed from the scene.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心移除每个粒子，因为粒子系统会自动处理这一点。当每个粒子达到其生命周期的末端时，它会自动从场景中移除。
- en: 'You can build and run the game now, but you will see that the particle system
    takes a bit of time to create the particles. To make it look as if it is getting
    created instantaneously, we will add the following highlighted code after adding
    the particle to the scene:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以构建并运行游戏，但您会发现粒子系统创建粒子需要一点时间。为了使其看起来像是瞬间创建的，我们在将粒子添加到场景后，将以下突出显示的代码添加进去：
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line will fast forward the simulation to 0.25 seconds after creating the
    particle so that it looks as if the particles are getting created instantaneously.
    Build and run the game again to see the particles in action.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将模拟快速推进到粒子创建后的0.25秒，看起来就像粒子是瞬间被创建出来的。再次构建并运行游戏，以查看粒子的效果。
- en: '![Adding a particle system to the game](img/B04014_05_15.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![将粒子系统添加到游戏中](img/B04014_05_15.jpg)'
- en: There are some additional parameters and properties present in the particle
    designer, such as `advanceSimuationTime`, that can be called and modified only
    in code. But it is better to design the majority of the particle through the designer
    and fine-tune it in code later when it is added to the scene.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子设计师中还有一些额外的参数和属性，例如`advanceSimuationTime`，只能在代码中调用和修改。但最好通过设计师设计大部分粒子，然后在将其添加到场景后通过代码进行微调。
- en: 'Now, if you want, you can create the particle system using code and define
    the parameters individually through the code, as shown in the following snippet,
    which will give the same result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您愿意，可以使用代码创建粒子系统，并通过代码单独定义参数，如下面的代码片段所示，这将产生相同的结果：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These are literally the same variables and parameters. The only difference is
    that here, it is in code format. Obviously, creating the particles using the designer
    is more convenient.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些确实是相同的变量和参数。唯一的区别是这里它是代码格式。显然，使用设计师创建粒子更方便。
- en: There are additional commands that can be used on the particle system that are
    available for your convenience at Apple's developer portal. You might want to
    go through it and experiment if you are interested.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果开发者门户中，有一些额外的命令可用于粒子系统，方便您使用。如果您感兴趣，可以查看并尝试一下。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to use actions and sprite sheets to create animation
    in the game. We looked at SpriteKit's inbuilt sprite sheet generator, and we used
    a professional tool called Texture Packer to create a sprite sheet. We also saw
    how easy it is to generate sprite sheets and animations using this professional
    tool.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用动作和精灵表来创建游戏中的动画。我们查看了SpriteKit内置的精灵表生成器，并使用了一个名为Texture Packer的专业工具来创建精灵表。我们还看到了使用这个专业工具生成精灵表和动画是多么容易。
- en: In addition to that, we saw an introduction to SpriteKit's particle designer,
    and created and implemented a particle system in the game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还看到了SpriteKit粒子设计器的介绍，并在游戏中创建并实现了粒子系统。
- en: There is still something missing in the game, however, and that is sound and
    font customization. We will be looking at this in the next chapter, which includes
    how to add the final touches to the game.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，游戏中仍然缺少一些东西，那就是音效和字体定制。我们将在下一章中探讨这个问题，包括如何为游戏添加最后的修饰。
