- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Developing the UI with Fragments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段开发 UI
- en: This chapter covers fragments and the fragment lifecycle. It demonstrates how
    to use them to build efficient and dynamic layouts that respond to different screen
    sizes and configurations and allow you to divide your UI into different sections.
    By the end of this chapter, you will be able to create static and dynamic fragments,
    pass data to and from fragments and activities, and use the Jetpack `Navigation`
    component to detail how fragments fit together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了片段和片段生命周期。它展示了如何使用它们来构建高效且动态的布局，这些布局能够响应不同的屏幕尺寸和配置，并允许你将你的 UI 划分为不同的部分。在本章结束时，你将能够创建静态和动态片段，在片段和活动之间传递数据，并使用
    Jetpack `Navigation` 组件详细说明片段如何组合在一起。
- en: In the previous chapter, we explored the Android activity lifecycle and looked
    into how it is used in apps to navigate between screens. We also analyzed various
    types of launch modes, which defined how transitioning between screens happened.
    In this chapter, you’ll explore fragments. A fragment is a section, portion, or,
    as the name implies, fragment of an Android activity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Android 活动生命周期，并研究了它在应用中用于屏幕间导航的方式。我们还分析了各种启动模式，这些模式定义了屏幕间转换是如何发生的。在本章中，你将探索片段。片段是一个部分、部分，或者正如其名称所暗示的，Android
    活动的一部分。
- en: Throughout the chapter, you’ll learn how to use fragments, see how they can
    exist in more than one activity, and discover how multiple fragments can be used
    in one activity. You’ll start by adding simple fragments to an activity and then
    progress to learning about the difference between static and dynamic fragments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用片段，了解它们可以存在于多个活动中，并发现如何在单个活动中使用多个片段。你将从向活动添加简单的片段开始，然后逐步学习静态和动态片段之间的区别。
- en: Fragments can be used to simplify creating layouts for Android tablets that
    have larger form factors using dual-pane layouts. For example, if you have an
    average-sized phone screen and you want to include a list of news stories, you
    might only have enough space to display the list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用片段来简化为具有较大尺寸的 Android 平板创建布局。例如，如果你有一个平均尺寸的手机屏幕，并且你想包含新闻故事列表，你可能只有足够的空间来显示列表。
- en: If you viewed the same list of stories on a tablet, you’d have more space available
    so you could display the same list and also a story itself to the right of the
    list. Each of these different areas of the screen can use a fragment. You can
    then use the same fragment on both the phone and the tablet. You benefit from
    reusing and simplifying the layouts and don’t have to repeat creating similar
    functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个平板上查看相同的新闻故事列表，你会拥有更多的可用空间，因此你可以显示相同的列表，并在列表的右侧显示一个故事。屏幕上的每个不同区域都可以使用一个片段。然后你可以在手机和平板上都使用相同的片段。你可以从重用和简化布局中受益，无需重复创建类似的功能。
- en: Once you’ve explored how fragments are created and used, you’ll then learn how
    to organize your user journeys with fragments. You’ll apply some established practices
    for using fragments in this way. Finally, you’ll learn how to simplify fragment
    use by creating a navigation graph with the Android Jetpack `Navigation` component,
    which allows you to specify linking fragments together with destinations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了片段的创建和使用方法之后，你将学习如何使用片段组织用户旅程。你将应用一些使用片段的既定实践。最后，你将学习如何通过使用 Android Jetpack
    `Navigation` 组件创建导航图来简化片段的使用，该组件允许你指定将片段与目的地链接在一起。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The fragment lifecycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段生命周期
- en: Static fragments and dual-pane layouts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态片段和双面板布局
- en: Dynamic fragments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态片段
- en: Jetpack Navigation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack 导航
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/KmdBZ](https://packt.link/KmdBZ)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在 GitHub 上找到，网址为 [https://packt.link/KmdBZ](https://packt.link/KmdBZ)
- en: The fragment lifecycle
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段生命周期
- en: A fragment is a component with its own lifecycle. Understanding the fragment
    lifecycle is critical as it provides callbacks at certain stages of fragment creation,
    the running state, and destruction that configure the initialization, display,
    and cleanup. Fragments run in an activity, and a fragment’s lifecycle is bound
    to the activity’s lifecycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个片段是一个具有自己生命周期的组件。理解片段的生命周期至关重要，因为它在片段创建、运行状态和销毁的某些阶段提供回调，这些回调配置了初始化、显示和清理。片段在活动中运行，一个片段的生命周期绑定到活动生命周期。
- en: 'In many ways, the fragment lifecycle is very similar to the activity lifecycle,
    and at first glance, it appears that the former replicates the latter. There are
    as many callbacks that are the same or similar in the fragment lifecycle as there
    are in the activity lifecycle, such as `onCreate(savedInstanceState: Bundle?)`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在许多方面，片段的生命周期与活动生命周期非常相似，乍一看，似乎前者复制了后者。片段生命周期中与活动生命周期相同或类似的回调有很多，例如`onCreate(savedInstanceState:
    Bundle?)`。'
- en: The fragment lifecycle is tied to the activity lifecycle, so wherever fragments
    are used, the fragment callbacks are interleaved with the activity callbacks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 片段生命周期与活动生命周期相关联，因此无论在哪里使用片段，片段回调都会与活动回调交织在一起。
- en: The same steps are gone through to initialize the fragment and prepare for it
    to be displayed to the user before being available for the user to interact with.
    The same teardown steps that an activity goes through happen to the fragment as
    well when the app is backgrounded, hidden, and exited. Fragments, like activities,
    have to extend/derive from a parent `Fragment` class, and you can choose which
    callbacks to override depending on your use case. The lifecycle is displayed in
    the following diagram, followed by more detail about each function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化片段并准备在用户交互之前显示给用户之前，会执行相同的步骤。当应用处于后台、隐藏或退出时，片段也会经历与活动相同的拆解步骤。片段，就像活动一样，必须扩展/从父`Fragment`类派生，你可以根据你的用例选择要覆盖哪些回调。生命周期在以下图中显示，随后是每个函数的更多详细信息。
- en: '![Figure 3.1 – Fragment lifecycle](img/B19411_03_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.1 – Fragment生命周期](img/B19411_03_01.jpg)'
- en: Figure 3.1 – Fragment lifecycle
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.1 – Fragment生命周期
- en: Let’s now explore these callbacks, the order they appear in, and what they do.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来探索这些回调，它们出现的顺序，以及它们的作用。
- en: onAttach
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onAttach
- en: '`override fun onAttach(context: Context)`: This is the point where your fragment
    becomes linked to the activity it is used in. It allows you to reference the activity,
    although at this stage neither the fragment nor the activity has been fully created.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onAttach(context: Context)`：这是你的片段与其所使用的活动关联起来的时刻。它允许你引用活动，尽管在这个阶段，片段和活动都还没有完全创建。'
- en: onCreate
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onCreate
- en: '`override fun onCreate(savedInstanceState: Bundle?)`: This is where you do
    any initialization of your fragment. This is not where you set the layout of your
    fragment, as at this stage, there is no UI available to display and no `setContentView`
    available as there is in an activity. As is the same in the activity’s `onCreate()`
    function, you can use the `savedInstanceState` parameter to restore the state
    of the fragment when it is being re-created.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onCreate(savedInstanceState: Bundle?)`：这是你进行片段初始化的地方。这不是设置片段布局的地方，因为在这一阶段，没有可显示的UI，也没有像活动中的`setContentView`那样的设置。'
- en: onCreateView
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onCreateView
- en: '`override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
    savedInstanceState: Bundle?): View?`: Now, this is where you get to create the
    layout of your fragment. The most important thing to remember here is that instead
    of setting the layout (as is the case with an activity), the fragment will actually
    return the layout `View?` from this function.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
    savedInstanceState: Bundle?): View?`：现在，这是你创建片段布局的地方。在这里要记住的最重要的事情是，与活动不同，片段实际上会从这个函数返回布局`View?`。'
- en: The views you have in your layout are available to refer to here, but there
    are a few caveats. You need to create the layout before you can reference the
    views contained within it, which is why it’s preferred to do view manipulation
    in `onViewCreated`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的布局中看到的视图在这里都可以参考，但也有一些注意事项。你需要在引用其中包含的视图之前创建布局，这就是为什么建议在`onViewCreated`中进行视图操作。
- en: onViewCreated
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onViewCreated
- en: '`override fun onViewCreated(view View, savedInstanceState: Bundle?)`: This
    callback is the one in between your fragment being fully created and being visible
    to the user. It’s where you’ll typically set up your views and add any functionality
    and interactivity to these views. This might be adding an `OnClickListener` to
    a button and then calling a function when it’s clicked.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onViewCreated(view View, savedInstanceState: Bundle?)`：这个回调是在片段完全创建和向用户可见之间的一个回调。通常在这里设置视图，并添加任何功能性和交互性到这些视图。这可能包括给按钮添加`OnClickListener`，并在点击时调用一个函数。'
- en: onActivityCreated
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onActivityCreated
- en: '`override fun onActivityCreated(context: Context)`: This is called immediately
    after the activity’s `onCreate` has been run. Most of the initialization of the
    view state of the fragment will have been done, and this is the place to do the
    final setup if required.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onActivityCreated(context: Context)`: 这是在活动 `onCreate` 运行后立即调用的。片段的视图状态的大多数初始化都将完成，如果需要，这是进行最终设置的地方。'
- en: onStart
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onStart
- en: '`override fun onStart()`: This is called when the fragment is about to become
    visible to the user but is not yet available for the user to interact with.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onStart()`: 当片段即将对用户可见但用户尚不能与之交互时调用。'
- en: onResume
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onResume
- en: '`override fun onResume()`: At the end of this call, your fragment is available
    for the user to interact with. Normally, there is minimal setup or functionality
    defined in this callback, as when the app goes into the background and then comes
    back into the foreground, this callback will always be called.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onResume()`: 在这次调用结束时，你的片段可供用户交互。通常，在此回调中定义的设置或功能最少，因为当应用进入后台然后返回前台时，此回调总是会调用。'
- en: Therefore, you don’t want to have to needlessly repeat the setup of the fragment
    when this could be done with a callback that isn’t run when the fragment becomes
    visible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你不想在可以不运行当片段变得可见时不必要地重复设置片段。
- en: onPause
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onPause
- en: '`override fun onPause()`: Like its counterpart, `onPause()` in an activity
    signals that your app is going into the background or has been partially covered
    by something else on the screen. Use this to save any changes to the fragment’s
    state.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onPause()`: 与其对应的活动中的 `onPause()` 一样，`onPause()` 表示你的应用正在进入后台或被屏幕上的其他内容部分覆盖。使用此回调来保存片段状态的变化。'
- en: onStop
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onStop
- en: '`override fun onStop()`: The fragment is no longer visible at the end of this
    call and goes into the background.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onStop()`: 在这次调用结束时，该片段不再可见并进入后台。'
- en: onDestroyView
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onDestroyView
- en: '`override fun onDestroyView()`: This is usually called for doing a final cleanup
    before the fragment is destroyed. You should use this callback if it is necessary
    to clean up any resources. If the fragment is pushed to the back stack and retained,
    then it can also be called without destroying the fragment. On completion of this
    callback, the fragment’s layout view is removed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onDestroyView()`: 这通常是在片段被销毁之前进行最终清理时调用的。如果你需要清理任何资源，应使用此回调。如果片段被推送到后台栈并保留，则也可以不销毁片段而调用它。完成此回调后，片段的布局视图将被移除。'
- en: onDestroy
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onDestroy
- en: '`override fun onDestroy()`: The fragment is being destroyed. This can occur
    because the app is being killed or because this fragment is being replaced by
    another fragment.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onDestroy()`: 正在销毁片段。这可能是因为应用被杀死，或者是因为这个片段被另一个片段替换。'
- en: onDetach
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onDetach
- en: '`override fun onDetach()`: This is called when the fragment has been detached
    from its activity.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`override fun onDetach()`: 当片段与其活动分离时调用。'
- en: 'There are more fragment callbacks, but these are the ones you will use for
    the majority of cases. Typically, you’ll only use a subset of these callbacks:
    `onAttach()` to associate an activity with the fragment, `onCreate` to initialize
    the fragment, `onCreateView` to set the layout, and then `onViewCreated`/`onActivityCreated`
    to do further initialization, and perhaps `onPause()` to do some cleanup.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的片段回调，但这些都是你将在大多数情况下使用的。通常，你只会使用这些回调的一部分：`onAttach()` 将活动与片段关联，`onCreate`
    初始化片段，`onCreateView` 设置布局，然后 `onViewCreated`/`onActivityCreated` 进行进一步初始化，也许还有
    `onPause()` 进行一些清理。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Further details of these callbacks can be found in the official documentation
    at https://developer.android.com/guide/fragments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调的更多详细信息可以在官方文档中找到，网址为 https://developer.android.com/guide/fragments。
- en: Now that we’ve gone through some of the theory of the fragment lifecycle and
    how it is affected by the host activity’s lifecycle, let’s see those callbacks
    being run in action.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了片段生命周期的理论以及它是如何受宿主活动生命周期影响的，让我们看看这些回调在实际运行中的情况。
- en: Exercise 3.01 – adding a basic fragment and the fragment lifecycle
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.01 – 添加基本片段和片段生命周期
- en: 'In this exercise, we will create and add a basic fragment to an app. The aim
    of this exercise is to gain familiarity with how fragments are added to an activity
    and the layout they display. To do this, you will create a new blank fragment
    with a layout in Android Studio. You will then add the fragment to the activity
    and verify the fragment has been added by the display of the fragment layout.
    Perform the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建并添加一个基本片段到应用中。这个练习的目的是熟悉片段如何添加到活动中以及它们显示的布局。为此，你将在 Android Studio
    中创建一个新的空白片段及其布局。然后，你将添加片段到活动中，并通过片段布局的显示来验证片段已被添加。执行以下步骤：
- en: Create an application in Android Studio with an empty activity called `Fragment`
    `Lifecycle` .
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个名为 `Fragment Lifecycle` 的空活动应用。
- en: 'Once the application has been built, create a new fragment by going to `Fragment
    (Blank)` option. When you’ve selected this option, you will be presented with
    the screen shown in *Figure 3**.2*:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用构建完成，通过转到 `Fragment (Blank)` 选项创建一个新的片段。当你选择此选项时，你将看到 *图 3**.2* 中显示的屏幕：
- en: '![Figure 3.2 – Creating a new fragment](img/B19411_03_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 创建新片段](img/B19411_03_02.jpg)'
- en: Figure 3.2 – Creating a new fragment
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 创建新片段
- en: 'Rename the fragment `MainFragment` and the layout `fragment_main`. Then, press
    `Fragment` class will be created and opened. There are two functions that have
    been added: `onCreate`, which initializes the fragment, and `onCreateView` (displayed
    in the following code snippet), which inflates the layout file used for the fragment:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将片段重命名为 `MainFragment` 和布局重命名为 `fragment_main`。然后，按 `Fragment` 类将被创建并打开。已添加两个函数：`onCreate`，用于初始化片段，以及
    `onCreateView`（在以下代码片段中显示），用于填充用于片段的布局文件：
- en: '[PRE0]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you open up the `fragment_main.xml` layout file, you’ll see the following
    code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你打开 `fragment_main.xml` 布局文件时，你会看到以下代码：
- en: '[PRE1]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A simple layout has been added with a `TextView` and some example text using
    `@string/hello_blank_fragment`. This string resource has the text `hello blank
    fragment`. As `layout_width` and `layout_height` are specified as `match_parent`,
    `TextView` will occupy the whole of the screen. The text itself, however, will
    be added at the top left of the view with the default position.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加一个简单的布局，包含一个 `TextView` 和一些使用 `@string/hello_blank_fragment` 的示例文本。这个字符串资源中的文本是
    `hello blank fragment`。由于 `layout_width` 和 `layout_height` 被指定为 `match_parent`，`TextView`
    将占据整个屏幕。然而，文本本身将添加到视图的左上角，使用默认位置。
- en: 'Add the `android:gravity="center"` attribute and value to the `TextView` so
    that the text appears in the center of the screen:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `android:gravity="center"` 属性和值添加到 `TextView` 中，以便文本显示在屏幕中央：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run up the UI now, you’ll see the **Hello World!** display in *Figure
    3**.3*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行 UI，你将在 *图 3**.3* 中看到 **Hello World!** 显示：
- en: '![Figure 3.3 – Initial app layout display without a fragment added](img/B19411_03_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 添加片段前的初始应用布局显示](img/B19411_03_03.jpg)'
- en: Figure 3.3 – Initial app layout display without a fragment added
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 添加片段前的初始应用布局显示
- en: Well, you can see some `hello blank fragment` text you might have been expecting.
    The fragment and its layout do not automatically get added to an activity when
    you create it. This is a manual process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以看到一些你可能期望的 `hello blank fragment` 文本。当你创建片段时，片段及其布局不会自动添加到活动中。这是一个手动过程。
- en: 'Open the `activity_main.xml` file and replace the contents with the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件，并用以下内容替换：
- en: '[PRE3]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just as there are view declarations you can add to layouts in XML, there is
    also a `fragment` element. You’ve added the fragment to `ConstraintLayout` with
    constraints of `match_parent` for `layout_width` and `layout_height` so it will
    occupy the whole of the screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在 XML 布局中添加视图声明一样，也存在一个 `fragment` 元素。你已经将片段添加到 `ConstraintLayout` 中，`layout_width`
    和 `layout_height` 的约束为 `match_parent`，因此它将占据整个屏幕。
- en: 'The most important `xml` attribute to examine here is `android:name`. It’s
    here where you specify the fully qualified name of the package and the `Fragment`
    class that you are going to add to the layout with `com.example.fragmentlifecycle.MainFragment`.
    Now run the app, and you will see the output shown in *Figure 3**.4*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要检查的最重要的 `xml` 属性是 `android:name`。正是在这里，你指定了要添加到布局中的 `Fragment` 类的完整限定名和包名，使用
    `com.example.fragmentlifecycle.MainFragment`。现在运行应用，你将看到 *图 3**.4* 中显示的输出：
- en: '![Figure 3.4 – App layout display with a fragment added](img/B19411_03_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 添加片段后的应用布局显示](img/B19411_03_04.jpg)'
- en: Figure 3.4 – App layout display with a fragment added
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 添加片段后的应用布局显示
- en: This proves that your fragment with the text `Hello blank fragment` has been
    added to the activity and the layout you defined is being displayed. Next, you’ll
    examine the callback methods between the activity and the fragment and how this
    happened.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了您的文本为`Hello blank fragment`的片段已添加到活动中，并且您定义的布局正在显示。接下来，您将检查活动与片段之间的回调方法以及这是如何发生的。
- en: Open up the `MainFragment` class and add a `TAG` constant to the companion object
    with the value `"MainFragment"` to identify the class.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainFragment`类，并在伴随对象中添加一个`TAG`常量，其值为`"MainFragment"`以标识该类。
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, add/update the functions with appropriate log statements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加/更新函数并添加适当的日志语句。
- en: 'You will need to add the imports for the `Log` statement and `context` to the
    imports at the top of the class. The following code snippet is truncated. Follow
    the link shown to see the full code block you need to use:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`Log`语句和`context`的导入添加到类的顶部的导入中。以下代码片段被截断。请按照显示的链接查看您需要使用的完整代码块：
- en: MainFragment.kt
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MainFragment.kt
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can find the complete code for this step at [https://packt.link/XcOJ4](https://packt.link/XcOJ4).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/XcOJ4](https://packt.link/XcOJ4)找到此步骤的完整代码。
- en: You will need to add `Log.d(TAG, "onCreateView")` to the `onCreateView` callback
    and `Log.d(TAG, "onCreate")` to the `onCreate` callback that already exist, and
    then override the `onAttach` function, adding `Log.d(TAG, "onAttach")`, and `onViewCreated`,
    adding `Log.d(TAG, "onViewCreated")`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在`onCreateView`回调中添加`Log.d(TAG, "onCreateView")`，在已存在的`onCreate`回调中添加`Log.d(TAG,
    "onCreate")`，并重写`onAttach`函数，添加`Log.d(TAG, "onAttach")`，以及添加`onViewCreated`，添加`Log.d(TAG,
    "onViewCreated")`。
- en: Next, open the `MainActivity` class and add a companion object with a `TAG`
    constant with the value `"MainActivity"`. Then add the `Log` import to the top
    of the class and then the common `onStart` and `onResume` callback methods, as
    shown in the following code snippet.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`MainActivity`类，并添加一个带有`TAG`常量的伴随对象，其值为`"MainActivity"`。然后，将`Log`导入添加到类的顶部，然后添加常见的`onStart`和`onResume`回调方法，如下面的代码片段所示。
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’ll see that you also have to add the `onCreate` log statement, `Log.d`(`TAG,`
    `"onCreate"`), as this callback was already there when you added the activity
    to the project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到您还必须添加`onCreate`日志语句`Log.d(TAG, "onCreate")`，因为当您将活动添加到项目中时，这个回调已经存在。
- en: You learned in [*Chapter 2*](B19411_02.xhtml#_idTextAnchor103), *Building User
    Screen Flows*, how to view log statements, and you are going to open the **Logcat**
    window in Android Studio to examine the logs and the order they are called in
    when you run the app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[*第二章*](B19411_02.xhtml#_idTextAnchor103)，*构建用户屏幕流程*中学习了如何查看日志语句，您将打开Android
    Studio中的**Logcat**窗口来检查日志以及它们在运行应用时的调用顺序。
- en: In [*Chapter 2*](B19411_02.xhtml#_idTextAnchor103), *Building User Screen Flows*,
    you viewed logs from a single activity so you could see the order they were called
    in. Now you’ll examine the order in which the `MainActivity` and `MainFragment`
    callbacks happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19411_02.xhtml#_idTextAnchor103)，*构建用户屏幕流程*中，您查看了一个活动的日志，以便您可以看到它们被调用的顺序。现在，您将检查`MainActivity`和`MainFragment`回调发生的顺序。
- en: 'Open up the `MainActivity` and `MainFragment` start with `Main`, you can type
    `tag:Main` in the search box to filter the logs to only show statements with this
    text. Run the app, and you should see the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开以`Main`开头的`MainActivity`和`MainFragment`，您可以在搜索框中键入`tag:Main`以过滤日志，只显示包含此文本的语句。运行应用，您应该看到以下内容：
- en: '![Figure 3.5 – Logcat statements shown when starting the app](img/B19411_03_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 启动应用时显示的Logcat语句](img/B19411_03_05.jpg)'
- en: Figure 3.5 – Logcat statements shown when starting the app
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 启动应用时显示的Logcat语句
- en: What’s interesting here is that the first few callbacks are from the fragment.
    It is linked to the activity it has been placed in with the `onAttach` callback.
    The fragment is initialized, and its view is displayed in `onCreate` and `onCreateView`,
    before another callback, `onViewCreated`, is called, confirming that the fragment
    UI is ready to be displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，前几个回调来自片段。它通过`onAttach`回调与放置在其中的活动链接。片段初始化，并在调用另一个回调`onCreateView`之前显示其视图，以确认片段UI已准备好显示。
- en: This is before the activity’s `onCreate` method is called. This makes sense
    as the activity creates its UI based on what it contains. As this is a fragment
    that defines its own layout, the activity needs to know how to measure, lay out,
    and draw the fragment as it does in the `onCreate` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在调用活动的 `onCreate` 方法之前。这很有意义，因为活动根据其包含的内容创建其 UI。由于这是一个定义自己布局的片段，活动需要知道如何在
    `onCreate` 方法中测量、布局和绘制片段。
- en: Then, the fragment receives confirmation that this has been done with the `onActivityCreated`
    callback before both the fragment and activity start to display the UI in `onStart`,
    before preparing the user to interact with it after their respective `onResume`
    callbacks have finished.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，片段通过 `onActivityCreated` 回调确认已完成此操作，在片段和活动开始显示 UI 的 `onStart` 之前，在各自的 `onResume`
    回调完成后准备用户与之交互。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The interaction between the activity and fragment lifecycles detailed previously
    is for cases when static fragments, which are those defined in the layout of an
    activity, are created. For dynamic fragments, which can be added when the activity
    is already running, the interaction can differ.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前详细说明的活动和片段生命周期之间的交互是在静态片段被创建的情况下。对于动态片段，它们可以在活动运行时添加，交互可能会有所不同。
- en: So, now that the fragment and the containing activity are shown, what happens
    when the app is backgrounded or closed? The callbacks are still interleaved when
    the fragment and activity are paused, stopped, and finished.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在片段和包含的活动都已显示，当应用被置于后台或关闭时会发生什么？当片段和活动暂停、停止和完成时，回调仍然交织在一起。
- en: 'Add the following callbacks to the `MainFragment` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下回调添加到 `MainFragment` 类：
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, add these callbacks to `MainActivity`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将这些回调添加到 `MainActivity`：
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build the app, and once it is running, you’ll see the callbacks from before
    starting both the fragment and activity. You can use the dustbin icon at the top
    left of the `Logcat` window to clear the statements. Then, rotate the app and
    review the output log statements:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用，一旦运行，你将看到之前启动片段和活动的回调。你可以使用 `Logcat` 窗口左上角的垃圾桶图标来清除语句。然后，旋转应用并查看输出日志语句：
- en: '![Figure 3.6 – Logcat statements shown when closing the app](img/B19411_03_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 关闭应用时显示的 Logcat 语句](img/B19411_03_06.jpg)'
- en: Figure 3.6 – Logcat statements shown when closing the app
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 关闭应用时显示的 Logcat 语句
- en: The `onPause` and `onStop` statements are as you might expect in that the fragment
    gets notified of these callbacks first as it is contained within the activity.
    You can think of this as being inward to outward in that the child elements are
    notified before the containing parent, so the parent knows how to respond.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPause` 和 `onStop` 语句正如你所预期的那样，因为片段首先在活动内部被通知这些回调。你可以将其视为从内到外，即子元素在包含它们的父元素之前被通知，因此父元素知道如何响应。'
- en: The fragment is then torn down, removed from the activity, and then destroyed
    with the `onDestroyView`, `onDestroy`, and `onDetach` functions before the activity
    itself is destroyed after any final cleanup is done in `onDestroy`. It doesn’t
    make sense for the activity to finish until all the component parts that make
    up the activity are themselves removed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，片段被拆解，从活动中移除，并在活动本身被销毁之前，使用 `onDestroyView`、`onDestroy` 和 `onDetach` 函数被销毁，这是在
    `onDestroy` 中完成任何最终清理之后。在所有组成活动的组件部分被移除之前，活动完成是没有意义的。
- en: The full fragment lifecycle callbacks and how they relate to the activity callbacks
    are complicated in Android because which callbacks are applied in which situation
    can differ quite substantially. To view a more detailed overview, see the official
    documentation at https://developer.android.com/guide/fragments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，完整的片段生命周期回调以及它们如何与活动回调相关联是复杂的，因为哪些回调在哪种情况下应用可能会有很大的差异。要查看更详细的概述，请参阅官方文档：https://developer.android.com/guide/fragments。
- en: For the majority of situations, you will only use the preceding fragment callbacks.
    This example demonstrates both how self-contained fragments are in their creation,
    display, and destruction, and also their interdependence with the containing activity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，你将只使用前面的片段回调。此示例演示了自包含片段在其创建、显示和销毁过程中的独立性，以及它们与包含活动的相互依赖性。
- en: Now that we’ve gone through a basic example of adding a fragment to an activity
    and examining the interaction between the fragment and the activity, let’s see
    a more detailed example of how you add two fragments to an activity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一个基本示例了解了如何将片段添加到活动并检查片段与活动之间的交互，让我们看看如何更详细地示例如何将两个片段添加到活动。
- en: Exercise 3.02 – adding fragments statically to an activity
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.02 – 将片段静态添加到活动
- en: 'This exercise will demonstrate how to add two fragments to an activity with
    their own UI and separate functionality. You’ll create a simple counter class
    that increments and decrements a number and a color class that changes the color
    applied programmatically to some `Hello World` text. Perform the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何将两个片段添加到具有自己 UI 和独立功能的活动。你将创建一个简单的计数器类，该类可以增加和减少一个数字，以及一个颜色类，该类可以改变应用于某些
    `Hello World` 文本的程序化颜色。执行以下步骤：
- en: 'Create an application in Android Studio with an empty activity called `Fragment`
    `Intro`. Then, add the following strings required for the exercise in the `res`
    | `values` | `strings.xml` file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个名为 `Fragment` `Intro` 的空活动。然后，在 `res` | `values` | `strings.xml`
    文件中添加以下所需的字符串：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These strings are used in both the counter fragment as well as the color fragment,
    which you will create next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串在计数器片段以及你将要创建的颜色片段中都会使用。
- en: Add a new blank fragment by going to `CounterFragment` with the `fragment_counter`
    layout name.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前往具有 `fragment_counter` 布局名称的 `CounterFragment` 来添加一个新的空白片段。
- en: 'Now, make changes to the `fragment_counter.xml` file. The following code is
    truncated for space. Follow the link shown for the full code you need to use:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改 `fragment_counter.xml` 文件。以下代码因空间限制而截断。请遵循显示的链接以获取你需要使用的完整代码：
- en: fragment_counter.xml
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`fragment_counter.xml`'
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can find the complete code for this step at [https://packt.link/ca4EK](https://packt.link/ca4EK).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/ca4EK](https://packt.link/ca4EK) 找到此步骤的完整代码。
- en: We are using a simple `ConstraintLayout` file that has a `TextView` set up for
    the `@+id/counter_text` header and a `TextView` for the value of the counter,
    `android:id="@+id/counter_value"` (with a default of `@string/zero`), which will
    be changed by the `android:id="@+id/plus"` and `android:id="@+id/minus"` buttons.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的 `ConstraintLayout` 文件，其中设置了 `TextView` 作为 `@+id/counter_text` 标题，以及一个
    `TextView` 用于计数器的值，`android:id="@+id/counter_value"`（默认为 `@string/zero`），它将由 `android:id="@+id/plus"`
    和 `android:id="@+id/minus"` 按钮更改。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a simple example such as this, you are not going to set individual styles
    on the views with `style="@some_style"` notation, which would be best practice
    to avoid repeating these values on each view.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的例子，你不会使用 `style="@some_style"` 符号在视图中设置单个样式，这是最佳实践，以避免在每个视图中重复这些值。
- en: 'Now open `CounterFragment` and add a property to be the counter below the class
    header (it is a `var` so it is mutable and can be changed):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `CounterFragment` 并在类标题下方添加一个属性作为计数器（它是一个 `var`，因此它是可变的，可以更改）：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now open and add the following `onViewCreated` function. You will also need
    to add the following imports to the top of the class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开并添加以下 `onViewCreated` 函数。你还需要在类的顶部添加以下导入：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve added `onViewCreated`, which is the callback run when the layout has been
    applied to your fragment. The `onCreateView` callback, which creates the view,
    was run when the fragment itself was created.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `onViewCreated`，这是当布局已应用于你的片段时运行的回调。创建视图的 `onCreateView` 回调是在片段本身创建时运行的。
- en: The buttons you’ve specified in the preceding fragment have `OnClickListener`
    set up on them to increment and decrement the value of the `counter`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你在先前的片段中指定的按钮已经设置了 `OnClickListener` 来增加和减少 `counter` 的值。
- en: 'Firstly, within the plus button `OnClickListener`, you are incrementing the
    counter and setting this value on the view:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在加号按钮的 `OnClickListener` 中，你正在增加计数器并将此值设置在视图中：
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, within the minus button `OnClickListener`, it decrements the value by
    one but only if the value is greater than one, so no negative numbers are set:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在减号按钮的 `OnClickListener` 中，它会将值减一，但仅当值大于一时，因此不会设置任何负数：
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You have not added the fragment to the `MainActivity` layout. To do this, go
    into `activity_main.xml` and replace the contents with the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还没有将片段添加到 `MainActivity` 布局中。为此，进入 `activity_main.xml` 并用以下代码替换内容：
- en: '[PRE15]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You are going to change the layout from `ConstraintLayout` to `LinearLayout`
    for simplicity as you can easily add one fragment above the other when you come
    to the next stage. You specify the fragment to be used within the `fragment` XML
    element with the `name` attribute with the fully qualified package name used for
    the class: `android:name="com.example.fragmentintro.CounterFragment`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化布局，你将把布局从`ConstraintLayout`改为`LinearLayout`，因为在进入下一阶段时，你可以轻松地将一个片段添加到另一个片段之上。你通过`fragment`
    XML元素中的`name`属性指定要使用的片段，使用用于类的完全限定包名：`android:name="com.example.fragmentintro.CounterFragment"`。
- en: If you used a different package name when you created the app, then this must
    refer to the `CounterFragment` you created. The important thing to grasp here
    is that you have added a fragment to your main activity layout and the fragment
    also has a layout.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建应用程序时使用了不同的包名，那么这必须指的是你创建的`CounterFragment`。这里要掌握的重要一点是，你已经将一个片段添加到主活动布局中，并且片段也有一个布局。
- en: This shows some of the power of using fragments as you can encapsulate the functionality
    of one feature of your app, complete with a layout file and fragment class, and
    add it to multiple activities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用片段的一些强大功能，因为你可以将应用程序一个功能的全部功能封装起来，包括布局文件和片段类，并将其添加到多个活动中。
- en: 'Once you’ve done this, run the fragment in the virtual device as in *Figure
    3**.7*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，如*图3**.7*所示，在虚拟设备上运行片段：
- en: '![Figure 3.7 – App displaying the counter fragment](img/B19411_03_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 显示计数器片段的应用程序](img/B19411_03_07.jpg)'
- en: Figure 3.7 – App displaying the counter fragment
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 显示计数器片段的应用程序
- en: You have created a simple counter. The basic functionality works as expected,
    incrementing and decrementing a counter value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个简单的计数器。基本功能按预期工作，增加和减少计数器值。
- en: In the next step, you are going to add another fragment to the bottom half of
    the screen. This demonstrates the versatility of fragments. You can have encapsulated
    pieces of the UI with functionality and features in different areas of the screen.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，你将在屏幕下半部分添加另一个片段。这展示了片段的通用性。你可以在屏幕的不同区域封装具有功能和特性的UI片段。
- en: Now, create a new fragment using the earlier steps for creating the `CounterFragment`
    called `ColorFragment` with the `fragment_color` layout name.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用创建`CounterFragment`的早期步骤创建一个新的片段，命名为`ColorFragment`，布局名称为`fragment_color`。
- en: 'Next, open up the `fragment_color.xml` file that has been created and replace
    the contents with the code at the following link. The following snippet is truncated
    – see the link for the full code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开创建的`fragment_color.xml`文件，并用以下链接中的代码替换其内容。以下片段被截断 – 请参阅链接以获取完整代码：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can find the complete code for this step at [https://packt.link/GCYDR](https://packt.link/GCYDR).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/GCYDR](https://packt.link/GCYDR)找到此步骤的完整代码。
- en: The layout adds a `TextView` with three buttons. The `TextView` text and the
    text for all the buttons are set as string resources (`@string`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 布局添加了一个`TextView`和三个按钮。`TextView`的文本以及所有按钮的文本都设置为字符串资源（`@string`）。
- en: 'Next, go into the `activity_main.xml` file and add `ColorFragment` below `CounterFragment`
    inside `LinearLayout`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入`activity_main.xml`文件，在`LinearLayout`内部`CounterFragment`下方添加`ColorFragment`：
- en: '[PRE17]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run the app, you will see that `ColorFragment` is not visible, as
    in *Figure 3**.8*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到`ColorFragment`不可见，如*图3**.8*所示：
- en: '![Figure 3.8 – App shown without ColorFragment displayed](img/B19411_03_071.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 未显示ColorFragment的应用程序](img/B19411_03_071.jpg)'
- en: Figure 3.8 – App shown without ColorFragment displayed
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 未显示ColorFragment的应用程序
- en: You’ve included `ColorFragment` in the layout, but because `CounterFragment`
    has its width and height set to match its parent (`android:layout_width="match_parent
    android:layout_height="match_parent"`) and it is the first view in the layout,
    it takes up all the space.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在布局中包含了`ColorFragment`，但由于`CounterFragment`的宽度和高度设置为匹配其父元素（`android:layout_width="match_parent"
    android:layout_height="match_parent"`），并且它是布局中的第一个视图，因此它占据了所有空间。
- en: What you need is some way to specify the proportion of the height that each
    fragment should occupy. The `LinearLayout` orientation is set to vertical so the
    fragments will appear one on top of the other when `layout_height` is not set
    to `match_parent`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种方式来指定每个片段应占用的身高比例。`LinearLayout`的方向设置为垂直，因此当`layout_height`未设置为`match_parent`时，片段将一个接一个地显示。
- en: In order to define the proportion of this height, you need to add another attribute,
    `layout_weight`, to each fragment in the `activity_main.xml` layout file. When
    you use `layout_weight` to determine the proportional height the fragments should
    occupy, you set the `layout_height` value of the fragments to `0dp`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这个高度的比例，您需要在`activity_main.xml`布局文件中的每个片段中添加另一个属性，`layout_weight`。当您使用`layout_weight`来确定片段应占用的比例高度时，将片段的`layout_height`值设置为`0dp`。
- en: 'Update the `activity_main.xml` layout with the following changes, setting `layout_height`
    for both fragments to `0dp` and adding the `layout_weight` attributes with the
    following values:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下更改更新`activity_main.xml`布局，将两个片段的`layout_height`设置为`0dp`，并添加以下值的`layout_weight`属性：
- en: '[PRE18]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These changes make `CounterFragment` occupy twice the height of `ColorFragment`,
    as shown in *Figure 3**.9*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使`CounterFragment`的高度是`ColorFragment`的两倍，如图*图3*.9所示：
- en: '![Figure 3.9 – CounterFragment with twice the amount of vertical space allocated](img/B19411_03_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – CounterFragment分配了两倍垂直空间](img/B19411_03_08.jpg)'
- en: Figure 3.9 – CounterFragment with twice the amount of vertical space allocated
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – CounterFragment分配了两倍垂直空间
- en: You can experiment by changing the weight values to see the differences you
    can make to the display of the layout.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改权重值来实验，看看您可以对布局显示做出哪些改变。
- en: At this point, pressing the **RED**, **GREEN**, and **BLUE** color buttons will
    have no effect on the **Hello World** text. The button actions have not been specified.
    The next step involves adding interactivity to the buttons to make changes to
    the style of the **Hello** **World** text.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，按下**红色**、**绿色**和**蓝色**颜色按钮对**Hello World**文本没有任何影响。按钮动作尚未指定。下一步涉及向按钮添加交互性，以便更改**Hello**
    **World**文本的样式。
- en: 'Add the following `onViewCreated` function in `ColorFragment`, which overrides
    its parent to add behavior to the fragment after the layout view has been set
    up. You will also need to add the `TextView`, `Color`, and `Button` imports to
    change the color of the text:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ColorFragment`中添加以下`onViewCreated`函数，该函数覆盖其父类，在布局视图设置完毕后向片段添加行为。您还需要添加`TextView`、`Color`和`Button`导入以更改文本颜色：
- en: '[PRE19]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you are adding an `OnClickListener` to each button defined in the layout
    and setting the **Hello World** text to the desired color.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在为布局中定义的每个按钮添加`OnClickListener`，并将**Hello World**文本设置为所需的颜色。
- en: 'Run the app and press the **RED**, **GREEN**, and **BLUE** buttons. You should
    see a similar display to the one in *Figure 3**.10*:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并按下**红色**、**绿色**和**蓝色**按钮。你应该看到与*图3.10*类似的显示。10*：
- en: '![Figure 3.10 – ColorFragment setting text color to red, green, and blue](img/B19411_03_09.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – ColorFragment设置文本颜色为红色、绿色和蓝色](img/B19411_03_09.jpg)'
- en: Figure 3.10 – ColorFragment setting text color to red, green, and blue
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – ColorFragment设置文本颜色为红色、绿色和蓝色
- en: This exercise, although simple, has demonstrated some fundamental concepts of
    using fragments. The features of your app that the user can interact with can
    be developed independently and not rely on bundling two or more features into
    one layout and activity. This makes fragments reusable and means you can focus
    your attention when developing your app on adding a well-defined UI, logic, and
    features into a single fragment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个练习很简单，但它展示了使用片段的一些基本概念。用户可以与之交互的应用程序功能可以独立开发，而不必将两个或更多功能捆绑到一个布局和活动文件中。这使得片段可重用，意味着您可以在开发应用程序时将注意力集中在将定义良好的UI、逻辑和功能添加到单个片段中。
- en: Static fragments and dual-pane layouts
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态片段和双面板布局
- en: The previous exercise introduced you to static fragments, those that can be
    defined in the activity XML layout file. You can also create different layouts
    and resources for different screen sizes. This is used for deciding which resources
    to display depending on whether the device is a phone or a tablet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的练习向您介绍了静态片段，那些可以在活动XML布局文件中定义的片段。您还可以为不同屏幕尺寸创建不同的布局和资源。这用于根据设备是手机还是平板电脑来决定显示哪些资源。
- en: The space for laying out UI elements can increase substantially with a larger
    size tablet. Android allows specifying different resources depending on many different
    form factors. The qualifier frequently used to define a tablet in the `res` (resources)
    folder is `sw600dp`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的尺寸平板电脑上，布局UI元素的空间可以显著增加。Android允许根据许多不同的形态因素指定不同的资源。在`res`（资源）文件夹中，通常使用`sw600dp`来定义平板电脑。
- en: This states that if the shortest width (`sw`) of the device is over 600 dp,
    then use these resources. This qualifier is used for 7” tablets and larger. Tablets
    facilitate what is known as dual-pane layouts. A pane represents a self-contained
    part of the user interface. If the screen is large enough, then two panes (dual-pane
    layouts) can be supported. This also provides the opportunity for one pane to
    interact with another to update content.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示如果设备的最短宽度（`sw`）超过600 dp，则使用这些资源。此限定符用于7英寸平板电脑及以上。平板电脑促进了所谓的双面板布局。一个面板代表用户界面的一个自包含部分。如果屏幕足够大，则可以支持两个面板（双面板布局）。这也提供了机会，让一个面板与另一个面板交互以更新内容。
- en: Exercise 3.03 – dual-pane layouts with static fragments
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03 – 使用静态片段的双面板布局
- en: In this exercise, you are going to create a simple app that displays a list
    of star signs and specific information about each star sign. It will use different
    displays for phones and tablets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个简单的应用程序，显示星座列表以及每个星座的详细信息。它将为手机和平板电脑使用不同的显示方式。
- en: The phone will display a list and then open the selected list item’s content
    on another screen while the tablet will display the same list in one pane and
    open the list item’s content in another pane on the same screen in a dual-pane
    layout.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 手机将显示一个列表，然后在另一个屏幕上打开所选列表项的内容，而平板电脑将在一个面板中显示相同的列表，并在同一屏幕上的另一个面板中打开列表项的内容，形成一个双面板布局。
- en: 'In order to do this, you have to create another layout that will only be used
    for 7” tablets and above. Perform the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你必须创建另一个仅用于7英寸平板电脑及以上的布局。执行以下步骤：
- en: Firstly, create a new Android Studio project with an `Empty Activity` called
    `Dual` `Pane Layouts`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Android Studio项目，名为 `Dual` `Pane Layouts` 的 `Empty Activity`。
- en: 'Then, making sure the Android view is selected in the project view on the left-hand
    side, go to **File** | **New** | **Android Resource File** and fill in the following
    fields of the dialog (you need to select **Smallest Screen Width** in the dialog’s
    left-hand pane – once you have selected it, the option changes to **Screen Width**):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，确保在左侧的项目视图中选中Android视图，转到 **文件** | **新建** | **Android资源文件** 并填写以下对话框中的字段（你需要在对话框的左侧面板中选择
    **最小屏幕宽度** – 选中后，选项将更改为 **屏幕宽度**）：
- en: '![Figure 3.11 – Device Variations View](img/B19411_03_10.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 设备变体视图](img/B19411_03_10.jpg)'
- en: Figure 3.11 – Device Variations View
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 设备变体视图
- en: This creates a new folder in the `main` | `res` folder named `'layout-sw600dp'`
    with the `activity_main.xml` layout file added.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在 `main` | `res` 文件夹中创建了一个名为 `'layout-sw600dp'` 的新文件夹，并添加了 `activity_main.xml`
    布局文件。
- en: At the moment, it is a duplicate of the `activity_main.xml` file added when
    you created the app, but you will change it to customize the screen display for
    tablets.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它是当你创建应用程序时添加的 `activity_main.xml` 文件的副本，但你会将其更改为自定义平板电脑的屏幕显示。
- en: In order to demonstrate the use of dual-pane layouts, you are going to create
    a list of star signs so that, when a list item is selected, it will display some
    basic information about the star sign.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示双面板布局的使用，你将创建一个星座列表，以便当选择列表项时，它会显示有关星座的一些基本信息。
- en: Go to the top toolbar and select `ListFragment`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往顶部工具栏并选择 `ListFragment`。
- en: 'For this exercise, you need to update the `strings.xml` and `themes.xml` files,
    adding the following entries:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你需要更新 `strings.xml` 和 `themes.xml` 文件，添加以下条目：
- en: strings.xml
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: strings.xml
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: themes.xml
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: themes.xml
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the `main` | `res` | `layout` | `fragment_list.xml` file and replace the
    default contents with the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main` | `res` | `layout` | `fragment_list.xml` 文件，并用以下内容替换默认内容：
- en: '[PRE22]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will see that the first `xml` element is a `ScrollView`. A `ScrollView`
    is a `ViewGroup` that allows the contents to scroll, and as you will be adding
    12 star signs into the `LinearLayout` it contains, this is likely to occupy more
    vertical space than is available on the screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到第一个 `xml` 元素是一个 `ScrollView`。`ScrollView` 是一个允许内容滚动的 `ViewGroup`，由于你将在其中添加12个星座到
    `LinearLayout`，它可能比屏幕上可用的垂直空间更多。
- en: Adding `ScrollView` prevents the contents from being cut off vertically when
    there is no more room to display them and scrolls the layout. A `ScrollView` can
    only contain one child view. Here, it’s a `LinearLayout`, and as the contents
    will be displayed vertically, the orientation is set to vertical (`android:orientation="vertical"`).
    Below the first title `TextView`, you have added a divider `View` and a `TextView`
    for the first star sign, Aquarius.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`ScrollView`可以防止内容在没有更多空间显示时垂直截断，并滚动布局。`ScrollView`只能包含一个子视图。在这里，它是一个`LinearLayout`，由于内容将垂直显示，因此方向设置为垂直（`android:orientation="vertical"`）。在第一个标题`TextView`下方，你添加了一个分隔符`View`和一个用于第一个星座水瓶座的`TextView`。
- en: Add the other 11 star signs with the same format, adding the divider first and
    then the `TextView`. The name of the string resource and the `id` value should
    be the same for each `TextView`. The names of the star signs you will create a
    view from are specified in the `strings.xml` file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的格式添加其他11个星座，首先添加分隔符，然后添加`TextView`。每个`TextView`的字符串资源名称和`id`值应该相同。你将创建视图的星座名称在`strings.xml`文件中指定。
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The technique used to lay out a list is fine for an example, but in a real-world
    app, you would create a `RecyclerView` dedicated to displaying lists that can
    scroll, with the data bound to the list by an adapter. You will cover this in
    a later chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于布局列表的技术对于示例来说是好的，但在实际应用中，你会创建一个用于显示可滚动列表的`RecyclerView`，数据通过适配器绑定到列表。你将在后面的章节中介绍这一点。
- en: 'Next, create `StarSignListener` above the `MainActivity` class header and make
    `MainActivity` implement it by adding the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`MainActivity`类标题上方创建`StarSignListener`，并通过添加以下代码使`MainActivity`实现它：
- en: '[PRE23]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is how the fragments will communicate back to the activity when a user
    selects a star sign from `ListFragment` and logic will be added depending on whether
    a dual pane is available or not.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当用户从`ListFragment`中选择星座时，片段将如何将信息反馈给活动，逻辑将根据是否有双面板而添加。
- en: 'Once you’ve created the layout file, go into the `ListFragment` class and update
    it with the following contents, keeping `onCreateView()` in place. You can see
    in the fragment in the `onAttach()` callback you are stating that the activity
    implements the `StarSignListener` interface so it can be notified when the user
    clicks an item in the list. Add the import for the `Context` required for `onAttach`
    with the other imports at the top of the file:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了布局文件，进入`ListFragment`类，并使用以下内容更新它，同时保留`onCreateView()`。你可以在片段的`onAttach()`回调中看到，你声明活动实现了`StarSignListener`接口，以便在用户点击列表中的项目时通知活动。在文件顶部与其他导入一起添加所需的`Context`导入：
- en: '[PRE24]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The remaining callbacks are similar to what you have seen in the previous exercises.
    You create the fragment view with `onCreateView`. You set up the buttons with
    an `OnClickListener` in `onViewCreated` and then you handle clicks in `onClick`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的回调与你在之前的练习中看到的是相似的。你通过`onCreateView`创建片段视图。你在`onViewCreated`中使用`OnClickListener`设置按钮，然后处理点击事件在`onClick`中。
- en: The `listOf` syntax in `onViewCreated` is a way of creating a `readonly` list
    with the specified elements, which in this case are your star sign `TextView`
    instances. Then, in the following code, you loop over these `TextViews`, setting
    the `OnClickListener` for each of the individual `TextViews` by iterating over
    the `TextView` list with the `forEach` statement. The `it` syntax here refers
    to the element of the list that is being operated on, which will be one of the
    12 star sign `TextViews`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`onViewCreated`中的`listOf`语法是创建一个具有指定元素的只读列表的方法，在这种情况下是你的星座`TextView`实例。然后，在接下来的代码中，你通过使用`forEach`语句遍历这些`TextView`，通过迭代`TextView`列表为每个单独的`TextView`设置`OnClickListener`。这里的`it`语法指的是正在操作的列表元素，它将是12个星座`TextView`之一。'
- en: 'Finally, the `onClick` statement communicates back to the activity through
    `StarSignListener` when one of the star signs in the list has been clicked:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当列表中的某个星座被点击时，`onClick`语句通过`StarSignListener`将信息反馈给活动：
- en: '[PRE25]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You check whether the view specified as `v` is null with `?` and then only operate
    upon it with the `let` scope function if it isn’t, before passing the `id` value
    of the star sign to `Activity`/`StarSignListener`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`?`检查指定的视图`v`是否为null，然后只有在不为null的情况下，使用`let`作用域函数对其进行操作，在将星座的`id`值传递给`Activity`/`StarSignListener`之前。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Listeners are a common way to react to changes. By specifying a `Listener` interface,
    you are specifying a contract to be fulfilled. The implementing class is then
    notified of the results of the listener operation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器是响应更改的常见方式。通过指定 `Listener` 接口，您指定了一个需要满足的合同。实现类随后会通知监听器操作的结果。
- en: 'Next, create `DetailFragment`, which will display the star sign details. Create
    a blank fragment as you have done before and call it `DetailFragment`. Replace
    the `fragment_detail` layout file contents with the following XML file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `DetailFragment`，它将显示星座详情。创建一个空白片段，就像之前做的那样，命名为 `DetailFragment`。用以下
    XML 文件替换 `fragment_detail` 布局文件的内容：
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, you create a simple `LinearLayout`, which will display the star sign name,
    the symbol of the star sign, and the date range. You’ll set these values in `DetailFragment`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个简单的 `LinearLayout`，它将显示星座名称、星座符号和日期范围。您将在 `DetailFragment` 中设置这些值。
- en: 'Open `DetailFragment` and update the contents with the following text and also
    add `TextView` and `Toast` imports to the imports list:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DetailFragment` 并用以下文本更新内容，同时将 `TextView` 和 `Toast` 导入添加到导入列表中：
- en: '[PRE27]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `onCreateView` inflates the layout as normal. The `setStarSignData()` function
    is what populates the data from the passed-in `starSignId`. The `when` expression
    is used to determine the ID of the star sign and set the appropriate contents.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateView` 方法会像平常一样填充布局。`setStarSignData()` 函数用于从传入的 `starSignId` 中填充数据。`when`
    表达式用于确定星座的 ID 并设置适当的内容。'
- en: 'The `setStarSignData` function here formats text passed with the `getString`
    function – `getString(R.string.symbol,"Water Carrier")`, for example, passes the
    text `Water Carrier` into the `symbol` string, `<string name="symbol">Symbol:
    %s</string>`, and replaces `%s` with the passed-in value. You can see what other
    string formatting options there are in the official docs: https://developer.android.com/guide/topics/resources/string-resource.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`setStarSignData` 函数使用 `getString` 函数格式化文本 – 例如，`getString(R.string.symbol,"Water
    Carrier")` 将文本 `Water Carrier` 传递到 `symbol` 字符串，`<string name="symbol">Symbol:
    %s</string>`，并用传入的值替换 `%s`。您可以在官方文档中查看其他字符串格式化选项：https://developer.android.com/guide/topics/resources/string-resource。'
- en: 'Following the pattern introduced by `aquarius`, add the other 11 star signs
    below the `aquarius` block from the completed file here: [https://packt.link/C9sWZ](https://packt.link/C9sWZ).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 按照由 `aquarius` 引入的模式，将其他 11 个星座添加到完成文件中的 `aquarius` 块下方：[https://packt.link/C9sWZ](https://packt.link/C9sWZ)。
- en: Right now, you have added both `ListFragment` and `DetailFragment`. Currently,
    however, they have not been added to the activity layout and/or synced together,
    so selecting the star sign item in `ListFragment` will not load contents into
    `DetailFragment`. Let’s look at how you can change that.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您已经添加了 `ListFragment` 和 `DetailFragment`。然而，目前它们尚未添加到活动布局中，也没有同步，因此选择 `ListFragment`
    中的星座项不会将内容加载到 `DetailFragment` 中。让我们看看如何改变这一点。
- en: Firstly, you need to change the layout of `activity_main.xml` in both the `layout`
    folder and `layout-sw600dp`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要更改 `layout` 文件夹和 `layout-sw600dp` 中的 `activity_main.xml` 的布局。
- en: 'Open up `res` | `layout` | `activity_main.xml` if in the Project view. In the
    default Android view, open up `res` | `layout` | `activity_main.xml` and select
    the top `activity_main.xml` file without (`sw600dp`). Replace the contents with
    the following:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果处于项目视图，打开 `res` | `layout` | `activity_main.xml`。在默认的 Android 视图中，打开 `res`
    | `layout` | `activity_main.xml` 并选择顶部的 `activity_main.xml` 文件（无 `sw600dp`）。用以下内容替换内容：
- en: '[PRE28]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the app and select one of the star signs now, you will get a `NotImplementedError`
    as we need to replace the `TODO` item with this functionality.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序并选择其中一个星座，您将得到一个 `NotImplementedError`，因为我们需要用这个功能替换 `TODO` 项。
- en: 'Then, open up `res` | `layout-sw600dp` | `activity_main.xml` if in the Project
    view. In the default Android view, open up `res` | `layout` | `activity_main.xml
    (sw600dp)`. Replace the contents with the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果处于项目视图，打开 `res` | `layout-sw600dp` | `activity_main.xml`。在默认的 Android 视图中，打开
    `res` | `layout` | `activity_main.xml (sw600dp)`。用以下内容替换内容：
- en: '[PRE29]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You are adding `LinearLayout`, which will by default lay out its content horizontally.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在添加 `LinearLayout`，它将默认水平排列其内容。
- en: You add `ListFragment`, a divider, and then `DetailFragment` and assign the
    fragments appropriate IDs. Notice also that you are using the concept of weights
    to assign the space available for each fragment. When you do this, you specify
    `android:layout_width="0dp"`. `layout_weight` then sets the proportion of the
    width available by the weight measurements as `LinearLayout` is set to lay out
    the fragments horizontally.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加 `ListFragment`，一个分隔符，然后是 `DetailFragment` 并为片段分配适当的 ID。注意，你还在使用权重概念来分配每个片段可用的空间。当你这样做时，你指定
    `android:layout_width="0dp"`。`layout_weight` 然后设置由权重测量值确定的可用宽度比例，因为 `LinearLayout`
    被设置为水平排列片段。
- en: '`ListFragment` is specified as `android:layout_weight="1"` and `DetailFragment`
    is specified as `android:layout_weight="2"`, which tells the system to assign
    `DetailFragment` twice the width of `ListFragment`. In this case, where there
    are three views including the divider, which is a fixed dp width, this will result
    roughly in `ListFragment` occupying one-third of the width and `DetailFragment`
    occupying two-thirds.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListFragment` 被指定为 `android:layout_weight="1"`，而 `DetailFragment` 被指定为 `android:layout_weight="2"`，这告诉系统将
    `DetailFragment` 的宽度分配给 `ListFragment` 的两倍。在这种情况下，有三个视图包括一个固定 dp 宽度的分隔符，这将大致导致
    `ListFragment` 占据三分之一的宽度，而 `DetailFragment` 占据三分之二。'
- en: To see the app, create a new virtual device as shown in [*Chapter 1*](B19411_01.xhtml#_idTextAnchor025),
    *Creating Your First App*, and select **Category** | **Tablet** | **Nexus 7**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看应用，请创建一个新的虚拟设备，如[*第 1 章*](B19411_01.xhtml#_idTextAnchor025)中所示，*创建您的第一个应用*，并选择**类别**
    | **平板** | **Nexus 7**。
- en: 'This will create a 7” tablet. Then, launch the virtual device and run the app.
    This is the initial view you will see when you launch the tablet in portrait mode:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个 7 英寸的平板。然后，启动虚拟设备并运行应用。这是你在横屏模式下启动平板时将看到的初始视图：
- en: '![Figure 3.12 – Initial star sign app UI display](img/B19411_03_11.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 初始星座应用 UI 显示](img/B19411_03_11.jpg)'
- en: Figure 3.12 – Initial star sign app UI display
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 初始星座应用 UI 显示
- en: You can see that the list takes up about a third of the screen and the blank
    space two-thirds of the screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到列表占据了大约三分之一的屏幕，而空白空间占据了三分之二的屏幕。
- en: Click the ![](img/B19411_03_12.png) bottom rotate button on the virtual device
    to turn the virtual device 90 degrees clockwise.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击虚拟设备底部的 ![](img/B19411_03_12.png) 旋转按钮，将虚拟设备顺时针旋转 90 度。
- en: Once you’ve done that, the virtual device will go into landscape mode. It will
    not, however, change the screen orientation to landscape.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，虚拟设备将进入横屏模式。然而，它不会改变屏幕的方向为横屏。
- en: In order to do this, click on the ![3](img/B19411_03_13.png) rotate button in
    the bottom-left corner of the virtual device. You can also select the status bar
    at the top of the virtual device and hold and drag down to display the quick settings
    bar where you can turn on auto-rotation by selecting the rotate button. (You might
    have to swipe left/right within the quick settings bar to show the **Auto-rotate**
    option.)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，点击虚拟设备左下角的 ![3](img/B19411_03_13.png) 旋转按钮。你还可以选择虚拟设备顶部的状态栏，按住并向下拖动以显示快速设置栏，其中你可以通过选择旋转按钮来打开自动旋转。（你可能需要在快速设置栏内左右滑动以显示
    **自动旋转** 选项。）
- en: "![Figure 3.13 – Quick settings bar wi\uFEFFth Auto-rotate selected](img/B19411_03_14.jpg)"
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 已选择自动旋转的快速设置栏](img/B19411_03_14.jpg)'
- en: Figure 3.13 – Quick settings bar with Auto-rotate selected
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 已选择自动旋转的快速设置栏
- en: 'This will then change the tablet layout to landscape:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将随后将平板布局更改为横屏：
- en: '![Figure 3.14 – Initial star sign app UI display in landscape on a tablet](img/B19411_03_15.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 平板在横屏模式下初始星座应用 UI 显示](img/B19411_03_15.jpg)'
- en: Figure 3.14 – Initial star sign app UI display in landscape on a tablet
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 平板在横屏模式下初始星座应用 UI 显示
- en: 'The next thing to do is enable selecting a list item to load contents into
    the `Detail` pane of the screen. For that, we need to make changes in `MainActivity`.
    Update `MainActivity` with the following code to retrieve fragments by their ID
    in the pattern of retrieving views by their IDs (there will be some unused imports
    that will be required when the phone implementation is done):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是启用选择列表项以将内容加载到屏幕的 `Detail` 面板中。为此，我们需要在 `MainActivity` 中进行更改。使用以下代码更新 `MainActivity`
    以通过其 ID 模式检索片段（当完成手机实现时将需要一些未使用的导入）：
- en: '[PRE30]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fragments were introduced in API 11 in 2011 with a `FragmentManager` class to
    manage their interactions with activities. `SupportFragmentManager` was introduced
    to support using fragments in Android versions before API 11 in the Android Support
    Library. `SupportFragmentManager` has been further developed as the base for the
    Jetpack Fragment library, which adds improvements for managing fragments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是在 2011 年的 API 11 中引入的，当时有一个 `FragmentManager` 类来管理它们与活动的交互。`SupportFragmentManager`
    被引入以支持在 Android 支持库中在 API 11 之前的 Android 版本中使用片段。`SupportFragmentManager` 已进一步发展，成为
    Jetpack Fragment 库的基础，该库为片段管理添加了改进。
- en: This example and those that follow use `supportFragmentManager.findFragmentById`
    to retrieve fragments. You can also, however, retrieve fragments with `Tag` if
    you add a tag to the fragment XML by using `android:tag="MyFragmentTag"`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例及其后续示例使用 `supportFragmentManager.findFragmentById` 来检索片段。然而，你也可以通过在片段 XML
    中添加标签来使用 `Tag` 检索片段，方法是使用 `android:tag="MyFragmentTag"`。
- en: You can then retrieve the fragment by using `supportFragmentManager.find``FragmentByTag("MyFragmentTag")`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `supportFragmentManager.findFragmentByTag("MyFragmentTag")` 来检索片段。
- en: In order to retrieve data from the fragment, the activity needs to implement
    `StarSignListener`. This completes the contract set in the fragment to pass back
    details to the implementing class. The `onCreate` function sets the layout and
    then checks whether `DetailFragment` is in the activity’s inflated layout by checking
    whether the `R.id.star_sign_detail` ID exists.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从片段检索数据，活动需要实现 `StarSignListener`。这完成了片段中设置的合同，以便将详细信息传递回实现类。`onCreate` 函数设置布局，然后检查
    `DetailFragment` 是否在活动的填充布局中，通过检查 `R.id.star_sign_detail` ID 是否存在。
- en: From the Project view, the `res` | `layout` | `activity_main.xml` file only
    contains `ListFragment`, but you’ve added the code in the `res` | `layout-sw600dp`
    | `activity_main.xml` file to contain `DetailFragment` with `android:id="@+id/star_sign_detail"`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目视图来看，`res` | `layout` | `activity_main.xml` 文件只包含 `ListFragment`，但你已经在 `res`
    | `layout-sw600dp` | `activity_main.xml` 文件中添加了代码，以包含带有 `android:id="@+id/star_sign_detail"`
    的 `DetailFragment`。
- en: This will be used for the layout of the Nexus 7 tablet. In the default Android
    view, open up `res` | `layout` | `activity_main.xml` and select the top `activity_main.xml`
    file without (`sw600dp`) and then select `activity_main.xml` (`sw600dp`) to see
    these differences.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将被用于 Nexus 7 平板的布局。在默认的 Android 视图中，打开 `res` | `layout` | `activity_main.xml`
    并选择顶部的 `activity_main.xml` 文件（不带 `sw600dp`），然后选择 `activity_main.xml` (`sw600dp`)
    以查看这些差异。
- en: 'So now we can retrieve the star sign ID passed from `ListFragment` back to
    `MainActivity` by `StarSignListener` and pass it into `DetailFragment`. This is
    achieved by checking the `isDualPane` Boolean, and if that evaluates to `true`,
    you know you can pass the star sign ID to `DetailFragment` with this code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们可以通过 `StarSignListener` 将从 `ListFragment` 传递回 `MainActivity` 的星座 ID 检索出来，并将其传递到
    `DetailFragment`。这是通过检查 `isDualPane` 布尔值来实现的，如果评估结果为 `true`，则知道可以将星座 ID 通过此代码传递给
    `DetailFragment`：
- en: '[PRE31]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You cast the fragment from `id` to `DetailFragment` and call the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将片段从 `id` 强制转换为 `DetailFragment` 并调用以下代码：
- en: '[PRE32]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you’ve implemented this function in the fragment and are checking by the
    `id` value which contents to display, the UI is updated:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你在片段中实现了此函数并通过 `id` 值检查要显示的内容，因此 UI 被更新：
- en: '![Figure 3.15 – Star sign app dual-pane display in landscape on a tablet](img/B19411_03_16.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 星座应用在平板上横向双面板显示](img/B19411_03_16.jpg)'
- en: Figure 3.15 – Star sign app dual-pane display in landscape on a tablet
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 星座应用在平板上横向双面板显示
- en: Now clicking on a list item works as intended, showing the dual-pane layout
    with the contents set correctly.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击列表项将按预期工作，显示双面板布局，内容设置正确。
- en: 'If the device is not a tablet, however, even when a list item is clicked, nothing
    will happen as there is not an `else` branch condition to do anything if the device
    is not a tablet, which is defined by the `isDualPane` Boolean. The display will
    be as in *Figure 3**.16* and won’t change when items are selected:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果设备不是平板，即使点击列表项，也不会发生任何事，因为没有为非平板设备定义的 `else` 分支条件来执行任何操作，这由 `isDualPane`
    布尔值定义。显示将如 *图 3**.16* 所示，并且在选择项目时不会改变：
- en: '![Figure 3.16 – Initial star sign app UI display on a phone](img/B19411_03_17.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 在手机上显示的初始星座应用 UI](img/B19411_03_17.jpg)'
- en: Figure 3.16 – Initial star sign app UI display on a phone
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 在手机上显示的初始星座应用 UI
- en: 'You are going to display the star sign detail in another activity. Create a
    new `DetailActivity` by going to `activity_detail.xml` with this layout:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将要在另一个活动中显示星座详情。通过访问`activity_detail.xml`并使用此布局创建一个新的`DetailActivity`：
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This adds `DetailFragment` as the only fragment in the layout. Now, update
    the `onCreate` function of `DetailActivity` with the following contents:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将`DetailFragment`添加为布局中的唯一片段。现在，更新`DetailActivity`的`onCreate`函数，内容如下：
- en: '[PRE34]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The star sign `id` is expected to be passed from another activity to this one
    by setting a key in the intent’s extras (also called a bundle). We covered intents
    in [*Chapter 2*](B19411_02.xhtml#_idTextAnchor103), *Building User Screen Flows*,
    but as a reminder, they enable communication between different components and
    also can send data.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星座`id`预期将通过在intent的extra（也称为bundle）中设置一个键从另一个活动传递到这个活动。我们在[*第2章*](B19411_02.xhtml#_idTextAnchor103)中介绍了intent，*构建用户屏幕流程*，但为了提醒，它们可以在不同组件之间进行通信，并且可以发送数据。
- en: In this case, the intent that opened this activity has set a star sign ID. It
    will use `id` to set the star sign ID in `DetailFragment`. Next, you need to implement
    the `else` branch of the `isDualPane` check to launch `DetailActivity`, passing
    through the star sign ID in the intent.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，打开此活动的intent已经设置了一个星座ID。它将使用`id`在`DetailFragment`中设置星座ID。接下来，你需要实现`isDualPane`检查的`else`分支以启动`DetailActivity`，并通过intent传递星座ID。
- en: 'Update `MainActivity` as follows to do this:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`MainActivity`以实现此功能：
- en: '[PRE35]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you click on one of the star sign names on a phone display, it shows the
    contents in `DetailActivity` occupying the whole of the screen without the list:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在手机显示上点击一个星座名称，它就会显示在`DetailActivity`中的内容，占据整个屏幕而没有列表：
- en: '![Figure 3.17 – Single-pane star sign detail screen on a phone](img/B19411_03_18.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 手机上的单面板星座详情屏幕](img/B19411_03_18.jpg)'
- en: Figure 3.17 – Single-pane star sign detail screen on a phone
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 手机上的单面板星座详情屏幕
- en: This exercise has demonstrated the flexibility of fragments. They can encapsulate
    the logic and display different features of your app, which can be integrated
    in different ways depending on the form factor of the device. They can be arranged
    onscreen in a variety of ways, which are constrained by the layout they are included
    in; therefore, they can feature as a part of dual-pane layouts or all or part
    of a single-pane layout.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了片段的灵活性。它们可以封装逻辑并展示应用的不同功能，根据设备的形态可以以不同的方式集成。它们可以在屏幕上以多种方式排列，这些排列受到它们包含的布局的限制；因此，它们可以作为双面板布局的一部分，或者作为单面板布局的全部或部分。
- en: This exercise showed fragments being laid out side by side on a tablet, but
    they can also be laid out on top of each other and in a variety of other ways.
    The next topic illustrates how the configuration of fragments used in your app
    doesn’t have to be specified statically in XML but can also be done dynamically.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了片段在平板电脑上并排布局，但它们也可以重叠布局，以及以其他多种方式布局。下一个主题将说明在应用中使用的片段配置不必在XML中静态指定，也可以动态完成。
- en: Dynamic fragments
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态片段
- en: So far, you’ve only seen fragments added in XML at compile time. Although this
    can satisfy many use cases, you might want to add fragments dynamically at runtime
    to respond to the user’s actions. This can be achieved by adding `ViewGroup` as
    a container for fragments and then adding, replacing, and removing fragments from
    `ViewGroup`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到了在编译时在XML中添加的片段。虽然这可以满足许多用例，但你可能希望在运行时动态添加片段以响应用户的操作。这可以通过添加`ViewGroup`作为片段的容器，然后从`ViewGroup`中添加、替换和删除片段来实现。
- en: This technique is more flexible as the fragments can be active until they are
    no longer needed and then removed, instead of always being inflated in XML layouts
    as you have seen with static fragments. If three or four more fragments are required
    to fulfill separate user journeys in one activity, then the preferred option is
    to react to the user’s interaction in the UI by adding/replacing fragments dynamically.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术更灵活，因为片段可以在不再需要时被移除，而不是像静态片段那样始终在XML布局中填充。如果在一个活动中需要三个或四个更多片段来满足不同的用户旅程，那么首选的选项是通过动态添加/替换片段来响应用户的UI交互。
- en: Using static fragments works better when the user’s interaction with the UI
    is fixed at compile time and you know in advance how many fragments you need.
    For example, this would be the case for selecting items from a list to display
    the contents.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户的UI交互在编译时固定，并且你事先知道需要多少个片段时，使用静态片段效果更好。例如，从列表中选择项目以显示内容的情况就是这样。
- en: Exercise 3.04 – adding fragments dynamically to an activity
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.04 – 向活动中动态添加片段
- en: 'In this exercise, we will build the same star sign app as before but will demonstrate
    how the list and detail fragments can be added to screen layouts dynamically and
    not directly within an XML layout. You can also pass arguments into a fragment.
    For simplicity, you are going to create the same configuration for both phones
    and tablets. Perform the following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建与之前相同的星座应用，但将展示如何动态地将列表和详情片段添加到屏幕布局中，而不是直接在XML布局中添加。你还可以向片段传递参数。为了简化，你将为手机和平板创建相同的配置。执行以下步骤：
- en: Create a new project with an `Empty Activity` called `Dynamic Fragments`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Dynamic Fragments` 的 `Empty Activity` 的新项目。
- en: 'Once you have done that, add the following dependency – you need to use `FragmentContainerView`,
    an optimized ViewGroup for handling fragment transactions with `app/build.gradle`
    within the `dependences{ }` block:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，添加以下依赖项 - 你需要使用 `FragmentContainerView`，这是一个用于处理片段事务的优化的 `ViewGroup`，在 `app/build.gradle`
    中的 `dependencies{ }` 块中使用：
- en: '[PRE36]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Copy the contents of the following XML resource files from *Exercise 3.03*
    – *dual-pane layouts with static fragments*, and add them to the corresponding
    files in this exercise: `strings.xml` (changing the `app_name` string from `Dual
    Pane Layouts` to `Dynamic Fragments`), `fragment_detail.xml`, and `fragment_list.xml`.
    All of these files exist in the project created in the previous exercise and you
    simply add the contents to this new project.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *Exercise 3.03* – *使用静态片段的双面板布局* 中复制以下XML资源文件的内容，并将它们添加到本练习中相应的文件中：`strings.xml`（将
    `app_name` 字符串从 `Dual Pane Layouts` 更改为 `Dynamic Fragments`），`fragment_detail.xml`
    和 `fragment_list.xml`。所有这些文件都存在于上一个练习中创建的项目中，你只需将这些内容添加到这个新项目中。
- en: Then, copy `DetailFragment` and `ListFragment` to the new project. You will
    have to change the package name from `package com.example.dualpanelayouts` to
    `package com.example.dynamicfragments` in these two files. Finally, add the styles
    defined below the base application style in `themes.xml` from the last exercise
    to `themes.xml` in this project.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `DetailFragment` 和 `ListFragment` 复制到新项目中。你将不得不在这两个文件中将包名从 `package com.example.dualpanelayouts`
    更改为 `package com.example.dynamicfragments`。最后，将上一个练习中在基本应用程序样式下方定义的样式添加到本项目的 `themes.xml`
    中。
- en: 'You now have the same fragments set up as in the previous exercise. Now, open
    the `activity_main.xml` layout and replace the contents with this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在已经设置了与上一个练习相同的片段。现在，打开 `activity_main.xml` 布局文件，并用以下内容替换其内容：
- en: '[PRE37]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is the `FragmentContainerView` you will add the fragments to. You’ll notice
    that there are no fragments added in the layout XML as these will be added dynamically.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将添加片段的 `FragmentContainerView`。你会注意到在布局XML中没有添加任何片段，因为这些片段将动态添加。
- en: 'Go into `MainActivity` and replace the content with the following:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `MainActivity` 并用以下内容替换其内容：
- en: '[PRE38]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You are getting a reference to the `FragmentContainerView` specified in `activity_main.xml`,
    creating a new `ListFragment`, and then adding this fragment to the `FragmentContainerView`
    with the ID of the `fragment_container`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在获取 `activity_main.xml` 中指定的 `FragmentContainerView` 的引用，创建一个新的 `ListFragment`，然后将这个片段添加到具有
    `fragment_container` ID 的 `FragmentContainerView` 中。
- en: The fragment transaction specified is `add` as you are adding a fragment to
    `FrameLayout` for the first time. You call `commit()` to execute the transaction
    immediately. There is a null check with `savedInstanceState` to only add this
    `ListFragment` if there is no state to restore, which there would be if a fragment
    had been previously added.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的片段事务是 `add`，因为你第一次将片段添加到 `FrameLayout` 中。你调用 `commit()` 来立即执行事务。使用 `savedInstanceState`
    进行空检查，以确保在没有要恢复的状态时才添加这个 `ListFragment`，如果有片段之前被添加，就会存在这种状态。
- en: 'Next, make `MainActivity` implement `StarSignListener` by adding the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让 `MainActivity` 通过添加以下代码来实现 `StarSignListener`：
- en: '[PRE39]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now if you run the app, you will see the star sign list being displayed on mobile
    and tablet.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果你运行应用，你将看到星座列表在手机和平板上显示。
- en: The problem you now come to is how to pass the star sign ID to `DetailFragment`
    now that it’s not in an XML layout.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在面临的问题是，由于它不在 XML 布局中，如何将星座 ID 传递给 `DetailFragment`。
- en: One option would be to use the same technique as in the last example by creating
    a new activity and passing the star sign ID in an intent, but you shouldn’t have
    to create a new activity to add a new fragment; otherwise, you might as well dispense
    with fragments and just use activities.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用与上一个示例相同的技巧，通过创建一个新的活动并将星座 ID 通过 intent 传递，但你不需要创建一个新的活动来添加一个新的片段；否则，你不如放弃片段，直接使用活动。
- en: You are going to replace `ListFragment` in `FragmentContainerView` with `DetailFragment`,
    but first, you need to find a way to pass the star sign ID into `DetailFragment`.
    You do this by passing this `id` value as an argument when you create the fragment.
    The standard way to do this is by using a `Factory` method in a fragment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你将用 `DetailFragment` 替换 `FragmentContainerView` 中的 `ListFragment`，但首先，你需要找到一种方法将星座
    ID 传递到 `DetailFragment`。你这样做是通过在创建片段时将此 `id` 值作为参数传递。这样做的一种标准方式是在片段中使用一个 `Factory`
    方法。
- en: 'Add the following code to the bottom of `DetailFragment` (a sample `factory`
    method will have been added when you created the fragment using the template/wizard,
    which you can update here):'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `DetailFragment` 的底部（当你使用模板/向导创建片段时，将添加一个示例 `factory` 方法，你可以在这里更新它）：
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A `companion` object allows you to add Java’s equivalent of static members into
    your class. Here, you are instantiating a new `DetailFragment` and setting arguments
    passed into the fragment. The arguments of the fragment are stored in a `Bundle()`,
    so in the same way as an activity’s intent extras (which is also a bundle), you
    add the values as key pairs. In this case, you are adding the `STAR_SIGN_ID` key
    with the value `starSignId`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `companion` 对象允许你在你的类中添加 Java 的静态成员。在这里，你实例化一个新的 `DetailFragment` 并设置传递给片段的参数。片段的参数存储在一个
    `Bundle()` 中，所以与活动 intent 的额外内容（也是一个 bundle）一样，你添加值作为键值对。在这种情况下，你添加了 `STAR_SIGN_ID`
    键和值 `starSignId`。
- en: 'The next thing to do is override one of the `DetailFragment` lifecycle functions
    to use the passed-in argument:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是重写 `DetailFragment` 的生命周期函数之一，以使用传入的参数：
- en: '[PRE41]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You do this in `onViewCreated` as at this stage, the layout of the fragment
    has been set up and you can access the view hierarchy (whereas if you accessed
    the arguments in `onCreate`, the fragment layout would not be available as this
    is done in `onCreateView`):'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你这样做是在 `onViewCreated` 中，因为在这个阶段，片段的布局已经设置，你可以访问视图层次结构（而如果在 `onCreate` 中访问参数，由于这是在
    `onCreateView` 中完成的，因此片段布局将不可用）：
- en: '[PRE42]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This line gets the star sign ID from the passed-in fragment arguments, setting
    a default of `0` if the `STAR_SIGN_ID` key cannot be found. Then, you call `setStarSignData(starSignId)`
    to display the star sign contents.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码从传入的片段参数中获取星座 ID，如果找不到 `STAR_SIGN_ID` 键，则设置默认值 `0`。然后，你调用 `setStarSignData(starSignId)`
    来显示星座内容。
- en: 'Now you just need to implement the `StarSignListener` interface in `MainActivity`
    to retrieve the star sign ID from `ListFragment`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你只需要在 `MainActivity` 中实现 `StarSignListener` 接口，以从 `ListFragment` 中检索星座 ID：
- en: '[PRE43]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You create `DetailFragment` as explained earlier with the `factory` method
    passing in the star sign ID: `DetailFragment.newInstance(starSignId)`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用前面解释的方法创建 `DetailFragment`，通过 `factory` 方法传入星座 ID：`DetailFragment.newInstance(starSignId)`。
- en: At this stage, `ListFragment` is still the fragment that has been added to the
    activity `FrameLayout`. You need to replace it with `DetailFragment`, which requires
    another transaction. This time, however, you use the `replace` function to replace
    `ListFragment` with `DetailFragment`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`ListFragment` 仍然是已经添加到活动 `FrameLayout` 中的片段。你需要用 `DetailFragment` 替换它，这需要另一个事务。然而，这次你使用
    `replace` 函数用 `DetailFragment` 替换 `ListFragment`。
- en: Before you commit the transaction, you call `.addToBackStack(null)` so the app
    does not exit when the back button is pressed but instead goes back to `ListFragment`
    by popping `DetailFragment` off the fragment stack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交事务之前，你调用 `.addToBackStack(null)`，这样当按下返回按钮时，应用不会退出，而是通过弹出 `DetailFragment`
    从片段堆栈返回到 `ListFragment`。
- en: This exercise has introduced adding fragments dynamically to your activity.
    The next topic introduces a more well-defined structure for creating fragments,
    called a navigation graph.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习介绍了动态将片段添加到你的活动。下一个主题将介绍创建片段的更明确的结构，称为导航图。
- en: Jetpack Navigation
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack 导航
- en: Using dynamic and static fragments, although very flexible, introduces a lot
    of boilerplate code into your app and can become quite complicated when user journeys
    require adding, removing, and replacing multiple fragments while managing the
    back stack.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态和静态片段，虽然非常灵活，但会在您的应用中引入大量样板代码，并且当用户旅程需要添加、删除和替换多个片段同时管理回退栈时，可能会变得相当复杂。
- en: Google introduced Jetpack components, as you learned in [*Chapter 1*](B19411_01.xhtml#_idTextAnchor025),
    *Creating Your First App*, to use established best practices in your code. The
    `Navigation` component within the suite of Jetpack components enables you to reduce
    boilerplate code and simplify navigation within your app. We are going to use
    it now to update the Star Sign app.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 [*第 1 章*](B19411_01.xhtml#_idTextAnchor025) 中所学的，Google 引入了 Jetpack 组件，以在您的代码中使用既定的最佳实践。Jetpack
    组件套件中的 `Navigation` 组件使您能够减少样板代码并简化应用内的导航。我们现在将使用它来更新星象应用。
- en: Exercise 3.05 – adding a Jetpack navigation graph
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.05 – 添加 Jetpack 导航图
- en: In this exercise, we are going to reuse most of the classes and resources from
    the last exercise. We will first create an empty project and copy the resources.
    Next, we will add the dependencies and create a navigation graph.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重用上一个练习中的大多数类和资源。我们首先创建一个空项目并复制资源。接下来，我们将添加依赖项并创建一个导航图。
- en: 'Using a step-by-step approach, we will configure the navigation graph and add
    destinations to navigate between fragments. Perform the following steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逐步方法，我们将配置导航图并添加目标以在片段之间导航。执行以下步骤：
- en: Create a new project with an `Empty Activity` called `Jetpack Fragments`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Jetpack Fragments` 的 `Empty Activity` 的新项目。
- en: Copy `strings.xml`, `fragment_detail.xml`, `fragment_list.xml`, `DetailFragment`,
    and `ListFragment` from the previous exercise, remembering to change the `app_name`
    string in `strings.xml` and the package name for the fragment classes. You will
    need to change the following line for the resources from `import com.example.dynamicfragments.R`
    to `import com.example.jetpacknavigation.R`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个练习中复制 `strings.xml`、`fragment_detail.xml`、`fragment_list.xml`、`DetailFragment`
    和 `ListFragment`，记得在 `strings.xml` 中更改 `app_name` 字符串以及片段类的包名。您需要将以下行从 `import
    com.example.dynamicfragments.R` 更改为 `import com.example.jetpacknavigation.R`。
- en: 'Finally, add the styles defined below the base application style in `themes.xml`
    from the last exercise to `themes.xml` in this project. You will also need to
    add the following above the class header in `MainActivity`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将上一个练习中在 `themes.xml` 中定义的样式添加到本项目的 `themes.xml` 中。您还需要在 `MainActivity` 的类头上方添加以下内容：
- en: '[PRE44]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once you have done that, add the following dependencies – you need to use the
    `Navigation` component in `app/build.gradle` within the `dependences{ }` block:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，添加以下依赖项 - 您需要在 `app/build.gradle` 文件中的 `dependencies{ }` 块中使用 `Navigation`
    组件：
- en: '[PRE45]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It will prompt you to `app` module is selected and go to **File** | **New**
    | **Android Resource**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将提示您选择 `app` 模块并转到 **文件** | **新建** | **Android 资源**。
- en: 'Once this dialog appears, change `nav_graph`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦出现此对话框，更改 `nav_graph`：
- en: '![Figure 3.18 – New Resource File dialog](img/B19411_03_19.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 新资源文件对话框](img/B19411_03_19.jpg)'
- en: Figure 3.18 – New Resource File dialog
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 新资源文件对话框
- en: Click `res` folder called `Navigation` with `nav_graph.xml` inside it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 点击名为 `Navigation` 的 `res` 文件夹，其中包含 `nav_graph.xml` 文件。
- en: 'Update the `nav_graph.xml` navigation file with the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `nav_graph.xml` 导航文件：
- en: '[PRE46]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding file is a working navigation graph. Although the syntax is unfamiliar,
    it is quite straightforward to understand:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件是一个有效的导航图。尽管语法不熟悉，但它相当直观易懂：
- en: '`ListFragment` and `DetailFragment` are present as they would be if you were
    adding static fragments.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ListFragment` 和 `DetailFragment` 的存在方式与您添加静态片段时相同。'
- en: There is an `id` value to identify the graph at the root `<navigation>` element
    and IDs on the fragments themselves. Navigation graphs introduce the concept of
    destinations, so at the root `navigation` level, there is `app:startDestination`,
    which has the ID of `starSignList`, which is `ListFragment`, then within the `<fragment>`
    tag, there is the `<``action>` element.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根 `<navigation>` 元素中有一个 `id` 值用于识别图，以及在片段本身上的 ID。导航图引入了目标的概念，因此在根 `navigation`
    级别，有 `app:startDestination`，其 ID 为 `starSignList`，对应 `ListFragment`，然后在 `<fragment>`
    标签内，有 `<action>` 元素。
- en: Actions are what link the destinations within the navigation graph together.
    The destination action here has an ID, so you can refer to it in code, and has
    a destination, which, when used, it will direct to.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作是将导航图内的目的地连接起来的东西。这里的动作有一个 ID，因此您可以在代码中引用它，并且有一个目的地，当使用时，它将引导到。
- en: Now that you’ve added the navigation graph, you need to use it to link the activity
    and fragments together.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了导航图，您需要使用它来将活动和片段连接起来。
- en: 'Open up `activity_main.xml` and replace `TextView` inside `ConstraintLayout`
    with the following `FragmentContainerView`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将 `ConstraintLayout` 内的 `TextView` 替换为以下 `FragmentContainerView`：
- en: '[PRE47]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`FragmentContainerView` has been added with the name `android:name="androidx.navigation.fragment.NavHostFragment"`.
    It will host the fragments from the `app:navGraph="@navigation/nav_graph"` that
    you have just created.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentContainerView` 已添加，名称为 `android:name="androidx.navigation.fragment.NavHostFragment"`。它将托管您刚刚创建的
    `app:navGraph="@navigation/nav_graph"` 中的片段。'
- en: '`app:defaultNavHost` states that it is the app’s default navigation graph.
    It also controls the back navigation when one fragment replaces another. You can
    have more than one `NavHostFragment` in a layout for controlling two or more areas
    of the screen that manage their own fragments, which you might use for dual-pane
    layouts in tablets, but there can only be one default.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`app:defaultNavHost` 表示它是应用程序的默认导航图。它还控制当一个片段替换另一个片段时的后退导航。您可以在布局中拥有多个 `NavHostFragment`
    来控制两个或更多屏幕区域，这些区域管理自己的片段，您可能用于平板电脑的双面板布局，但只能有一个默认的。'
- en: There are a few changes you need to make to make the app work as expected in
    the `ListFragment`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要对应用程序进行一些更改，以便在 `ListFragment` 中按预期工作。
- en: 'Firstly, remove the class file header and references to `StarSignListener`.
    So, the following will be replaced:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，移除类文件头和 `StarSignListener` 的引用。因此，以下内容将被替换：
- en: '[PRE48]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And it will be replaced with the following line of code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被以下代码行替换：
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, at the bottom of the class, remove the `onClick` overridden method as
    you are not implementing `View.OnClicklistener`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在类的底部，移除 `onClick` 覆盖方法，因为您没有实现 `View.OnClicklistener`：
- en: '[PRE50]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `onViewCreated` method, replace the `forEach` statement that loops over
    the star sign views:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onViewCreated` 方法中，替换遍历星象视图的 `forEach` 语句：
- en: '[PRE51]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Replace it with the following code and add the `Navigation` import to the imports
    list:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它，并将 `Navigation` 导入添加到导入列表中：
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, you are creating a bundle to pass `STAR_SIGN_ID` with the view ID of the
    selected star sign to `NavigationClickListener`. It uses the ID of the `R.id.star_sign_id_action`
    action to load `DetailFragment` when clicked as that is the destination for the
    action. `DetailFragment` does not need any changes and uses the passed-in `fragment`
    argument to load the details of the selected star sign ID.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在创建一个包来传递 `STAR_SIGN_ID`，带有所选星象视图的视图 ID 到 `NavigationClickListener`。它使用
    `R.id.star_sign_id_action` 动作的 ID 来加载 `DetailFragment`，因为那是动作的目的地。`DetailFragment`
    不需要任何更改，并使用传入的 `fragment` 参数来加载所选星象 ID 的详细信息。
- en: Run up the app, and you’ll see that the app behaves as it did before.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，您会看到应用程序的行为与之前相同。
- en: Now you’ve been able to remove a significant amount of boilerplate code and
    document the navigation within the app in the navigation graph. In addition, you
    have offloaded more of the management of the fragment lifecycle to the Android
    framework, saving more time to work on features.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经能够删除大量样板代码，并在导航图中记录应用程序内的导航。此外，您已经将更多片段生命周期的管理卸载到 Android 框架，从而节省更多时间来开发功能。
- en: Jetpack Navigation is a powerful `androidx` component and enables you to map
    your whole app and the relationships between fragments, activities, and so on.
    You can also use it selectively to manage different areas of your app that have
    a defined user flow, such as the startup of your app and guiding the user through
    a series of welcome screens, or some wizard layout user journey, for example.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 导航是一个强大的 `androidx` 组件，它使您能够映射整个应用程序以及片段、活动等之间的关系。您还可以选择性地使用它来管理应用程序中具有定义良好的用户流程的不同区域，例如应用程序的启动和引导用户通过一系列欢迎屏幕，或者一些向导布局的用户旅程，例如。
- en: With this knowledge, let’s try completing an activity using the techniques learned
    from all these exercises.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们尝试使用从所有这些练习中学到的技术来完成一个活动。
- en: Activity 3.01 – creating a quiz on the planets
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三.01 – 在行星上创建一个测验
- en: For this activity, you will create a quiz where users have to answer one of
    three questions on the planets of the Solar System. The number of fragments you
    choose to use is up to you. However, considering this chapter’s content, which
    is separating the UI and logic into separate fragment components, it is likely
    you will use two fragments or more to achieve this.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，您将创建一个问答，用户必须回答太阳系中行星的三个问题之一。您选择使用多少个片段由您决定。然而，考虑到本章的内容，即把 UI 和逻辑分离到单独的片段组件中，您可能需要使用两个或更多的片段来实现这一点。
- en: The screenshots that follow show one way this could be done, but there are multiple
    ways to create this app. You can use one of the approaches detailed in this chapter,
    such as static fragments, dynamic fragments, or the Jetpack `Navigation` component,
    or something custom that uses a combination of these and other approaches.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了完成此任务的一种方法，但创建此应用程序有多种方法。您可以使用本章中详细说明的方法之一，例如静态片段、动态片段或 Jetpack `Navigation`
    组件，或者使用这些和其他方法的组合来创建自定义内容。
- en: 'The content of the quiz is as follows. In the UI, you need to ask the user
    these three questions:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是问答的内容。在 UI 中，您需要向用户提出以下三个问题：
- en: What is the largest planet?
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪颗是最大的行星？
- en: Which planet has the most moons?
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪颗行星拥有最多的卫星？
- en: Which planet spins on its side?
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪颗行星是侧卧旋转的？
- en: 'Then, you need to provide a list of planets so the user can choose the planet
    that they believe is the answer to the question:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要提供一个行星列表，以便用户可以选择他们认为的答案：
- en: '`MERCURY`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`水星`'
- en: '`VENUS`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`金星`'
- en: '`EARTH`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地球`'
- en: '`MARS`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`火星`'
- en: '`JUPITER`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`木星`'
- en: '`SATURN`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`土星`'
- en: '`URANUS`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`天王星`'
- en: '`NEPTUNE`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`海王星`'
- en: 'Once they have given their answer, you need to show them whether they are correct
    or wrong. The correct answer should be accompanied by some text that gives more
    detail about the question’s answer:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们给出了答案，您需要显示他们是否正确。正确的答案应该有一些文本，提供有关问题答案的更多详细信息：
- en: '[PRE53]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following are some screenshots of how the UI might look to achieve the
    requirements of the app you need to build:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些截图，展示了如何实现您需要构建的应用程序的要求：
- en: '**Questions screen**:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题界面**:'
- en: "![Figure 3.19 – Planet Quiz questi\uFEFFons screen](img/B19411_03_20.jpg)"
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 行星问答界面](img/B19411_03_20.jpg)'
- en: Figure 3.19 – Planet Quiz questions screen
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 行星问答问题界面
- en: '**Answer** **options screen**:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案选项界面**:'
- en: '![Figure 3.20 – Planet Quiz multiple-choice answer screen](img/B19411_03_21.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 行星问答多选题答案界面](img/B19411_03_21.jpg)'
- en: Figure 3.20 – Planet Quiz multiple-choice answer screen
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 行星问答多选题答案界面
- en: '**Answer screen**:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案界面**:'
- en: '![Figure 3.21 – Planet Quiz answer screen with detailed answer](img/B19411_03_22.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 行星问答详细答案界面](img/B19411_03_22.jpg)'
- en: Figure 3.21 – Planet Quiz answer screen with detailed answer
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 行星问答详细答案界面
- en: 'The following steps will help to complete the activity:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成活动：
- en: Create an Android project with an `Empty Activity`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 `Empty Activity` 的 Android 项目。
- en: Update the `strings.xml` file with the entries you need for the project.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您需要的项目条目更新 `strings.xml` 文件。
- en: Amend the `themes.xml` file with styles for the project.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `themes.xml` 文件以包含项目的样式。
- en: Create a `QuestionsFragment`, update the layout with the questions, and add
    interaction with buttons and `OnClickListener`(s).
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `QuestionsFragment`，更新布局以包含问题，并添加按钮和 `OnClickListener`(s) 的交互。
- en: Optionally, create a multiple-choice fragment and add answer options and button-click
    handling (this can also be done by adding the possible answer options to `QuestionsFragment`).
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，创建一个多选题片段，并添加答案选项和按钮点击处理（这也可以通过将可能的答案选项添加到 `QuestionsFragment` 中来完成）。
- en: Create an `AnswersFragment` that displays the relevant question’s answer and
    also displays more details about the answer itself.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `AnswersFragment`，显示相关问题的答案，并显示有关答案的更多详细信息。
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在 [https://packt.link/By7eE](https://packt.link/By7eE) 找到。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered fragments in depth, starting with learning about the
    fragment lifecycle and the key functions to override in your own fragments. We
    then moved on to adding simple fragments statically to an app in XML and demonstrating
    how the UI display and logic can be self-contained in individual fragments. Other
    options for how to add fragments to an app using a `FragmentContainerView` and
    dynamically adding and replacing fragments were then covered. We then finished
    with how this can be simplified by using the Jetpack `Navigation` component.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了片段，从了解片段生命周期和需要在您自己的片段中重写的关键功能开始。然后，我们转向在XML中将简单的片段静态地添加到应用程序中，并演示了UI显示和逻辑如何可以在单个片段中自包含。接着，我们介绍了如何使用`FragmentContainerView`将片段添加到应用程序中，以及动态添加和替换片段的其他选项。最后，我们讨论了如何通过使用Jetpack
    `Navigation`组件来简化这一过程。
- en: Fragments are one of the fundamental building blocks of Android development.
    The concepts you have learned about here will allow you to build upon them and
    progress to create increasingly more advanced apps. Fragments are at the core
    of building effective navigation into your apps in order to bind features and
    functionality that are simple and easy to use.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是Android开发的基本构建块之一。您在这里学到的概念将使您能够在此基础上构建，并逐步创建越来越高级的应用程序。片段是构建有效导航的核心，以便将简单易用的功能和功能绑定到您的应用程序中。
- en: The next chapter will explore this area in detail by using established UI patterns
    to build clear and consistent navigation and illustrate how fragments are used
    to enable this.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过使用已建立的UI模式来构建清晰和一致的导航，并说明片段是如何被用来实现这一点的，来详细探讨这个领域。
