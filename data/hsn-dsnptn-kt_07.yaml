- en: Staying Reactive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持响应式
- en: Once we're familiar with functional programming and its building blocks, we
    can start discussing reactive programming concepts. While it's not coupled with
    functional programming (you can be reactive while writing object-oriented or procedural
    code, too), it's still better to discuss after learning about functional programming
    and its foundation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了函数式编程及其构建块，我们就可以开始讨论响应式编程的概念。虽然它并不与函数式编程耦合（你甚至可以在编写面向对象或过程式代码时变得响应式），但在了解函数式编程及其基础之后讨论会更好。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reactive principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式原则
- en: Reactive extension
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式扩展
- en: Reactive principles
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式原则
- en: So, what is reactive programming?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是响应式编程呢？
- en: It's summarized nicely by the reactive manifesto: [https://www.reactivemanifesto.org](https://www.reactivemanifesto.org).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言很好地总结了这一点：[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)。
- en: 'To cite it, reactive programs are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 引用它，响应式程序是：
- en: Responsive
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应性
- en: Resilient
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Elastic
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Message-driven
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动
- en: To understand these four topics, let's imagine 10 people standing in a line
    for a cashier. Each one of them can see only the person in front, but not how
    many people are in the line ahead of that person or what the cashier is doing.
    Do you have this picture in your mind? Let's start then.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这四个主题，让我们想象有10个人站在收银员队伍中。他们中的每一个人只能看到前面的人，但看不到前面有多少人在排队，或者收银员在做什么。你脑海中有没有这个画面？那么，我们就从这里开始。
- en: Responsiveness
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应性
- en: Would you stand in that line for the cashier?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你会站在那个收银员队伍中吗？
- en: That depends on the urgency and how much time you have. If you're in a hurry,
    you'll probably leave empty-handed before reaching the cash register.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于紧急程度和你的时间。如果你很匆忙，你可能会在到达收银台之前空手而归。
- en: That's a system being unresponsive to you. You're often in the same situation
    when reaching a call center of one of the service providers by phone. You're asked
    to wait on the line, and you wait. But, more often than not, a nice automatic
    voice tells you how many people are waiting on the same line ahead of you or even
    how much time you'll have to wait.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种系统对你不响应的情况。当你通过电话联系某家服务提供商的客户服务中心时，你经常会遇到这种情况。你会被要求在电话线上等待，然后你就等待。但是，更常见的情况是，一个友好的自动语音会告诉你，在你前面有多少人在等待，甚至告诉你你需要等待多长时间。
- en: In both cases, the result is the same. You've wasted your time waiting in line
    or on the line. But the second system was responsive to your needs, and you could
    make decisions based on that.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果都是一样的。你在排队或电话线上浪费了时间。但第二个系统对你的需求做出了响应，你可以据此做出决定。
- en: Resiliency
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Let's continue to resiliency. You're waiting on the line for 10 minutes, then
    the line drops. Or, you reached one of the customer care representatives, but
    they hang up on you by mistake. How often does that happen? That's the system
    not being resilient to failures. Or, you've waited in line for half an hour to
    see a doctor, when they suddenly leave the office and go to a golf club, asking
    you to come back tomorrow. That's a system that wasn't responsive in the face
    of failure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论弹性。你已经在电话线上等了10分钟，然后队伍消失了。或者，你联系到了一位客户服务代表，但他们不小心挂断了你的电话。这种情况有多常见？这就是系统对失败不具弹性的表现。或者，你排队等了半小时去看医生，但他们突然离开办公室去打高尔夫球，让你明天再来。这是一个面对失败时没有响应的系统。
- en: 'The reactive manifesto discusses various ways to achieve resiliency:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言讨论了实现弹性的各种方法：
- en: Delegation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委派
- en: Replication
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Containment
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: Isolation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: Delegation is when the doctor comes out of their office and tells you, *I can't
    see you* *today, but knock on the other door; they'll see to you soon*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 委派是指医生走出办公室告诉你，“我今天不能见你，但敲一下另一扇门；他们很快就会见你。”
- en: Replication is for a clinic to always have two doctors available, just in the
    event that one of them miss their favorite team playing this evening. It relates
    to elasticity, which we'll discuss in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是为了诊所总是有两名医生可用，以防其中一名医生今晚错过了他们最喜欢的球队比赛。这与弹性有关，我们将在下一节讨论。
- en: Containment and isolation are usually discussed together. What if you actually
    don't need to see the doctor? Maybe you only need a prescription from them. Then,
    you could leave them a message (we'll discuss message-passing soon, as it's also
    an important part of reactiveness) and they'll send you a recipe when they're
    between games. You decoupled yourself from seeing a doctor. It also provided you
    with isolation from the doctors' failures or problems. What you didn't know is
    that, while printing your recipe, their computer crashed twice and they were really
    stressed about that. But because you weren't in front of them, they kept that
    to themselves.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 限制和隔离通常一起讨论。如果你实际上不需要看医生呢？也许你只需要他们的处方。那么，你可以给他们留条消息（我们很快会讨论消息传递，因为它也是反应性的一个重要部分），当他们游戏间隙时，他们会给你发送处方。你从看医生的需求中解脱出来。这也让你从医生的失败或问题中得到了隔离。你不知道的是，在他们打印处方的时候，他们的电脑两次崩溃，他们对此非常焦虑。但因为你不在他们面前，他们把这件事留给了自己。
- en: Elasticity
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: So, in the previous section, we discussed replication. To prevent failures,
    our clinic always has two doctors available. Maybe the second doctor served some
    patients, or maybe they were just patiently waiting for the first doctor to leave
    for their football game to start working.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在前一节中，我们讨论了复制。为了防止失败，我们的诊所总是有两个医生可用。也许第二位医生服务了一些病人，或者他们只是耐心地等待第一位医生离开去踢足球比赛开始工作。
- en: But, what would happen to that resilient system if suddenly there is a flu epidemic
    or a band of rabid squirrels starts attacking citizens in the nearby park? Two
    doctors won't be able to handle all of the patients and then, again, we have a
    problem with resiliency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果突然爆发流感疫情或一群狂怒的松鼠开始在附近的公园攻击市民，那么那个弹性系统会发生什么？两位医生将无法处理所有病人，然后，我们再次面临弹性问题。
- en: But what if we had a supply of retired doctors sitting in their homes playing
    mahjong? Certainly, we could call them to come and help bandage all of those squirrel
    victims. And after they were all properly treated, the doctors could return to
    their mahjong.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一批退休医生坐在家里打麻将呢？当然，我们可以叫他们来帮助包扎所有那些松鼠受害者。在他们都得到适当治疗后，医生们可以回到他们的麻将桌。
- en: That's a system being elastic depending on the workload.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个根据工作量而弹性的系统。
- en: Elasticity builds on scalability. We could treat all of those patients because
    each doctor could work independently. But what if all of the bandages were stored
    in a single box? Then it would create a bottleneck, with all of those doctors
    standing around waiting for the next pack of bandages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性建立在可扩展性之上。我们之所以能够治疗所有那些病人，是因为每位医生可以独立工作。但如果所有的绷带都存放在一个盒子里呢？那么就会形成瓶颈，所有医生都站在那里等待下一包绷带。
- en: Message-driven
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动
- en: This is also referred to as *asynchronous message passing*. So, we saw in the
    *Resiliency* section that if you could leave a message for the doctor, it may
    make the system more resilient.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为*异步消息传递*。所以，我们在*弹性*部分看到，如果你能给医生留条消息，这可能会使系统更具弹性。
- en: What if all of the patients would only leave messages? Then each doctor could
    prioritize them or batch-process those messages. For example, printing all recipes
    together, instead of switching between different tasks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的病人都只留下消息呢？那么每位医生都可以优先处理它们或批量处理这些消息。例如，一起打印所有处方，而不是在不同任务之间切换。
- en: In addition to loose coupling and isolation, there's also *location transparency*.
    You didn't know tha your doctor sent you this prescription while driving home
    (they snuck out of the window while you left your message). But you don't care since
    you got what you wanted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了松散耦合和隔离之外，还有*位置透明性*。你不知道你的医生是在开车回家的路上给你发送这个处方的（在你留言的时候，他们从窗户溜出去）。但你并不在乎，因为你得到了你想要的东西。
- en: Using messages also allows an interesting option of *backpressure*. If your
    doctor receives too many messages, they may collapse from stress. To avoid that,
    they may text you to say that you'll have to wait a bit longer to receive your
    prescription. Or, if they have a secretary, we may even ask them to do that anyway.
    Again, we're talking about delegation here, as all of those principles are correlated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息还允许一个有趣的选项，即*背压*。如果医生收到的消息太多，他们可能会因为压力而崩溃。为了避免这种情况，他们可能会给你发短信说你需要等待更长一点时间才能收到处方。或者，如果他们有秘书，我们甚至可以要求他们这样做。再次强调，我们在这里讨论的是委托，因为所有这些原则都是相关的。
- en: Messages are also non-blocking. After you leave the message, you don't sit there
    waiting for the doctor's response. You usually go back home, to your regular tasks.
    The ability to perform other tasks while you wait is one of the cornerstones of
    concurrency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 消息也是非阻塞的。在您离开消息后，您不必等待医生的回复。您通常会回家，继续您的常规任务。在等待时执行其他任务的能力是并发的一个基石。
- en: Reactive extension
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: The rest of this chapter will be dedicated to the specific implementation of
    reactive principles in Kotlin. The predominant library in this field is RxJava.
    Since Kotlin is fully interoperable with Java libraries, RxKotlin is only a thin
    wrapper over the original RxJava. Hence, we'll discuss it as if these are one
    and the same library, and highlight the differences, if any.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将致力于 Kotlin 中反应式原则的具体实现。这个领域的首选库是 RxJava。由于 Kotlin 与 Java 库完全兼容，RxKotlin
    只是原始 RxJava 的一层薄包装。因此，我们将将其视为同一个库，并突出显示任何差异。
- en: As soon as we start talking about RxJava, you'll recognize it's built upon the **Observer**
    design pattern we discussed in [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7),
    *Getting Familiar with Behavioral Patterns*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始讨论 RxJava，您就会认出它是建立在我们在 [第 4 章](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7)
    中讨论的 **观察者** 设计模式之上的。
- en: 'We''ll start by adding the following dependency to our Gradle project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的 Gradle 项目中添加以下依赖项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Currently, this is the latest version of RxJava2, but when you read this chapter,
    there will probably ba a more recent version already. Feel free to use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是 RxJava2 的最新版本，但当你阅读这一章时，可能已经有了更新的版本。请随意使用它。
- en: 'You may remember that the pattern consists of two objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，该模式由两个对象组成：
- en: '`publisher`: Produces data'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发布者`：产生数据'
- en: '`subscriber`: Consumes data'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`订阅者`：消费数据'
- en: In RxJava, publishers are called `Observable`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 中，发布者被称为 `Observable`。
- en: 'The following code will create our first publisher:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建我们的第一个发布者：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To start consuming those numbers, we can supply a lambda to the `subscribe()`
    function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始消费这些数字，我们可以向 `subscribe()` 函数提供一个 lambda 表达式：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are other functions available on `Observable` that you''ll immediately
    recognize: `map()` and `filter()`, for example. Those are the same functions that
    are available on regular arrays in Kotlin:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 上还有其他可用的函数，您会立即认出：例如 `map()` 和 `filter()`。这些函数与 Kotlin 中常规数组上的函数相同：'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: OK, this is nice, but we've already discussed collections and streams in sequences
    in the previous chapter. Why do it again?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很好，但我们已经在上一章讨论了序列中的集合和流。为什么还要再次讨论？
- en: 'Let''s look at the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code will wait for five milliseconds before terminating and it will print
    the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在终止前等待五毫秒，并打印以下内容：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is unexpected. `Sleeping` was the last line in the code, but it's printed
    first. Then notice that `P2` is printed before `P1` sometimes if you run this
    example more than once. And sometimes, it's `P1` before `P2`, much like in the
    code. What's going on here?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不预期的。`Sleeping` 是代码中的最后一行，但它首先被打印出来。然后注意，如果您多次运行此示例，有时 `P2` 会先于 `P1` 打印。有时，`P1`
    会先于 `P2` 打印，这与代码中的情况相似。这里发生了什么？
- en: That's asynchronicity in action. We need `Thread.sleep()` here to allow our
    listeners to run for some time, otherwise, our program would terminate. And when
    they're called, it doesn't matter where in the actual code they were placed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是异步操作的实际应用。我们需要在这里使用 `Thread.sleep()` 以允许我们的监听器运行一段时间，否则我们的程序将终止。并且当它们被调用时，它们被放置在代码中的位置无关紧要。
- en: In this chapter, we'll use `Thread.sleep()` and `CountDownLatch` a lot to demonstrate
    how asynchronism works. In a real-life application, you should never use `Thread.sleep`.
    If you're still not familiar with `CountDownLatch,` don't worry, we'll explain
    how it works the first time we stumble upon it, in the *Flowables* section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量使用 `Thread.sleep()` 和 `CountDownLatch` 来演示异步操作的工作原理。在实际应用中，您永远不应该使用
    `Thread.sleep()`。如果您还不熟悉 `CountDownLatch`，不要担心，我们将在第一次遇到它时在 *Flowables* 部分解释它的工作原理。
- en: Well, that's how the Observer design pattern behaves, naturally. But with Observer,
    there's also an option to unsubscribe. How do we achieve it here?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是观察者设计模式自然的行为。但观察者还有一个取消订阅的选项。我们在这里是如何实现的？
- en: 'Let''s replace the second listener with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码替换第二个监听器：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A call to `subscribe()` returns a `Disposable`. When you no longer want to receive
    updates, you can call `dispose()` on it, which is synonymous with *unsubscribe*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `subscribe()` 返回一个 `Disposable`。当你不再想接收更新时，你可以调用它上的 `dispose()`，这与 *取消订阅*
    同义。
- en: 'Your output may look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出可能看起来像这样：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What if we were to create our own `Observable`, with its own specific logic?
    There''s a `create()` method for that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建自己的 `Observable`，具有它自己的特定逻辑怎么办？有一个 `create()` 方法可以做到这一点：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We create an `Observable` that publishes numbers. To push a new value to all
    listeners, we use the `onNext()` method. We notify the listeners that there's
    no more data with `onComplete()`. Finally, if an error occurrs, we can call `onError()`,
    supplying the exception as an argument.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个发布数字的 `Observable`。要向所有听众推送新值，我们使用 `onNext()` 方法。我们通过 `onComplete()` 通知听众没有更多数据了。最后，如果发生错误，我们可以调用
    `onError()`，并提供异常作为参数。
- en: 'You''ll notice that if we try to actually call `onError()`, we''ll get an exception:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果我们尝试实际调用 `onError()`，我们会得到一个异常：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's because we use the shorthand form with the lambda listener.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们使用了带有 lambda 监听器的简写形式。
- en: 'If we want to handle errors correctly, we also need to supply *error handler*
    as a second argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要正确处理错误，我们还需要提供 *错误处理器* 作为第二个参数：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s also a third parameter, which is the `onComplete` handler:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第三个参数，即 `onComplete` 处理器：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our examples, we'll rarely use error handlers since our code is very basic.
    But you should always provide them in real applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们很少使用错误处理器，因为我们的代码非常基础。但在实际应用中，你应该始终提供它们。
- en: Hot Observable
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热观察者
- en: Hot `Observable` is a term we'll use a lot in this chapter, as opposed to cold
    `Observable`. All Observable we discussed before was cold. That meant they knew
    everything that happened from the beginning of time, and each time somebody asked
    them politely, they could repeat the whole history. Hot `Observable` only know
    what happens now. Think of the weather forecast and weather history, for example.
    The weather forecast is hot—you'll get the current weather, let's say every minute.
    The weather history is cold–you can get the whole history of weather changes,
    if you care about it. If you still don't get this concept, don't worry too much.
    We have half of the chapter ahead of us to cover it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 热 `Observable` 是我们在本章中会大量使用的一个术语，与冷 `Observable` 相对。我们之前讨论的所有 `Observable` 都是冷的。这意味着它们知道从时间开始发生的一切，每次有人礼貌地询问时，它们都可以重复整个历史。热
    `Observable` 只知道现在发生的事情。例如，想想天气预报和天气历史。天气预报是热的——你将每分钟得到当前的天气。天气历史是冷的——如果你关心它，你可以得到整个天气变化的历史。如果你仍然不理解这个概念，不要过于担心。我们还有一半的章节要覆盖它。
- en: 'As you''ve probably noticed, up until now, all of our subscribers always got
    all the data, no matter when they subscribed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，到目前为止，所有我们的订阅者总是得到所有数据，无论他们何时订阅：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But that''s not always the case. More often, we have the data source coming
    from outside and not created each time by the `publisher`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但情况并不总是这样。更常见的是，数据源来自外部，而不是每次都由 `publisher` 创建：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, instead of creating the list inside, we have a reference to its iterator.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是在内部创建列表，而是有一个对其迭代器的引用。
- en: 'Let''s see how the following code behaves now:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码现在是如何表现的：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have two subscribers, as before. Up until now, all subscribers executed
    on the same thread we were running. For this example, we assigned them a separate
    thread each. That would allow us to simulate operations that are running for some
    time: 10 ms, in this case. To specify on which thread subscriber should run, we
    use `subscribeOn()`. `Schedulers` is an utility class, much like `Executors` from
    Java 5\. In this case, it will assign a new thread for each listener.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个订阅者，就像之前一样。到目前为止，所有订阅者都在我们运行的同一个线程上执行。对于这个例子，我们为每个订阅者分配了一个单独的线程。这将允许我们模拟运行一段时间（在这种情况下是
    10 毫秒）的操作。要指定订阅者应该在哪个线程上运行，我们使用 `subscribeOn()`。`Schedulers` 是一个实用类，类似于 Java 5
    中的 `Executors`。在这种情况下，它将为每个听众分配一个新的线程。
- en: 'The output may look something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能看起来像这样：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that if every consumer received all the data previously, now the second
    subscriber will never receive numbers 1-5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果每个消费者之前都接收到了所有数据，现在第二个订阅者将永远不会接收到数字 1-5。
- en: After the second subscriber is connected, only one of them will receive the
    data each time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个订阅者连接后，每次只有其中之一会接收到数据。
- en: What if we want to publish data to all of the subscribers simultaneously?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想同时向所有订阅者发布数据怎么办？
- en: Multicast
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多播
- en: 'There''s a `publish()` method for that:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `publish()` 方法可以做到这一点：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We again create a somewhat *hot* `Observable`, but this time we specify that
    it will run on a separate thread with `observeOn()`. We also use the `publish()`
    method, which turns our `Observable` into `ConnectableObservable`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次创建了一个稍微热的`Observable`，但这次我们指定它将在单独的线程上运行，使用`observeOn()`。我们还使用了`publish()`方法，它将我们的`Observable`转换为`ConnectableObservable`。
- en: 'If we simply subscribe to this type of `Observable`, nothing will happen. We
    need to tell it when to start running. We use that with the `connect()` method.
    Since the `connect()` method is blocking, we''ll execute it from a separate thread
    for this example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅仅订阅这种类型的`Observable`，将不会发生任何事情。我们需要告诉它何时开始运行。我们使用`connect()`方法来做这件事。由于`connect()`方法是阻塞的，我们将在这个例子中从单独的线程执行它：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we''ll let publisher work for a few milliseconds, then connect our first
    listener:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让发布者工作几毫秒，然后连接我们的第一个监听器：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After some more time, we connect a second listener, and allow them to finish:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，我们连接第二个监听器，并允许它们完成：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s see the output now, as it''s quite interesting:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的输出，因为它相当有趣：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, having this `connect()` is not always comfortable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有这个`connect()`并不总是舒适的。
- en: 'For that reason, we have a method called `refCount()`, which turns our `ConnectableObservable`
    back into a regular `Observable`. It will keep a reference count of the subscribers,
    and dispose of the subscriptions only after all subscribers have done so, too:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个名为`refCount()`的方法，它将我们的`ConnectableObservable`转换回常规的`Observable`。它将保持订阅者的引用计数，并且只有在所有订阅者都这样做之后才会取消订阅：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And if calling `publish().refCount()` is too cumbersome, there''s also the `share()`
    method that does exactly that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`publish().refCount()`太繁琐，还有一个`share()`方法可以做到这一点：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Subject
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subject
- en: The easiest way to understand `Subject` is that `Subject = Observable + Observer`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Subject`的最简单方式是`Subject = Observable + Observer`。
- en: 'On the one hand, it allows others to `subscribe()` to it. On the other, it
    can `subscribe` to other `Observable`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，它允许其他人`subscribe()`订阅它。另一方面，它可以`subscribe`到其他`Observable`：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code prints six lines, three for each subscriber:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印六行，每个订阅者三行：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we didn't use `publish()` on our `dataSource`, so it's cold. Cold
    means that each time somebody subscribes to this source, it will begin sending
    data anew. The hot `Observable`, on the other hand, doesn't have all the data,
    and will only send what it has from this moment on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在`dataSource`上使用`publish()`，所以它是冷的。冷意味着每次有人订阅这个源时，它都会重新开始发送数据。另一方面，热的`Observable`并没有所有数据，它只会从这一刻开始发送它所拥有的数据。
- en: For that reason, we need to first connect all the listeners, and only then begin
    to listen to the `dataSource`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要首先连接所有监听器，然后才开始监听`dataSource`。
- en: 'If we''re using a hot `dataSource`, we can switch the calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用热的`dataSource`，我们可以切换调用：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As in the previous section, we use `connect()` to tell `dataSource` when to
    start emitting data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用`connect()`来告诉`dataSource`何时开始发射数据。
- en: ReplaySubject
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplaySubject
- en: 'In addition to `PublishSubject`, which we discussed in the previous section,
    there are other subjects available. To understand how `ReplaySubject` works, let''s
    see first the following example with `PublishSubject`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中讨论的`PublishSubject`之外，还有其他主题可用。为了理解`ReplaySubject`是如何工作的，让我们首先看看以下使用`PublishSubject`的例子：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This prints the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Clearly, some events are lost for good.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一些事件已经永久丢失。
- en: 'Now, let''s replace `PublishSubject` with `ReplaySubject` and examine the output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`ReplaySubject`替换`PublishSubject`并检查输出：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following output will be printed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被打印：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With `ReplaySubject`, no events are lost. You can see from the output, though,
    that until some point, events aren't multicast, even when there is more than one
    `subscriber`. Instead, for each `subscriber`, `ReplaySubject` performs a kind
    of catch-up of what it missed until now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ReplaySubject`，不会丢失任何事件。然而，从输出中可以看出，直到某个点，事件不会多播，即使有多个`subscriber`。相反，对于每个`subscriber`，`ReplaySubject`会执行一种追赶，以弥补到目前为止错过的事件。
- en: 'The benefits of this approach are clear. We converted what seems to be a *hot*
    `Observable` into something quite *cold*. But there are also limitations. By using `ReplaySubject.create`,
    we produce an unbounded subject. If it tries to record too many events, we will
    simply run out of memory. To avoid that, we can use the `createWithSize()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是显而易见的。我们将看似热的`Observable`转换成了相当冷的。但也有一些限制。通过使用`ReplaySubject.create`，我们产生了一个无界的主题。如果它尝试记录太多事件，我们可能会简单地耗尽内存。为了避免这种情况，我们可以使用`createWithSize()`方法：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It creates the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了以下输出：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, now our subject remembers fewer items, so the earliest events
    are lost.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在我们的主题记住的项目更少，因此最早的事件丢失了。
- en: BehaviorSubject
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`'
- en: 'Imagine a situation when you have a stream of updates every minute. You want
    to display the latest value you received, then keep updating it when new data
    comes in. You can use `ReplaySubject` with a size of one. But there''s also `BehaviorSubject`
    exactly for this case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这种情况：你每分钟都会有一串更新。你想要显示你收到的最新值，然后在有新数据进来时继续更新它。你可以使用大小为1的`ReplaySubject`。但还有`BehaviorSubject`正好适用于这种情况：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output will be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: AsyncSubject
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AsyncSubject`'
- en: This is a strange `subject` since, unlike the others, it doesn't update its
    subscribers. So, what is it good for?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个奇怪的`subject`，因为它与其他不同，它不会更新其订阅者。那么它有什么好处呢？
- en: 'What if you wanted to have a very basic functionality, simply updating a screen
    with the latest value and never refreshing it again until the screen is closed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想有一个非常基本的功能，只是更新屏幕上的最新值，并且直到屏幕关闭不再刷新：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Be careful, though. Since `AsyncSubject` waits for the sequence to complete,
    if the sequence is infinite, it will never call its subscribers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要小心。由于`AsyncSubject`等待序列完成，如果序列是无限的，它将永远不会调用其订阅者：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: SerializedSubject
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SerializedSubject`'
- en: It's important not to call the `onNext()`/`onComplete()`/`onError()` methods
    from different threads, as it will make the calls non-serializable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要从不同的线程调用`onNext()`/`onComplete()`/`onError()`方法，因为这会使调用非序列化。
- en: 'This is a **Proxy** of sorts around any regular `subject`, which synchronizes
    calls to the unsafe methods. You can wrap any `subject` with `SerializedSubject`
    using the `toSerialized()` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个某种形式的**代理**，围绕任何常规`subject`，它同步调用不安全的方法。你可以使用`toSerialized()`方法将任何`subject`包装在`SerializedSubject`中：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Flowables
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Flowables`'
- en: In all previous examples, we emitted data using `Observable` or `subject`, which
    also extends `Observable`, and it worked out pretty well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的例子中，我们使用`Observable`或`subject`来发射数据，它们也扩展了`Observable`，并且效果相当不错。
- en: But our listeners weren't doing much. What if they were to do something more
    substantial?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的听众并没有做什么。如果他们要做更多实质性的事情会怎样？
- en: 'Let''s see the following example. We''ll produce a lot of unique strings:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。我们将生成大量的唯一字符串：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're using `CountDownLatch` so the main thread will be able to wait until we
    finish. In addition, we're also printing how much time it took to emit 100,000
    events. This will be useful later.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CountDownLatch`以便主线程能够等待我们完成。此外，我们还打印了发射100,000个事件所需的时间。这将在以后很有用。
- en: 'In the `subscribe()` method, we would repeat those strings 1,000 times:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subscribe()`方法中，我们将重复这些字符串1,000次：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`AtomicInteger` is used to count the number of processed events in a thread-safe
    way.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AtomicInteger`用于以线程安全的方式计数线程中处理的事件的数量。'
- en: 'We''re obviously consuming more slowly than we''re producing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然消费的速度比生产慢：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But the interesting point is that, after some period, the producing time will
    increase dramatically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但有趣的是，在一段时间之后，生产时间将急剧增加。
- en: 'That''s the point when we start to run out of memory. Let''s now replace our
    `Observable` with `Flowable`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始耗尽内存的点。现在，让我们用`Flowable`替换我们的`Observable`：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, instead of passing only a lambda, we also pass a second argument,
    which is `BackpressureStrategy`. What happens is that, behind the scenes, `Flowable`
    has a bounded buffer. This is very similar to how we could make `ReplaySubject`
    bounded. The second argument is telling `Flowable` what should happen if this
    buffer limit is reached. In this case, we're asking it to throw away those events.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不仅传递了一个lambda表达式，还传递了第二个参数，即`BackpressureStrategy`。幕后发生的事情是`Flowable`有一个有界缓冲区。这与我们如何使`ReplaySubject`有界非常相似。第二个参数告诉`Flowable`当缓冲区达到限制时应该发生什么。在这种情况下，我们要求它丢弃这些事件。
- en: 'Now, we should check the final part of our output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该检查我们输出的最后部分：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, note that we didn't get stuck at any point. Actually, the pace of our
    production is constant.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们没有在任何地方卡住。实际上，我们的生产速度是恒定的。
- en: Second, you should note that although we *produced* 10,000,000 events, we *consumed*
    only 2.8 million. All other events were dropped.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你应该注意，尽管我们*生产*了1,000万次事件，但我们*消费*了只有280万次。其他所有事件都被丢弃了。
- en: But we didn't run out of memory, which is the great benefit of `Flowable`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们没有耗尽内存，这是`Flowable`的巨大好处。
- en: If you do want `Flowable` to behave like `Observable`, you can specify `BackpressureStrategy.BUFFER`,
    and see that it begins to stutter around the same lines.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想让`Flowable`表现得像`Observable`，你可以指定`BackpressureStrategy.BUFFER`，并看到它开始在这些行周围出现卡顿。
- en: 'As a general guideline, use `Flowable` when as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般指南，当以下情况发生时使用`Flowable`：
- en: You plan to emit more than 1,000 items (some may say 10,000)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划发射超过1,000个项目（有些人可能会说10,000）
- en: You're reading a file
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在读取文件
- en: You're querying a database
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在查询数据库
- en: You have some network streaming to do
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一些网络流需要处理
- en: 'Use `Observable` as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如此使用`Observable`：
- en: You have a limited amount of data you plan to emit.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划发射有限数量的数据。
- en: You deal with user input. Humans aren't as quick as they think they are and
    don't produce many events.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你处理用户输入。人类并不像他们想象的那么快，也不产生很多事件。
- en: 'You care about the performance of the flow: `Observable` are simpler, thus
    faster.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你关心流的性能：`Observable`更简单，因此更快。
- en: When we used the lambda expression, we didn't notice much difference between
    `Flowable` and `Observable`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用lambda表达式时，我们没有在`Flowable`和`Observable`之间注意到太大的区别。
- en: 'Instead, now we''ll replace it with an anonymous class and see what benefits
    this approach provides:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之，现在我们将使用匿名类，并看看这种方法提供了哪些好处：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's obviously a lot more code. We need to implement four methods now.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是更多的代码。现在我们需要实现四个方法。
- en: What interests us the most is the `onSubscribe()` method. Here, we receive a
    new object called `Subscription` and store it in a property.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的是`onSubscribe()`方法。在这里，我们接收一个新的对象，称为`Subscription`，并将其存储在一个属性中。
- en: 'For now, we''ll drop the fancy code that we were using in our listener before,
    and simply print every new string we receive:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将丢弃我们在监听器之前使用的花哨代码，并简单地打印我们接收到的每个新字符串：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Huh? That's strange. Our listener doesn't print anything.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯？这很奇怪。我们的监听器没有打印任何东西。
- en: 'Let''s go to our `onSubscribe` and modify it a bit:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的`onSubscribe`并稍作修改：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Subscription` has a method called `request()`, which receives the number of
    items we''re willing to take.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscription`有一个名为`request()`的方法，它接收我们愿意接收的项目数量。'
- en: You can run the code again to see that now our subscriber prints the first 100
    strings, then goes silent again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次运行代码，现在我们的订阅者打印了前100个字符串，然后又沉默了。
- en: 'We''ve already discussed the `BackpressureStrategy.DROP` and `BackpressureStrategy.BUFFER`
    strategies. Let''s now focus on the `BackpressureStrategy.MISSING` strategy. The
    name is a bit confusing; *custom* would be better. We''ll see why in a moment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`BackpressureStrategy.DROP`和`BackpressureStrategy.BUFFER`策略。现在让我们专注于`BackpressureStrategy.MISSING`策略。这个名字有点令人困惑；*自定义*可能更好。我们很快就会看到原因：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And we''ll go back to `onNext()`, which actually does something:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将回到`onNext()`，它实际上做了一些事情：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So, we're back to repeating strings. And after we finish with each, we ask our
    `Flowable` to provide the next one with `subscription.request(1)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们又回到了重复字符串。在完成每个字符串后，我们通过`subscription.request(1)`要求我们的`Flowable`提供下一个字符串。
- en: Quickly enough, though, we receive `MissingBackpressureException`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们很快就会收到`MissingBackpressureException`。
- en: That's because we specified the `BackpressureStrategy.MISSING` strategy, and
    didn't specify the size of the buffer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们指定了`BackpressureStrategy.MISSING`策略，但没有指定缓冲区的大小。
- en: 'To fix that, we''ll use the `onBackpressureBuffer()` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用`onBackpressureBuffer()`方法：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That postponed the problem, but we still crash with `MissingBackpressureException`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这推迟了问题，但我们仍然因为`MissingBackpressureException`而崩溃。
- en: 'What we need in this case is not to *create* a `Flowable`, but to *generate*
    it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要的不是*创建*一个`Flowable`，而是*生成*它：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that, unlike `create()`, `generate()` receives a lambda that represents
    *a single action*. For that reason, we cannot have loops inside it. Instead, we
    store our state, if any, outside.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`create()`不同，`generate()`接收一个lambda，它代表*单个操作*。因此，我们无法在其中使用循环。相反，我们将状态（如果有的话）存储在外部。
- en: 'The output looks as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Take note of how much slower the production is now. That's because we wait for
    our consumer to process the event before supplying the next batch.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在生产速度有多慢。这是因为我们在向消费者提供下一批之前等待消费者处理事件。
- en: Holding state
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持状态
- en: 'Having those values captured in a closure may seem a bit ugly. There''s a more
    functional alternative, but it''s quite hard to grasp. Generate can receive two
    functions instead of one:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包中捕获这些值可能看起来有点丑陋。有一个更函数式的替代方案，但它很难掌握。`Generate`可以接收两个函数而不是一个：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Well, that's a mouthful. Let's try to understand what's going on there.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这听起来有点复杂。让我们试着理解那里发生了什么。
- en: 'The first initial state is `() -> State`. In our case, the state can be represented
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个初始状态是 `() -> State`。在我们的例子中，状态可以表示如下：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We don't pass an instance of `CountDownLatch` to our function for the sake of
    simplicity. You'll soon understand why.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们不向我们的函数传递 `CountDownLatch` 的实例。你很快就会明白为什么。
- en: So, our first argument is the `() -> State` function, which has no parameters
    and returns a `State`. Now, the second argument should be a function, that is, `(State,
    Emitter<T>) -> State`. In our case, we emit strings, so our function is `(State,
    Emitter<String>) -> State`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个参数是 `() -> State` 函数，它没有参数并返回一个 `State`。现在，第二个参数应该是一个函数，即 `(State,
    Emitter<T>) -> State`。在我们的例子中，我们发射字符串，所以我们的函数是 `(State, Emitter<String>) -> State`。
- en: 'Since this is all a bit confusing not only to us but also to the Kotlin compiler,
    we specify exactly what types of functions those are, `Callable<State>` and `BiFunction<State,
    Emitter<String>, State>`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不仅仅对我们，也对 Kotlin 编译器来说有点混乱，我们明确指定了这些函数的类型，即 `Callable<State>` 和 `BiFunction<State,
    Emitter<String>, State>`：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, sometimes purely functional code is much more complex. Luckily
    for us, Kotlin allows us to chose different approaches for different situations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有时纯函数式代码可能非常复杂。幸运的是，Kotlin 允许我们根据不同情况选择不同的方法。
- en: FlowableProcessor
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlowableProcessor
- en: Much like any `Subject` is an `Observer` and `Observable` at the same time,
    any `FlowableProcessor` is a `Flowable` that is both a `Publisher` and `Subscriber`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何 `Subject` 同时是 `Observer` 和 `Observable` 一样，任何 `FlowableProcessor` 都是一个既是
    `Publisher` 也是 `Subscriber` 的 `Flowable`。
- en: 'To understand this statement, let''s take the example of `ReplaySubject` and
    rewrite it using `ReplayProcessor`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个陈述，让我们以 `ReplaySubject` 为例，并使用 `ReplayProcessor` 重新编写它：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Any `Observable` can be converted to `Flowable` using the `toFlowable()` method.
    As with any `Flowable`, we need to specify which strategy to use. In our case,
    we use `BackpressureStrategy.DROP`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `Observable` 都可以使用 `toFlowable()` 方法转换为 `Flowable`。与任何 `Flowable` 一样，我们需要指定要使用哪种策略。在我们的例子中，我们使用
    `BackpressureStrategy.DROP`。
- en: 'As you can see, `Flowable` supports the `publish()` method, the same as `Observable`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Flowable` 支持与 `Observable` 相同的 `publish()` 方法：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Instead of creating `ReplaySubject`, we create `ReplayProcessor`, which also
    supports size limiting:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是创建 `ReplaySubject`，而是创建 `ReplayProcessor`，它也支持大小限制：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is practically the same:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输出实际上是相同的：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But in case of big input, we now have backpressure to protect us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但在处理大量输入时，我们现在有了背压来保护我们。
- en: Batching
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理
- en: Sometimes, slowing the producer is not possible. So, are we back to the original
    problem, of either dropping some events or running out of memory? Luckily, Rx
    still has a few tricks up its sleeve. It is often more efficient to process data
    in batches. We've already discussed such a case in the previous chapter. For that,
    we can specify `buffer()` for our `subseriber`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，减慢生产者是不可能的。那么，我们是否又回到了原始问题，即丢弃一些事件或耗尽内存？幸运的是，Rx 仍然有一些锦囊妙计。批量处理数据通常更有效率。我们已经在上一章讨论了这种情况。为此，我们可以为我们的
    `subscriber` 指定 `buffer()`。
- en: 'Buffer has three flavors. The first one is batch-per-size:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区有三种类型。第一种是按大小批处理：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It outputs the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出以下内容：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The second is the batch-per-time interval. Imagine we have a screen with a
    screen that displays the latest news, and new updates arrive every few seconds.
    But for us, it''s fine to refresh the view only once every five seconds:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是每时间间隔的批次。想象一下，我们有一个屏幕，上面显示最新的新闻，并且每几秒钟就会更新。但对我们来说，每五秒刷新一次视图就足够了：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It outputs the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出以下内容：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The third flavor allows us to become dependent on another `Observable`. We''ll
    batch until it asks us to flush the data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型允许我们依赖于另一个 `Observable`。我们将批量处理，直到它要求我们刷新数据：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It outputs the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出以下内容：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Throttling
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流
- en: Throttling on the consumer side is similar to dropping on the producer side.
    But it can be applied not only to `Flowable`, but also to `Observable`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者端的节流类似于生产者端的丢弃。但它不仅可以应用于 `Flowable`，也可以应用于 `Observable`。
- en: 'You specify the time interval, and each time get only one element, either the
    first or last one, in that interval:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你指定时间间隔，然后在该间隔内每次只获取一个元素，要么是第一个，要么是最后一个：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Execute this example a few times and you will see that you get different results.
    Throttling is highly sensitive to timing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个示例几次，你就会看到你得到不同的结果。节流对时间非常敏感。
- en: '`throttleFirst()` outputs `[8, 11, 15, 17, 21]` because it received the following
    windows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleFirst()` 输出 `[8, 11, 15, 17, 21]`，因为它接收到了以下窗口：'
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that `[22]` is throttled and never printed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`[22]`被节流并且从未打印出来。
- en: 'Now, let''s see what happens when we use `throttleLast()`, instead:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们使用`throttleLast()`时会发生什么：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`throttleLast()` outputs `[10, 13, 16, 19, 22]` because it received the following
    windows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleLast()`输出`[10, 13, 16, 19, 22]`，因为它接收到了以下窗口：'
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Again, `[22]` is throttled and never printed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`[22]`被节流并且从未打印出来。
- en: Throttling is the last resiliency tool we'll discuss in this chapter, but it's
    probably one of the most useful ones.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 节流是本章我们将讨论的最后一种弹性工具，但它可能是最有用的之一。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the main benefits of reactive systems. Such
    systems should be responsive, resilient, elastic, and driven by messaging.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了反应式系统的主要好处。这些系统应该是响应的、弹性的、可伸缩的，并由消息驱动。
- en: We also discussed the Java 9 Reactive Streams API and its most popular implementation,
    which is Rx.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Java 9反应式流API及其最流行的实现，即Rx。
- en: Now you should better understand the difference between cold and hot `Observable`.
    A cold `Observable` starts working only when someone subscribes to it. A hot `Observable`,
    on the other hand, always emits events, even if nobody is listening.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该更好地理解了冷`Observable`和热`Observable`之间的区别。一个冷`Observable`只有在有人订阅它时才开始工作。另一方面，热`Observable`始终发出事件，即使没有人监听。
- en: We also discussed the concept of backpressure, implemented with `Flowable`.
    It allows for a feedback mechanism between the producer and consumer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了`Flowable`实现的背压概念。它允许生产者和消费者之间有反馈机制。
- en: In addition, you should be familiar with the notion of multicasting using subjects.
    It allows us to send the same message to multiple listeners.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该熟悉使用主题进行多播的概念。它允许我们向多个监听器发送相同的消息。
- en: Finally, we discussed some resilience mechanisms, such as buffering and throttling,
    that allow us to accumulate or drop messages, in case we're unable to process
    them in time.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些弹性机制，例如缓冲和节流，这些机制允许我们在无法及时处理消息时积累或丢弃消息。
- en: In the next chapter, we'll start discussing threads, a concept that should be
    familiar to you if you come from a Java background, and coroutines, which are
    lightweight threads introduced in Kotlin 1.1.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始讨论线程，如果你有Java背景，你应该熟悉这个概念，以及协程，这是Kotlin 1.1中引入的轻量级线程。
