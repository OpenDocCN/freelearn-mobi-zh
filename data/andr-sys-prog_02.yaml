- en: Setting Up the Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'After the introduction about system programming in the last chapter, we need
    to set up a development environment first before we can go further. We need to
    know how to build and test **Android Open Source Project** (**AOSP**) while we
    explore various Android system programming topics in this book. We will cover
    the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章介绍系统编程之后，我们需要首先设置一个开发环境，然后我们才能继续前进。在我们探索本书中各种 Android 系统编程主题的同时，我们需要了解如何构建和测试
    **Android 开源项目（AOSP**）。在本章中，我们将涵盖以下主题：
- en: Installing the Android SDK and setting up an Android Virtual Device
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Android SDK 和设置 Android 虚拟设备
- en: Setting up the AOSP build environment and building a testing image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 AOSP 构建环境和构建测试镜像
- en: Creating your own source code repository mirror
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的源代码仓库镜像
- en: Summary of Android versions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 版本总结
- en: Since we will use Android emulator as one of the virtual hardware platforms,
    we need to use one particular Android version throughout this book. At the time
    of writing, the latest Android version is Android 7 (Nougat). We will use Android
    7 throughout the book. I started work on this book with Android 6, so the source
    code for Android 6 is also available in my GitHub repository at [https://github.com/shugaoye](https://github.com/shugaoye).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 Android 模拟器作为虚拟硬件平台之一，因此在这本书中我们需要使用特定的 Android 版本。在撰写本书时，最新的 Android
    版本是 Android 7（牛轧糖）。本书将使用 Android 7。我开始这本书的工作时使用的是 Android 6，因此 Android 6 的源代码也存放在我的
    GitHub 仓库中，网址为 [https://github.com/shugaoye](https://github.com/shugaoye)。
- en: From the first release to Android 7, both the development environment and the
    AOSP source code have been changed a lot. We will have a brief look at various
    Android versions first before we talk about the development environment setup.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个版本到 Android 7，开发环境和 AOSP 源代码都发生了很大变化。在我们讨论开发环境设置之前，我们将简要回顾各种 Android 版本。
- en: 'To set up the AOSP build environment, there are two things that you need to
    pay special attention to the host environment and Java SDK. Even though the recommended
    host environment is Ubuntu running on Intel architecture, the hardware architecture
    and Ubuntu versions have changed from release to release. You can always refer
    to the following URL at Google for the latest AOSP build environment setup:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 AOSP 构建环境，有两件事需要特别注意：主机环境和 Java SDK。尽管推荐的宿主环境是运行在英特尔架构上的 Ubuntu，但硬件架构和 Ubuntu
    版本从发布到发布都有所变化。你可以始终参考以下 Google 的 URL 获取最新的 AOSP 构建环境设置：
- en: '[https://source.android.com/source/index.html](https://source.android.com/source/index.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://source.android.com/source/index.html](https://source.android.com/source/index.html)'
- en: For Gingerbread (2.3.x) and above, a 64-bit build environment is required. For
    older versions, the build environment is 32-bit systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gingerbread（2.3.x）及以上版本，需要 64 位构建环境。对于较旧版本，构建环境是 32 位系统。
- en: The Ubuntu versions used range from Ubuntu 10.04 to 14.04, but for each release
    there is a recommended Ubuntu version. If it is a new setup, it is suggested to
    use the recommended Ubuntu version to make the job easier. However, there are
    no hard requirements here. You should be able to use any Ubuntu version higher
    than the recommended Ubuntu version. There are also many articles about how to
    set up the AOSP build using a different Linux distribution such as RedHat or Debain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的 Ubuntu 版本范围从 Ubuntu 10.04 到 14.04，但对于每个版本都有一个推荐的 Ubuntu 版本。如果是新的设置，建议使用推荐的
    Ubuntu 版本来使工作更简单。然而，这里没有硬性要求。你应该能够使用比推荐版本更高的任何 Ubuntu 版本。也有很多关于如何使用不同的 Linux 发行版（如
    RedHat 或 Debain）设置 AOSP 构建的文章。
- en: Oracle JDK was used to build AOSP until Lollipop. From Lollipop and the above,
    OpenJDK was used instead of Oracle JDK.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lollipop 及以上版本中，使用 OpenJDK 替代了 Oracle JDK，用于构建 AOSP。
- en: The following table summarizes all Android releases, required hosts, and JDK
    environments until Nougat; you can refer to it for full details.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了直到 Nougat 的所有 Android 发布、所需主机和 JDK 环境；你可以参考它以获取详细信息。
- en: '**AOSP releases**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**AOSP 发布**：'
- en: '| **Nickname** | **AOSP** | **SDK API level** | **Host** | **JDK** | **OS/Ubuntu**
    | **Goldfish** | **Ranchu** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **昵称** | **AOSP** | **SDK API 级别** | **主机** | **JDK** | **操作系统/Ubuntu** |
    **Goldfish** | **Ranchu** |'
- en: '| Cupcake | 1.5 | 3 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Cupcake | 1.5 | 3 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Donut | 1.6 | 4 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Donut | 1.6 | 4 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Eclair | 2.0/2.1 | 5 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Eclair | 2.0/2.1 | 5 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Eclair | 2.0.1 | 6 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 甜点 | 2.0.1 | 6 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Eclair | 2.1 | 7 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 甜点 | 2.1 | 7 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Froyo | 2.2 | 8 | x86 | Oracle JDK 5 | 10.04 | x |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 甜甜圈 | 2.2 | 8 | x86 | Oracle JDK 5 | 10.04 | x |  |'
- en: '| Gingerbread | 2.3.1 | 9 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 甜点 | 2.3.1 | 9 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Gingerbread | 2.3.3 | 10 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 姜饼 | 2.3.3 | 10 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Honeycomb | 3.0 | 11 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 蜂巢 | 3.0 | 11 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Honeycomb | 3.1 | 12 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 蜂巢 | 3.1 | 12 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Honeycomb | 3.2 | 13 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 蜂巢 | 3.2 | 13 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Ice Cream Sandwich | 4.0 | 14 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 冰淇淋三明治 | 4.0 | 14 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Ice Cream Sandwich | 4.0.3 | 15 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 冰淇淋三明治 | 4.0.3 | 15 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Jelly Bean | 4.1.2 | 16 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 姜饼 | 4.1.2 | 16 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Jelly Bean | 4.2.2 | 17 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 姜饼 | 4.2.2 | 17 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| Jelly Bean | 4.3.1 | 18 | x64 | Oracle JDK 6 | 12.04 | x |  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 姜饼 | 4.3.1 | 18 | x64 | Oracle JDK 6 | 12.04 | x |  |'
- en: '| KitKat | 4.4.2 | 19 | x64 | Oracle JDK 6 | 12.04 | x | x |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 4.4.2 | 19 | x64 | Oracle JDK 6 | 12.04 | x | x |'
- en: '| KitKat | 4.4W.2 | 20 | x64 | Oracle JDK 6 | 12.04 | x | x |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 4.4W.2 | 20 | x64 | Oracle JDK 6 | 12.04 | x | x |'
- en: '| Lollipop | 5.0.1 | 21 | x64 | Open JDK 7 | 12.04 | x | x |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 5.0.1 | 21 | x64 | Open JDK 7 | 12.04 | x | x |'
- en: '| Lollipop | 5.1.1 | 22 | x64 | Open JDK 7 | 12.04 | x | x |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 5.1.1 | 22 | x64 | Open JDK 7 | 12.04 | x | x |'
- en: '| Mashmallow | 6.0 | 23 | x64 | Open JDK 7 | 14.04 | x | x |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 6.0 | 23 | x64 | Open JDK 7 | 14.04 | x | x |'
- en: '| Nougat | 7.0.x | 24 | x64 | Open JDK 8 | 14.04 | x | x |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 7.0.x | 24 | x64 | Open JDK 8 | 14.04 | x | x |'
- en: '| Nougat | 7.1.1 | 25 | x64 | Open JDK 8 | 14.04 | x | x |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 棉花糖 | 7.1.1 | 25 | x64 | Open JDK 8 | 14.04 | x | x |'
- en: From the preceding table, you can see that the ranchu emulator is supported
    by KitKat and the others. If you install and download the system image of Kitkat
    or the others on Android SDK, you should be able to find two kernel files, `kernel-qemu`
    and `kernel-ranchu`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表格中，你可以看到ranchu模拟器支持KitKat和其他系统。如果你在Android SDK上安装并下载KitKat或其他系统的系统镜像，你应该能够找到两个内核文件，`kernel-qemu`和`kernel-ranchu`。
- en: There are two API levels in the Nougat releases. Android 7.0.0 and 7.1.0 are
    API level 24\. Android 7.1.1 and 7.1.2 are API level 25\. All source code in this
    book can support up to API level 25.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Nougat版本中有两个API级别。Android 7.0.0和7.1.0是API级别24。Android 7.1.1和7.1.2是API级别25。本书中的所有源代码都支持到API级别25。
- en: The code name of the original Android emulator is goldfish. It is based on an
    older version of QEMU. A new Android emulator version was released based on QEMU
    2.x in 2016\. The code name of this new emulator is ranchu. It is supported by
    KitKat and the others.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Android模拟器的代号是goldfish。它基于较老版本的QEMU。2016年基于QEMU 2.x发布了一个新的Android模拟器版本。这个新模拟器的代号是ranchu。它支持KitKat和其他系统。
- en: Installing Android SDK and setting up an Android Virtual Device
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Android SDK并设置Android虚拟设备
- en: Ideally, if you have an AOSP build environment, you can build everything including
    Android SDK from scratch. However, it is much more convenient to have an Android
    SDK installation to help with virtual device creation or running emulator images.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，如果你有一个AOSP构建环境，你可以从头开始构建包括Android SDK在内的所有内容。然而，拥有一个Android SDK安装包来帮助创建虚拟设备或运行模拟器镜像要方便得多。
- en: 'You can always download the latest Android SDK from the following website:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下网站始终下载最新的Android SDK：
- en: '[https://developer.android.com/index.html](https://developer.android.com/index.html)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/index.html](https://developer.android.com/index.html)'
- en: The host environment that we use in this book is Ubuntu 14.04\. Download the
    Android SDK for Linux and decompress it to a folder in your `Home` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的宿主环境是Ubuntu 14.04。下载适用于Linux的Android SDK并将其解压缩到你的`Home`目录下的一个文件夹中。
- en: The tools in Android SDK have been changed since API level 25\. You may use
    an older version of Android SDK or the latest Android SDK so I gave the instructions
    for both cases here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK中的工具自API级别25以来已经发生了变化。你可以使用较旧的Android SDK或最新的Android SDK，因此我在这里提供了两种情况的说明。
- en: Creating AVD in an older version of SDK
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在较旧版本的SDK中创建AVD
- en: 'For the older version of SDK, such as `android-sdk_r24.4.1-linux.tgz`, it includes
    all necessary components and we can use it after decompression. We can find the
    following contents after decompressing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的 SDK 版本，例如 `android-sdk_r24.4.1-linux.tgz`，它包含所有必要的组件，我们可以在解压缩后使用它。解压缩后，我们可以找到以下内容：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can add the `platform-tools` and `tools` directory to your `PATH` environment
    variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `platform-tools` 和 `tools` 目录添加到你的 `PATH` 环境变量中。
- en: We will use a virtual device based on API level 25 in this book to test our
    image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用基于 API 级别 25 的虚拟设备来测试我们的镜像。
- en: 'To create a virtual device, we can launch **Android Virtual Device** (**AVD**)
    Manager using the following command, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建虚拟设备，我们可以使用以下命令启动 **Android 虚拟设备**（**AVD**）管理器，如下面的截图所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/image_02_001.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_001.png)'
- en: AVD Manager
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AVD 管理器
- en: 'Click the Create... button in AVD Manager and create a new virtual device named
    `a25x86` with the following configuration, as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AVD 管理器中单击“创建...”按钮，创建一个名为 `a25x86` 的新虚拟设备，配置如下，如下面的截图所示：
- en: Android 7.1.1 - API level 25
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 7.1.1 - API 级别 25
- en: 1024 MB RAM
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1024 MB RAM
- en: 400 MB SD card
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 MB SD 卡
- en: 400 MB internal storage
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 MB 内部存储
- en: 'Display size at 480 x 800: hdpi'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示尺寸为 480 x 800：hdpi
- en: '![](img/image_02_002.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_002.png)'
- en: Android Virtual Device a25x86
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Android 虚拟设备 a25x86
- en: Creating AVD in the latest version of SDK
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最新版本的 SDK 中创建 AVD
- en: 'For the newer versions, there is only SDK command-line tools available for
    download. For example, if you download the command-line tools for r25, such as
    `tools_r25.2.3-linux.zip`, you can find the `tools` folder only. In this case,
    you need to use Android SDK Manager at `tools/bin/sdkmanager` to download the
    rest of SDK components. To download the rest of SDK components, you can use the
    following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较新版本，只有 SDK 命令行工具可供下载。例如，如果你下载了 r25 的命令行工具，如 `tools_r25.2.3-linux.zip`，你只能找到
    `tools` 文件夹。在这种情况下，你需要使用 Android SDK 管理器在 `tools/bin/sdkmanager` 中下载其余的 SDK 组件。要下载其余的
    SDK 组件，你可以使用以下命令：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you use the latest version of Android SDK, you may get the following error
    message, if you follow the previous instructions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是最新版本的 Android SDK，如果你遵循前面的说明，你可能会得到以下错误消息：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, you can create AVD using the following command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用以下命令创建 AVD。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing the goldfish emulator
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 goldfish 模拟器
- en: 'In Android 7, both the ranchu and goldfish emulators are supported. Let''s
    test the goldfish emulator first. We can run this virtual device in the goldfish
    emulator using the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 7 中，ranchu 和 goldfish 模拟器都受到支持。让我们首先测试 goldfish 模拟器。我们可以使用以下命令在 goldfish
    模拟器中运行此虚拟设备：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To monitor the status of a virtual device, we can use the following Android
    emulator options:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要监控虚拟设备的状态，我们可以使用以下 Android 模拟器选项：
- en: '`-verbose`: Shows the emulator debug information.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-verbose`: 显示模拟器调试信息。'
- en: '`-show-kernel`: Shows kernel debug information.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-show-kernel`: 显示内核调试信息。'
- en: '`-shell`: Uses `stdio` as the command line prompt.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-shell`: 使用 `stdio` 作为命令行提示符。'
- en: '`-engine`: Selects the emulator engine. The choice can be `auto`, `classic`,
    or `qemu2`. The `classic` option is to use the goldfish emulator and the `qemu2`
    option is to use the ranchu emulator. If the option is `auto` or without the `engine`
    option, the system will check the environment and try to launch ranchu first.
    If it fails, it will fall back to goldfish.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-engine`: 选择模拟器引擎。选项可以是 `auto`、`classic` 或 `qemu2`。`classic` 选项是使用 goldfish
    模拟器，而 `qemu2` 选项是使用 ranchu 模拟器。如果选项是 `auto` 或没有 `engine` 选项，系统将检查环境并尝试首先启动 ranchu。如果失败，将回退到
    goldfish。'
- en: From the preceding log, we can see that the `kernel-qemu` kernel file is used
    for the goldfish emulator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的日志中，我们可以看到 goldfish 模拟器使用的是 `kernel-qemu` 内核文件。
- en: Both the ranchu and goldfish emulators are developed on top of QEMU, but they
    use different kernel and QEMU versions. We can verify the QEMU version used for
    either goldfish or ranchu using the following emulator commands.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ranchu 和 goldfish 模拟器都是在 QEMU 的基础上开发的，但它们使用不同的内核和 QEMU 版本。我们可以使用以下模拟器命令验证 goldfish
    或 ranchu 使用的 QEMU 版本。
- en: 'To verify the QEMU version used by goldfish, we can run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 goldfish 使用的 QEMU 版本，我们可以运行以下命令：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the preceding output, we can see that QEMU version 0.10.50 is used for
    the goldfish emulator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到 goldfish 模拟器使用的是 QEMU 版本 0.10.50。
- en: 'For the latest emulator version, it seems there is a bug with regard to handling
    the classic engine. You may get the following error message, when you execute
    the preceding command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最新的模拟器版本，似乎在处理经典引擎方面存在一个错误。当你执行前面的命令时，可能会得到以下错误信息：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The emulator command is a wrapper for QEMU. Any command-line options after `-qemu`
    are passed to QEMU as the command lines of QEMU directly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器命令是 QEMU 的包装器。任何 `-qemu` 之后的所有命令行选项都直接作为 QEMU 的命令行传递给 QEMU。
- en: 'To find out the emulator version, we can use the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出模拟器版本，我们可以使用以下命令：
- en: '`**$ emulator -version**` The following command will show the QEMU version:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ emulator -version**` 以下命令将显示 QEMU 版本：'
- en: '`**$ emulator -qemu -version**`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ emulator -qemu -version**`'
- en: 'After the Android device has started successfully, from the Android UI, we
    can go to Settings -> About Phone and see the screen shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 设备成功启动后，从 Android UI，我们可以进入设置 -> 关于手机，并查看以下截图所示的屏幕：
- en: '![](img/image_02_003.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: Android kernel version of goldfish
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: goldfish 的 Android 内核版本
- en: 'Pay attention to the following information on the About Phone screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意关于“关于手机”屏幕上的以下信息：
- en: 'Android version: 7.1'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 版本：7.1
- en: 'Kernel version: 3.4.67'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核版本：3.4.67
- en: 'Build number: sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建号：`sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys`
- en: As we can see from the preceding information, the kernel version is `3.4.67`
    and the filesystem build number is `sdk_google_phone_x86-userdebug 7.1 NPF26K
    3479480 test-keys` for goldfish emulator. In the next section, we can see that
    ranchu emulator uses a different kernel version, even though both emulators share
    the same filesystem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的信息所示，内核版本是 `3.4.67`，文件系统构建号是 `sdk_google_phone_x86-userdebug 7.1 NPF26K
    3479480 test-keys`，针对金鱼模拟器。在下一节中，我们可以看到 ranchu 模拟器使用不同的内核版本，尽管这两个模拟器共享相同的文件系统。
- en: 'The Android system build includes two parts: the AOSP system and an Android-compatible
    Linux kernel. The build result of the AOSP system includes all image files for
    the Android system except the kernel image. They are built separately and are
    also under difference licenses. The preferred license for the AOSP is the Apache
    Software License, while the Linux kernel is under the GPLv2 License. Be aware
    of this difference. It also means that the AOSP build doesn''t include the kernel
    build. We have to build the kernel separately. We can also use different kernel
    images with the same filesystem as in the test of the goldfish and ranchu emulator.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Android 系统构建包括两部分：AOSP 系统和一个兼容 Android 的 Linux 内核。AOSP 系统的构建结果包括 Android 系统的所有镜像文件，除了内核镜像。它们是分别构建的，并且也处于不同的许可之下。AOSP
    的首选许可协议是 Apache 软件许可协议，而 Linux 内核则处于 GPLv2 许可协议之下。请注意这一差异。这也意味着 AOSP 构建不包括内核构建。我们必须单独构建内核。我们还可以使用与金鱼和
    ranchu 模拟器测试中相同的文件系统使用不同的内核镜像。
- en: When we talk about the Android version, we have to look into the details of
    the kernel version and filesystem build number.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 Android 版本时，我们必须查看内核版本和文件系统构建号的详细信息。
- en: Testing ranchu emulator
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 ranchu 模拟器
- en: 'We can test ranchu emulator as well with the same virtual device. We can use
    a similar command without the `-engine` option or with the `-engine qemu2` option
    to start ranchu emulator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同的虚拟设备测试 ranchu 模拟器。我们可以使用不带 `-engine` 选项或带有 `-engine qemu2` 选项的类似命令来启动
    ranchu 模拟器：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding log, we can see that the kernel file `kernel-ranchu` is used
    in ranchu emulator.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的日志中，我们可以看到在 ranchu 模拟器中使用内核文件 `kernel-ranchu`。
- en: 'We can also verify the QEMU version used by ranchu emulator using the following
    command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令验证 ranchu 模拟器使用的 QEMU 版本：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that ranchu uses a much newer QEMU version that can support many
    new features, which we will discuss later in this book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 ranchu 使用了一个支持许多新特性的较新版本的 QEMU，我们将在本书的后续章节中讨论这些特性。
- en: 'Again, let''s review the version information in Settings as we did for goldfish
    emulator; refer to the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们回顾一下设置中的版本信息，就像我们为金鱼模拟器所做的那样；参见图下所示：
- en: '![](img/image_02_004.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004.png)'
- en: Android kernel version of ranchu
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ranchu 的 Android 内核版本
- en: We can see that the ranchu emulator uses the kernel version 3.10.0, which is
    different from the goldfish emulator. The filesystem build is the same as for
    the goldfish emulator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 ranchu 模拟器使用的是内核版本 3.10.0，这与金鱼模拟器不同。文件系统构建与金鱼模拟器相同。
- en: The AOSP build environment and the Android emulator build
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOSP 构建环境和 Android 模拟器构建
- en: In order to create our own Android system, we have to set up the AOSP build
    environment and build our own AOSP target for the Android emulator. Since Android
    is under rapid development, the build process and environment setup can change
    from time to time. You can always refer to Google's website for the latest information,
    [https://source.android.com/source/building.html](https://source.android.com/source/building.html).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们自己的Android系统，我们必须设置AOSP构建环境并构建用于Android模拟器的AOSP目标。由于Android正在快速发展，构建过程和环境设置可能会随时发生变化。您始终可以参考谷歌的网站以获取最新信息，[https://source.android.com/source/building.html](https://source.android.com/source/building.html)。
- en: While the Google website and other sources can give general guidelines and procedures
    about the AOSP build, in this section we will look specifically at how to build
    AOSP for Android emulator image for API level 25.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然谷歌网站和其他资源可以提供关于AOSP构建的一般指南和程序，但在本节中，我们将具体探讨如何为API级别25的Android模拟器镜像构建AOSP。
- en: The AOSP build environment
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOSP构建环境
- en: Since we want to set up a build environment for API level 25, you can refer
    to the table of AOSP releases for the basic requirements about the host and JDK.
    It is recommended to use the Ubuntu 14.04 64-bit host with Open JDK 8\. For the
    hardware requirement, you may want to have a powerful enough computer with at
    least 8 GB RAM and 500 GB hard disk space.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要为API级别25设置构建环境，您可以参考AOSP发布表以获取主机和JDK的基本要求。建议使用64位的Ubuntu 14.04主机和Open
    JDK 8。对于硬件要求，您可能需要一个至少拥有8 GB RAM和500 GB硬盘空间的强大计算机。
- en: Installing the required packages
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的软件包
- en: 'We use the Ubuntu 14.04 64-bit version as our host operating system. After
    installing Ubuntu 14.04, the first thing you have to do is to install all necessary
    software packages as follows. If you use a different Linux distribution, you can
    refer to Google''s website or search on the Internet for the relevant setup procedures.
    Let''s execute the following commands to install all necessary packages for Ubuntu
    14.04:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用64位的Ubuntu 14.04版本作为我们的宿主操作系统。在安装Ubuntu 14.04之后，您必须做的第一件事是按照以下方式安装所有必要的软件包。如果您使用的是不同的Linux发行版，您可以参考谷歌的网站或在网上搜索相关的设置程序。让我们执行以下命令来安装Ubuntu
    14.04的所有必要软件包：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing Open JDK 7 and 8
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Open JDK 7和8
- en: We will install both Open JDK 7 and 8 so we can build both Android 6 and 7 in
    our build environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装Open JDK 7和8，这样我们就可以在我们的构建环境中构建Android 6和7。
- en: 'To build Android API level 23, we need to install OpenJDK 7\. We can execute
    the following commands from the Linux console to install OpenJDK 7:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Android API级别23，我们需要安装OpenJDK 7。我们可以从Linux控制台执行以下命令来安装OpenJDK 7：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For Android 7, we need to use OpenJDK 8 to build. There are no available supported
    OpenJDK 8 packages for Ubuntu 14.04 yet, but the Ubuntu 15.04 OpenJDK 8 packages
    have been used successfully with Ubuntu 14.04\. We need to install OpenJDK 8 on
    Ubuntu 14.04 using the following instructions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android 7，我们需要使用OpenJDK 8来构建。目前还没有适用于Ubuntu 14.04的受支持的OpenJDK 8软件包，但Ubuntu
    15.04的OpenJDK 8软件包已经成功用于Ubuntu 14.04。我们需要按照以下说明在Ubuntu 14.04上安装OpenJDK 8。
- en: 'Download the `.deb` packages for 64-bit architecture from [archive.ubuntu.com](http://archive.ubuntu.com):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从[archive.ubuntu.com](http://archive.ubuntu.com)下载64位架构的`.deb`软件包：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Optionally, confirm the checksums of the downloaded files against the SHA256
    string listed with each preceding package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，确认下载文件的校验和与每个先前包中列出的SHA256字符串相匹配。
- en: 'For example, with the *sha256sum* tool:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用*sha256sum*工具：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Install the packages:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run `dpkg` for each of the `.deb` files you downloaded. It may produce errors
    due to missing dependencies:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对您下载的每个`.deb`文件运行`dpkg`。由于缺少依赖项，可能会产生错误：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To fix missing dependencies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复缺少的依赖项：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With both OpenJDK 7 and 8 installed, we can update the default Java version
    by running the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了OpenJDK 7和8之后，我们可以通过运行以下命令来更新默认的Java版本：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a build environment ready now. You may want to refer to Google's website
    to set up other things. For example, we may want to use cache to speed up the
    build or set up a separate output directory out of the AOSP tree.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了构建环境。您可能想要参考谷歌的网站来设置其他事项。例如，我们可能想要使用缓存来加速构建或设置一个独立的输出目录，不在AOSP树中。
- en: Downloading the AOSP source
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载AOSP源代码
- en: Once we have a build environment ready, we need to get the AOSP source code.
    Again, refer to Google's website or the Internet to get more information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了构建环境，我们需要获取AOSP源代码。再次，请参考谷歌的网站或互联网以获取更多信息。
- en: You need to download the Android 7 source code from [source.android.com](https://source.android.com/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[source.android.com](https://source.android.com/)下载Android 7源代码。
- en: Installing repo
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装repo
- en: 'AOSP consists of a large number of Git repositories, and we have to use the
    repo tool to manage these Git repositories. To download and install repo, we can
    use the following commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP由大量的Git仓库组成，我们必须使用repo工具来管理这些Git仓库。要下载和安装repo，我们可以使用以下命令：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Initializing a repo client and downloading the AOSP source tree
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化repo客户端并下载AOSP源代码树
- en: 'After we have the repo tool, we can initialize the repo and download the AOSP
    source tree by executing the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了repo工具之后，我们可以执行以下命令来初始化repo并下载AOSP源代码树：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pay attention to the AOSP tag `android-7.1.1_r4` here. This is the version of
    AOSP source code that we use throughout this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的AOSP标签`android-7.1.1_r4`。这是我们全书使用的AOSP源代码版本。
- en: 'It will take quite a long time to get the AOSP source tree. After we get the
    source tree, let''s take a look at the top level folders:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 获取AOSP源代码树需要相当长的时间。在获取源代码树后，让我们看看顶级文件夹：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I won't explore the details about the source tree here; we will cover this in
    [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml), *Discovering Kernel,
    HAL, and Virtual Hardware*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细探讨源代码树；我们将在[第3章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)中介绍，*发现内核、HAL和虚拟硬件*。
- en: Building AOSP Android emulator images
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 AOSP Android 模拟器镜像
- en: 'In this book, we will use x86-based emulators. The x86-based emulator can use
    virtualization technology on the host, so it is much faster than the ARM emulator.
    We want to build the one that comes with the AOSP source code first. To create
    an Android emulator build, we can execute the following commands from the AOSP
    top-level folder:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用基于x86的模拟器。基于x86的模拟器可以在主机上使用虚拟化技术，因此它比ARM模拟器快得多。我们首先想要构建的是包含AOSP源代码的那个。要从AOSP顶级文件夹执行以下命令来创建Android模拟器构建：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We set up the environment variables first using the startup script `envsetup.sh`.
    After that, we execute the command `lunch` to choose a build target. To build
    for the Android-x86 emulator, we can choose the target `aosp_x86-eng`, which will
    build an Android emulator version for x86\. To learn more about the script file
    `envsetup.sh` and command `lunch`, refer to the Google website at [https://source.android.com](https://source.android.com).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用启动脚本`envsetup.sh`设置环境变量。之后，我们执行`lunch`命令来选择构建目标。要为Android-x86模拟器构建，我们可以选择目标`aosp_x86-eng`，这将构建适用于x86的Android模拟器版本。要了解更多关于脚本文件`envsetup.sh`和命令`lunch`的信息，请参考谷歌网站[https://source.android.com](https://source.android.com)。
- en: 'The actual build is started after we execute the following `make` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下`make`命令后，实际构建开始：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The entire build time is dependent on your hardware configuration. Even on a
    high-end CORE i7 Intel processor, it may take about 40 minutes. The option `-j4`
    starts the parallel build using four processor cores. You can choose the number
    according to your computer hardware.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 整个构建时间取决于您的硬件配置。即使在高端的Intel Core i7处理器上，也可能需要大约40分钟。选项`-j4`将启动使用四个处理器核心的并行构建。您可以根据您的计算机硬件选择数字。
- en: Testing AOSP images
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试AOSP镜像
- en: 'After the build is completed, we find all images in the output folder, as shown
    in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以在输出文件夹中找到所有镜像，如下面的截图所示：
- en: '![](img/image_02_005.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005.png)'
- en: Build output of generic_x86
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: generic_x86的构建输出
- en: The AOSP build output is stored under the `$AOSP/out` folder. This folder includes
    the build results for both target and host. The build results for different devices
    are stored separately at `$AOSP/out/target/product/{device name}`. In our case,
    it is `$AOSP/out/target/product/generic_x86`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP构建输出存储在`$AOSP/out`文件夹下。此文件夹包括目标和主机的构建结果。不同设备的构建结果分别存储在`$AOSP/out/target/product/{设备名称}`下。在我们的例子中，是`$AOSP/out/target/product/generic_x86`。
- en: The images `system.img`, `userdata.img`, and `ramdisk.img` are necessary to
    run the emulator, but as you can see there is no kernel image. We will discuss
    kernel builds later in this book. For now, we will use the kernel image from Android
    SDK to test our AOSP build.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.img`、`userdata.img`和`ramdisk.img`这些镜像文件对于运行模拟器是必要的，但如您所见，这里没有内核镜像。我们将在本书的后面部分讨论内核构建。目前，我们将使用Android
    SDK中的内核镜像来测试我们的AOSP构建。'
- en: 'To test using our AOSP images, we can create a script as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的AOSP镜像进行测试，我们可以创建以下脚本：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can put this script `test_aosp.sh` in the `$HOME/bin` folder. Usually, we
    can add `$HOME/bin` to the executable search `path` variable so that we can run
    this script `test_aosp.sh` from the command line as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个脚本 `test_aosp.sh` 放在 `$HOME/bin` 文件夹中。通常，我们可以将 `$HOME/bin` 添加到可执行搜索 `path`
    变量中，这样我们就可以在命令行中如下运行这个脚本 `test_aosp.sh`：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you test your AOSP build using Android 6 or earlier, you need to use classic
    engines instead of ranchu. The ranchu build has a problem in the Android 6 AOSP
    build, but this issue has been fixed in the Android 7 build. To support ranchu
    in the 6.0.1 AOSP build, we have to change the manifest to include the latest
    emulator device. The Android SDK release doesn't have this issue. Google fixed
    this issue internally, but didn't publish the fixes until Android 7.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Android 6 或更早的版本测试你的 AOSP 构建，你需要使用经典引擎而不是 ranchu。ranchu 构建在 Android 6
    AOSP 构建中有一个问题，但在 Android 7 构建中这个问题已经被修复。为了在 6.0.1 AOSP 构建中支持 ranchu，我们必须更改清单以包含最新的模拟器设备。Android
    SDK 发布版没有这个问题。谷歌内部修复了这个问题，但直到 Android 7 才发布修复。
- en: 'After the emulator starts, we can check the version information as we did before.
    In the following screenshot, we can see the version information in AOSP images:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器启动后，我们可以检查版本信息，就像之前做的那样。在下面的屏幕截图中，我们可以看到 AOSP 图像中的版本信息：
- en: '![](img/image_02_006.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_006.png)'
- en: Android version of AOSP image
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP 图像的 Android 版本
- en: As we can see, kernel version 3.10.0 is used; this is because we use the ranchu
    emulator. Let's compare the information with SDK images that we tested before.
    From the following table, we can see that the model number is AOSP on IA Emulator
    instead of sdk. The Android version is 7.1 for SDK and 7.1.1 for AOSP. The AOSP
    image build number is the build target `aosp_x86-eng`, which we chose previously,
    and this also includes the date and time of the build.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用了内核版本 3.10.0；这是因为我们使用了 ranchu 模拟器。让我们将信息与之前测试的 SDK 图像进行比较。从下面的表格中，我们可以看到模型号是
    IA 模拟器上的 AOSP 而不是 sdk。SDK 的 Android 版本是 7.1，而 AOSP 的版本是 7.1.1。AOSP 图像的构建号是构建目标
    `aosp_x86-eng`，这是我们之前选择的，这也包括了构建的日期和时间。
- en: '**SDK and AOSP versions**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**SDK 和 AOSP 版本**：'
- en: '|  | **SDK (goldfish)** | **SDK (ranchu)** | **AOSP** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  | **SDK (goldfish)** | **SDK (ranchu)** | **AOSP** |'
- en: '| Model | sdk | sdk | AOSP on IA Emulator |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | sdk | sdk | IA 模拟器上的 AOSP |'
- en: '| Android version | 7.1 | 7.1 | 7.1.1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Android 版本 | 7.1 | 7.1 | 7.1.1 |'
- en: '| Kernel version | 3.4.67 | 3.10.0 | 3.10.0 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 内核版本 | 3.4.67 | 3.10.0 | 3.10.0 |'
- en: '| Build number | sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys
    | sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys | aosp_x86-eng 7.1.1
    NMF26O eng.sgye 20170126.183237 test-keys |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 构建号 | sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys | sdk_google_phone_x86-userdebug
    7.1 NPF26K 3479480 test-keys | aosp_x86-eng 7.1.1 NMF26O eng.sgye 20170126.183237
    test-keys |'
- en: Creating your own repository mirror
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的仓库镜像
- en: It usually takes a very long time to download the AOSP source code. After you
    have downloaded the AOSP source code, you have actually downloaded a specific
    version of the AOSP source code from the remote repository. You may have to test
    different configurations or versions in your development work. It is a very time-consuming
    task to switch to a different version or create a new copy of the AOSP source
    code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 AOSP 源代码通常需要非常长的时间。在你下载了 AOSP 源代码之后，实际上你已经从远程仓库下载了 AOSP 源代码的特定版本。在你的开发工作中，你可能需要测试不同的配置或版本。切换到不同的版本或创建
    AOSP 源代码的新副本是一个非常耗时的工作。
- en: In this book, we will use the AOSP source code as the base for our development.
    To reuse some of the existing open source projects that are not included in AOSP,
    we have to modify the repo manifest from time to time. This involves changing
    the repo configuration. To work more efficiently, we can use a local mirror. It
    can save a lot of time to create a local mirror instead of downloading source
    code from remote repositories for all configuration changes. It may take hours
    to change a configuration from a remote repository, but it will need just a few
    minutes with the local repository.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 AOSP 源代码作为我们开发的基线。为了重用一些不包括在 AOSP 中的现有开源项目，我们不得不不时修改 repo 清单。这涉及到更改
    repo 配置。为了更有效地工作，我们可以使用本地镜像。创建本地镜像可以节省大量时间，而不是从远程仓库下载所有配置更改的源代码。从一个远程仓库更改配置可能需要数小时，但使用本地仓库只需要几分钟。
- en: When we work with open source projects, the server to host the project may change
    from time to time. It is always good to have your own mirror so that we won't
    rely too much on the remote repositories. With a local mirror, we can still work
    without too much impact even though the remote server may be not available for
    a certain period. This is exactly the issue that I face when I try to integrate
    Android-x86 projects in the later part of this book.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理开源项目时，托管项目的服务器可能会不时更改。拥有自己的镜像总是很好的，这样我们就不会过于依赖远程仓库。即使远程服务器在一段时间内不可用，我们仍然可以继续工作。这正是我在尝试将
    Android-x86 项目集成到本书的后期部分时遇到的问题。
- en: I will explain how to create a mixed local mirror of AOSP, Android-x86, and
    GitHub in this section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本节中解释如何创建 AOSP、Android-x86 和 GitHub 的混合本地镜像。
- en: Repo and manifest
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Repo 和 manifest
- en: To create and manage repository mirrors, we need to understand the `repo` command
    and the directory structure managed by `repo` a little more. The `repo` command
    deals with a XML file manifest and it stores everything in a folder called `.repo`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和管理仓库镜像，我们需要更深入地了解 `repo` 命令和 `repo` 管理的目录结构。`repo` 命令处理 XML 文件 manifest，并将所有内容存储在名为
    `.repo` 的文件夹中。
- en: 'After we run the `repo init` command as we did in the previous section, a `.repo`
    folder is created under the current folder. If we take a look at the `.repo` folder,
    we can see the following contents:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们像上一节那样运行 `repo init` 命令之后，当前文件夹下会创建一个 `.repo` 文件夹。如果我们查看 `.repo` 文件夹，我们可以看到以下内容：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Three folders and a symbolic link are created. The following is an explanation
    of each:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了三个文件夹和一个符号链接。以下是每个的解释：
- en: '`manifests`: This is a working copy of the Git repository of the manifest itself.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifests`：这是 manifest 本身 Git 仓库的工作副本。'
- en: '`manifests.git`: This is the Git repository of the manifest. The manifest itself
    is under the version control using Git.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifests.git`：这是 manifest 的 Git 仓库。manifest 本身使用 Git 进行版本控制。'
- en: '`manifest.xml`: This is a symbolic link to the file `.repo/manifests/default.xml`.
    This file is the main configuration file used by `repo`. We will look into the
    details later.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifest.xml`：这是到文件 `.repo/manifests/default.xml` 的符号链接。这是 `repo` 使用的配置文件。我们稍后会详细了解。'
- en: '`repo`: The repo tool itself is written in the Python language. Python scripts
    are stored in this folder.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repo`：repo 工具本身是用 Python 语言编写的。Python 脚本存储在这个文件夹中。'
- en: 'After we run the `repo init` command to initialize the repo data structure,
    we can run the `repo sync` command to retrieve a working copy. If we look at the
    `.repo` folder again after the `repo sync` command, we can see that there are
    two project related folders created:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行 `repo init` 命令初始化 repo 数据结构之后，我们可以运行 `repo sync` 命令来检索工作副本。如果我们再次查看 `.repo`
    文件夹，在 `repo sync` 命令之后，我们可以看到创建了两个与项目相关的文件夹：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is an explanation of the newly created file and folders:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对新创建的文件和文件夹的解释：
- en: '`project.list`: This is a list of all projects downloaded.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.list`：这是所有下载项目的列表。'
- en: '`project-objects`: This is a copy of the remote repository.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project-objects`：这是远程仓库的副本。'
- en: '`projects`: This is the repository hierarchy matching the working copy. The
    path may be rearranged after a repository is copied to local. The contents in
    this folder are symbolic links to the items in `project-objects`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projects`：这是与工作副本匹配的仓库层次结构。在仓库复制到本地后，路径可能会重新排列。这个文件夹中的内容是 `project-objects`
    中项的符号链接。'
- en: The most important file in the `.repo` folder is `.repo/manifests/default.xml`
    or its symbolic link `manifest.xml`. The detailed specification of this file can
    be found in the document under the `.repo` folder at `.repo/repo/docs/manifest-format.txt`.
    We won't go into any details, but let's take look at the most commonly used elements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`.repo` 文件夹中最重要的文件是 `.repo/manifests/default.xml` 或其符号链接 `manifest.xml`。该文件的详细规范可以在
    `.repo` 文件夹下的 `.repo/repo/docs/manifest-format.txt` 文档中找到。我们不会深入细节，但让我们看看最常用的元素。'
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code snippet, we can see that there are three XML elements
    inside manifest:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到在 manifest 中有三个 XML 元素：
- en: '`remote`: The `remote` element provides the details about remote repository.
    We can give it a name such as `aosp`. The URL of the remote repository can be
    specified in the `fetch` field. It can be a relative path or a full path.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote`：`remote` 元素提供了远程仓库的详细信息。我们可以给它起一个名字，例如 `aosp`。远程仓库的 URL 可以在 `fetch`
    字段中指定。它可以是相对路径或完整路径。'
- en: '`default`: There are multiple `remote` elements that can be specified in manifest.
    The `default` element defines which `remote` is the default one.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 清单中可以指定多个`remote`元素。`default`元素定义了哪个`remote`是默认的。'
- en: '`project`: Each `project` element defines a Git repository. The `path` field
    supplies the local path after it is downloaded. The `name` field supplies the
    remote path of the Git repository. The `revision` field supplies the branch that
    we want to get and the `remote` field tells us which remote server we use to get
    the Git repository.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project`: 每个`project`元素定义了一个Git仓库。`path`字段提供下载后的本地路径，`name`字段提供Git仓库的远程路径，`revision`字段提供我们想要获取的分支，`remote`字段告诉我们我们使用哪个远程服务器来获取Git仓库。'
- en: There are other XML elements that can be used in manifest as well. You can find
    out what they are by looking at the preceding specification yourself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 清单中还可以使用其他XML元素。你可以通过查看前面的规范来了解它们是什么。
- en: Using a local mirror for AOSP
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地镜像进行AOSP
- en: 'If you refer to the article from the Google website about downloading the source,
    you can find a section called *Using a local mirror*. It reveals that if you need
    two different configurations of the AOSP build environment, the download for two
    clients is larger than the size of a full mirror of the repository. It is very
    simple to set up a mirror as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考谷歌网站上的关于下载源的文章，你可以找到一个名为*使用本地镜像*的部分。它揭示，如果你需要两个不同的AOSP构建环境配置，两个客户端的下载大小将大于整个仓库镜像的大小。设置镜像非常简单，如下所示：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the preceding commands, we can see that we actually use a different manifest
    to create a mirror. If we look at the content of the manifest for a mirror, we
    can see the following XML code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到我们实际上使用不同的清单来创建镜像。如果我们查看镜像清单的内容，我们可以看到以下XML代码：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can see that for all projects, there are only the project names without other
    information in each project item. This is because we actually copy each Git repository
    to the local as a bare Git repository. We won't check out a working copy, so we
    don't need to worry about the version.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于所有项目，每个项目项中只有项目名称，没有其他信息。这是因为我们实际上将每个Git仓库复制到本地作为一个裸Git仓库。我们不会检出工作副本，所以我们不需要担心版本。
- en: 'If we look at the manifest to check out a working copy, we will see the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看清单以检出工作副本，我们将看到以下内容：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It includes more items than the one to create a mirror. The `name` field specifies
    the path at the remote repository and the `path` field specifies the local path
    after the repository is downloaded to the local. We also need to specify `revision`
    that we want to retrieve.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含的项比创建镜像的项更多。`name`字段指定远程仓库的路径，`path`字段指定下载到本地的本地路径。我们还需要指定我们想要检索的`revision`。
- en: 'After we have a mirror, we can check out a copy of the AOSP source from that
    mirror as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有一个镜像之后，我们可以按照以下方式从该镜像检出AOSP源的一个副本：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you need, you can check out multiple copies from the local mirror. No matter
    if you check out multiple copies or you change to a different version, you can
    save a lot of time compared to checking out from a remote repository.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以从本地镜像检出多个副本。无论你是检出多个副本还是切换到不同的版本，与从远程仓库检出相比，你可以节省很多时间。
- en: When you work on a system-level project, you may need projects out of the AOSP
    source. For example, in this book, we use multiple projects from CyanogenMod,
    Android-x86, and my own projects in GitHub. In this case, we can actually create
    our own manifest to mix all projects that we need together from our local mirror.
    Our local mirror will become a superset of the public mirror. We can create branches
    and tags from time to time in local repositories, but we only push the baselines
    that we want to release to the public repositories. This is exactly what the Google
    development team does in their private repositories.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在系统级项目上工作时，你可能需要AOSP源之外的某些项目。例如，在这本书中，我们使用了来自CyanogenMod、Android-x86以及我在GitHub上的多个项目。在这种情况下，我们实际上可以创建自己的清单，将我们从本地镜像中需要的所有项目混合在一起。我们的本地镜像将成为公共镜像的超集。我们可以不时地在本地仓库中创建分支和标签，但我们只推送我们想要发布到公共仓库的基线。这正是谷歌开发团队在他们私有仓库中所做的。
- en: Creating your own mirror of GitHub
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的GitHub镜像
- en: All source code used in this book is stored in GitHub. We also use source from
    other projects in GitHub, because many open source projects are hosted on GitHub,
    such as CyanogenMod, OmniROM, Team Win Recovery, and so on. We can create a mirror
    for all projects that we have used in local storage so that we can commit any
    changes and create our own baselines. If you want to make changes to any projects
    that are not owned by yourself, you can create your own copy using the Fork function
    of GitHub.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的所有源代码都存储在GitHub上。我们还使用了GitHub上其他项目的源代码，因为许多开源项目托管在GitHub上，例如CyanogenMod、OmniROM、Team
    Win Recovery等等。我们可以为我们在本地存储中使用的所有项目创建镜像，这样我们就可以提交任何更改并创建自己的基线。如果你想要更改不属于你自己的任何项目，你可以使用GitHub的Fork功能创建自己的副本。
- en: 'To create your own manifest for GitHub, you can create a repository in GitHub,
    call it `mirror`, and then add an XML file called `default.xml` to it as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要为GitHub创建自己的清单，你可以在GitHub中创建一个仓库，命名为`mirror`，然后添加一个名为`default.xml`的XML文件，如下所示：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the preceding `default.xml`, we can see that we actually fetch multiple
    projects from CyanogenMod, TWRP, OmniROM, and our own GitHub repositories using
    a single XML file. We put all of them together to form our own GitHub local mirror.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`default.xml`中，我们可以看到，我们实际上使用单个XML文件从CyanogenMod、TWRP、OmniROM以及我们自己的GitHub仓库获取了多个项目。我们将它们全部放在一起，形成我们自己的GitHub本地镜像。
- en: 'To create the local mirror, we can use the following commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本地镜像，我们可以使用以下命令：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After we have created the local mirror, we can check what we have downloaded
    via the following screen:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了本地镜像之后，我们可以通过以下屏幕检查我们下载了什么：
- en: '![](img/image_02_007.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_007.png)'
- en: Content of the local mirror
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本地镜像的内容
- en: From the preceding screenshot, we can see that all Git repositories that we
    specified in `default.xml` are copied to our local storage. The manifest file
    for the local mirror that I use in this book can be found at [https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到，我们在`default.xml`中指定的所有Git仓库都被复制到了我们的本地存储中。我在这本书中使用的本地镜像清单文件可以在以下链接找到：[https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror)。
- en: Fetching Git repositories outside GitHub
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitHub之外获取Git仓库
- en: As we can see from the preceding example, we created our manifest repository
    for the GitHub mirror. After that, we use it to initialize our mirror repo. Then
    we use the `repo sync` command to fetch all Git repositories from GitHub to our
    local mirror.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们为GitHub镜像创建了我们的清单仓库。之后，我们使用它来初始化我们的镜像仓库。然后我们使用`repo sync`命令从GitHub获取所有Git仓库到我们的本地镜像。
- en: How about repositories that we don't have write access to? In this book, we
    use a lot of projects from Android-x86\. However, we don't have write permission
    to Android-x86 repositories. The Android-x86 project also doesn't have a mirror
    manifest available for use.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那些我们没有写权限的仓库怎么办？在这本书中，我们使用了来自Android-x86的大量项目。然而，我们没有Android-x86仓库的写权限。Android-x86项目也没有可用的镜像清单。
- en: 'We can actually create a mirror manifest file from the original Android-x86
    manifest. We can refer to the document at the following link for how to get Android-x86
    source code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以从原始的Android-x86清单文件创建一个镜像清单文件。我们可以参考以下链接中的文档来获取Android-x86的源代码：
- en: '[http://www.android-x86.org/getsourcecode](http://www.android-x86.org/getsourcecode)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.android-x86.org/getsourcecode](http://www.android-x86.org/getsourcecode)'
- en: 'The previous document mentioned that we can use the following command to initialize
    and sync repo from the Android-x86 repository:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文档提到，我们可以使用以下命令初始化并同步来自Android-x86仓库的repo：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can clone the preceding Android-x86 manifest repository to a folder and
    analyze it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的Android-x86清单仓库克隆到一个文件夹中，并对其进行分析：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After we clone it, we can find the preceding two files. `default.xml` is used
    to initialize the Android-x86 repo and `cm.xml` is used to initialize Android-x86
    for the CyanogenMod build.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们克隆它之后，我们可以找到前面的两个文件。`default.xml`用于初始化Android-x86仓库，而`cm.xml`用于初始化CyanogenMod构建的Android-x86。
- en: 'If we look at the content of `default.xml`, we can see the following code snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`default.xml`的内容，我们可以看到以下代码片段：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that the Android-x86 manifest includes two parts. The first part
    is Android-x86, its own repositories, and the rest are the original AOSP repositories.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Android-x86的清单文件包括两部分。第一部分是Android-x86自身的仓库，其余的是原始的AOSP仓库。
- en: We can retrieve the first part and compose a mirror manifest for Android-x86\.
    Where should we put this file? We can put it in a branch of the same mirror manifest
    repository in our GitHub.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检索第一部分并为 Android-x86 创建一个镜像清单。我们应该把这个文件放在哪里？我们可以把它放在我们 GitHub 上同一个镜像清单仓库的一个分支中。
- en: 'In the working copy of our GitHub mirror repository, we can create a branch
    called `android-x86`. We can replace `default.xml` in our GitHub mirror with the
    first part in Android-x86 manifest and we get the one in the following listing:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 GitHub 镜像仓库的工作副本中，我们可以创建一个名为 `android-x86` 的分支。我们可以用 Android-x86 清单中的第一部分替换我们
    GitHub 镜像中的 `default.xml`，如下所示：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see from the preceding listing, we removed unnecessary fields such
    as `path` or `groups`, and so on. With this manifest for the Android-x86 mirror,
    we can create a local mirror for Android-x86 now as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的列表所示，我们移除了诸如 `path` 或 `groups` 等不必要的字段。有了这个 Android-x86 镜像的清单，我们现在可以创建一个
    Android-x86 的本地镜像，如下所示：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After we download all Git repositories, we can see the content as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下载所有 Git 仓库之后，我们可以看到以下内容：
- en: '![](img/image_02_008.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_008.png)'
- en: Local mirror of android-x86
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: android-x86 的本地镜像
- en: Creating your own manifest for client download
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为客户端下载创建自己的清单
- en: 'With all local mirrors, we can create our own manifest to check out our source
    code now. We can put it in our GitHub in a new repository called `manifests`.
    In this repository, we can create an XML file, `default.xml`, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了所有本地镜像，我们可以创建自己的清单来检出我们的源代码。我们可以在我们的 GitHub 上的一个名为 `manifests` 的新仓库中放置它。在这个仓库中，我们可以创建一个
    XML 文件，`default.xml`，如下所示：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding listing, this is a manifest modified based on the AOSP release
    `android-7.1.1_r4` manifest. In this file, we combined multiple projects from
    AOSP, Android-x86, TWRP, and our own GitHub projects into one. Usually, we have
    to do this using `local_manifests` to fetch all non-AOSP projects into our local
    copy. This approach usually takes a very long time and it is difficult to create
    baselines for our own configurations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，这是一个基于 AOSP 发布的 `android-7.1.1_r4` 清单修改后的清单。在这个文件中，我们将来自 AOSP、Android-x86、TWRP
    和我们自己的 GitHub 项目的多个项目合并到了一起。通常，我们必须使用 `local_manifests` 来将所有非 AOSP 项目检索到我们的本地副本。这种方法通常需要非常长的时间，并且很难为我们自己的配置创建基线。
- en: The `local_manifests` file can be used to overwrite the configuration of the
    manifest file temporarily. You can refer to *Appendix B* of *Embedded Programming
    with Android* to find out more details.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_manifests` 文件可以用来临时覆盖清单文件的配置。你可以参考《Android嵌入式编程》的附录 B 来了解更多细节。'
- en: With a local mirror and our own manifest, we can find a clean way to do this.
    When you have one copy for AOSP and one copy for Android-x86, you have a lot of
    duplicated projects in your storage because Android-x86 manifests include many
    original projects from AOSP. With the preceding setup, there are no duplicated
    projects in your local mirror.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地镜像和我们的自己的清单，我们可以找到一种干净的方式来完成这个任务。当你有一个 AOSP 的副本和一个 Android-x86 的副本时，你的存储中会有很多重复的项目，因为
    Android-x86 的清单包括了来自 AOSP 的许多原始项目。使用前面的设置，你的本地镜像中没有重复的项目。
- en: 'To check out a working copy, we can use the following commands:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要检出工作副本，我们可以使用以下命令：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we want to check out a build of Android-x86, it becomes a different configuration
    instead of a totally different repository now:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要检查 Android-x86 的构建版本，现在它将是一个不同的配置，而不是一个完全不同的仓库：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we have our own local mirror, we can use the `sync-c="true"` option in
    the manifest, as we can see in the previous listing. With this option, the `repo`
    command will only check out the version we need in our working copy instead of
    creating the Git repositories with all revisions. This can save a lot of space
    for the working copy. However, this is not recommended without a local mirror,
    because it will take even longer when you switch to a different version.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有自己的本地镜像，我们可以在清单中使用 `sync-c="true"` 选项，就像前一个列表中看到的那样。使用这个选项，`repo` 命令将只在我们的工作副本中检出我们需要的版本，而不是创建包含所有修订版本的
    Git 仓库。这可以为工作副本节省大量的空间。然而，如果没有本地镜像，这并不推荐，因为当你切换到不同版本时，这将会花费更长的时间。
- en: You can find the manifest to check out a working copy at my GitHub [https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的 GitHub [https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests)
    上找到用于检出工作副本的清单。
- en: We will use this to manage all different build configurations in this book.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个方法来管理本书中所有不同的构建配置。
- en: 'I introduced two kinds of manifest files here:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里介绍了两种清单文件：
- en: To create a local mirror, you can refer to the manifest file at [https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建本地镜像，您可以参考位于[https://github.com/shugaoye/mirror](https://github.com/shugaoye/mirror)的清单文件。
- en: To check out a working copy, you can refer to the manifest file at [https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查工作副本，您可以参考位于[https://github.com/shugaoye/manifests](https://github.com/shugaoye/manifests)的清单文件。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up the environment for SDK and AOSP. We built the Android
    emulator images for AOSP. We also tested and compared the Android images in Android
    SDK and AOSP. All these steps are necessary before we continue exploring how to
    create our own Android system later. We also spent some time discussing how to
    set up our own repo mirror. This tip can help us later, when we start to create
    projects from multiple open source projects. In the next chapter, we will start
    to explore the architecture of Android. We will look into the details of layers
    related to the porting and customization of the Android system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为SDK和AOSP设置了环境。我们为AOSP构建了Android模拟器镜像。我们还测试并比较了Android SDK和AOSP中的Android镜像。在我们继续探索如何创建自己的Android系统之前，所有这些步骤都是必要的。我们还花了一些时间讨论如何设置自己的repo镜像。这个技巧可以在我们开始从多个开源项目创建项目时帮助我们。在下一章中，我们将开始探索Android的架构。我们将深入研究与Android系统的移植和定制相关的层级的细节。
