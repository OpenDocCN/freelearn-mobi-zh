- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Runtime Permissions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时权限
- en: As we build our Android apps, there are some functionalities that require permissions
    to be granted for them to function properly. Due to privacy and data security
    policies, we as developers can not automatically grant permissions to the apps
    that we develop. We need to inform the users of the permissions that the apps
    need and why they need them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建Android应用，有一些功能需要授权才能正常工作。由于隐私和数据安全政策，我们作为开发者不能自动为我们开发的应用授权。我们需要通知用户应用需要的权限以及为什么需要它们。
- en: In this chapter, we will understand runtime permissions and how to request them
    in our app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解运行时权限以及如何在我们的应用中请求它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Understanding runtime permissions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解运行时权限
- en: Requesting permissions at runtime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时请求权限
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要已下载Android Studio Hedgehog或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用前一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine)找到本章的代码。
- en: Understanding runtime permissions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运行时权限
- en: '`requestPermissions()` and `checkSelfPermission()`. The user only needs to
    grant permission once during the lifetime of the app.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestPermissions()`和`checkSelfPermission()`。用户只需在应用生命周期内授权一次。'
- en: Some of the features that need permission to be granted to work are camera,
    location, microphone and storage. Before using them, ensure that a user has permission
    to use them. If the user has not granted permission, you must request it from
    them. If the user has denied the permission, you must show a dialog explaining
    why you need it and ask the user to grant it from the settings. If the user has
    granted permission, you can use the feature. Failing to do these checks often
    results in an app crashing or a feature not working. If your app targets Android
    6.0 and above, you must request these permissions at runtime, and the user must
    grant the permission for the app to work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要授权才能正常工作的功能包括相机、位置、麦克风和存储。在使用它们之前，请确保用户有权限使用它们。如果用户未授权，您必须向他们请求。如果用户拒绝授权，您必须显示一个对话框解释为什么需要它，并要求用户从设置中授权。如果用户已授权，您可以使用该功能。未能进行这些检查通常会导致应用崩溃或功能无法正常工作。如果您的应用针对Android
    6.0及以上版本，您必须在运行时请求这些权限，并且用户必须授权才能使应用工作。
- en: 'The flow for requesting permissions is shown in the following chart:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请求权限的流程如下所示：
- en: '![Figure 9.1 – The runtime permissions flow](img/B19779_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 运行时权限流程](img/B19779_09_01.jpg)'
- en: Figure 9.1 – The runtime permissions flow
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 运行时权限流程
- en: 'As shown in the preceding diagram, this is the flow:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这是流程：
- en: The initial step is to *declare* the permission in the manifest file. This is
    done by adding the permission to the manifest file.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在清单文件中*声明*权限。这是通过将权限添加到清单文件来完成的。
- en: After adding the permission to the manifest file, we must *design the UX* for
    the feature that needs the permission to be granted.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将权限添加到清单文件后，我们必须*设计UX*，以便需要授权的功能。
- en: The next step is *waiting for the user to use* the feature that needs permission
    to be granted. At this point, we check whether the user has granted permission.
    If the user has granted permission, we proceed to use the feature.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是*等待用户使用*需要授权的特定功能。在此阶段，我们检查用户是否已授权。如果用户已授权，我们继续使用该功能。
- en: If the user *has not granted permission*, we first check whether we need to
    *show a rationale* that explains why we need permission. If we need to show the
    rationale, we show it with explanations and then request permission from the user.
    If we do not need to show the rationale, we just request permission from the user.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户*尚未授权*，我们首先检查是否需要*展示理由*来解释为什么我们需要权限。如果需要展示理由，我们将通过解释来展示它，然后请求用户授权。如果我们不需要展示理由，我们只需直接请求用户授权。
- en: Once the permission is requested, we wait for the *user to grant or deny* permission.
    If the user grants permission, we proceed to use the feature. If the user denies
    permission, we allow the app to work, but the user cannot use the feature that
    needs permission to work.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦请求了权限，我们就等待**用户授予或拒绝**权限。如果用户授予了权限，我们就继续使用该功能。如果用户拒绝了权限，我们允许应用继续运行，但用户无法使用需要权限才能运行的功能。
- en: With this flow in mind, let us look at how to implement it in code. We are going
    to request permission to access a location.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个流程，让我们看看如何在代码中实现它。我们将请求访问位置的权限。
- en: Requesting permissions at runtime
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时请求权限
- en: 'We will follow the steps covered in *Figure 9**.1* to request runtime permissions
    for our app:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循**图9**.1中涵盖的步骤来为我们的应用请求运行时权限：
- en: 'Let us start by adding the permission to the manifest file. We will request
    permission to access the user’s location. To do this, we add the following permission
    to the manifest file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将权限添加到清单文件开始。我们将请求访问用户位置的权限。为此，我们在清单文件中添加以下权限：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This specifies that our app will be using the `ACCESS_COARSE_LOCATION` permission.
    Declaring permissions in the manifests is crucial for enhancing security, user
    awareness, and overall app compatibility. By explicitly specifying the actions
    or resources apps require access to permissions informs users during installations,
    allowing them to make informed decisions about granting or denying access. This
    declaration ensures compatibility across different Android versions and devices,
    facilitates inter-app communication, and supports intent filtering to control
    component access. Permissions also play a role in runtime permission requests
    for dangerous permissions and help maintain platform compatibility. Additionally,
    Play Store reviews declare permissions as part of the submission process, contributing
    to adherence to policies and guidelines. In essence, manifest-based permission
    declarations are fundamental for creating secure, transparent, and user-controlled
    environments in our apps.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了我们的应用将使用`ACCESS_COARSE_LOCATION`权限。在清单中声明权限对于增强安全性、用户意识和整体应用兼容性至关重要。通过明确指定应用需要访问的动作或资源，可以在安装过程中通知用户，使他们能够做出明智的决定，关于是否授予或拒绝访问。这种声明确保了不同Android版本和设备之间的兼容性，促进了应用间的通信，并支持意图过滤以控制组件访问。权限在运行时请求危险权限中也发挥作用，有助于保持平台兼容性。此外，Play商店的审核过程将权限作为提交流程的一部分，有助于遵守政策和指南。本质上，基于清单的权限声明对于创建安全、透明和用户控制的环境至关重要。
- en: The next thing is to create the UX for the feature that needs permission. We
    will create a dialog to request permissions from the user. It will also have the
    logic that shows the rationale to the user if permission was previously denied.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是创建需要权限的功能的用户界面。我们将创建一个对话框来请求用户的权限。它还将包含逻辑，如果之前拒绝了权限，则向用户展示理由。
- en: 'Let’s create a new file in the `view` package named `PermissionDialog.kt` and
    add the utility functions to the file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`view`包中创建一个名为`PermissionDialog.kt`的新文件，并将实用函数添加到该文件中：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first function checks whether the permission has been granted using the
    `ContextCompat.checkSelfPermission()` function. The second function checks whether
    we need to show the rationale to the user. This is done using the `ActivityCompat.shouldShowRequestPermissionRationale()`
    function. This function returns `true` if the app has requested this permission
    previously and the user denied the request. If the user turned down the permission
    request in the past and chose the `false`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数使用`ContextCompat.checkSelfPermission()`函数检查权限是否已被授予。第二个函数检查是否需要向用户展示理由。这是通过使用`ActivityCompat.shouldShowRequestPermissionRationale()`函数来完成的。如果应用之前请求过此权限并且用户拒绝了请求，该函数返回`true`。如果用户之前拒绝了权限请求并选择了`false`。
- en: Next, let us create a sealed class that will be used to represent the state
    of the permission request.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个密封类，用于表示权限请求的状态。
- en: 'Create a new file named `PermissionAction.kt` in the `data` package, and add
    the following code to the file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data`包中创建一个名为`PermissionAction.kt`的新文件，并将以下代码添加到该文件中：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class has two states, `PermissionGranted` and `PermissionDenied`. A user
    can either grant or deny permission.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该类有两个状态，`PermissionGranted`和`PermissionDenied`。用户可以授予或拒绝权限。
- en: 'Next, let us create the dialog that will be used to request permission from
    the user. Head back to the `PermissionDialog.kt` file and add the following code
    to the file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个用于请求用户权限的对话框。返回到 `PermissionDialog.kt` 文件，并向文件中添加以下代码：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s break down the preceding code:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码：
- en: We have created a composable, `PermissionDialog`, which takes three parameters,
    `context`, `permission` string, and a `permissionAction` callback, which passed
    the option the user selected to the call site.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个可组合的 `PermissionDialog`，它接受三个参数，`context`、`permission` 字符串和一个 `permissionAction`
    回调，该回调将用户选择的选项传递给调用位置。
- en: Inside the composable, the first thing we do is check whether permission has
    been granted. If permission has been granted, we call the `permissionAction` callback
    with the `PermissionGranted` state and return.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可组合函数内部，我们首先检查权限是否已被授予。如果权限已被授予，我们调用 `permissionAction` 回调并传递 `PermissionGranted`
    状态，然后返回。
- en: Next, we also created `permissionsLauncher`, which is used to request permission
    from the user. We use the `rememberLauncherForActivityResult()` function to create
    a launcher for the contract. We then use the launcher to request permission from
    the user. If the user grants the permission, we call the `permissionAction` callback
    with the `PermissionGranted` state. If the user denies the permission, we call
    the `permissionAction` callback with the `PermissionDenied` state.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们还创建了 `permissionsLauncher`，用于请求用户权限。我们使用 `rememberLauncherForActivityResult()`
    函数创建一个用于合同的启动器。然后我们使用启动器请求用户权限。如果用户授予权限，我们调用 `permissionAction` 回调并传递 `PermissionGranted`
    状态。如果用户拒绝权限，我们调用 `permissionAction` 回调并传递 `PermissionDenied` 状态。
- en: If the permission has not been granted, we check whether we need to show the
    rationale to the user. If we need to, we show the rationale with explanations
    and then request permission from the user. If we do not need to show the rationale,
    we must request permission from the user. In our case, the rationale is `AlertDialog`,
    with two action items and a message explaining why we need the permission. The
    first action item is used to request permission from the user. The second action
    item is used to cancel the permission request. If we tap the `permissionAction`
    callback is called with the `PermissionDenied` state, and the dialog is dismissed.
    We also have two mutable states, `isDialogDismissed` and `isPristine`. The first
    is used to check whether the dialog has been dismissed. The second one let’s know
    whether the dialog was shown before. We use these states combined to know whether
    to show the dialog or not.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果权限尚未被授予，我们检查是否需要向用户显示理由。如果需要，我们将使用解释显示理由，然后请求用户权限。如果我们不需要显示理由，我们必须请求用户权限。在我们的情况下，理由是
    `AlertDialog`，包含两个操作项和一个解释为什么我们需要权限的消息。第一个操作项用于请求用户权限。第二个操作项用于取消权限请求。如果我们点击，`permissionAction`
    回调将使用 `PermissionDenied` 状态被调用，并且对话框将被关闭。我们还有两个可变状态，`isDialogDismissed` 和 `isPristine`。第一个用于检查对话框是否已被关闭。第二个让我们知道对话框是否之前显示过。我们使用这些状态结合来确定是否显示对话框。
- en: Lastly, if we do not need to show the rationale, we just request permission
    from the user. We use `SideEffect` to request permission from the user because
    we want to request permission from the user as soon as the dialog is shown.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们不需要显示理由，我们只需请求用户权限。我们使用 `SideEffect` 请求用户权限，因为我们希望在对话框显示时立即请求权限。
- en: Since we do not have an actual feature in our app currently that uses location,
    we are going to simulate permission flow with our `PetsScreen` composable.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们当前的应用程序中没有使用位置的实际功能，我们将使用 `PetsScreen` 可组合函数来模拟权限流程。
- en: 'Let’s head to the `PetsScreen.kt` file and modify it to the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `PetsScreen.kt` 文件，并将其修改为以下内容：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have only made a few changes to this file:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只对这个文件做了一些修改：
- en: First, we have added a `showContent` mutable state that is used to check whether
    we should show the content of the screen. We have also set the initial value of
    the state to `false`. We will use this state to show the content of the screen
    if the user grants permission. We also have the `context` variable used to get
    the screen’s context.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个 `showContent` 可变状态，用于检查我们是否应该显示屏幕的内容。我们还设置了状态的初始值为 `false`。如果用户授予权限，我们将使用此状态来显示屏幕内容。我们还有
    `context` 变量，用于获取屏幕的上下文。
- en: We have also added the `PermissionDialog` composable to the `PetsScreen` composable.
    We have passed the context and the permission – in this case, the `ACCESS_COARSE_LOCATION`
    permission – to the composable. We have also passed a callback to the composable
    that is used to get the state of the permission request. If the user grants the
    permission, we set the `showContent` state to `true` and show a toast with the
    `showContent` state to `false`.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还向`PetsScreen`可组合组件添加了`PermissionDialog`可组合组件。我们传递了上下文和权限——在这种情况下，是`ACCESS_COARSE_LOCATION`权限——到可组合组件中。我们还传递了一个回调到可组合组件，用于获取权限请求的状态。如果用户授予了权限，我们将`showContent`状态设置为`true`并显示一个带有`showContent`状态的吐司，如果状态为`false`，则不显示屏幕内容。
- en: Lastly, we have added a check to see whether the `showContent` state is `true`.
    If the state is `true`, we show the content of the screen. If the state is `false`,
    we do not show the content of the screen.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个检查来查看`showContent`状态是否为`true`。如果状态为`true`，我们显示屏幕内容。如果状态为`false`，我们不显示屏幕内容。
- en: 'Build and run the app. At first, we will see the permission dialog, as shown
    in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。一开始，我们将看到权限对话框，如下面的截图所示：
- en: '![Figure 9.2 – The permission dialog](img/B19779_09_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 权限对话框](img/B19779_09_02.jpg)'
- en: Figure 9.2 – The permission dialog
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 权限对话框
- en: Tap the **Don’t allow** option, which will show an empty white screen, since
    we don’t show any content when the user has not granted the app permission.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**不允许**选项，这将显示一个空白的白色屏幕，因为我们没有在用户未授予应用权限时显示任何内容。
- en: '![Figure 9.3 – The no permission screen](img/B19779_09_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 无权限屏幕](img/B19779_09_03.jpg)'
- en: Figure 9.3 – The no permission screen
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 无权限屏幕
- en: The next time we run the app, we will see the rationale dialog showing why the
    app needs permission.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们运行应用时，将看到显示应用为何需要权限的理性对话框。
- en: '![Figure 9.4 – The permission rationale](img/B19779_09_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 权限理性说明](img/B19779_09_04.jpg)'
- en: Figure 9.4 – The permission rationale
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 权限理性说明
- en: On this rationale dialog, we can either cancel the request or grant access.
    Tapping the **Grant Access** option should bring up the permission dialog shown
    in *Figure 9**.2*, and by tapping the **While using the app** option, we grant
    the app the location permission, and now, we should be able to see the list of
    cute cats once again. Running the app again does not show the dialogs, since we
    have already granted the app the location permission.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个理性对话框中，我们可以取消请求或授予访问权限。点击**授予访问权限**选项将显示如图*9.2*所示的权限对话框，通过点击**使用应用时**选项，我们授予应用位置权限，现在，我们应该能够再次看到可爱猫咪的列表。再次运行应用不会显示对话框，因为我们已经授予了应用位置权限。
- en: '![Figure 9.5 – Cute cats](img/B19779_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 可爱的猫咪](img/B19779_09_05.jpg)'
- en: Figure 9.5 – Cute cats
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 可爱的猫咪
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored what runtime permissions are and why we should
    declare and request permissions in our apps. Step by step, we learned how to request
    runtime permissions in our app and how to show permission rationale dialogs, explaining
    to users why we need access to runtime permissions in cases where they have denied
    apps access to permissions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了运行时权限是什么以及为什么我们应该在我们的应用中声明和请求权限。一步一步地，我们学习了如何在我们的应用中请求运行时权限以及如何显示权限理性对话框，解释为什么在用户拒绝应用访问权限的情况下，我们需要访问运行时权限。
- en: In the next chapter, we will learn debugging tips and tricks, how to detect
    leaks using LeakCanary, how to inspect HTTPS requests/responses fired by our app
    using Chucker, and how to inspect the Room database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习调试技巧和窍门，如何使用LeakCanary检测泄漏，如何使用Chucker检查我们应用发出的HTTPS请求/响应，以及如何检查Room数据库。
- en: 'Part 3: Code Analysis and Tests'
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：代码分析和测试
- en: In this part, you will gain proficiency in debugging through a series of valuable
    tips and tricks. Unveiling the intricacies, you will discover techniques for detecting
    memory leaks within your app and adeptly inspecting HTTP requests triggered by
    your application. Our exploration extends to inspecting your local database, offering
    insights into its inner workings. Diving into Kotlin best practices, you will
    delve into code analysis for your application, addressing code smells for enhanced
    code quality. This part also includes a comprehensive exploration of testing methodologies,
    empowering you to seamlessly integrate tests across various layers of your MVVM
    architecture.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您将通过一系列宝贵的技巧和窍门掌握调试技能。揭示其复杂性，您将发现检测应用中内存泄漏的技术，并熟练地检查由您的应用程序触发的HTTP请求。我们的探索扩展到检查您的本地数据库，深入了解其内部工作原理。深入Kotlin最佳实践，您将深入分析您的应用程序代码，解决代码异味以提升代码质量。本部分还包括对测试方法的全面探索，使您能够无缝地将测试集成到MVVM架构的各个层次。
- en: 'This section contains the following chapters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 10*](B19779_10.xhtml#_idTextAnchor121), *Debugging Your App*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19779_10.xhtml#_idTextAnchor121), *调试您的应用*'
- en: '[*Chapter 11*](B19779_11.xhtml#_idTextAnchor135), *Enhancing Code Quality*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19779_11.xhtml#_idTextAnchor135), *提升代码质量*'
- en: '[*Chapter 12*](B19779_12.xhtml#_idTextAnchor157), *Testing Your App*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19779_12.xhtml#_idTextAnchor157), *测试您的应用*'
