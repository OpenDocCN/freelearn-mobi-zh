- en: Chapter 4. Give a Snake a Snack…
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：给蛇一份小吃……
- en: One of the challenges of object-oriented design for a game is how to build fully
    cohesive objects that function as needed for a game. We will build this project
    with that focus in mind. The main class for the player will be as self-contained
    and self-sufficient as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏面向对象设计的一个挑战是如何构建完全统一的对象，使其能够满足游戏的需求。我们将带着这个重点来构建这个项目。玩家的主要类将尽可能自给自足。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Overriding methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法
- en: Self-contained classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自包含的类
- en: Difficulty levels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难度级别
- en: Scaling level progression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别进度的缩放
- en: Object lifespan control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象生命周期控制
- en: The project is…
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 该项目是……
- en: 'This chapter will take on the often copied game that has graced pretty much
    every possible computing platform, from early cell phones to current consoles:
    the snake game. There are many variations under a variety of names, but the mechanics
    are generally the same. You control a snake that is always moving forward. You
    can turn the snake right or left (at right angles only), avoiding walls and eating
    mice (or other food). Each time you eat something, your snake gets longer. You
    can go on eating (and growing) until you run into a wall or your own tail.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨一个经常被复制的游戏，它几乎出现在了所有可能的计算平台上，从早期的手机到当前的游戏机：蛇游戏。在各种各样的名称下有许多变体，但机制通常是相同的。你控制着一条始终向前移动的蛇。你可以将蛇向右或向左（仅限于直角）转动，避开墙壁并吃掉老鼠（或其他食物）。每次你吃掉东西，你的蛇就会变长。你可以继续吃（并成长），直到撞到墙壁或自己的尾巴。
- en: Design approach
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计方法
- en: The "classic" way to handle the snake's movement in a snake game is to draw
    a new body segment in the direction the snake is moving, and erase the one at
    the end. While this approach works, we want to use a more object-oriented approach
    in our design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在蛇游戏中处理蛇的移动的“经典”方式是在蛇移动的方向上绘制一个新的身体段，并擦除末尾的一个。虽然这种方法可行，但我们希望在设计中使用更面向对象的方法。
- en: We will focus on letting the snake be as autonomous as possible. We want a `snake`
    class that we can simply instruct to move, and the `snake` object will handle
    the movement itself. The `snake` class will also be able to handle what to do
    when we pass it a message to "turn left" or "turn right".
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于让蛇尽可能自主。我们希望有一个`snake`类，我们可以简单地指示它移动，而`snake`对象将处理移动本身。`snake`类还将能够处理当我们传递“向左转”或“向右转”的消息时应该做什么。
- en: 'The levels should be generated with a variable number of walls inside the playfield,
    as well as drawing outer walls around the edge of the screen. Finally, we need
    to have mice appear on the playfield as the food. These mice should have a limited
    lifespan, so they will disappear if they are not eaten in a given amount of time.
    When a mouse is eaten or runs out of life, we will replace it with another. Let''s
    see what it should look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 级别应该生成带有可变数量的墙壁的游乐场内部，以及绘制屏幕边缘的外墙。最后，我们需要在游乐场上出现老鼠作为食物。这些老鼠应该有一个有限的生命周期，所以如果它们在给定时间内没有被吃掉，它们就会消失。当老鼠被吃掉或耗尽生命时，我们将用另一个来替换它。让我们看看它应该是什么样子：
- en: '![Design approach](img/9007_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![设计方法](img/9007_04_01.jpg)'
- en: We will also establish three difficulty levels, and incrementing game levels
    for each difficulty. Since the game is based primarily on random elements, we
    need to use the difficulty and the level number in setting the variable elements
    in the game (for example, high levels are faster with more mice and more walls),
    as well as the snake's movement speed. That doesn't sound too difficult, does
    it?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将建立三个难度级别，并为每个难度级别增加游戏关卡。由于游戏主要基于随机元素，我们需要在设置游戏中的变量元素（例如，高等级更快，有更多老鼠和更多墙壁）以及蛇的移动速度时使用难度和等级数字。这听起来并不太难，对吧？
- en: Building a better snake
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打造更好的蛇
- en: The first thing we need to keep in mind is that the snake is of a variable length.
    The snake could be as short as one segment or as long as 100 segments (in theory—we
    won't get that long in our game). As we said during the design, the snake should
    be as autonomous as possible. With that in mind, let's look at the `SNSnake.h`
    file to see what we need.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的第一件事是蛇的长度是可变的。蛇的长度可以从一个段到100个段（理论上——在我们的游戏中我们不会那么长）。正如我们在设计期间所说，蛇应该尽可能自主。考虑到这一点，让我们看看`SNSnake.h`文件，看看我们需要什么。
- en: '**Filename**: `FileSNSnake.h`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`FileSNSnake.h`'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to track how fast the snake should move (`snakeSpeed`) and what direction
    it is moving in (`snakeDirection`). But what is this `SnakeHeading` variable type?
    We will again be placing our common definitions in a separate definitions file,
    `SNDefinitions.h`. Even though we did not import that file in this header, it
    is imported in the `SNSnakeSegment.h` file, which is then imported here, so we
    can use it freely. The definition of `SnakeHeading` is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪蛇应该移动多快（`snakeSpeed`）以及它移动的方向（`snakeDirection`）。但这个`SnakeHeading`变量类型是什么？我们再次将我们的公共定义放在一个单独的定义文件中，`SNDefinitions.h`。尽管我们没有在这个头文件中导入该文件，但它被导入到`SNSnakeSegment.h`文件中，然后又在这里导入，因此我们可以自由使用它。`SnakeHeading`的定义如下：
- en: '**Filename**: `SNDefinitions.h`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNDefinitions.h`'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `SnakeHeading` type uses these four directional values (which are integers
    in disguise) to keep track which direction, relative to the playfield, the snake
    is facing. This is easier than trying to remember that one means "up".
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`SnakeHeading`类型使用这四个方向值（实际上是整数）来跟踪蛇相对于游戏区域面向哪个方向。这比记住一个代表“向上”要容易得多。'
- en: The entire snake's body, including the head, will be stored in the `NSMutableArray`
    `snakeBody`. This array will contain objects of type `SNSnakeSegment`, but we
    don't have to provide those specifics in the header.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 整个蛇的身体，包括头部，将存储在`NSMutableArray` `snakeBody`中。这个数组将包含类型为`SNSnakeSegment`的对象，但我们不需要在头文件中提供这些具体信息。
- en: One aspect worth pointing out is that we declare some of these variables as
    properties. Why only some, and not others? When you declare a property, it can
    be accessed from outside the class. A variable without a property declaration
    will be only usable inside the class in which it is defined. So here, we know
    we will want the main playfield to be able to use the `snakeSpeed`, `snakeDirection`,
    and `snakeBody`, so we declare those as properties.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的一点是，我们将一些变量声明为属性。为什么只声明一些，而不是全部呢？当你声明一个属性时，它可以从类外部访问。没有属性声明的变量只能在定义它的类内部使用。因此，在这里，我们知道我们希望主游戏区域能够使用`snakeSpeed`、`snakeDirection`和`snakeBody`，所以我们把这些声明为属性。
- en: The `headRow` and `headColumn` are convenience variables to keep track of where
    we want the head of the snake to start in our playing grid. These could be done
    away with entirely and hardcode the starting values, but this allows us to easily
    relocate the snake's starting position without digging through the code to identify
    the values to change.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`headRow`和`headColumn`是方便的变量，用于跟踪蛇头在游戏网格中的起始位置。这些变量完全可以被删除，并直接硬编码起始值，但这样做允许我们轻松地重新定位蛇的起始位置，而无需在代码中查找要更改的值。'
- en: We will be handling all of the segment creation within this class (using the
    `addSegment` method), so we need to keep a reference to the game layer itself.
    This is stored in the `parentLayer` variable, which is of type `SNPlayfieldLayer`.
    As we discussed in [Chapter 3](ch03.html "Chapter 3. Thumping Moles for Fun"),
    *Thumping Moles for Fun*, the `@class` declaration at the top of the header file
    tells the compiler "we have a class called `SNPlayfieldLayer` , but that's all
    you need to know for now". Unlike our use of a forward declaration in [Chapter
    3](ch03.html "Chapter 3. Thumping Moles for Fun"), we do need to call a method
    from that class, so we will add the line `#import "SNPlayfieldLayer.h"` into the
    `SNSnake.m` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类内部处理所有段落的创建（使用`addSegment`方法），因此我们需要保留游戏层的引用。这个引用存储在`parentLayer`变量中，其类型为`SNPlayfieldLayer`。正如我们在[第3章](ch03.html
    "第3章。有趣的敲击土拨鼠")中讨论的那样，*有趣的敲击土拨鼠*，头文件顶部的`@class`声明告诉编译器“我们有一个名为`SNPlayfieldLayer`的类，但你现在只需要知道这些”。与我们在[第3章](ch03.html
    "第3章。有趣的敲击土拨鼠")中使用的前向声明不同，我们需要从该类中调用一个方法，因此我们将添加一行`#import "SNPlayfieldLayer.h"`到`SNSnake.m`文件中。
- en: 'We also provide several exposed methods in the header. These should all be
    fairly self-explanatory. We do need to point out the one class method, `createWithLayer:
    withLength:`. In earlier chapters, we often took the approach of using default
    `init` structures, and filled in the variables after the object was instantiated.
    While this does work, it is often cleaner to build your own class methods to ensure
    that no required parameters are overlooked. This approach also allows us to pursue
    our goal with this game of making the snake as self-contained as possible.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还在头文件中提供了几个公开的方法。这些都应该相当容易理解。我们需要指出一个类方法，`createWithLayer: withLength:`。在早期章节中，我们经常采用使用默认的
    `init` 结构，并在对象实例化后填充变量。虽然这确实可行，但通常更干净的做法是构建自己的类方法，以确保不会遗漏任何必需的参数。这种方法还允许我们追求在这个游戏中使蛇尽可能自包含的目标。'
- en: Anatomy of a snake segment
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蛇段的解剖结构
- en: Before we dive into the `SNSnake` implementation, let's turn our attention to
    the `SNSnakeSegment`. This is the object that will represent each segment of the
    snake, both head and body. This class is a mostly unmodified subclass of `CCSprite`,
    but we will make a small, yet important change to its behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 `SNSnake` 的实现之前，让我们将注意力转向 `SNSnakeSegment`。这是将代表蛇的每个部分（包括头部和身体）的对象。这个类是
    `CCSprite` 的一个基本未修改的子类，但我们将对其行为进行一个小而重要的修改。
- en: '**Filename**: `SNSnakeSegment.h`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNSnakeSegment.h`'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We establish a property named `priorPosition` , which is the position where
    this sprite was before the last time it moved. We also keep a property for `parentSegment`.
    The `parentSegment` is the segment of the snake directly in front of the current
    segment. In this way, each snake segment has a direct connection to the segment
    in front of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `priorPosition` 的属性，这是这个精灵在最后一次移动之前的所在位置。我们还保留了一个 `parentSegment`
    属性。`parentSegment` 是位于当前段前面的蛇的段。这样，每个蛇段都与它前面的段有直接的联系。
- en: '**Filename**: `SNSnakeSegment.m`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNSnakeSegment.m`'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class is very brief, yet it will make our game a lot easier to build. In
    most ways this will behave as a normal `CCSprite`, except when the `setPosition`
    method is used. We are overriding `setPosition` to provide new behavior. First,
    we store our current position in the `priorPosition` variable, and then we call
    the `super setPosition` method, which actually calls the standard `CCSprite` `setPosition`
    method. All told, this will behave like a standard `setPosition`, except that
    it is quietly storing the coordinates of its last position before the move. To
    understand why, we will need to look at the snake's implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课非常简短，但会使我们的游戏构建变得更加容易。在大多数情况下，它将表现得像一个正常的 `CCSprite`，除了当使用 `setPosition`
    方法时。我们正在重写 `setPosition` 以提供新的行为。首先，我们将当前的位置存储在 `priorPosition` 变量中，然后调用 `super
    setPosition` 方法，该方法实际上调用标准的 `CCSprite` `setPosition` 方法。总的来说，这会表现得像标准的 `setPosition`，但它在移动之前会悄悄地存储其最后位置的坐标。要理解原因，我们需要查看蛇的实现。
- en: Dissecting the snake
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解剖蛇
- en: Let's begin with the `createWithLayer:withLength:` class method, and the related
    `initWithLayer:withLength:` instance method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `createWithLayer:withLength:` 类方法和相关的 `initWithLayer:withLength:` 实例方法开始。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNSnake.m`'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We keep a reference to the layer passed (as `parentLayer`), initialize the `NSMutableArray
    snakeBody`, and set some default values for the rest of the variables. We then
    call `addHead` to add the snake's head. This must be called before we make any
    calls to `addSegment`, because we need the head to be the first element in the
    array. We then use the `startLength` variable to determine how many times we need
    to call the `addSegment` method. Notice that the `addSegment` loop will iterate
    one time less than the passed `startLength`. We do this because the head does
    count as a part of the snake length, so if we requested a `snakeLength` of five,
    we only need to generate four body segments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留传递的层引用（作为 `parentLayer`），初始化 `NSMutableArray snakeBody`，并为其他变量设置一些默认值。然后我们调用
    `addHead` 来添加蛇的头部。这必须在调用 `addSegment` 之前完成，因为我们需要头部成为数组中的第一个元素。然后我们使用 `startLength`
    变量来确定需要调用 `addSegment` 方法多少次。请注意，`addSegment` 循环将比传递的 `startLength` 少迭代一次。我们这样做是因为头部也算作蛇的一部分长度，所以如果我们请求的
    `snakeLength` 是五，我们只需要生成四个身体段。
- en: Building the head
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建头部
- en: Now let's look at the `addHead` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `addHead` 方法。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNSnake.m`'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We begin this method by using the standard `CCSprite` `spriteWithSpriteFrameName`
    convenience method to create the sprite. Next we see one of the reasons we keep
    a reference to the `parentLayer`. To set the value of the `CGPoint newPos`, we
    call the `positionForRow:andColumn:` method directly from the parent layer. Calling
    the method from the parent layer guarantees we are using the same grid formula
    for all object position calculations, without having to maintain multiple versions
    of the same `positionForRow:` method in different classes. This is the only piece
    of code that uses the `headRow` and `headColumn` variables, so we could have avoided
    those variables and embedded the values directly in this method call if we wanted
    to tighten up the code. We set the position for our `newSeg` to the value of `newPos`,
    and then we set the value of `priorPosition` to the same value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始这个方法时，使用标准的`CCSprite` `spriteWithSpriteFrameName`便利方法来创建精灵。接下来我们看到我们保留对`parentLayer`引用的一个原因。为了设置`CGPoint
    newPos`的值，我们直接从父层调用`positionForRow:andColumn:`方法。从父层调用该方法确保我们在所有对象位置计算中使用相同的网格公式，而无需在不同的类中维护多个相同的`positionForRow:`方法的多个版本。这是唯一使用`headRow`和`headColumn`变量的代码片段，因此如果我们想使代码更加紧凑，我们可以避免这些变量并将值直接嵌入到这个方法调用中。我们将`newSeg`的位置设置为`newPos`的值，然后我们将`priorPosition`的值设置为相同的值。
- en: 'The next line is the only real substantial difference between the head and
    a body segment: we set the `parentSegment` to nil. If the segment does not have
    a `parentSegment`, we can be sure it is the head segment.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条是头部和身体部分之间唯一的真正实质性区别：我们将`parentSegment`设置为nil。如果一个部分没有`parentSegment`，我们可以确信它是头部部分。
- en: After adding the snake's head to the `snakeBody` array, we add the head as a
    child of the `parentLayer`. Notice we use a `Z` order of 100\. When we create
    the snake, we want the head to overlap the next body segment, so we start with
    a high `Z` value for the head.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在将蛇头添加到`snakeBody`数组之后，我们将头作为`parentLayer`的子项添加。注意我们使用`Z`顺序为100。当我们创建蛇时，我们希望头部与下一个身体部分重叠，因此我们为头部开始使用一个高的`Z`值。
- en: Building the body segments
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建身体部分
- en: We now turn our attention to the `addSegment` method, which adds a single body
    segment to the snake.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注意力转向`addSegment`方法，该方法向蛇添加一个单独的身体部分。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNSnake.m`'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At first glance, this looks very similar to the `addHead` method. Let's take
    a closer look. We use a different image for the body segments. Then we look up
    the last segment in the `snakeBody` array. Here we use the prior segment's position
    as the position for our new segment. We also set the `parentSegment` variable
    to point to the prior segment. So each segment now has a connection to the one
    in front of it, and it identifies its own position as being in the prior location
    of the parent segment. (For the initial building of the snake, these will all
    share the same coordinates, but this design will be essential when we are calling
    this method during gameplay.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎与`addHead`方法非常相似。让我们仔细看看。我们为身体部分使用不同的图像。然后我们在`snakeBody`数组中查找最后一个部分。在这里，我们使用先前部分的位置作为新部分的位置。我们还设置`parentSegment`变量指向先前部分。因此，每个部分现在都与前面的部分相连，并识别自己的位置为位于父部分的前一个位置。（对于蛇的初始构建，这些都将共享相同的坐标，但当我们游戏过程中调用此方法时，这种设计将是必不可少的。）
- en: We add this segment to the `snakeBody` array, and then add this segment to the
    `parentLayer`. You will notice we assign the `Z` order as `100 – [snakeBody count].`
    This will essentially slip each segment under the segment in front of it, since
    a higher `Z` order is drawn on top of lower `Z` orders.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个部分添加到`snakeBody`数组中，然后将这个部分添加到`parentLayer`中。你会注意到我们分配的`Z`顺序为`100 – [snakeBody
    count]`。这实际上会将每个部分滑到前面部分的下面，因为较高的`Z`顺序会覆盖较低的`Z`顺序。
- en: Moving the snake
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动蛇
- en: We now turn our attention to the way we move the snake. Since we want as much
    of the snake's control inside the snake object, we will be generating our own
    `move` method, instead of using `setPosition`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在关注的是移动蛇的方式。由于我们希望尽可能多的蛇的控制权在蛇对象内部，我们将生成自己的`move`方法，而不是使用`setPosition`。
- en: '**Filename**: `SNDefinition.h`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNDefinition.h`'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `SNDefinitions.h` file we have created a `gridSize` definition that works
    well with the graphics we have defined for this project. Having a centralized
    `gridSize` definition allows us to alter the dimensions of the playfield in one
    place. With that definition fresh in our minds, let's look at the `move` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SNDefinitions.h` 文件中，我们创建了一个 `gridSize` 定义，它与本项目定义的图形配合得很好。拥有集中化的 `gridSize`
    定义允许我们在一个地方改变游戏场的尺寸。带着这个定义清晰地记在心中，让我们看看 `move` 方法。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNSnake.m`'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the `snakeDirection` variable and the defined `gridSize` to determine
    where to move the head of the snake. All of the snake's movements will be constrained
    to the grid. If we allowed free movement, it would be extremely easy to run into
    the edges of a wall. By constraining the snake's movements to a grid, we allow
    the snake to have "close calls" with walls without dying because they were one
    pixel too close.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `snakeDirection` 变量和定义的 `gridSize` 来确定蛇头的移动位置。蛇的所有移动都将被限制在网格内。如果我们允许自由移动，那么撞到墙壁边缘会变得极其容易。通过将蛇的移动限制在网格内，我们允许蛇在接近墙壁时“擦肩而过”而不死亡，因为它们只差一像素。
- en: We then iterate through all members of the `snakeBody` array. If the segment
    does not have a `parentSegment` defined, it is the head. We use the `ccpAdd` function
    to add the new `moveByCoords` to the head's current position. The `ccpAdd` function
    takes two `ccp` coordinates as arguments and adds them together into a new `ccp`
    value. The end result is a new position for the head segment, moved in the desired
    direction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历 `snakeBody` 数组的所有成员。如果一个片段没有定义 `parentSegment`，那么它就是头部。我们使用 `ccpAdd`
    函数将新的 `moveByCoords` 添加到头部的当前位置。`ccpAdd` 函数接受两个 `ccp` 坐标作为参数，并将它们相加成一个新的 `ccp`
    值。最终结果是头部片段的新位置，向期望的方向移动。
- en: If there is a `parentSegment` defined, it is a normal body segment. Here is
    where we take advantage of the extra variables we added to the `SNSnakeSegment`
    class. We set the segment's position to the prior position of their parent segment.
    This means for each segment, it will move to the same position just vacated by
    the segment in front of it. In this way, the snake's body will follow the same
    path as the head, even through multiple turns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了 `parentSegment`，那么它是一个正常的身体片段。在这里，我们利用了添加到 `SNSnakeSegment` 类中的额外变量。我们将片段的位置设置为它们父片段的前一个位置。这意味着对于每个片段，它将移动到前面片段刚刚空出的相同位置。通过这种方式，蛇的身体将遵循与头部相同的路径，即使是通过多个转弯。
- en: Turning the snake
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蛇的转身
- en: Now that we have addressed moving the snake, we need to make it turn. As we
    just saw in the `move` method, the movement is completely driven by the `snakeDirection`
    variable. All we need to do is adjust that variable, and the snake will move in
    the new direction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了蛇的移动问题，我们需要让它能够转身。正如我们在 `move` 方法中看到的，移动完全由 `snakeDirection` 变量驱动。我们只需要调整这个变量，蛇就会向新的方向移动。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNSnake.m`'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the snake is sent the message to `turnLeft`, and the snake is currently facing
    up, the new direction will be facing left. We check each of the four movement
    directions, and change the snake's direction appropriately. Since the `switch`
    statements are using the integer values underlying the `SnakeHeading` type, it
    is very efficient and lightweight code. We repeat the same structure in the `turnRight`
    command, except we change the `snakeDirection` to turn in the correct "turn right"
    direction. (See the code bundle if you need to see how `turnRight` differs from
    `turnLeft`.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果蛇接收到 `turnLeft` 的消息，并且蛇当前面向上方，新的方向将是面向左侧。我们检查四个移动方向中的每一个，并相应地改变蛇的方向。由于 `switch`
    语句使用的是 `SnakeHeading` 类背后的整数值，因此代码非常高效且轻量级。我们在 `turnRight` 命令中重复相同的结构，只是将 `snakeDirection`
    改变为正确的“向右转”方向。（如果您需要查看 `turnRight` 与 `turnLeft` 的区别，请参阅代码包。）
- en: Death of a snake
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蛇的死亡
- en: There is one method left to complete the snake. At some point, the player will
    do something unfortunate and run into a wall (or their own tail). The snake dies,
    and game is over. We include the visual "death" in the snake class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方法需要完成蛇的功能。在某个时刻，玩家可能会做出不幸的事情，撞到墙壁（或自己的尾巴）。蛇死亡，游戏结束。我们在蛇类中包含了视觉上的“死亡”效果。
- en: '**Filename**: `SNSnake.m`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNSnake.m`'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We leverage `cocos2d` actions to give a nice death sequence. We set up two separate
    `CCRepeatForever` sequences that are run simultaneously on the snake's head. We
    flash red and then back to normal sprite color (setting the color to pure white
    gives the original sprite coloring). We also scale the head to twice its own size,
    and then back to normal. We set these with slightly different durations, so the
    two behaviors are not in lockstep with each other. Together, these provide a nice
    appearance of throbbing pain, perfect for the death of the snake.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用`cocos2d`动作来给出一个漂亮的死亡序列。我们设置了两个分别运行的`CCRepeatForever`序列，这两个序列同时作用于蛇的头。我们使它闪烁红色，然后恢复到正常的精灵颜色（将颜色设置为纯白色给出原始精灵着色）。我们还放大头部到其两倍大小，然后恢复到正常。我们设置这些动作的持续时间略有不同，所以这两个行为不会同步进行。共同作用，这些提供了很好的搏动痛感外观，非常适合蛇的死亡。
- en: Building the environment
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建环境
- en: The snake is now functionally complete, so we turn our attention to building
    an interesting environment for the snake to live in. All of our game objects use
    the same positioning method we saw when designing the snake.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇的功能现在已经完整，因此我们将注意力转向为蛇构建一个有趣的生活环境。我们所有的游戏对象都使用我们在设计蛇时看到的相同定位方法。
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method takes the designated row and column values and multiplies them by
    the `gridSize`. The additional modifiers (-2 and -4) are used to better align
    the walls so there is an equal size of partial walls on the outside edges of the
    screen. This is because the `gridSize` value of `22` does not exactly fit the
    dimensions of the iPhone screen. With this slight adjustment, it looks visually
    centered after we add the outer walls.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将指定的行和列值乘以`gridSize`。额外的修正值（-2和-4）用于更好地对齐墙壁，以便屏幕外部边缘有相等大小的部分墙壁。这是因为`gridSize`值为`22`并不完全符合iPhone屏幕的尺寸。通过这种轻微的调整，在添加外围墙壁后，它看起来在视觉上居中。
- en: Outer walls
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外围墙壁
- en: The first part of the environment to build are the outer walls, since the snake
    needs to be contained on the screen. Let's look at that method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要构建的环境部分是外围墙壁，因为蛇需要被限制在屏幕内。让我们看看那个方法。
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have two separate loops, one for each pair of edges on the screen. The loop
    for the left and right edges is the same, as is the top and bottom edge loop.
    We iterate from the minimum grid position through the maximum grid position for
    that edge of the screen. We base the maximum on the size of the screen divided
    by the `gridSize`, so we will always be at the outside edges, even if we change
    the `gridSize`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个独立的循环，一个用于屏幕上每一对边缘。左右边缘的循环与上下边缘的循环相同。我们从这个边缘的屏幕最小网格位置迭代到最大网格位置。我们基于屏幕大小除以`gridSize`来设置最大值，所以即使我们改变`gridSize`，我们也将始终位于外部边缘。
- en: For each position (and side of the screen), we create a new `CCSprite`, set
    its position, and add it to the layer. We also add it to the `wallsOnField` array.
    The `wallsOnField` array is critical to the collision handling routines we will
    address shortly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个位置（和屏幕的侧面），我们创建一个新的`CCSprite`，设置其位置，并将其添加到层中。我们还将其添加到`wallsOnField`数组中。`wallsOnField`数组对于我们将要解决的碰撞处理程序至关重要。
- en: Inner walls
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部墙壁
- en: When we move to building the inner walls, we have a couple of additional details
    to consider. We need to make sure the position is not already occupied by another
    object. We also want to make sure we don't build a wall in front of the snake.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向构建内部墙壁时，我们需要考虑一些额外的细节。我们需要确保位置没有被其他对象占用。我们还想要确保不要在蛇的前方建造墙壁。
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We start this method by creating a `CGRect` that is directly in front of the
    snake. This `CGRect` assumes the snake is facing up, which is the default we established
    in the `SNSnake` class. Our design does not allow for adding extra walls during
    a level, so we can be sure the snake is facing up when the environment is built.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个方法开始创建一个`CGRect`，它直接位于蛇的前方。这个`CGRect`假设蛇面向上，这是我们已经在`SNSnake`类中建立的默认设置。我们的设计不允许在关卡中添加额外的墙壁，所以我们可以确信在构建环境时蛇是面向上的。
- en: We generate a random position, based on the screen size divided by the `gridSize`.
    We go ahead and build a new wall and add it to the layer. At this point, we don't
    know if the wall is in a good position or not, but we add it anyway. We then proceed
    to iterate through all of our arrays to see if the new wall we just created is
    overlapping an existing object, using a call to `CGRectIntersectsRect`. We also
    check to see if the new wall is in the "line of sight" of the snake. If the wall
    is in an empty position, we add it to the `wallsOnField` array. If it is in a
    bad (occupied) position, we remove the wall from the layer and then call the `createWall`
    method again to build a replacement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据屏幕大小除以`gridSize`生成一个随机位置。然后我们继续构建一个新的墙壁并将其添加到层中。在这个时候，我们还不知道墙壁是否处于合适的位置，但我们仍然添加它。然后我们遍历所有的数组，看看我们刚刚创建的新墙壁是否与现有的对象重叠，这是通过调用`CGRectIntersectsRect`来实现的。我们还检查新墙壁是否在蛇的“视线”范围内。如果墙壁处于空位，我们就将其添加到`wallsOnField`数组中。如果它在不良（被占用）的位置，我们就从层中移除墙壁，然后再次调用`createWall`方法来构建替代品。
- en: Building snake food
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建蛇的食物
- en: 'We only have one type of object left to complete the environment: mice to eat.
    If you recall from our original design, we want the mice to have a limited lifespan
    before they disappear from the playfield. We do this by creating `SNMouse`, a
    subclass of `CCSprite`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一种对象来完成环境：可以吃的老鼠。如果你还记得我们的原始设计，我们希望老鼠在从游戏场消失之前有一个有限的生命周期。我们通过创建`SNMouse`，`CCSprite`的子类来实现这一点。
- en: '**Filename**: `SNMouse.m`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNMouse.m`'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are using a new variable, `lifespan`, and we set it to a random value between
    10 and 20 (this is in seconds). This is defined when the mouse is instantiated,
    so it will be different for each mouse. (Note that we use a class convenience
    method that overrides the `spriteWithSpriteFrameName`. This is needed in `cocos2d
    2.0` because the `init` method is not called during instantiation.) The actual
    creation of the mouse is nearly the same as the `createWall` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个新的变量`lifespan`，并将其设置为10到20秒之间的随机值（这是以秒为单位的）。这是在老鼠实例化时定义的，所以每个老鼠都会不同。（注意，我们使用了一个类便利方法，它覆盖了`spriteWithSpriteFrameName`。在`cocos2d
    2.0`中，这是必需的，因为在实例化期间不会调用`init`方法。）老鼠的实际创建几乎与`createWall`方法相同。
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only structural difference between this method and the `createWall` method
    is that we don't check for the snake's "line of sight" `CGRect`, since there's
    no harm in putting a mouse directly in front of the snake. That's all it takes
    to make snake food.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与`createWall`方法相比，这个方法的唯一结构差异是我们不检查蛇的“视线”`CGRect`，因为将老鼠直接放在蛇的前面没有害处。这就是制作蛇的食物的全部内容。
- en: Collisions and eating
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞和进食
- en: Now that we have all of the visible objects on the screen, we can move to the
    collision detection. Collision detection is actually the easy part. We have already
    written code that looks suspiciously like collision detection in the `createWall`
    and `createMouse` methods. The checks we perform are nearly the same, except we
    are concerned only with collisions involving the head of the snake, since it is
    the only part of the snake that can collide with another surface. Let's look at
    the `checkForCollisions` method in two sections. The first section contains the
    checking for game ending crashes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将屏幕上的所有可见对象都准备好了，我们可以转向碰撞检测。实际上，碰撞检测是容易的部分。我们已经在`createWall`和`createMouse`方法中编写了看起来像碰撞检测的代码。我们执行的检查几乎相同，但我们只关心涉及蛇头的碰撞，因为它是蛇唯一可以与其他表面碰撞的部分。让我们看看`checkForCollisions`方法的两个部分。第一部分包含检查游戏结束的碰撞。
- en: '**Filename**: `SNPlayfieldLayer.m` (`checkForCollisions`, part 1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`（`checkForCollisions`，第一部分）'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we get the head segment to use in all of our collision checking. We compare
    it against all segments in the `snakebody` array. If the `CGRectIntersectsRect`
    is true (that is, the two `CGRects` are overlapping at least a bit), and the segment
    it is testing is not the head, then it has crashed into its own tail. The second
    check is the same `boundingBox` check we used earlier against all the walls in
    the `wallsOnField` array. Any positive hits in these routines will cause the `snakeCrash`
    method to be called.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取头部段以用于所有的碰撞检测。我们将其与`snakebody`数组中的所有段进行比较。如果`CGRectIntersectsRect`为真（即，两个`CGRect`至少有一点重叠），并且它正在测试的段不是头部，那么它已经撞到了自己的尾巴。第二个检查与之前我们对`wallsOnField`数组中所有墙壁进行的`boundingBox`检查相同。这些例程中的任何阳性碰撞都会导致调用`snakeCrash`方法。
- en: The second half is concerned with eating mice. It is a little more involved,
    but still fairly simple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是关于吃老鼠的。这稍微复杂一些，但仍然相当简单。
- en: '**Filename**: `SNPlayfieldLayer.m` (`checkForCollisions`, part 2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`（`checkForCollisions`部分2）'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we look for collisions between the snake's head and the mice on the playfield.
    Because we want to eat the mice, not crash into them, we care more about which
    mouse is being eaten. In this case, we retain the mouse that has just been eaten
    in the `mouseToEat` variable. We do this because part of the process we must go
    through to remove the mouse would cause the array to mutate while iterating through
    it, which would cause the game to crash. So we set `mouseToEat` to reference the
    mouse in question, and set the `isMouseEaten` `BOOL` to `YES`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们寻找蛇头与游戏场上的老鼠之间的碰撞。因为我们想要吃掉老鼠，而不是撞到它们，所以我们更关心哪只老鼠被吃掉。在这种情况下，我们在`mouseToEat`变量中保留刚刚被吃掉的老鼠。我们这样做是因为移除老鼠的过程的一部分会在遍历数组时导致数组突变，这会导致游戏崩溃。因此，我们将`mouseToEat`设置为引用相关老鼠，并将`isMouseEaten`布尔值设置为`YES`。
- en: Once we are safely outside of the loop through the `miceOnField` array, we can
    remove the mouse from the layer (`removeFromParentAndCleanup`) as well as removing
    it from the `miceOnField` array. We then trigger the creation of a new mouse.
    Since each mouse eaten should lengthen the snake by one, we then call the snake's
    `addSegment` method. This is the same method we used in the initial build of the
    snake.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安全地离开了`miceOnField`数组的循环，我们就可以从层中移除老鼠（`removeFromParentAndCleanup`），以及从`miceOnField`数组中移除它。然后我们触发创建一个新的老鼠。由于每吃掉一只老鼠蛇的长度应该增加一，所以我们调用蛇的`addSegment`方法。这是我们在蛇的初始构建中使用的相同方法。
- en: Levels and difficulties
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别和难度
- en: 'You can play on the same level for only a limited time before your snake becomes
    so long that it is impossible to continue. To solve that issue, we will implement
    levels. Additionally, not everyone likes to play at the same speed to begin with,
    so we will also add difficulty or skill levels. We address this need by another
    custom `init` method for the `SNPlayfieldLayer` class, as shown in the following
    shortened form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在同一级别上玩有限的时间，然后你的蛇变得如此长以至于无法继续。为了解决这个问题，我们将实现级别。此外，并不是每个人都愿意以相同的速度开始游戏，所以我们将添加难度或技能级别。我们通过为`SNPlayfieldLayer`类添加另一个自定义的`init`方法来满足这一需求，如下所示简化的形式：
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we create the scene (and subsequently the layer), we pass it to the starting
    level and skill level. We store those passed values in the variables: `levelNum`
    and `currentSkill`. We want the level and skill-based parameters all centralized,
    so all of the level-control values are set in one method, `createSnake`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建场景（以及随后的层）时，我们将它传递给起始级别和技能级别。我们将这些传递的值存储在变量中：`levelNum`和`currentSkill`。我们希望基于级别和技能的参数都集中在一起，所以所有的级别控制值都在一个方法`createSnake`中设置。
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we see how we are setting a few important variables based on the `levelNum`
    and `currentSkill`. Part of the "behind the scenes" is our use of mathematical
    operations using the `currentSkill`. It is of type `SNSkillLevel`, which is another
    custom type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们是如何根据`levelNum`和`currentSkill`设置一些重要变量的。幕后的一部分是我们使用`currentSkill`进行数学运算。它属于`SNSkillLevel`类型，这是另一种自定义类型。
- en: '**Filename**: `SNDefinitions.h`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNDefinitions.h`'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From this you can see that any reference to the `currentSkill` type is actually
    representing values of `1`, `2`, or `3`. So the number of walls we would create
    for a game on `kSkillHard` and level 10 would be `3 + (10 * 3) = 33`. This allows
    the game to slowly ramp up in difficulty, with the skill level determining not
    only that level 1 begins slightly harder, but the actual difficulty scales up
    faster on the harder skill levels.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里你可以看到，任何对`currentSkill`类型的引用实际上代表的是`1`、`2`或`3`的值。所以对于一个在`kSkillHard`和10级上的游戏，我们会创建`3
    + (10 * 3) = 33`个墙壁。这使得游戏难度可以逐渐增加，技能级别不仅决定了级别1开始时稍微困难一些，而且实际难度在更难的技能级别上增长得更快。
- en: The snake speed needs a little explanation. The speed is actually the delay
    between movements. So the lower the number, the faster it moves. Our calculation
    starts at `.3` and uses a formula to speed up as the levels increase. So the previously
    cited example of `kSkillHard` on level 10 would result in a snake speed of `0.3
    – (13 * 0.02)`, which is a pretty fast value of `0.04`. All of this logic was
    centralized in this method so we can tweak the parameters side-by-side as we approach
    our optimal gameplay experience.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇的速度需要稍作解释。速度实际上是移动之间的延迟。所以数字越低，它移动得越快。我们的计算从`.3`开始，并使用一个公式随着级别的增加而加速。所以之前提到的在级别10上的`kSkillHard`示例将导致蛇的速度为`0.3
    – (13 * 0.02)`，这是一个相当快的值`0.04`。所有这些逻辑都集中在这个方法中，这样我们就可以在接近最佳游戏体验时调整参数。
- en: The main loop
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: Much of the remaining functionality is in the `update` method. There are three
    distinct sections of the loop, and we will look at them in turn. The first section
    handles the movement updates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的大部分功能都集中在`update`方法中。循环中有三个不同的部分，我们将依次查看它们。第一部分处理移动更新。
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m` (`update`部分1)'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We use a standard delta time counter to keep adding to the `stepTime` variable.
    On each loop, we check if the `stepTime` is greater than the `snakeSpeed` variable.
    If it is, then we need to move the snake. As discussed in the previous sections
    of the chapter, all we have to do is call the snake's `move` method. The only
    time we need to check for collisions is after the snake's `move` method is called,
    so we call that method next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标准的delta时间计数器来不断向`stepTime`变量中添加。在每次循环中，我们检查`stepTime`是否大于`snakeSpeed`变量。如果是，那么我们需要移动蛇。如前几节所述，我们只需要调用蛇的`move`方法。唯一需要检查碰撞的时间是在调用蛇的`move`方法之后，所以我们接下来调用该方法。
- en: Level-up checking
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级检查
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m` (`update`部分2)'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here we have hard-coded the value of `8` as being the total number of mice
    needed to be eaten per level before we advance. Although we don''t reproduce the
    `showLevelComplete` method here, it unschedules the update, gives a "Level Complete"
    display, and then makes the following call:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们硬编码了`8`作为每级升级前需要吃掉的总老鼠数。虽然我们没有在这里重现`showLevelComplete`方法，但它会取消更新，显示“完成级别”的提示，然后进行以下调用：
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m`'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We call `replaceScene`, requesting the current scene to be replaced with a fresh
    one that is exactly the same, except one level higher. The level-based variables
    we saw in the `createSnake` method will make the next level just a little bit
    harder, and the level up process can continue for as long as the player can keep
    up with it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`replaceScene`，请求将当前场景替换为一个全新的场景，除了级别高一级之外，其他都完全相同。在`createSnake`方法中我们看到的基于级别的变量会使下一级稍微难一些，并且升级过程可以持续进行，直到玩家能够跟上为止。
- en: Dead mice
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死老鼠
- en: The third and final piece of the update loop handles the `lifespan` we discussed
    for the mice. Every mouse already has a semi-random `lifespan`, but we haven't
    done anything with it yet.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 更新循环的第三和最后一部分处理我们讨论的老鼠的`lifespan`。每只老鼠已经有一个半随机的`lifespan`，但我们还没有对它做任何事情。
- en: '**Filename**: `SNPlayfieldLayer.m` (`update`, part 3)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`SNPlayfieldLayer.m` (`update`部分3)'
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We again use the delta time, but this time we subtract the delta from the `lifespan`
    of every mouse on the field. If a mouse's `lifespan` reaches zero, it died of
    old age. We add it to the `deadMice` array so we can get rid of it outside of
    the loop. We use an array in this method because there could be more than one
    mouse whose `lifespan` expires in the same iteration. We remove the dead mice
    from the `miceOnField` array, clear them from the layer, and create new mice in
    their place. This assures that the correct number of mice are on-screen at all
    times.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用delta时间，但这次我们从场地上每只老鼠的`lifespan`中减去delta。如果一个老鼠的`lifespan`达到零，它就因年老而死亡。我们将它添加到`deadMice`数组中，以便在循环外将其移除。我们在这个方法中使用数组，因为可能有不止一只老鼠在同一迭代中`lifespan`到期。我们从`miceOnField`数组中移除死老鼠，从层中清除它们，并在它们的位置创建新的老鼠。这确保了屏幕上始终有正确数量的老鼠。
- en: But…how do we control the snake?
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但是……我们如何控制蛇呢？
- en: The most basic question of all has been completely ignored until now. We have
    dealt with how the game works internally, but we have actually left the player
    out in the cold. It is precisely because we have done so much "under the hood"
    work on the snake and its environment that makes the touch handler really anti-climatic.
    We will focus on the direct user interaction. (There is additional code that handles
    the game over and some basic splash screens that are outside of the scope of this
    chapter.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最基本的问题至今仍未被完全忽略。我们处理了游戏内部的工作方式，但实际上却让玩家处于孤立无援的状态。正是因为我们在蛇及其环境中做了大量的“幕后”工作，才使得触摸处理显得平淡无奇。我们将专注于直接的用户交互。（还有一些处理游戏结束和本章范围之外的某些基本启动屏幕的额外代码。）
- en: '**Filename**: `SNPlayfieldLayer.m`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `SNPlayfieldLayer.m`'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start by using a standard conversion of the touch to OpenGL coordinate space.
    We evaluate the converted touch location and compare its `x` value to determine
    which half of the screen has been touched. If the left half of the screen was
    touched, we instruct the snake to turn left. For the right side, we instruct the
    snake to turn right. You will notice that we are using `ccTouchBegan`, rather
    than `ccTouchEnded`. We want responsiveness as soon as the screen is touched,
    not relying on the player lifting their finger off or moving it around. If they
    want to turn, we want to respond as fast as possible, and only trigger once. The
    touch will not trigger again until their finger is raised and tapped again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用标准的触摸转换到OpenGL坐标空间。我们评估转换后的触摸位置，并将其`x`值进行比较，以确定屏幕的哪一半被触摸。如果屏幕的左侧被触摸，我们指示蛇向左转。对于右侧，我们指示蛇向右转。你会注意到我们使用的是`ccTouchBegan`，而不是`ccTouchEnded`。我们希望在屏幕被触摸时立即响应，而不是依赖于玩家抬起手指或移动手指。如果他们想要转弯，我们希望尽可能快地响应，并且只触发一次。直到他们的手指抬起并再次轻触，触摸才不会再次触发。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have focused more on internal structure than we have on
    complex gameplay. By designing each object as fully contained as possible, it
    insulates the layer from the object. If we wanted to change the way the snake's
    movement is handled, for example, we could make those changes in the `SNSnake`
    class without touching the `SNPlayfieldLayer` at all. We have experimented with
    overriding the `setPosition` method to control the serpentine nature of the snake's
    movement. We have implemented easy collision detection. We have also built our
    first game that includes several difficulty levels with increasingly more difficult
    playable levels. Finally, we have seen how adding a single variable can be all
    we really need to turn a `CCSprite` into a mouse with a life of its own (and how
    to get rid of dead ones).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地关注内部结构，而不是复杂的游戏玩法。通过尽可能完全地设计每个对象，它隔离了层与对象之间的关系。例如，如果我们想改变蛇的运动处理方式，我们可以在`SNSnake`类中进行更改，而无需触及`SNPlayfieldLayer`。我们尝试了覆盖`setPosition`方法来控制蛇的蜿蜒运动。我们还实现了简单的碰撞检测。我们还构建了我们的第一个游戏，该游戏包含几个难度级别，可玩级别越来越难。最后，我们看到了如何添加一个变量就可以将`CCSprite`变成一个拥有自己生命的鼠标（以及如何摆脱那些死去的鼠标）。
- en: In the next chapter we will move on to a brick-breaking game using the `Box2D`
    physics engine. We will use plists to store level data and even build some simple
    power-ups that will change the physics of the game while the game is running.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用`Box2D`物理引擎进行砖块破碎游戏。我们将使用plist存储关卡数据，甚至构建一些简单的升级，这些升级可以在游戏运行时改变游戏的物理特性。
