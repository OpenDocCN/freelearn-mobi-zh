- en: '*Chapter 3*: Understanding Structural Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：理解结构型模式'
- en: This chapter covers **structural patterns** in **Kotlin**. In general, structural
    patterns deal with relationships between **objects**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了**Kotlin**中的**结构型模式**。一般来说，结构型模式处理**对象**之间的关系。
- en: We'll discuss how to extend the functionality of our objects without producing
    complex class hierarchies. We'll also discuss how to adapt to changes in the future
    or fix some of the design decisions taken in the past, as well as how to reduce
    the memory footprint of our program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何在不产生复杂类层次结构的情况下扩展我们对象的功能。我们还将讨论如何适应未来的变化或修复过去所做的某些设计决策，以及如何减少我们程序的内存占用。
- en: 'In this chapter, we will cover the following patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下模式：
- en: Decorator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Adapter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Facade
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: By the end of this chapter, you'll have a better understanding of how to compose
    your objects so that they can be simpler to extend and adapt to different types
    of changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更好地理解如何组合你的对象，以便它们可以更容易地扩展并适应不同类型的变更。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The requirements for this chapter are the same as the previous chapters—you'll
    need **IntelliJ IDEA** and the **JDK**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与前面的章节相同——你需要**IntelliJ IDEA**和**JDK**。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03)。
- en: Decorator
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'In the previous chapter, we discussed the **Prototype** design pattern, which
    allows us to create instances of classes with slightly (or not so slightly) different
    data. This raises a question:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**原型**设计模式，它允许我们创建具有略微（或不是那么略微）不同数据的类的实例。这引发了一个问题：
- en: '*What if we want to create a set of classes that all have slightly different
    behavior?*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们想创建一组所有都具有略微不同行为的类会发生什么？*'
- en: Well, since functions in Kotlin are *first-class citizens* (which we will explain
    in this chapter), you could use the Prototype design pattern to achieve this aim.
    After all, creating a set of classes with slightly different behavior is what
    JavaScript does successfully. But the goal of this chapter is to discuss another
    approach to the same problem. After all, design patterns are all about *approaches*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，由于Kotlin中的函数是**一等公民**（我们将在本章中解释这一点），你可以使用原型设计模式来实现这个目标。毕竟，创建一组具有略微不同行为的类是JavaScript成功做到的事情。但本章的目标是讨论对同一问题的另一种方法。毕竟，设计模式都是关于**方法**的。
- en: By implementing the **Decorator** design pattern, we allow the users of our
    code to specify the abilities they want to add.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现**装饰器**设计模式，我们允许我们的代码用户指定他们想要添加的能力。
- en: Enhancing a class
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强类
- en: 'Let''s say that we have a rather simple class that registers all of the captains
    in the Star Trek universe along with their vessels:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个相当简单的类，它注册了星际迷航宇宙中的所有船长及其船只：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One day, your captain—sorry, *scrum master*—comes to you with an urgent requirement.
    From now on, every time someone searches for a captain, we must also log this
    into a console. However, there''s a catch to this simple task: you cannot modify
    the `StarTrekRepository` class directly. There are other consumers for this class,
    and they don''t need this logging behavior.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一天，你的船长——抱歉，*敏捷大师*——来找你，有一个紧急要求。从现在起，每次有人搜索船长时，我们必须也将此记录到控制台。然而，这个简单任务有一个陷阱：你不能直接修改`StarTrekRepository`类。这个类还有其他消费者，他们不需要这个记录行为。
- en: But before we dive deeper into this problem, let's discuss one peculiarity we
    can observe in our class – that is, a strange operator you can see in the `getCaptain`
    function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入探讨这个问题之前，让我们讨论一下我们可以在我们的类中观察到的某个特性——那就是在`getCaptain`函数中可以看到的一个奇怪的运算符。
- en: The Elvis operator
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爱丽丝运算符
- en: In [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*, we learned that Kotlin is not only strongly typed, but it is also a null-safe
    language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B17816_01_ePub.xhtml#_idTextAnchor015) *Kotlin入门*中，我们了解到Kotlin不仅强类型，而且还是一种空安全语言。
- en: '*What happens if, as in our example, there could be no value stored in a map
    for a particular key?*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果，像我们的例子一样，某个键在映射中可能没有存储值会发生什么？*'
- en: If we're working with a map, one option is to use the `getOrDefault` method
    that maps provide in Kotlin. This might be a viable option in this particular
    case, but it won't work in situations where you might have to deal with a null
    value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在处理一个映射，一个选项是使用 Kotlin 提供的 `getOrDefault` 方法。在这种情况下，这可能是一个可行的选项，但在你可能需要处理空值的情况下，它将不起作用。
- en: 'Another option is to use the `?:`). If you''re wondering about how this operator
    got its name, it does resemble Elvis Presley''s hairstyle somewhat:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `?:` 操作符。如果你想知道这个操作符名字的由来，它确实在一定程度上与猫王艾维斯·普雷斯利的发型相似：
- en: '![Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks
    a bit like a pompadour hairstyle'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 如果我们将 Elvis 操作符顺时针旋转 90 度，它看起来有点像庞克发型]'
- en: '](img/B17816_03_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17816_03_01.jpg](img/B17816_03_01.jpg)'
- en: Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks a
    bit like a pompadour hairstyle
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 如果我们将 Elvis 操作符顺时针旋转 90 度，它看起来有点像庞克发型]'
- en: 'The goal of the Elvis operator is to provide a default value in case we receive
    a null value. Take another look at the `getCaptain` function to see how this is
    done. The *desugared* form of the same function would be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis 操作符的目标是在我们收到空值时提供一个默认值。再次看看 `getCaptain` 函数，看看这是如何实现的。该函数的 *去糖化* 形式如下：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, you can see that this operator saves us a lot of typing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到这个操作符为我们节省了很多打字。
- en: The inheritance problem
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承问题
- en: 'Let''s go back to the task at hand. Since our class and its methods are declared
    open, we can extend the class and override the function we need:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到手头的任务。由于我们的类及其方法被声明为公开的，我们可以扩展这个类并覆盖我们需要的函数：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That was quite easy! Although the name of that class is getting quite long.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单！尽管那个类的名字变得越来越长。
- en: 'Note how we delegate to the implementation in our parent class by using the
    `super` keyword here. However, the next day, your boss (sorry, *scrum-master*)
    comes again and asks for another feature. When adding a captain, we need to check
    that their name is no longer than 15 characters. That may be a problem for some
    Klingons, but you decide to implement it anyway. And, by the way, this feature
    should not be related to the logging feature we developed previously. Sometimes
    we just want the logging, and sometimes we just want the validation. So, here''s
    what our new class will look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过使用 `super` 关键字将实现委托给父类的。然而，第二天，你的老板（抱歉，*敏捷大师*）又来要求另一个功能。在添加船长时，我们需要检查他们的名字长度不超过
    15 个字符。这可能对一些克林贡人来说是个问题，但你决定无论如何都要实现它。顺便说一下，这个功能不应与之前开发的日志记录功能相关。有时我们只想记录日志，有时我们只想进行验证。所以，我们的新类将如下所示：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another task done.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务已完成。
- en: 'However, the next day, another requirement arises: in some cases, we need `StarTrekRepository`
    to have logging enabled and also perform validation at the same time. I guess
    we''ll have to name it `LoggingGetCaptainValidatingAddCaptainStarTrekRepository`
    now.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二天，又出现了另一个需求：在某些情况下，我们需要 `StarTrekRepository` 具有日志记录功能并执行验证。我想我们现在得把它命名为
    `LoggingGetCaptainValidatingAddCaptainStarTrekRepository`。
- en: Problems like this are surprisingly common, and they are a clear indication
    that a design pattern may help us here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题出奇地常见，并且它们是设计模式可能在这里帮助我们的一个明确迹象。
- en: The purpose of the Decorator design pattern is to add new behaviors to our objects
    dynamically. In our example, *logging* and *validating* are two behaviors that
    we sometimes want to be applied to our object and sometimes don't want to be applied.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式的目的是动态地为我们的对象添加新行为。在我们的例子中，*日志记录* 和 *验证* 是我们有时希望应用到对象上，有时又不想应用的行为。
- en: 'We''ll start by converting our `StarTrekRepository` into an interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `StarTrekRepository` 转换为一个接口：
- en: '[PRE29]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we''ll implement that interface using the same logic as before:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用之前的逻辑实现该接口：
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, instead of extending our concrete implementation, we''ll implement the
    interface and use a new keyword called `by`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不会扩展我们的具体实现，而是实现接口并使用一个新的关键字 `by`：
- en: '[PRE42]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `by` keyword delegates the implementation of an interface to another object.
    That's why the `LoggingGetCaptain` class doesn't have to implement any of the
    functions declared in the interface. They are all implemented by default by another
    object that the instance wraps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` 关键字将接口的实现委托给另一个对象。这就是为什么 `LoggingGetCaptain` 类不需要实现接口中声明的任何函数。它们都由实例包装的另一个对象默认实现。'
- en: 'In this case, the hardest part to understand is the signature. What we need
    from the Decorator design pattern is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最难理解的部分是签名。我们需要从装饰器设计模式中得到如下内容：
- en: We need to be able to receive the object we're decorating.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够接收我们装饰的对象。
- en: We need to be able to keep a reference to the object.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够保留对象的引用。
- en: When our decorator is called, we need to be able to decide if we would like
    to change the behavior of the object we're holding or to delegate the call.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的装饰器被调用时，我们需要能够决定是否要改变我们持有的对象的行为，或者要委托调用。
- en: We need to be able to extract an interface or have one provided already by the
    (library) author.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够提取一个接口或者由（库）作者提供。
- en: Note that we don't use the `super` keyword anymore. If we tried to, it wouldn't
    work, as there is a class that we're implementing now. Instead, we use the reference
    to the `wrapped` interface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再使用`super`关键字。如果我们尝试这样做，它将不会工作，因为我们现在正在实现一个类。相反，我们使用对`wrapped`接口的引用。
- en: 'To make sure we understand this pattern, let''s implement our second decorator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们理解这个模式，让我们实现我们的第二个装饰器：
- en: '[PRE49]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The only difference between the preceding example and the `ValidatingAddCaptainStarTrekRepository`
    implementation is that we use the `require` function instead of an `if` expression.
    This is often more readable, and it will also throw `IllegalArgumentException`
    if the expression is `false`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子和`ValidatingAddCaptainStarTrekRepository`实现之间的唯一区别是我们使用`require`函数而不是`if`表达式。这通常更易于阅读，如果表达式为`false`，它还会抛出`IllegalArgumentException`。
- en: 'Let''s see how it works now:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE60]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The last line will throw an exception:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将抛出异常：
- en: '[PRE65]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, this pattern allows us to *compose behavior*, just as we wanted.
    Now, let's take a short detour and discuss *operator overloading* in Kotlin, as
    this will help us to improve our design pattern even more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个模式允许我们*组合行为*，正如我们希望的那样。现在，让我们短暂地偏离一下，讨论一下 Kotlin 中的*操作符重载*，因为这将帮助我们进一步改进我们的设计模式。
- en: Operator overloading
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符重载
- en: 'Let''s take another look at the interface that was extracted. Here, we are
    describing basic operations on a map that are usually associated with array/map
    access and assignment. In Kotlin, we have some nice syntactic sugar called `DefaultStarTrekRepository`,
    we can see that working with maps is very intuitive in Kotlin:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看提取的接口。在这里，我们描述了通常与数组/映射访问和赋值相关的基本映射操作。在 Kotlin 中，我们有一些称为`DefaultStarTrekRepository`的语法糖，我们可以看到在
    Kotlin 中处理映射是非常直观的：
- en: '[PRE66]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It would be useful if we could work with our repository as if it was a map:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够像使用地图一样使用我们的仓库，那将很有用：
- en: '[PRE68]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using Kotlin, we can actually achieve this behavior quite easily. First, let''s
    change our interface:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kotlin，我们实际上可以非常容易地实现这种行为。首先，让我们改变我们的接口：
- en: '[PRE70]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that we've added the `operator` keyword that prefixes the function definition.
    Let's understand what this keyword means.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在函数定义前添加了`operator`关键字。让我们理解这个关键字的意义。
- en: 'Most programming languages support some form of operator overloading. Let''s
    take **Java** as an example and look at the following two lines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都支持某种形式的操作符重载。让我们以**Java**为例，看看以下两行代码：
- en: '[PRE74]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can see that the `+` operator acts differently depending on whether the
    arguments are strings or integers. That is, it can add two numbers, but it can
    also concatenate two strings. You can imagine that the *plus* operation can be
    defined on other types. For example, it makes a lot of sense to concatenate two
    lists using the same operator:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`+`操作符根据参数是字符串还是整数而表现出不同的行为。也就是说，它可以添加两个数字，也可以连接两个字符串。你可以想象，*加*操作可以在其他类型上定义。例如，使用相同的操作符连接两个列表是非常有意义的：
- en: '[PRE76]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unfortunately, this code won't compile in Java, and we can't do anything about
    it. That's because operator overloading is a feature reserved to the language
    itself, and not for its users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码在 Java 中无法编译，我们对此无能为力。这是因为操作符重载是语言本身保留的功能，而不是为用户保留的。
- en: 'Let''s look at another extreme, the **Scala** programming language. In Scala,
    any set of characters can be defined as an operator. So, you may encounter code
    such as the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个极端，**Scala**编程语言。在 Scala 中，任何一组字符都可以被定义为操作符。因此，你可能会遇到以下这样的代码：
- en: '[PRE77]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Kotlin takes a middle ground between these two approaches. It allows you to
    overload certain *well-known* operations, but it limits what can and cannot be
    overloaded. Although this list is limited, it is quite long, so we''ll not write
    it in full here. However, you can find it in the official Kotlin documentation:
    [https://kotlinlang.org/docs/operator-overloading.html](https://kotlinlang.org/docs/operator-overloading.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 在这两种方法之间采取中间立场。它允许你重载某些 **知名** 操作，但限制了可以和不可以重载的内容。尽管这个列表有限，但它相当长，所以我们不会在这里全部列出。然而，你可以在官方
    Kotlin 文档中找到它：[https://kotlinlang.org/docs/operator-overloading.html](https://kotlinlang.org/docs/operator-overloading.html)。
- en: If you use the `operator` keyword with a function that is unsupported or with
    the wrong set of arguments, you'll get a compilation error. The square brackets
    that we started with in the previous code example are called indexed access operators
    and correlate with the `get(x)` and `set(x, y)` methods we have just defined.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `operator` 关键字与不支持或参数设置错误的函数一起使用，你将得到一个编译错误。我们在上一个代码示例中开始使用的方括号称为索引访问运算符，与我们所定义的
    `get(x)` 和 `set(x, y)` 方法相关。
- en: Caveats of the Decorator design pattern
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器设计模式的注意事项
- en: The Decorator design pattern is great because it lets us compose objects *on
    the fly*. And using Kotlin's `by` keyword makes it easy to implement. But there
    are still limitations that you need to be aware of.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式很棒，因为它允许我们即时组合对象。使用 Kotlin 的 `by` 关键字使其易于实现。但仍然存在一些限制，你需要注意。
- en: 'First, you cannot see *inside* of the Decorator. This means that there''s no
    way of knowing which specific object it wraps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你无法看到装饰器的 **内部**。这意味着没有办法知道它包装了哪个特定的对象：
- en: '[PRE78]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Although `withLoggingAndValidating` contains `ValidatingAdd` (and it may behave
    like it), it is not an instance of `ValidatingAdd`! Keep that in mind when performing
    casts and type checks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `withLoggingAndValidating` 包含 `ValidatingAdd`（并且它可能表现得像这样），但它并不是 `ValidatingAdd`
    的一个实例！在进行类型转换和类型检查时，请记住这一点。
- en: So, you might wonder where this pattern would be used in the real world. One
    example is the `java.io.*` package, with classes implementing the `Reader` and
    `Writer` interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会想知道这个模式在现实世界中会用在何处。一个例子是 `java.io.*` 包，其中包含实现 `Reader` 和 `Writer` 接口类的类。
- en: 'For example, if you want to read a file efficiently, you can use `BufferedReader`,
    which receives another reader as its constructor argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想高效地读取文件，你可以使用 `BufferedReader`，它将另一个读取器作为其构造函数参数：
- en: '[PRE86]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`FileReader` serves this purpose, as it implements the `Reader` interface.
    So does `BufferedReader` itself.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader` 用于此目的，因为它实现了 `Reader` 接口。`BufferedReader` 本身也实现了。'
- en: Let's move on to our next design pattern.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们的下一个设计模式。
- en: Adapter
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: The main goal of the **Adapter** design pattern is to convert one interface
    to another interface. In the physical world, the best example of this idea would
    be an electrical plug adapter or a USB adapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器**设计模式的主要目标是转换一个接口到另一个接口。在现实世界中，这个想法的最好例子可能是电源插头适配器或USB适配器。'
- en: Imagine yourself in a hotel room late in the evening, with 7% battery left on
    your phone. Your phone charger was left in the office at the other end of the
    city. You only have an EU plug charger with a Mini USB cable. But your phone uses
    USB-C, as you had to upgrade. You're in New York, so all of your outlets are (of
    course) USB-A. So, what do you do? Oh, it's easy. You look for a Mini USB to USB-C
    adapter in the middle of the night and hope that you have remembered to bring
    your EU to US plug adapter as well. Only 5% battery left – time is running out!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自己在晚上很晚的时候在酒店房间里，手机只剩下 7% 的电量。你的手机充电器被遗忘在城市的另一端的办公室里。你只有一个 EU 插头充电器和 Mini
    USB 线。但你的手机使用 USB-C，因为你不得不升级。你在纽约，所以所有的插座当然都是 USB-A。那么，你该怎么办？哦，很简单。你在半夜找 Mini
    USB 到 USB-C 适配器，并希望你还记得带上 EU 到 US 插头适配器。只剩下 5% 的电量——时间正在流逝！
- en: So, now that we understand what adapters are for in the physical world, let's
    see how we can apply the same principle in code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了适配器在现实世界中的作用，让我们看看我们如何在代码中应用同样的原则。
- en: Let's start with interfaces.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从接口开始。
- en: '`USPlug` assumes that power is `Int`. It has `1` as its value if it has power
    and any other value if it doesn''t:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`USPlug` 假设电源是 `Int`。如果它有电源，其值为 `1`；如果没有，则值为任何其他值：'
- en: '[PRE87]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`EUPlug` treats power as `String`, which is either `TRUE` or `FALSE`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`EUPlug` 将电源视为 `String`，其值为 `TRUE` 或 `FALSE`：'
- en: '[PRE90]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For `UsbMini`, power is an `enum`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `UsbMini`，电源是一个 `enum`：
- en: '[PRE93]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, for `UsbTypeC`, power is a `Boolean` value:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `UsbTypeC`，电源是一个 `Boolean` 值：
- en: '[PRE99]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Our goal is to bring the power value from a US power outlet to our cellphone,
    which will be represented by this function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将美国电源插座中的功率值传输到我们的手机上，这将被这个函数表示：
- en: '[PRE102]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Let''s start by declaring what a US power outlet will look like in our code.
    It will be a function that returns a `USPlug`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先声明一下在我们的代码中美国电源插座将是什么样子。它将是一个返回`USPlug`的函数：
- en: '[PRE109]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the previous chapter, we discussed two different uses of the `object` keyword.
    In the global scope, it creates a Singleton object. When used together with the
    `companion` keyword inside of a class, it creates a place for defining `static`
    functions. The same keyword can also be used to generate anonymous classes. Anonymous
    classes are classes that are created *on the fly*, usually to implement an interface
    in an ad-hoc manner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了`object`关键字的不同用法。在全局范围内，它创建一个单例对象。当与类内部的`companion`关键字一起使用时，它为定义`static`函数提供了一个位置。相同的关键字也可以用来生成匿名类。匿名类是在*即时*创建的类，通常用于以临时方式实现接口。
- en: 'Our charger will be a function that takes `EUPlug` as an input and outputs
    `UsbMini`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可充电器将是一个函数，它以`EUPlug`作为输入并输出`UsbMini`：
- en: '[PRE115]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Next, let''s try to combine our `cellPhone`, `charger`, and `usPowerOutlet`
    functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试组合我们的`cellPhone`、`charger`和`usPowerOutlet`函数：
- en: '[PRE122]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: As you can see, we get two different type errors – the Adapter design pattern
    should help us solve these.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们得到了两个不同的类型错误——适配器设计模式应该帮助我们解决这些问题。
- en: Adapting existing code
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配现有代码
- en: 'We need two types of adapters: one for our power plugs and another one for
    our USB ports.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两种类型的适配器：一种用于我们的电源插座，另一种用于我们的USB端口。
- en: In Java, you would usually create a pair of classes for this purpose. In Kotlin,
    we can replace these classes with **extension functions**. We already mentioned
    extension functions briefly in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*. Now, it's time to cover them in more detail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你通常会为此目的创建一对类。在Kotlin中，我们可以用**扩展函数**来替换这些类。我们已经在[*第一章*](B17816_01_ePub.xhtml#_idTextAnchor015)，“Kotlin入门”中简要提到了扩展函数。现在，是时候更详细地介绍它们了。
- en: 'We could adapt the US plug to work with the EU plug by defining the following
    extension function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义以下扩展函数来使US插头与EU插头兼容：
- en: '[PRE129]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The `this` keyword in the context of an extension function refers to the object
    we're extending – just as if we were implementing this method inside of the class
    definition. Again, we use an anonymous class to implement the required interface
    on the fly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数中的`this`关键字指的是我们要扩展的对象——就像我们在这个类的定义内部实现这个方法一样。再次强调，我们使用匿名类来即时实现所需的接口。
- en: 'We can create a USB adapter between the Mini USB and USB-C instances in a similar
    way:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式在Mini USB和USB-C实例之间创建一个USB适配器：
- en: '[PRE136]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Finally, we can get back online again by combining all those adapters together:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过组合所有这些适配器来重新上线：
- en: '[PRE142]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As you can see, we didn't have to create any new classes that implement these
    interfaces. By using Kotlin's extension functions, our code stays short and to
    the point.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不必创建任何实现这些接口的新类。通过使用Kotlin的扩展函数，我们的代码保持简短且直接。
- en: The Adapter design pattern is more straightforward than the other design patterns,
    and you'll see it used widely. Now, let's discuss some of its real-world uses
    in more detail.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式比其他设计模式更直接，你将看到它被广泛使用。现在，让我们更详细地讨论一些其现实世界的应用。
- en: Adapters in the real world
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的适配器
- en: You've probably encountered many uses of the Adapter design pattern already.
    These are normally used to adapt between *concepts* and *implementations*. For
    example, let's take the concept of a JVM collection versus the concept of a JVM
    stream.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经遇到了许多适配器设计模式的用法。这些通常用于在*概念*和*实现*之间进行适配。例如，让我们以JVM集合的概念与JVM流的概念为例。
- en: 'We already discussed `listOf()` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`listOf()`函数：
- en: '[PRE147]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'A **stream** is a *lazy* collection of elements. You cannot simply pass a collection
    to a function that receives a stream, even though it may make sense:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是一个*延迟*的元素集合。你不能简单地将一个集合传递给接收流的函数，即使这可能是有意义的：'
- en: '[PRE148]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Luckily, collections provide us with the `.stream()` adapter method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，集合为我们提供了`.stream()`适配器方法：
- en: '[PRE152]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Many other Kotlin objects have adapter methods that usually start with `to`
    as a prefix. For example, `toTypedArray()` converts a list to an array.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他Kotlin对象都有以`to`为前缀的适配器方法。例如，`toTypedArray()`将列表转换为数组。
- en: Caveats of using adapters
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器的注意事项
- en: '*Have you ever plugged a 110 V US appliance into a 220 V EU socket through
    an adapter, and fried it totally?*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*你有没有把110伏的美国电器通过适配器插到220伏的欧盟插座上，然后完全烧毁过？*'
- en: 'If you''re not careful, that''s something that could also happen to your code.
    The following example uses another adapter, and it also compiles well:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不够小心，你的代码也可能发生这种情况。以下示例使用另一个适配器，它也能编译：
- en: '[PRE153]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: But it never completes because `Stream.generate()` produces an infinite list
    of integers. So, be careful and adopt this design pattern wisely.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它永远不会完成，因为`Stream.generate()`产生了一个无限整数列表。所以，要小心，并且明智地采用这种设计模式。
- en: Bridge
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接
- en: While the Adapter design pattern helps you to work with legacy code, the **Bridge**
    design pattern helps you to avoid abusing inheritance. The way it works is actually
    very simple.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**适配器**设计模式可以帮助你处理遗留代码，但**桥接**设计模式可以帮助你避免滥用继承。它的工作方式实际上非常简单。
- en: Let's imagine we want to build a system to manage different kinds of troopers
    for the Galactic Empire.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要构建一个系统来管理银河帝国的不同类型的冲锋队员。
- en: 'We''ll start with an interface:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个接口开始：
- en: '[PRE155]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'And we''ll create multiple implementations for different types of troopers:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为不同类型的冲锋队员创建多个实现：
- en: '[PRE159]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'There are also stronger versions of them:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也有更强的版本：
- en: '[PRE175]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'And there are also scout troopers that can run faster than the others:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有能够比其他人跑得快的侦察兵：
- en: '[PRE185]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: That's a lot of classes!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多类！
- en: 'One day, our dear designer comes and asks that all stormtroopers should be
    able to shout, and each will have a different phrase. Without thinking twice,
    we add a new function to our interface:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，我们亲爱的设计师来了，要求所有的冲锋队员都应该能够喊话，每个人都会有一个不同的短语。没有多想，我们在我们的接口中添加了一个新的功能：
- en: '[PRE190]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: By doing that, all the classes that implement this interface stop compiling.
    And we have a lot of them. That's a lot of changes that we'll have to make. So,
    we'll just have to suck it up and get to work.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，所有实现这个接口的类都无法编译了。我们有很多这样的类。这意味着我们需要做出很多修改。所以，我们只能硬着头皮去工作了。
- en: '*Or will we?*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们真的会这样做吗？*'
- en: We go and change the implementations of five different classes, feeling lucky
    that there are only five and not fifty.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去修改了五个不同类的实现，感到幸运的是只有五个而不是五十个。
- en: Bridging changes
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接更改
- en: The idea behind the Bridge design pattern is to flatten the class hierarchy
    and have fewer specialized classes in our system. It also helps us to avoid the
    *fragile base class* problem when modifying the superclass introduces subtle bugs
    to classes that inherit from it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥接**设计模式背后的思想是简化类层次结构，并在我们的系统中拥有更少的专用类。它还帮助我们避免在修改超类时引入对继承它的类产生微妙错误的*脆弱基类*问题。'
- en: 'First, let''s try to understand why we have this complex hierarchy and many
    classes. It''s because we have two orthogonal, unrelated properties: *weapon type*
    and *movement speed*.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试理解为什么我们有这样一个复杂的层次结构和许多类。这是因为我们有两个正交、无关的属性：*武器类型*和*移动速度*。
- en: 'Let''s say that instead, we wanted to pass those properties to the constructor
    of a class that implements the same interface we have been using all along:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将这些属性传递给一个实现我们一直在使用的相同接口的类的构造函数：
- en: '[PRE195]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The properties that `StormTrooper` receives should be interfaces, so we can
    choose their implementation later:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`StormTrooper`接收的属性应该是接口，这样我们就可以稍后选择它们的实现：'
- en: '[PRE206]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Notice that these methods return `Meters` and `PointsOfDamage` instead of simply
    returning `Long` and `Int`. This feature is called **type aliasing**. To understand
    how this works, let's take a short detour.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法返回`Meters`和`PointsOfDamage`而不是简单地返回`Long`和`Int`。这个特性被称为**类型别名**。为了理解它是如何工作的，让我们短暂地偏离一下。
- en: Type aliasing
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: Kotlin allows us to provide alternative names for existing types. These are
    called **aliases**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许我们为现有类型提供替代名称。这些被称为**别名**。
- en: 'To declare an alias, we use a new keyword: `typealias`. From now on, we can
    use `Meters` instead of plain old `Int` to return from our `move()` method. These
    aren''t new types. The Kotlin compiler will always translate `PointsOfDamage`
    to `Long` during compilation. Using them provides two advantages:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个别名，我们使用一个新的关键字：`typealias`。从现在开始，我们可以使用`Meters`而不是普通的`Int`来从我们的`move()`方法返回。这些不是新类型。Kotlin编译器在编译时始终将`PointsOfDamage`转换为`Long`。使用它们提供了两个优点：
- en: The first advantage is *better semantics* (as in our case). We can tell exactly
    what the *meaning* of the value we're returning is.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个优点是*更好的语义*（就像我们的情况一样）。我们可以确切地知道我们返回的值的*含义*。
- en: The second advantage is being *concise*. Type aliases allow us to hide complex
    generic expressions. We'll expand on this in the following sections.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个优点是简洁。类型别名允许我们隐藏复杂的泛型表达式。我们将在接下来的章节中进一步探讨这一点。
- en: Constants
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: Let's go back to our `StormTrooper` class. It's time to provide some implementations
    for the `Weapon` and `Legs` interfaces.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`StormTrooper`类。现在是时候为`Weapon`和`Legs`接口提供一些实现了。
- en: 'First, let''s define the regular damage and speed of `StormTrooper`, using
    imperial units:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义`StormTrooper`的常规伤害和速度，使用帝国单位：
- en: '[PRE214]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: These values are very effective since they are known during compilation.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在编译时已知，因此非常有效。
- en: Unlike `static final` variables in Java, they cannot be placed inside a class.
    You should place them either at the top level of your package or nest them inside
    of an object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java中的`static final`变量不同，它们不能放在类内部。你应该将它们放在包的顶层，或者将它们嵌套在对象内部。
- en: 'Important Note:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'Although Kotlin has type inference, we can specify the types of our constants
    explicitly and even use type aliases. *How about having* `DEFAULT_TIMEOUT : Seconds
    = 60` *instead of* `DEFAULT_TIMEOUT_SECONDS = 60` *in your code?*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然Kotlin有类型推断，但我们仍然可以明确指定常量的类型，甚至可以使用类型别名。*那么，在你的代码中使用`DEFAULT_TIMEOUT : Seconds
    = 60`而不是`DEFAULT_TIMEOUT_SECONDS = 60`怎么样？*'
- en: 'Now, we can provide some implementations for our interfaces:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的接口提供一些实现：
- en: '[PRE216]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Next, let''s look at how we can move the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何移动以下内容：
- en: '[PRE225]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Finally, we need to make sure that we can implement the same functionality
    without the complex class hierarchy we had before:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保我们可以实现相同的功能，而不需要之前复杂类层次结构：
- en: '[PRE231]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Now we have a flat class hierarchy, which is much simpler to extend and also
    to understand. If we need more functionality, such as the shouting ability we
    mentioned earlier, we would add a new interface and a new constructor argument
    for our class.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个扁平的类层次结构，这使它更容易扩展和理解。如果我们需要更多的功能，比如我们之前提到的呼喊能力，我们就会为我们的类添加一个新的接口和一个新的构造函数参数。
- en: In the real world, this pattern is often used in conjunction with dependency
    injection frameworks. For example, this would allow us to replace an implementation
    that used a real database with a mocked interface. This would make our code easier
    to set up and faster to test.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，这种模式通常与依赖注入框架结合使用。例如，这将允许我们用一个模拟接口替换使用真实数据库的实现。这将使我们的代码更容易设置，并且测试速度更快。
- en: Composite
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: 'This chapter is dedicated to composing objects within one another, so it may
    look strange to have a separate section for the **Composite** design pattern.
    As a result, this raises a question:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于介绍如何在对象之间组合对象，因此单独有一个关于**组合**设计模式的章节可能会显得有些奇怪。因此，这引发了一个问题：
- en: '*Shouldn''t this design pattern encompass all of the others?*'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个设计模式难道不应该包含所有其他的设计模式吗？*'
- en: As in the case of the Bridge design pattern, the name may not reflect its true
    uses and benefits.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 就像桥接设计模式的情况一样，名称可能并不反映其真正的用途和好处。
- en: Let's continue with our `StormTrooper` example from before. Lieutenants of the
    Empire quickly discover that no matter how well equipped, stormtroopers cannot
    hold their ground against the rebels because they are uncoordinated.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续之前的`StormTrooper`例子。帝国的尉官们很快发现，无论装备多么精良，风暴兵都无法抵挡叛军的进攻，因为他们缺乏协调。
- en: To provide better coordination, the Empire decides to introduce the concept
    of a *squad* for the stormtroopers. A squad should contain one or more stormtrooper
    of any kind, and when given commands, it should behave exactly as if it was a
    single unit.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的协调，帝国决定为风暴兵引入一个名为`squad`的概念。一个`squad`应该包含一个或多个任何类型的风暴兵，并且当接到命令时，它应该表现得就像一个单一的单元。
- en: '`Squad`, clearly, consists of a collection of stormtroopers:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`Squad`显然是由一组风暴兵组成的：'
- en: '[PRE234]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Let''s add a couple of them to begin with:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加几个：
- en: '[PRE235]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'To make our squad act as if it was a single unit, we''ll add two methods to
    it called `move` and `attack`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的`squad`表现得像一个单一的单元，我们将向其中添加两个名为`move`和`attack`的方法：
- en: '[PRE237]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Both functions will repeat any received orders to all of the units they contain.
    At first, the approach seems to be working. However, what happens if we change
    our `Trooper` interface by adding a new function? Consider the following code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都会将接收到的命令重复给它们包含的所有单位。起初，这个方法看起来似乎有效。然而，如果我们通过添加一个新函数来更改`Trooper`接口，会发生什么呢？考虑以下代码：
- en: '[PRE249]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Nothing seems to break, but our `Squad` class stops doing what it was supposed
    to do – that is, act as if it was a single unit. A single unit now has a method
    that our composite class does not.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎没有出现问题，但我们的`Squad`类不再执行它应该执行的操作——即表现得像一个单一的单位。现在，单一的单位有一个我们的组合类没有的方法。
- en: 'In order to prevent this from happening in the future, let''s see what happens
    if our `Squad` class implements the same interface as the units it contains:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止未来发生这种情况，让我们看看如果我们的`Squad`类实现了与包含的单位相同的接口会发生什么：
- en: '[PRE254]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'That change will force us to implement the `retreat` function and mark the
    other two functions with the `override` keyword:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改将迫使我们实现`retreat`函数，并用`override`关键字标记其他两个函数：
- en: '[PRE255]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Now, we'll take a short detour to discuss an alternative and more convenient
    approach to this example – one that would allow us to construct the same object
    but result in a composite that is more pleasant to use.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将短暂地偏离主题，讨论一种替代且更方便的方法来处理这个例子——一种可以构建相同对象但结果更易于使用组合的方法。
- en: Secondary constructors
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 次级构造函数
- en: 'Our code did achieve its goals. However, it would be good if instead of passing
    a list of stormtroopers to the constructor (as we do now), we could pass our stormtroopers
    directly, without wrapping them in a list:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码确实实现了其目标。然而，如果我们可以直接传递我们的风暴兵，而不是像现在这样传递风暴兵的列表给构造函数，那会更好：
- en: '[PRE266]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: One way to achieve this is to add `Squad` class.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是为`Squad`类添加。
- en: 'Up until now, we were always using the *primary constructor* of the class.
    That''s the constructor declared after the class name. But we can define more
    than one constructor for a class. We can define secondary constructors for a class
    using the `constructor` keyword inside the class body:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用类的*主构造函数*。这是在类名之后声明的构造函数。但我们可以为类定义多个构造函数。我们可以在类体内部使用`constructor`关键字为类定义次级构造函数：
- en: '[PRE268]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Unlike Java, there's no need to repeat the class name for each constructor.
    That also means fewer changes are required if you decide to rename the class.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，没有必要为每个构造函数重复类名。这也意味着，如果你决定重命名类，所需进行的更改会更少。
- en: Note how each secondary constructor must call the primary constructor. This
    is similar to using the `super` keyword in Java.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个次级构造函数都必须调用主构造函数。这类似于在Java中使用`super`关键字。
- en: The varargs keyword
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`vararg`关键字'
- en: This is clearly not the way to go, since we cannot predict how many more elements
    someone might want to pass us. If you come from Java, you have probably thought
    about `Trooper... units`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个好的方法，因为我们无法预测有人可能会想传递给我们多少个元素。如果你来自Java，你可能已经考虑过`Trooper... units`。
- en: 'Kotlin provides us with the `vararg` keyword for the same purpose. By combining
    a secondary constructor with `varargs`, we get the following piece of code, which
    is very nice:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为我们提供了`vararg`关键字来实现相同的目的。通过将次级构造函数与`varargs`结合，我们得到以下代码，这非常不错：
- en: '[PRE274]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Now, we are able to create a squad with any number of stormtroopers without
    the need to wrap them in a list first:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够创建包含任意数量风暴兵的班，而无需首先将它们包装在列表中：
- en: '[PRE279]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Let''s try to understand how this works under the hood. The Kotlin compiler
    translates a `vararg` argument to an `Array` of the same type:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这是如何工作的。Kotlin编译器将`vararg`参数转换为相同类型的`Array`：
- en: '[PRE280]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Arrays in Kotlin have an Adapter method that allows them to be converted to
    a list of the same type. Interestingly, we can use the Adapter design pattern
    to help us implement the Composite design pattern.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的数组有一个适配器方法，允许它们被转换为相同类型的列表。有趣的是，我们可以使用适配器设计模式来帮助我们实现组合设计模式。
- en: Nesting composites
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套组合
- en: 'The Composite design pattern has another interesting property. Previously,
    we proved that we can create a squad containing multiple stormtroopers. We can
    also create a squad of squads:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式还有一个有趣的特性。之前，我们证明了我们可以创建包含多个风暴兵的班。我们还可以创建班的班：
- en: '[PRE281]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Now, giving an order to the platoon will work in exactly the same way as giving
    it to a squad. In fact, this pattern allows us to support a tree-like structure
    of arbitrary complexity and to perform operations on all of its nodes.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向排下达命令的方式将与向班下达命令的方式完全相同。实际上，这种模式允许我们支持任意复杂度的树状结构，并对所有节点执行操作。
- en: 'The Composite design pattern may seem a bit incomplete until we reach the next
    chapter, where we will discover its partner: the **Iterator** design pattern.
    When both design patterns are combined, they really shine. If you are still unsure
    how this pattern is useful after completing this section, come back to it after
    you have also learned about the Iterator design pattern.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式可能在我们达到下一章之前看起来有点不完整，在那里我们将发现它的伙伴：**迭代器**设计模式。当这两种设计模式结合使用时，它们真的会发光。如果你在完成本节后仍然不确定这个模式有什么用，在你学习了迭代器设计模式之后，再回过头来复习它。
- en: In the real world, the Composite design pattern is widely used in `Group` widget
    in `View` interface in order to be able to act on their behalf.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，组合设计模式在`View`接口中的`Group`小部件中被广泛使用，以便能够代表它们执行操作。
- en: As long as all the objects in the hierarchy implement the same interface, no
    matter how deep the nesting is, we can ask the top-level object to invoke an action
    on everything beneath it.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 只要层次结构中的所有对象都实现了相同的接口，无论嵌套有多深，我们都可以要求顶层对象对其下方的所有对象执行一个操作。
- en: Facade
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: The use of *facade* as a term to refer to a design pattern comes directly from
    building architecture. That is, a facade is the face of a building that is normally
    made to look more appealing than the rest of it. In programming, *facades* can
    help to hide the ugly details of an implementation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 将“外观”作为一个术语来指代设计模式直接来源于建筑学。也就是说，外观是建筑物的正面，通常被设计得比其他部分更有吸引力。在编程中，“外观”可以帮助隐藏实现中的丑陋细节。
- en: The **Facade** design pattern itself aims to provide a nicer, simpler way to
    work with a family of classes or interfaces. We previously discussed the idea
    of a family of classes when covering the **Abstract Factory** design pattern.
    The Abstract Factory design pattern focuses on creating related classes, while
    the Facade design pattern focuses on working with them once they have been created.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式设计模式本身旨在提供一种更优雅、更简单的方式来处理一组类或接口。我们之前在介绍**抽象工厂**设计模式时讨论了类族的概念。抽象工厂设计模式侧重于创建相关类，而外观模式设计模式侧重于创建后如何使用它们。
- en: 'To better understand this, let''s go back to the example we used for the Abstract
    Factory design pattern. In order to be able to start our server from a configuration
    using our Abstract Factory, we could provide users of our library with a set of
    instructions:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们回顾一下我们用于抽象工厂设计模式的示例。为了能够从配置文件使用我们的抽象工厂启动服务器，我们可以向我们的库用户提供一组指令：
- en: Check if the given file is `.json` or `.yaml` by trying to parse it with a **JSON**
    parser.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尝试使用**JSON**解析器解析它来检查给定的文件是否为`.json`或`.yaml`。
- en: If we received an error, try parsing it using a **YAML** parser.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们收到错误，尝试使用**YAML**解析器解析它。
- en: If there were no errors, pass the results to the Abstract Factory to create
    the necessary objects.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有错误，将结果传递给抽象工厂以创建必要的对象。
- en: While helpful, following this set of instructions may require quite a bit of
    skill and knowledge. Developers may struggle to find the correct parser, or they
    might ignore any exceptions thrown from a JSON parser in instances where it's
    dealing with a `.yaml` file, for example.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有帮助，但遵循这一系列指令可能需要相当多的技能和知识。开发者可能难以找到正确的解析器，或者他们可能会忽略在处理`.yaml`文件等情况下从JSON解析器抛出的任何异常。
- en: '*What problems are our users facing at the moment?*'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的用户目前面临什么问题？*'
- en: 'To load a configuration, they will need to interact with at least three different
    interfaces:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载配置，它们至少需要与三个不同的接口进行交互：
- en: A JSON parser (covered in the *Abstract Factory* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 解析器（在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)的*抽象工厂*部分中介绍，*使用创建型模式*）
- en: YAML Parser (covered in the *Abstract Factory* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 解析器（在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)的*抽象工厂*部分中介绍，*使用创建型模式*）
- en: Server Factory (covered in the *Factory Method* section in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*)
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器工厂（在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)的*工厂方法*部分中介绍，*使用创建型模式*）
- en: Instead, it would be great to have a single function (`startFromConfiguration()`)
    that would take a path to a configuration file, parse it, and then, if there were
    no errors in the process, start our server.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有一个单独的函数（`startFromConfiguration()`）会很好，它将接受一个配置文件的路径，解析它，然后，如果在过程中没有错误，启动我们的服务器。
- en: We'll be providing a *facade* to our users to simplify working with a set of
    classes. One way to achieve this goal would be to provide a new class to encapsulate
    all of this logic for us. This is a common tactic in most languages.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为用户提供一个 *门面*，以简化与一组类的交互。实现这一目标的一种方法是为我们提供一个新的类来封装所有这些逻辑。这在大多数语言中是一种常见的策略。
- en: 'However, in Kotlin, we have a better option that uses a technique we already
    discussed in this chapter when covering the Adapter design pattern. We can make
    `startFromConfiguration()` an *extension function* on the `Server` class:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Kotlin 中，我们有一个更好的选择，这个选择使用了一种我们在本章讨论适配器设计模式时已经讨论过的技术。我们可以将 `startFromConfiguration()`
    作为 `Server` 类的一个 *扩展函数*：
- en: '[PRE282]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: You can see that this implementation is exactly the same as in the Adapter design
    pattern. The only difference is the end goal. In the case of the Adapter design
    pattern, the goal is to make an otherwise *unusable* class *usable*. Remember,
    one of the goals of the Kotlin language is to *reuse* as much as possible. For
    the Façade design pattern, the goal is to make a *complex* group of classes *easy
    to use*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个实现与适配器设计模式中的实现完全相同。唯一的区别是最终目标。在适配器设计模式的情况下，目标是使一个原本 *不可用* 的类 *可用*。记住，Kotlin
    语言的一个目标就是尽可能多地 *重用*。对于门面设计模式，目标是使一个 *复杂* 的类组 *易于使用*。
- en: 'Important Note:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Depending on when you read this book, you may not need the `ExperimentalPathApi`
    annotation anymore. This feature was introduced in Kotlin 1.4, and once it is
    stable it will be made an integral part of the language.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你阅读这本书的时间，你可能不再需要 `ExperimentalPathApi` 注解。这个特性是在 Kotlin 1.4 中引入的，一旦它稳定，它将成为语言的一个组成部分。
- en: We already discussed that in Kotlin, `try` is an *expression* that returns a
    *value*. Here, you can see that we can also return a value from a `catch` block,
    further reducing the need for mutable variables.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，在 Kotlin 中，`try` 是一个 *表达式*，它会返回一个 *值*。在这里，你可以看到我们也可以从 `catch` 块中返回一个值，这进一步减少了对于可变变量的需求。
- en: Next, let's understand what happens in the first two lines of this function.
    `Path` is a rather new API that was introduced in `toFile` is an example of the
    Adapter design pattern that converts between a path and an actual file. Finally,
    the `readLine()` function will attempt to read the entire file into memory, split
    line by line. Consider using the Facade design pattern when working with any code
    base that would benefit from being simplified.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解这个函数的前两行发生了什么。`Path` 是一个相对较新的 API，它在 `toFile` 中是一个适配器设计模式的例子，它将路径转换为实际的文件。最后，`readLine()`
    函数将尝试将整个文件读入内存，按行分割。考虑在使用任何可以从简化中受益的代码库时使用门面设计模式。
- en: Flyweight
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元
- en: '`data` class. But a `data` class is all about state.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 类。但 `data` 类完全是关于状态的。'
- en: '*So, is the data class related to the Flyweight design pattern at all?*'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，数据类与享元设计模式有什么关系吗？*'
- en: To understand this design pattern better, we need to jump back in time some
    twenty years. Back in 1994, when the original *Design Patterns* book was published,
    your regular PC had 4 MB of RAM. During this period, one of the main goals of
    any process was to save that precious RAM, as you could fit only so much into
    it.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个设计模式，我们需要回顾二十年前。在 1994 年，当原始的 *设计模式* 书籍出版时，你的普通 PC 只有 4 MB 的 RAM。在这个时期，任何进程的主要目标都是节省那宝贵的
    RAM，因为你可以放入其中的东西是有限的。
- en: Nowadays, some *cellphones* have 8 GB of RAM. Bear that in mind when we discuss
    what the Flyweight design pattern is all about in this section.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些 *手机* 有 8 GB 的 RAM。当我们讨论本节中享元设计模式的内容时，请记住这一点。
- en: Having said that, let's see how we can use our resources more efficiently, as
    this is always important!
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看我们如何更有效地使用我们的资源，因为这始终很重要！
- en: Being conservative
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保守
- en: Imagine we're building a 2D side-scrolling arcade platform game. That is, you
    have your game character, which you control with arrow keys or a gamepad. Your
    character can move left, right, and jump.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在构建一个 2D 侧滚动街机平台游戏。也就是说，你有你的游戏角色，你可以用箭头键或游戏手柄来控制它。你的角色可以左右移动，并且可以跳跃。
- en: Since we're a really small indie company consisting of one developer (who is
    also a graphic designer, product manager, and sales representative), two cats,
    and a canary named Michael, we use only 16 colors in our game. And our character
    is 64 pixels tall and 64 pixels wide.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是一家非常小的独立公司，由一位开发者（同时也是图形设计师、产品经理和销售代表）、两只猫和一只名叫 Michael 的金丝雀组成，我们在游戏中只使用了
    16 种颜色。而且我们的角色高 64 像素，宽 64 像素。
- en: 'Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian
    snails:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色有很多敌人，主要由肉食性的坦桑尼亚蜗牛组成：
- en: '[PRE294]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Since it''s a 2D game, each snail has only two directions of movement: `LEFT`
    and `RIGHT`. We can represent these directions using an `enum` class:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个2D游戏，每只蜗牛只有两个移动方向：`LEFT`和`RIGHT`。我们可以使用`enum`类来表示这些方向：
- en: '[PRE295]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'To be able to draw itself on a screen, each snail will hold a pair of images
    and a direction:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在屏幕上绘制自己，每只蜗牛将保存一对图像和一个方向：
- en: '[PRE299]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'Important Note:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The definition of the `File` class comes from `java.io.File`. Remember that
    you can always refer to our GitHub project to see the needed imports.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类的定义来自`java.io.File`。请记住，您始终可以参考我们的GitHub项目以查看所需的导入。'
- en: 'Based on the direction, we can get the current sprite that shows us which direction
    the snail is facing and use this to draw it:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 根据方向，我们可以获取当前精灵，它显示了蜗牛面向的方向，并使用它来绘制蜗牛：
- en: '[PRE307]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: When any of the enemies move, they basically just slide left or right.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何敌人移动时，它们基本上只是向左或向右滑动。
- en: 'What we would like is to have multiple animated sprites to reproduce the snail''s
    movements in each direction. We can generate a list of such sprites for each snail
    enemy using a `List` generator:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拥有多个动画精灵来再现蜗牛在每个方向上的移动。我们可以使用`List`生成器为每只蜗牛敌人生成这样的精灵列表：
- en: '[PRE313]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: Here, we initialize a list of eight elements, passing a `block` function as
    a constructor. The benefit of this approach is that we can apply complex logic
    during the creation of a collection while still keeping it effectively immutable.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化一个包含八个元素的列表，将一个`block`函数作为构造函数传递。这种方法的优点是在创建集合的同时，我们仍然可以有效地保持其不可变。
- en: 'For each element, we decide what image to get:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个元素，我们决定获取哪个图像：
- en: Positions `0` and `1` are for still images, facing left and right.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置`0`和`1`用于静止图像，面向左和右。
- en: Positions `2` through `4` are for moving left.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置`2`到`4`用于向左移动。
- en: Positions `5` through `7` are for moving right.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置`5`到`7`用于向右移动。
- en: Let's do some math now. Each snail is represented by a 64 x 64 image. Assuming
    each color takes up exactly one byte, the single images will take up 4 KB of RAM
    in the memory. Since we have eight images for a snail, we need 32 KB of RAM for
    each one, which allows us to fit only 32 snails into 1 MB of memory.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做一些数学计算。每只蜗牛由一个64 x 64的图像表示。假设每种颜色恰好占用一个字节，单个图像将占用4 KB的RAM。由于我们每只蜗牛有八张图像，因此每只蜗牛需要32
    KB的RAM，这使得我们只能在1 MB的内存中容纳32只蜗牛。
- en: Since we want to have thousands of these dangerous and extremely fast creatures
    on screen and to be able to run our game on a 10-year-old phone, we clearly need
    a better solution.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在屏幕上显示成千上万这种危险且极其快速的生物，并且能够在10年前的手机上运行我们的游戏，我们显然需要一个更好的解决方案。
- en: Saving memory
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节省内存
- en: '*What''s the problem we have with all of our snails?*'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们所有的蜗牛有什么问题？*'
- en: 'They''re actually quite fat, heavyweight snails. We would like to put them
    on a diet. Each snail stores eight images within its *snaily* body. But these
    images are actually the same for each snail. This raises a question:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实际上相当胖，是重型的蜗牛。我们希望给它们节食。每只蜗牛在其*蜗牛状*身体内存储了八张图像。但这些图像对每只蜗牛来说实际上是相同的。这引发了一个问题：
- en: '*What if we extract those sprites into a Singleton object or a Factory Method
    and then only reference them from each instance?*'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们将这些精灵提取到一个单例对象或工厂方法中，然后只从每个实例中引用它们会怎样？*'
- en: 'For example, consider the following code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE324]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: This way, our `getCurrentSprite` function could stay the same, and we'll only
    consume 256 KB of memory, no matter how many snails we generate. We could generate
    millions of them without affecting the footprint of our program.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的`getCurrentSprite`函数可以保持不变，并且无论我们生成多少只蜗牛，我们只会消耗256 KB的内存。我们可以生成数百万只蜗牛，而不会影响我们程序的体积。
- en: And this is exactly the idea behind the Flyweight design pattern. That is, limit
    the number of heavyweight objects (in our case, the image files) by sharing them
    between the lightweight objects (in our case, the snails).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Flyweight设计模式的理念。也就是说，通过在轻量级对象（在我们的例子中是蜗牛）之间共享它们来限制重量级对象（在我们的例子中是图像文件）的数量。
- en: Caveats of the Flyweight design pattern
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flyweight设计模式的注意事项
- en: We should take extra care about the immutability of the data we pass. If, for
    example, we used `var` instead of `val` in our Singleton, it could be disastrous
    for our code. The same goes for mutable data structures. We wouldn't want someone
    removing an image, replacing it, or clearing the list of images altogether.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该特别注意我们传递的数据的不可变性。例如，如果我们在一个单例中用`var`代替`val`，这可能会对我们的代码造成灾难。同样，对于可变数据结构也是如此。我们不希望有人删除图片、替换它，或者完全清除图片列表。
- en: Luckily, Kotlin makes handling these cases rather easy. Just make sure to always
    use values instead of variables in your extrinsic state, and remember to use immutable
    data structures, which cannot be altered after they have been created.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kotlin使得处理这些情况变得相当容易。只需确保在你的外部状态中始终使用值而不是变量，并记住使用不可变数据结构，这些数据结构在创建后不能被更改。
- en: You can debate the usefulness of this pattern in this era of plentiful memory.
    However, as we have already said, the tools in the toolbox don't take up much
    space, and having another design pattern under your belt may still prove useful.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以辩论在这个内存丰富的时代这个模式的有用性。然而，正如我们之前所说的，工具箱中的工具并不占用多少空间，而且拥有另一个设计模式在你的口袋里可能仍然是有用的。
- en: Proxy
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Much like the Decorator design pattern, the **Proxy** design pattern extends
    an object's functionality. However, unlike a decorator, which always does what
    it's told, having a proxy may mean that when asked to do something, the object
    does something totally different.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 与装饰者设计模式类似，**代理**设计模式扩展了一个对象的功能。然而，与总是按指示行事装饰者不同，拥有一个代理可能意味着当被要求做某事时，对象会做完全不同的事情。
- en: When we discussed **Creational Patterns** in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*, we already touched on the idea of *expensive*
    objects. For example, an object that accesses network resources or takes a lot
    of time to create.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)“使用创建型模式”中讨论**创建型模式**时，我们已经提到了*昂贵*对象的概念。例如，一个访问网络资源或需要很长时间创建的对象。
- en: We at the *Funny Cat App* provide our users with funny cat images on a daily
    basis. On our homepage and mobile application, each user sees a lot of pictures
    of funny cats. When they click or touch any of those images, it expands to its
    full-screen glory.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**Funny Cat App**上为用户提供每日的搞笑猫咪图片。在我们的主页和移动应用中，每位用户都能看到许多搞笑猫咪的图片。当他们点击或触摸这些图片中的任何一张时，它就会扩展到全屏的辉煌。
- en: Fetching cat images over the network is very expensive, and it consumes a lot
    of memory, especially if those are images of cats that tend to indulge in a second
    dessert after dinner. What we want to do is fetch the full-sized image only once
    at the time it is requested. And if it is requested multiple times, we want to
    be able to show it to family or friends. In short, we don't want to have to fetch
    it every time.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络获取猫咪图片非常昂贵，并且消耗大量内存，尤其是如果这些是那些晚餐后倾向于再来一份甜点的猫咪的图片。我们想要做的是，在请求时只获取一次全尺寸图片。如果它被多次请求，我们希望能够向家人或朋友展示它。简而言之，我们不想每次都要获取它。
- en: There's no way to avoid loading the image once. But when it's being accessed
    for the second time, we would like to avoid going over the network again and instead
    return the result that was cached in memory. That's the idea of the **Proxy**
    design pattern; instead of the expected behavior of going over the network each
    time, we're being a bit lazy and returning the result that we already prepared.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法避免加载图片一次。但当它第二次被访问时，我们希望避免再次通过网络获取，而是返回内存中缓存的那个结果。这就是**代理**设计模式的想法；而不是每次都通过网络获取预期的行为，我们变得有点懒惰，返回我们已经准备好的结果。
- en: It's a bit like going into a cheap diner, ordering a hamburger, and getting
    it after only two minutes, but cold. Well, that's because someone else hated onions
    and returned it to the kitchen a while ago. True story.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像走进一家便宜的餐厅，点了一份汉堡，两分钟后就拿到了，但却是冷的。嗯，那是因为有人不喜欢洋葱，所以之前就把它退回厨房了。这是真的。
- en: 'This sounds like it would require a lot of logic. But as you''ve probably guessed
    (especially after meeting the Decorator design pattern), Kotlin can perform miracles
    by reducing the amount of boilerplate code you need to write to achieve your goals:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能需要很多逻辑。但正如你可能猜到的（尤其是在遇到装饰者设计模式之后），Kotlin可以通过减少你需要编写的样板代码来达到你的目标，从而创造奇迹：
- en: '[PRE338]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Previously, we've seen the `by` keyword in a different context – that is, when
    delegating the implementation of an interface to another class (as discussed in
    *The Decorator design pattern* section of this chapter).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在不同的上下文中看到了 `by` 关键字——即，当将接口的实现委托给另一个类时（如本章中“装饰器设计模式”部分所述）。
- en: As you may have noticed, in this case, we use the `by` keyword to delegate the
    initialization of a field to happen later. We use a function called `lazy`, which
    is one of the `image` property, it will execute our code block and save its results
    into the `image` property. The following invocations of that property will simply
    return its value.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，在这种情况下，我们使用 `by` 关键字将字段的初始化委托给稍后进行。我们使用一个名为 `lazy` 的函数，它是 `image`
    属性之一，它将执行我们的代码块并将结果保存到 `image` 属性中。对该属性的后续调用将简单地返回其值。
- en: 'Sometimes, the Proxy design pattern is divided into three sub-patterns:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，代理设计模式被分为三个子模式：
- en: '**Virtual proxy**: Lazily caches the result'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟代理**：延迟缓存结果'
- en: '**Remote proxy**: Issues a call to the remote resource'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程代理**：向远程资源发出调用'
- en: '**Protection or access control proxy**: Denies access to unauthorized parties'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护或访问控制代理**：拒绝未经授权的访问'
- en: You can regard our previous example as either a virtual proxy or a combination
    of the virtual and remote types of proxies.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将我们之前的示例视为虚拟代理或虚拟和远程代理类型的组合。
- en: Lazy delegation
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载委托
- en: You may wonder what happens if two threads try to initialize the image at the
    same time. By default, the `lazy()` function is synchronized. Only one thread
    will win, and others will wait until the image is ready.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如果两个线程同时尝试初始化图像会发生什么。默认情况下，`lazy()` 函数是同步的。只有一个线程会获胜，其他线程将等待图像准备就绪。
- en: If you don't mind two threads executing the lazy block (for example, if it's
    not that expensive), you can use `lazy(LazyThreadSafetyMode.PUBLICATION)` instead.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎两个线程执行懒加载块（例如，如果它并不那么昂贵），你可以使用 `lazy(LazyThreadSafetyMode.PUBLICATION)`
    代替。
- en: If performance is absolutely critical for you and you're absolutely sure that
    two threads won't ever execute the same block simultaneously, you can use `LazyThreadSafetyMode.NONE`,
    which is not thread-safe.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能对你至关重要，并且你绝对确信两个线程永远不会同时执行相同的代码块，你可以使用 `LazyThreadSafetyMode.NONE`，它不是线程安全的。
- en: Proxying and delegation is a very useful approach for many complex problems,
    and we'll explore this in the following chapters.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 代理和委托是解决许多复杂问题的非常有用方法，我们将在接下来的章节中探讨这一点。
- en: Summary
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how structural design patterns can help us
    to create more flexible code that can adapt to changes with ease, sometimes even
    at runtime. We've covered how we can add functionality to an existing class with
    the Decorator design pattern, and we've explored how *operator overloading* can
    allow us to provide more intuitive syntax to common operations.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了结构型设计模式如何帮助我们创建更灵活的代码，这些代码可以轻松适应变化，有时甚至在运行时。我们介绍了如何使用装饰器设计模式向现有类添加功能，以及我们探讨了如何通过重载运算符提供更直观的语法来执行常见操作。
- en: We then learned how to adapt one interface to another interface using extension
    methods, and we also learned how to create anonymous objects to implement an interface
    only once. Next, we discussed how to simplify class hierarchies using the Bridge
    design pattern. You should now know how to create a shortcut for a type name with
    `typealias` and also how to define efficient constants with `const`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用扩展方法将一个接口适配到另一个接口，并且我们也学习了如何创建匿名对象以实现接口的一次性实现。接下来，我们讨论了如何使用桥接设计模式简化类层次结构。你现在应该知道如何使用
    `typealias` 为类型名创建快捷方式，以及如何使用 `const` 定义高效的常量。
- en: Moving on, we looked at the Composite design pattern, and we considered how
    it could help you to design a system that needs to treat groups of objects and
    regular objects in the same way. We also learned about secondary constructors
    and how a function can receive an *arbitrary number of arguments* when using the
    `vararg` keyword. We learned how the Facade design pattern helps us to simplify
    working with complex systems by exposing a simple interface, while the Flyweight
    design pattern allows us to reduce the memory footprint of our application.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了组合设计模式，并考虑了它如何帮助你设计需要以相同方式处理对象组和常规对象系统的系统。我们还学习了辅助构造函数以及当使用 `vararg`
    关键字时，一个函数可以接收任意数量的参数。我们学习了外观设计模式如何通过提供一个简单的接口来帮助我们简化与复杂系统的交互，而享元设计模式允许我们减少应用程序的内存占用。
- en: Finally, we've covered how delegating to another class works in Kotlin, implementing
    the same interface and using the `by` keyword in the Proxy design pattern and
    demonstrating its use with a `lazy` delegate. With these design patterns, you
    should be able to structure your system in a much more extensible and maintainable
    manner.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经介绍了在 Kotlin 中如何通过委托给另一个类来实现功能，实现相同的接口，并在 Proxy 设计模式中使用 `by` 关键字，并通过一个
    `lazy` 委托来展示其用法。使用这些设计模式，你应该能够以更可扩展和可维护的方式构建你的系统。
- en: 'In the next chapter, we''ll discuss the third family of classic design patterns:
    behavioral patterns.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论经典设计模式的第三大家族：行为模式。
- en: Questions
  id: totrans-604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What differences are there between the implementations of the Decorator and
    Proxy design patterns?
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Decorator 和 Proxy 设计模式的实现之间有什么区别？
- en: What is the main goal of the Flyweight design pattern?
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flyweight 设计模式的主要目标是什么？
- en: What is the difference between the Facade and Adapter design patterns?
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Facade 和 Adapter 设计模式之间有什么区别？
