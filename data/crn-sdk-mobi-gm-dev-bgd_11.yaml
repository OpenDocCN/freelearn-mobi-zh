- en: Chapter 11. Implementing In-App Purchases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。实现应用内购买
- en: In-App Purchase is an optional feature, which developers can use to embed a
    store directly within an app. Sometimes you may want to extend more features in
    your current game to keep your consumers interested in playing. Here's your chance
    and possibly more revenue in your pocket!
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用内购买是一个可选功能，开发者可以使用它将商店直接嵌入到应用中。有时你可能想扩展你当前游戏中的更多功能，以保持消费者对游戏的兴趣。这是你的机会，也许还能让你的口袋里多些收入！
- en: 'This chapter only concerns with In-App Purchases in the Apple iTunes Store
    for the iOS platform. If you are a paid Corona SDK subscriber, In-App Purchase
    support for Android via Google''s Google Play Store (not available on Kindle Fire
    and Nook) is available in the Daily Builds page starting with build 2012.760\.
    The Daily Builds can be found at: [http://developer.anscamobile.com/downloads/daily-builds](http://developer.anscamobile.com/downloads/daily-builds).
    Android developers who want to implement In-App Purchases in their apps can use
    this as an alternative.'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章仅涉及 iOS 平台的 Apple iTunes Store 中的应用内购买。如果你是付费的 Corona SDK 订阅者，从构建 2012.760
    开始，Daily Builds 页面提供了通过 Google Play Store（Kindle Fire 和 Nook 上不可用）的 Android 应用内购买支持。Daily
    Builds 可以在以下网址找到：[http://developer.anscamobile.com/downloads/daily-builds](http://developer.anscamobile.com/downloads/daily-builds)。希望在自己的应用中实现应用内购买的
    Android 开发者可以使用这个作为替代方案。
- en: 'We''ll cover the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Consumable, non-consumable, and subscription purchases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可消耗、不可消耗和订阅购买
- en: Making transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行交易
- en: Restoring purchased items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复已购买的项目
- en: Initializing Corona's store module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 Corona 的商店模块
- en: Creating and testing In-App Purchases on a device
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上创建和测试应用内购买
- en: Ready, set, go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 准备，设置，出发！
- en: The wonders of In-App Purchase
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用内购买的奇妙之处
- en: 'The purpose of implementing In-App Purchase is to add an in-app payment functionality
    to collect payment for enhanced functionality or additional content usable in
    your game. The following are options of incorporating this feature:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实现应用内购买的目的是在应用内添加支付功能，以收集增强功能或可用于游戏的额外内容的费用。以下是将此功能整合的选项：
- en: A game that offers new level packs to play outside of the default content
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供新关卡包以供在默认内容之外游玩的游戏
- en: A freemium game that allows you to purchase virtual currency to create/build
    new assets during gameplay
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款允许你在游戏过程中购买虚拟货币以创建/构建新资产的免费增值游戏
- en: Adding additional characters or special power ups to enhance game elements
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外的角色或特殊能力提升游戏元素
- en: These are some examples that can be done with In-App Purchases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些可以使用应用内购买完成的事例。
- en: In-App Purchases allow users to purchase additional content within an application.
    The App Store manages transaction information only. Developers cannot use the
    App Store to deliver content. So, either you bundle content with your app when
    you ship it waiting to be unlocked upon purchase, or you have to work out your
    own system to download the data if you wish to deliver content.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用内购买允许用户在应用程序内购买额外内容。App Store 仅管理交易信息。开发者不能使用 App Store 来交付内容。因此，你可以在发布应用时将内容捆绑到应用中，等待购买解锁，或者如果你希望交付内容，你必须制定自己的系统来下载数据。
- en: Types of In-App Purchases
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用内购买类型
- en: 'There are several In-App Purchase types you can apply in your apps. They are
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的应用中应用几种不同的应用内购买类型。具体如下：
- en: '**Consumable:** These are products that must be purchased each time the user
    needs that item. They''re typically a one-time service, such as money in an app
    where you need to pay for supplies to build structures.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可消耗的：** 这些是每次用户需要该物品时都必须购买的产品。它们通常是单次服务，例如在应用中需要付费购买用于建造结构的材料。'
- en: '**Non-consumable:** These are products that only need to be purchased once
    by the user. This could be additional level packs in a game.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可消耗的：** 这些是用户只需购买一次的产品。这可能是游戏中额外的关卡包。'
- en: '**Auto-renewable subscription:** These are products that allow the user to
    purchase in-app content for a set duration of time. An example of an auto-renewable
    subscription would be a magazine or newspaper that takes advantage of the auto-renewing
    functionality built into iOS.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动续订订阅：** 这些是允许用户购买设定时间段的内嵌内容的商品。自动续订订阅的一个例子是利用 iOS 中内置的自动续订功能订阅的杂志或报纸。'
- en: '**Free subscriptions:** These are used to put free subscription content in
    newsstands. Once a user signs up for a free subscription, it will be available
    on all devices associated with the user''s Apple ID. Note that free subscriptions
    do not expire and can only be offered in newsstand-enabled apps.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免费订阅**：这些用于将免费订阅内容放入新闻亭。一旦用户注册免费订阅，它将在与用户的Apple ID关联的所有设备上可用。请注意，免费订阅不会过期，并且只能在启用了新闻亭的应用中提供。'
- en: '**Non-renewing subscriptions:** Similar to auto-renewable subscriptions, this
    is a non-renewing subscription that requires a user to renew each time the subscription
    is due to expire. Your app must contain code that recognizes when the expiration
    occurs. It must also prompt the user to purchase a new subscription. An auto-renewable
    subscription eliminates these steps.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非续订订阅**：类似于自动续订订阅，这是一种非续订订阅，每次订阅到期时都需要用户续订。您的应用程序必须包含代码以识别何时发生到期。它还必须提示用户购买新的订阅。自动续订订阅消除了这些步骤。'
- en: Corona's store module
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Corona的store模块
- en: 'Applying In-App Purchases in your application can be a little mind-boggling
    and a tedious process. Integrating it with Corona requires calling the `store`
    module:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中应用内购可能是一个有点令人困惑且繁琐的过程。与Corona集成需要调用`store`模块：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `store` module is already incorporated into the Corona API, similar to
    Facebook and Game Network. You can find more information on Corona''s `store`
    module at the following URL: [http://developer.anscamobile.com/reference/in-app-purchases](http://developer.anscamobile.com/reference/in-app-purchases).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`store`模块已经集成到Corona API中，类似于Facebook和游戏网络。您可以在以下URL中找到有关Corona的`store`模块的更多信息：[http://developer.anscamobile.com/reference/in-app-purchases](http://developer.anscamobile.com/reference/in-app-purchases)。'
- en: store.init()
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`store.init()`'
- en: This must be called when handling store transactions to your app. It activates
    In-App Purchases and allows you to receive callbacks with the listener function
    you specify.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理商店交易到您的应用程序时必须调用此方法。它激活内购，并允许您通过指定的监听器函数接收回调。
- en: 'Syntax:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Parameters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`listener`—This function that will handle transaction callback events.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`listener`—将处理交易回调事件的函数。'
- en: 'Example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: 'The following blocks determine the transaction states that can occur during
    an In-App Purchase. The four different states are: purchased, restored, cancelled,
    and failed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块确定在应用内购买过程中可能发生的交易状态。四种不同的状态是：已购买、已恢复、已取消和失败。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: event.transaction
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`event.transaction`'
- en: The object containing the transaction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 包含交易的对象。
- en: 'The transaction object supports the following read-only properties:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 交易对象支持以下只读属性：
- en: '`state`—A string containing the state of the transaction. Valid values are`"purchased",
    "restored", "cancelled"`, and`"failed"`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`—包含交易状态的字符串。有效值是`"purchased"`、`"restored"`、`"cancelled"`和`"failed"`。'
- en: '`productIdentifier`—The product identifier associated with the transaction.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productIdentifier`—与交易关联的产品标识符。'
- en: '`receipt`—A unique receipt returned from the store. It is returned as a hexadecimal
    string.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receipt`—从商店返回的唯一收据。它以十六进制字符串的形式返回。'
- en: '`identifier`—A unique transaction identifier returned from the store. It is
    a string.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identifier`—从商店返回的唯一交易标识符。它是一个字符串。'
- en: '`date`—The date of when the transaction occurred.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`—交易发生的日期。'
- en: '`originalReceipt`—A unique receipt returned from the store from the original
    purchase attempt. This is mostly relevant in a case of a restore. It is returned
    as a hexadecimal string.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originalReceipt`—从原始购买尝试中从商店返回的唯一收据。这在恢复情况下尤为重要。它以十六进制字符串的形式返回。'
- en: '`originalIdentifier`—A unique transaction identifier returned from the store
    from the original purchase attempt. This is mostly relevant in a case of a restore.
    It is a string.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originalIdentifier`—从原始购买尝试中从商店返回的唯一交易标识符。这在恢复情况下尤为重要。它是一个字符串。'
- en: '`originalDate`—The date of when the original transaction occurred. This is
    mostly relevant in a case of a restore.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originalDate`—原始交易发生的日期。这在恢复情况下尤为重要。'
- en: '`errorType`—The type of error that occurred when the state is`"failed"` (a
    string).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorType`—在状态为`"failed"`时发生的错误类型（一个字符串）。'
- en: '`errorString`—A descriptive error message of what went wrong in the`"failed"`
    case.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorString`—在`"failed"`情况下描述错误的错误消息。'
- en: store.loadProducts()
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`store.loadProducts()`'
- en: This method retrieves information about items available for sale. This includes
    the price of each item, a name, and a description.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检索有关可供销售的商品的信息。这包括每个商品的价格、名称和描述。
- en: 'Syntax:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Parameters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`arrayOfProductIdentifiers`—An array with each element containing a string
    of the Product ID of the In-App product you want to know about.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayOfProductIdentifiers`—包含您想要了解的In-App产品Product ID字符串的数组的数组。'
- en: '`listener`—A callback function that is invoked when the store finishes retrieving
    the product information.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener`—当商店完成检索产品信息时被调用的回调函数。'
- en: 'Example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: The following block displays the list of products that are available in the
    app. Information about the product can be retrieved from the `loadProductsCallback()`
    function and determines whether it is valid or invalid.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块显示了应用中可用的产品列表。可以通过`loadProductsCallback()`函数检索产品的信息，并确定其是否有效或无效。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: event.products
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.products
- en: When `store.loadProducts()` returns its requested list of products, you can
    access the array of product information through the `event.products` property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当`store.loadProducts()`返回其请求的产品列表时，您可以通过`event.products`属性访问产品信息数组。
- en: Product information such as title, description, price, and the product identifier
    is contained in a table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标题、描述、价格和产品标识符等信息包含在一个表中。
- en: 'Syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each entry in the `event.products` array supports the following fields:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.products`数组中的每个条目支持以下字段：'
- en: '`title`—The localized name of the item'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`—项目的本地化名称'
- en: '`description`—The localized description of the item'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`—项目的本地化描述'
- en: '`price`—The price of an item (as a number)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`—项目的价格（作为数字）'
- en: '`productIdentifier`—The product identifier'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productIdentifier`—产品标识符'
- en: event.invalidProducts
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.invalidProducts
- en: When `store.loadProducts()` returns its requested list of products, any products
    you requested that are not available for sale will be returned in an array. Access
    the array of invalid products through the `event.invalidProducts` property.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当`store.loadProducts()`返回其请求的产品列表时，任何您请求但不可销售的产品将以数组形式返回。通过`event.invalidProducts`属性访问无效产品的数组。
- en: It is a Lua array containing the product identifier string requested from `store.loadProducts()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Lua数组，包含从`store.loadProducts()`请求的产品标识符字符串。
- en: 'Syntax:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: store.canMakePurchases
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.canMakePurchases
- en: This returns true if purchases are allowed, false otherwise. Corona's API can
    check if purchasing is possible. iOS devices provide a setting that disables purchasing.
    This can be used to avoid purchasing apps accidentally.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许购买，则返回true，否则返回false。Corona的API可以检查是否可以进行购买。iOS设备提供一项禁用购买的设置。这可以用来避免意外购买应用。
- en: 'Example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: store.purchase()
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.purchase()
- en: '`store.purchase()` Initiates a purchase transaction on a provided list of products.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.purchase()` 在提供的产品列表上启动购买交易。'
- en: This function will send out purchase requests to the store. The listener specified
    in `store.init()` will be invoked when the store finishes processing the transaction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将向商店发送购买请求。当商店完成处理交易时，指定的`store.init()`中的监听器将被调用。
- en: 'Syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`arrayOfProducts`—An array specifying the products you want to buy.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrayOfProducts`—指定您想要购买的产品数组的数组。'
- en: 'Example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: store.finishTransaction()
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.finishTransaction()
- en: This method notifies the App Store that a transaction is complete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通知App Store交易已完成。
- en: After you finish handling a transaction, you must call `store.finishTransaction()`
    on the transaction object. If you don't do this, the App Store will think your
    transaction was interrupted and will attempt to resume it on the next application
    launch.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完交易后，您必须在交易对象上调用`store.finishTransaction()`。如果您不这样做，App Store会认为您的交易被中断，并在下一次应用启动时尝试恢复它。
- en: 'Syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`transaction` - The transaction object belonging to the transaction you want
    to mark as finished.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`transaction` - 您想要标记为完成的交易所属的交易对象。'
- en: 'Example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: store.restore()
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.restore()
- en: Any previously purchased items that have been wiped clean from a device or upgraded
    to a new device can be restored on the users account without paying for the product
    again. The `store.restore()` API initiates this process. Transactions can be restored
    by the `transactionCallback` listener, which is registered with `store.init()`.
    Transaction state will be`"restored"` and your app may then make use of the`"originalReceipt",
    "originalIdentifier"`, and`"originalDate"` fields of the transaction object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何已从设备中清除或升级到新设备的先前购买的项目可以在用户的账户中恢复，而无需再次为产品付费。`store.restore()` API启动此过程。可以通过`transactionCallback`监听器恢复交易，该监听器与`store.init()`注册。交易状态将为`"restored"`，然后您的应用可以使用交易对象的`"originalReceipt"`、`"originalIdentifier"`和`"originalDate"`字段。
- en: 'Syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: The block will run through the `transactionCallback()` function and determine
    if a product has been previously purchased from the application. If the result
    is true, `store.restore()` will initiate the process of retrieving the product
    without asking the user to pay for it again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 块将运行 `transactionCallback()` 函数，并确定应用程序是否之前已购买过产品。如果结果是 true，`store.restore()`
    将启动一个过程，无需再次要求用户付费即可检索产品。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create an In-App Purchase
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 In-App Purchase
- en: 'Before reading on, make sure you know how to create an App ID and Distribution
    Provisioning Profile from the iOS Provisioning Portal. Also, make sure you already
    know how to manage new applications in iTunes Connect. If you''re unsure, please
    refer to [Chapter 10](ch10.html "Chapter 10. Optimizing, Testing, and Shipping
    your Games"), *Optimizing, Testing, and Shipping your Games*, for more information.
    The following are the things that need to be ready in your app before creating
    an In-App Purchase:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，请确保您知道如何从 iOS Provisioning Portal 创建 App ID 和分发配置文件。同时，请确保您已经知道如何在 iTunes
    Connect 中管理新应用程序。如果您不确定，请参阅第 10 章，*优化、测试和发布您的游戏*，以获取更多信息。在创建 In-App Purchase 之前，您的应用程序需要准备以下事项：
- en: A Distribution Certificate already made for your app.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序已制作的分发证书。
- en: An explicit App ID for your application that is, `com.companyname.appname`.
    Do not substitute a wild-card character (asterisk *). The **Bundle ID** needs
    to be completely unique to use the In-App Purchase function.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序显式指定的 App ID，即 `com.companyname.appname`。不要使用通配符（星号 *）。**包标识符**需要完全唯一才能使用内购功能。
- en: An ad-hoc Distribution Provisioning Profile (used for testing In-App Purchases).
    When you're ready to submit an app with In-App Purchase, an App Store Distribution
    Provisioning Profile is required.![Create an In-App Purchase](img/1888_11_01.jpg)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试 In-App Purchases 的临时分发配置文件（ad-hoc Distribution Provisioning Profile）。当您准备好提交带有
    In-App Purchase 的应用程序时，需要一个 App Store 分发配置文件。![创建 In-App Purchase](img/1888_11_01.jpg)
- en: Have your application information set up in iTunes Connect. You do not have
    to have your binary uploaded to create or test In-App Purchases.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iTunes Connect 中设置您的应用程序信息。您不需要上传二进制文件来创建或测试 In-App Purchases。
- en: Make sure that you already have an iOS Paid Applications contract in effect
    with Apple. If you don't have, you'll need to request one in **Contracts, Tax,
    and Banking** located on the iTunes Connect home page. You will need to provide
    your banking and tax information in order to offer In-App Purchases in your apps.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已经与苹果公司签订了有效的 iOS 付费应用程序合同。如果没有，您需要在 iTunes Connect 主页上的**合同、税务和银行**部分请求一个。为了在您的应用程序中提供
    In-App Purchases，您需要提供您的银行和税务信息。
- en: Time for action—creating the In-App Purchase in iTunes Connect
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 In-App Purchase 的操作时间——在 iTunes Connect 中创建
- en: We'll be implementing an In-App Purchase through iTunes Connect and create a
    scenario in a sample application that will call a transaction. Let's create the
    Product ID that will use in our In-App Purchase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 iTunes Connect 实现内购，并在示例应用程序中创建一个将调用交易的场景。让我们创建将在我们的 In-App Purchase 中使用的
    Product ID。
- en: Log in to iTunes Connect. On the home page, select **Manage Your Applications**.
    Select the application you plan to add an In-App Purchase to.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 iTunes Connect。在主页上，选择**管理您的应用程序**。选择您计划添加 In-App Purchase 的应用程序。
- en: Once you're on the app summary page, click on the **Manage In-App Purchases**
    button and then click on the **Create New** button on the top-left corner.![Time
    for action—creating the In-App Purchase in iTunes Connect](img/1888_11_02.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您在应用程序摘要页面上，点击**管理内购**按钮，然后点击左上角的**创建新**按钮。![创建 In-App Purchase 的操作时间——在 iTunes
    Connect 中创建](img/1888_11_02.jpg)
- en: You will be brought to a page that shows you a summary of the type of In-App
    Purchases you can create. For this example, **Non-Consumable** is selected. We'll
    be creating a product that only needs to be purchased once.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被带到一页，显示您可以创建的 In-App Purchases 类型摘要。在这个例子中，**不可消耗**被选中。我们将创建一个只需购买一次的产品。
- en: In the next page is the area you fill in the information about the product.
    The information applies to consumable, non-consumable, and non-renewing Subscription
    In-App Purchases. Fill out the **Reference Name** and **Product ID** for your
    product. The **Product ID** needs to be a unique identifier and can be any alphanumeric
    sequence of letters and numbers (that is, `com.companyname.appname.productid).`
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页是您填写产品信息的区域。这些信息适用于消耗性、非消耗性和非续订订阅 In-App Purchase。填写您产品的 **参考名称** 和 **产品
    ID**。**产品 ID** 需要是一个唯一的标识符，可以是任何字母数字序列（即，`com.companyname.appname.productid`)。
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Auto-Renewable subscriptions require you to generate a shared secret. If you
    are to use Auto-Renewable Subscriptions in your app, then on the **Manage in-App
    Purchases** page, click on the **View or generate a shared secret** link. You
    will be brought to a page to generate the shared secret. Click on the **Generate**
    button. The shared secret will display a string of 32 randomly generated alphanumeric
    characters. When you choose Auto-Renewable Subscriptions, the difference from
    the other In-App Purchase types is that you have to choose the duration between
    auto-renewals of your product. For more information on Auto-Renewable Subscriptions,
    go to: [https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf](http://https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf).'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动续订订阅需要您生成一个共享密钥。如果您要在您的应用中使用自动续订订阅，那么在 **管理 In-App Purchase** 页面上，点击 **查看或生成共享密钥**
    链接。您将被带到生成共享密钥的页面。点击 **生成** 按钮。共享密钥将显示一串32个随机生成的字母数字字符。当您选择自动续订订阅时，与其他 In-App
    Purchase 类型不同的是，您必须选择您产品的自动续订间隔。有关自动续订订阅的更多信息，请访问：[https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf](http://https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf)。
- en: '![Time for action—creating the In-App Purchase in iTunes Connect](img/1888_11_03.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间——在 iTunes Connect 中创建 In-App Purchase](img/1888_11_03.jpg)'
- en: Click on the **Add Language** button. Select the language that will be used
    for the In-App Purchase. Add a **Display Name** for your product and a short description
    about it. When you're done, click on the **Save** button.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_04.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加语言** 按钮。选择用于 In-App Purchase 的语言。为您的产品添加一个 **显示名称** 和简短描述。完成后，点击 **保存**
    按钮。![操作时间——在 iTunes Connect 中创建 In-App Purchase](img/1888_11_04.jpg)
- en: In **Pricing and Availability**, make sure that **Yes** is selected for **Cleared
    for Sale**. In the **Price Tier** drop-down menu, select the price you plan to
    sell your In-App Purchase. In this example, **Tier 1** is selected. In **Screenshot
    for Review**, you'll need to upload a screenshot of your In-App Purchase. If you're
    testing on an ad-hoc build, the screenshot is not necessary. Once you're ready
    for distribution, the screenshot is required so the In-App Purchase can be reviewed
    upon submittal. Click on the **Save** button when done.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_05.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **定价和可用性** 中，确保 **已批准销售** 处选择 **是**。在 **价格层级** 下拉菜单中，选择您计划销售的 In-App Purchase
    的价格。在本例中，**层级 1** 被选中。在 **审核截图** 中，您需要上传您的 In-App Purchase 的截图。如果您正在对 ad-hoc 构建进行测试，则不需要截图。一旦您准备好分发，截图是必需的，以便在提交时对
    In-App Purchase 进行审核。完成后，点击 **保存** 按钮。![操作时间——在 iTunes Connect 中创建 In-App Purchase](img/1888_11_05.jpg)
- en: You will see a summary of the In-App Purchase you created on the next page.
    Click on the **Done** button if all the information looks correct.![Time for action—creating
    the In-App Purchase in iTunes Connect](img/1888_11_06.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在下一页看到您创建的 In-App Purchase 的摘要。如果所有信息看起来都正确，请点击 **完成** 按钮。![操作时间——在 iTunes
    Connect 中创建 In-App Purchase](img/1888_11_06.jpg)
- en: What just happened?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Adding a new In-App Purchase is a rather simple process. The information contained
    in the **Product ID** is what will be called upon during a transaction. Managing
    the type of In-App Purchase is entirely up to what type of product you want to
    sell in your game. This example demonstrates the purpose of taking a non-consumable
    product that represents purchasing/unlocking a new level in a game. It's a common
    scenario for users that want to sell level packs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的 In-App Purchase 是一个相对简单的过程。**产品 ID** 中包含的信息将在交易期间被调用。管理 In-App Purchase
    的类型完全取决于您想在游戏中销售哪种类型的产品。本例演示了选择代表购买/解锁游戏新级别的非消耗性产品的目的。这是用户想要销售关卡包的常见场景。
- en: Your application does not have to be completed to test In-App Purchases. All
    that is required is to have your application information set up in iTunes Connect
    so you can manage In-App Purchase features.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序不必完成即可测试 In-App Purchases。所需的所有内容是将您的应用程序信息设置在 iTunes Connect 中，以便您可以管理
    In-App Purchase 功能。
- en: Time for action—using the Corona store module to create an In-App Purchase
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用 Corona 商店模块创建 In-App Purchase
- en: Now that we have set up our Product ID for our In-App Purchase in iTunes Connect,
    we can implement it into our app to purchase the product we're going to sell.
    A sample menu app of **Breakout** was created to demonstrate how to purchase levels
    within an application. The app contains two levels in the level select screen.
    The first one is available by default and the second one is locked and can only
    be unlocked by purchasing it for $0.99\. We're going to create a level select
    screen so it acts in that manner.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 iTunes Connect 中设置了我们的 In-App Purchase 产品 ID，我们可以将其实现到我们的应用程序中，以购买我们打算出售的产品。一个名为
    **Breakout** 的示例菜单应用程序被创建来演示如何在应用程序内购买级别。该应用程序在级别选择屏幕中有两个级别。第一个默认可用，第二个被锁定，并且只能通过购买它来解锁，价格为
    $0.99。我们将创建一个级别选择屏幕，使其以这种方式运行。
- en: In the `Chapter 11` folder, copy the `Breakout In-App Purchase Demo` project
    folder to your desktop. You can download the project files accompanying this book
    from the Packt website. You will notice that the configuration, libraries, assets
    and `.lua` files needed are included.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 11` 文件夹中，将 `Breakout In-App Purchase Demo` 项目文件夹复制到您的桌面上。您可以从 Packt
    网站下载本书附带的项目文件。您会注意到所需的配置、库、资源和 `.lua` 文件都已包含在内。
- en: Create a new levelselect.lua file and save it to the project folder.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `levelselect.lua` 文件并将其保存到项目文件夹中。
- en: Set up the scene with the following variables and saving/loading functions.
    The most important variable of all is `local store = require("store")` which calls
    the `store` module for In-App Purchases.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下变量和保存/加载函数设置场景。最重要的变量是 `local store = require("store")`，它调用 In-App Purchases
    的 `store` 模块。
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create the `createScene()` event and remove the`"mainmenu", "level1"`, and`"level2"`
    scenes.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `createScene()` 事件并删除 `"mainmenu"`、`"level1"` 和 `"level2"` 场景。
- en: '[PRE15]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, create the `enterScene()` event and an array that contains a string of
    the **Product ID** set as an In-App Purchase in iTunes Connect.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `enterScene()` 事件和一个包含在 iTunes Connect 中设置为 In-App Purchase 的 **产品 ID**
    字符串的数组。
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add a local blank table for `validProducts` and `invalidProducts`. Create a
    local function called `unpackValidProducts()` that checks valid and invalid Product
    IDs.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `validProducts` 的本地空表和 `invalidProducts`。创建一个名为 `unpackValidProducts()`
    的本地函数，用于检查有效的和无效的产品 ID。
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create a local function called `loadProductsCallback()` with an `event` parameter.
    Set up the handler to receive product information with `print` statements.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `loadProductsCallback()` 的本地函数，带有 `event` 参数。设置处理程序以使用 `print` 语句接收产品信息。
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a local function called `transactionCallback()` with an `event` parameter.
    Add in several cases of results that are supposed to occur for every `transaction.state`.
    When the store is done with the transaction, call `store.finishTransaction(event.transaction)`
    before the end of the function. Set up another local function called `setUpStore()`
    with an `event` parameter to call `store.loadProducts(listOfProducts, loadProductsCallback)`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `transactionCallback()` 的本地函数，带有 `event` 参数。添加几个针对每个 `transaction.state`
    应该发生的结果的案例。当商店完成交易后，在函数结束前调用 `store.finishTransaction(event.transaction)`。设置另一个名为
    `setUpStore()` 的本地函数，带有 `event` 参数，以调用 `store.loadProducts(listOfProducts, loadProductsCallback)`。
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Set up the display objects for the background and level 1 button.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置背景和第 1 级别按钮的显示对象。
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Set up the level 2 button placement.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置第 2 级别按钮的位置。
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Use the local `onBuyLevel2Touch(event)` function and create an `if` statement
    to check when `event.phase == ended and level2Unlocked ~= tonumber(loadedLevel2Unlocked)`
    so the scene changes to `mainmenu.lua`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本地的 `onBuyLevel2Touch(event)` 函数并创建一个 `if` 语句来检查当 `event.phase == ended and
    level2Unlocked ~= tonumber(loadedLevel2Unlocked)` 时，场景将变为 `mainmenu.lua`。
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Within the same `if` statement, create a local function called `buyLevel2()`
    with a `product` parameter to call the `store.purchase()` function.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `if` 语句中，创建一个名为 `buyLevel2()` 的本地函数，带有 `product` 参数，以调用 `store.purchase()`
    函数。
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add in an `elseif` statement to check when level 2 has been purchased and unlocked
    once the transaction has been completed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交易完成后，添加一个 `elseif` 语句来检查是否已购买并解锁了第 2 级别。
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Activate the In-App Purchase with `store.init()` and call `transactionCallback()`
    as the parameter. Also call `setupMyStore()` with a timer set at 500 milliseconds.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `store.init()` 激活内购，并将 `transactionCallback()` 作为参数调用。同时，使用 500 毫秒的计时器调用
    `setupMyStore()`。
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create the close UI button and a local function called `onCloseTouch()` with
    an event parameter. Set the function transition scenes to `loadmainmenu.lua` upon
    release of the close button. Close the `enterScene()` event with `end`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建关闭 UI 按钮，并创建一个带有事件参数的本地函数 `onCloseTouch()`。在释放关闭按钮时，将函数过渡场景设置为 `loadmainmenu.lua`。使用
    `end` 关闭 `enterScene()` 事件。
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create the `exitScene()` and `destroyScene()` events. Within the `exitScene()`
    event, cancel the `menuTimer` timer. Add in all the event listeners to the scene
    events and `return scene`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `exitScene()` 和 `destroyScene()` 事件。在 `exitScene()` 事件中，取消 `menuTimer` 计时器。将所有事件监听器添加到场景事件中，并
    `return scene`。
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save the file and run the project in the Corona simulator. When you select the
    **Play** button, you will notice a **1** button and a **Locked** button on the
    level select screen. By pressing the **Locked** button it calls the store to make
    a transaction. You will notice a `print` statement in the terminal that displays
    what **Product ID** is being referred to for purchase. The full In-App Purchase
    features cannot be tested in the simulator. You will have to create a distribution
    build and upload it to an iOS device to instigate a purchase in the store.![Time
    for action—using the Corona store module to create an In-App Purchase](img/1888_11_07.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在 Corona 模拟器中运行项目。当您选择 **播放** 按钮时，您将在关卡选择屏幕上注意到一个 **1** 按钮和一个 **锁定** 按钮。通过按下
    **锁定** 按钮来调用商店进行交易。您将在终端中注意到一个 `print` 语句，显示正在购买的产品 **Product ID**。在模拟器中无法测试完整的内购功能。您必须创建一个分发构建并将其上传到
    iOS 设备上，以在商店中引发购买。![使用 Corona 商店模块创建内购的时刻](img/1888_11_07.jpg)
- en: What just happened?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In this example, we used the `saveValue()` and `loadValue()` functions from
    the `BeebeGames` class to implement how our locked level will go from locked to
    unlocked using movieclips as buttons. The array in `local listOfProducts` displays
    a Product ID in a string format. The **Product ID** in this example needs to be
    a non-consumable In-App Purchase type and has to be an existing one in iTunes
    Connect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了 `BeebeGames` 类中的 `saveValue()` 和 `loadValue()` 函数来实现如何使用电影剪辑作为按钮，将我们的锁定级别从锁定状态转换为解锁状态。`local
    listOfProducts` 中的数组以字符串格式显示产品 ID。在此示例中，**Product ID** 需要是一个不可消耗的内购类型，并且必须在 iTunes
    Connect 中存在。
- en: The `unpackValidProducts()` function checks how many valid and invalid items
    are in the In-App Purchase. The `loadProductsCallback()` function receives the
    product information in the store. The `transactionCallback(event)` function checks
    every state—`"purchased","restored", "cancelled"`, and`"failed"`. When a`"purchased"`
    state is achieved within the In-App Purchase, the `saveValue()` function is called
    to change the value of `level2.data`. When the transaction is completed, `store.finishTransaction(event.transaction)`
    needs to be called to tell the store you are done with your purchase.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpackValidProducts()` 函数检查内购中有多少有效和无效的项目。`loadProductsCallback()` 函数接收存储中的产品信息。`transactionCallback(event)`
    函数检查每个状态——`"purchased"`、"restored"`、"cancelled"` 和 `"failed"`。当在内购中达到 `"purchased"`
    状态时，将调用 `saveValue()` 函数来更改 `level2.data` 的值。当交易完成时，需要调用 `store.finishTransaction(event.transaction)`
    来告诉商店您已完成购买。'
- en: The `setupMyStore(event)` function calls `store.loadProducts(listOfProducts,
    loadProductsCallback)` and checks the available Product ID(s) in the application.
    The event is handled once `store.init(transactionCallback)` is initialized and
    `setupMyStore()` is called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupMyStore(event)` 函数调用 `store.loadProducts(listOfProducts, loadProductsCallback)`
    并检查应用程序中可用的产品 ID。一旦 `store.init(transactionCallback)` 初始化并调用 `setupMyStore()`，事件就会被处理。'
- en: The `onBuyLevel2Touch(event)` function allows us to check when an In-App Purchase
    has been made for the locked level. When the user is able to purchase and accepts
    the In-App Purchase, the transaction is processed and the value of `level2Unlocked`
    will match that of `tonumber(loadedLevel2Unlocked)`. The `buyLevel2(product)`
    function validates the purchased item with `store.purchase()` once the Product
    ID returns valid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBuyLevel2Touch(event)` 函数允许我们检查已为锁定级别进行了内购操作。当用户能够购买并接受内购时，交易将被处理，`level2Unlocked`
    的值将与 `tonumber(loadedLevel2Unlocked)` 相匹配。一旦产品 ID 返回有效，`buyLevel2(product)` 函数将使用
    `store.purchase()` 验证购买的商品。'
- en: After the In-App Purchase, the screen transitions to the main menu to allow
    the **Locked** button to change to the level **2** button. Once the button has
    changed to frame 2, level 2 is accessible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 In-App Purchase 之后，屏幕切换到主菜单，以便将 **锁定** 按钮更改为 **2** 级按钮。一旦按钮切换到帧 2，就可以访问第二级。
- en: Have a go hero—handling multiple product IDs
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试处理多个产品 ID 的英雄——处理多个产品 ID
- en: Now that you know how to create an In-App Purchase for one product, try adding
    more than one in the same application. The scenarios are open-ended.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何为单个产品创建 In-App Purchase，尝试在同一个应用程序中添加多个。场景是开放的。
- en: 'You can add the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加以下内容：
- en: More levels for purchases
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买更多级别
- en: New characters the user can play as if your game has a feature user character.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以扮演的新角色，如果您的游戏有用户角色功能。
- en: New background scenes for your application
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序添加新的背景场景
- en: How you handle new products for your store is up to you.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何处理商店中的新产品完全取决于您。
- en: Testing In-App Purchases
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 In-App Purchase
- en: You want to make sure that purchases work correctly. Apple provides a sandbox
    environment that allows you to test your app In-App Purchases. The sandbox environment
    uses the same model as the App Store, but does not process actual payments. Transactions
    return as if payments were processed successfully. It is a requirement to test
    In-App Purchases in a sandbox environment before submitting them for review by
    Apple.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您想确保购买操作正确无误。Apple 提供了一个沙盒环境，允许您测试您的应用程序的 In-App Purchase。沙盒环境使用与 App Store
    相同的模型，但不处理实际支付。交易返回时，就像支付已成功处理一样。在将 In-App Purchase 提交给 Apple 审查之前，必须在沙盒环境中测试
    In-App Purchase 是一项要求。
- en: When testing in the sandbox environment, you'll need to create a separate user
    test account that is different from your current iTunes Connect account. Using
    your current account is not allowed to test your store in the sandbox.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在沙盒环境中进行测试时，您需要创建一个与您当前的 iTunes Connect 账户不同的单独用户测试账户。不允许使用当前账户在沙盒中测试您的商店。
- en: User test accounts
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户测试账户
- en: While logged into your iTunes Connect account, you'll have to select the **Manage
    Users** link from the home page. Select **Test User** on the **Select User Type**
    page. Add a new user and make sure that the test account uses an e-mail address
    that is not associated with any other Apple account. All test accounts should
    only be used in the test environment when testing In-App Purchases. Click on the
    **Save** button when all the information is filled in.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 登录您的 iTunes Connect 账户后，您需要从主页选择 **管理用户** 链接。在 **选择用户类型** 页面上选择 **测试用户**。添加新用户，并确保测试账户使用的是与任何其他
    Apple 账户不相关的电子邮件地址。所有测试账户应在测试 In-App Purchase 时仅在测试环境中使用。当所有信息填写完毕后，点击 **保存**
    按钮。
- en: Once your user test account is created, you'll have to make sure that you're
    signed out of your Apple account in the **Store** settings of your device. This
    will keep non-test accounts from being used when testing In-App Purchases. You're
    only allowed to sign in to your user test account when prompted in the In-App
    Purchase sandbox when testing your application. Do not sign in to your test account
    before the application is launched. This will prevent it from invalidating your
    test account.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了用户测试账户，您需要确保在设备的 **商店** 设置中注销您的 Apple 账户。这将防止在测试 In-App Purchase 时使用非测试账户。您只能在
    In-App Purchase 沙盒测试您的应用程序时被提示时登录用户测试账户。在应用程序启动之前不要登录测试账户。这将防止测试账户无效。
- en: Time for action—testing the In-App Purchase with the Breakout In-App Purchase
    demo
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用 Breakout In-App Purchase 示例测试 In-App Purchase
- en: Before you can test an In-App Purchase on an iOS device, make sure that you
    have a test user account already made in iTunes Connect. Also, make sure that
    you created a distribution build using an ad-hoc Distribution Provisioning Profile
    for the app to test In-App Purchase features. If you followed all the earlier
    steps in this chapter, testing a purchase through the store will work accordingly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以在 iOS 设备上测试 In-App Purchase 之前，请确保您已经在 iTunes Connect 中创建了一个测试用户账户。此外，请确保您使用针对测试
    In-App Purchase 功能的应用程序创建了使用 ad-hoc 分发配置文件的发行版构建。如果您遵循了本章中此前的所有步骤，通过商店进行的购买测试将相应地工作。
- en: In the Corona simulator, create a distribution build of the Breakout In-App
    Purchase Demo. Once the build has been compiled, upload the build to your iOS
    device.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Corona 模拟器中，创建 Breakout In-App Purchase 示例的发行版构建。一旦构建编译完成，请将构建上传到您的 iOS 设备。
- en: Keep your device connected to your machine and launch Xcode. In the toolbar,
    select **Windows** | **Organizer**. Once you're in **Organizer**, select the device
    that is connected in the **Devices** section and then select **Console**. This
    will allow you to check the console output of your device to catch debug messages
    from your code, (that is, `print` statements) and any application crashes.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持您的设备连接到您的计算机，并启动Xcode。在工具栏中，选择**窗口** | **组织者**。一旦进入**组织者**，在**设备**部分选择连接的设备，然后选择**控制台**。这将允许您检查设备的控制台输出，以捕获代码中的调试消息（即`print`语句）和任何应用程序崩溃。
- en: Before launching the application, you'll need to select the **Settings** icon
    on your device. Scroll up until you see the **Store** icon and select it.![Time
    for action—testing the In-App Purchase with the Breakout In-App Purchase demo](img/1888_11_08.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，您需要在您的设备上选择**设置**图标。向上滚动，直到您看到**商店**图标，然后选择它。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_08.jpg)
- en: Sign out of your iTunes Store account if you're logged in so you can test In-App
    Purchases in the sandbox environment.![Time for action—testing the In-App Purchase
    with the Breakout In-App Purchase demo](img/1888_11_09.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已登录到iTunes Store账户，请先退出，以便您可以在沙盒环境中测试内购功能。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_09.jpg)
- en: Launch the Breakout In-App Purchase demo from your device. Select the **Play**
    button and then select the **Locked** button. The screen will transition back
    to the main menu and a window will pop up to confirm your In-App Purchase. Click
    on **OK** to continue with the purchase.![Time for action—testing the In-App Purchase
    with the Breakout In-App Purchase demo](img/1888_11_10.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的设备启动Breakout内购演示。选择**播放**按钮，然后选择**锁定**按钮。屏幕将切换回主菜单，并弹出一个窗口以确认您的内购。点击**确定**继续购买。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_10.jpg)
- en: Next you will be greeted with another window to sign in with your Apple ID.
    This is where you will log in with your test user account you created in iTunes
    Connect. Do not sign in with your actual Apple account ID used to log in to iTunes
    Connect.![Time for action—testing the In-App Purchase with the Breakout In-App
    Purchase demo](img/1888_11_11.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个窗口，要求您使用Apple ID登录。这是您将使用在iTunes Connect中创建的测试用户账户登录的地方。不要使用您用于登录iTunes
    Connect的实际Apple账户ID。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_11.jpg)
- en: Once you're logged in, select the **Play** button again. You will notice that
    the **2** button has been unlocked. When you select it, you will have access to
    that scene.![Time for action—testing the In-App Purchase with the Breakout In-App
    Purchase demo](img/1888_11_12.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，再次选择**播放**按钮。您会注意到**2**按钮已被解锁。选择它后，您将可以访问该场景。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_12.jpg)
- en: Exit out of the app and refer to the console. You will notice the output from
    the device and some familiar `print` statements from our code. The console log
    displays the **Product ID** used for the In-App Purchase and informs you if it
    is valid and if the transaction was successful.![Time for action—testing the In-App
    Purchase with the Breakout In-App Purchase demo](img/1888_11_13.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出应用程序并查看控制台。您会注意到设备输出的输出以及我们代码中的一些熟悉的`print`语句。控制台日志显示用于内购的**产品ID**，并告知您它是否有效以及交易是否成功。![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_13.jpg)
- en: If you want to make sure that the In-App Purchase actually worked, delete the
    application from your device and log out of your user test account. Upload the
    same build to your device. No need to create a new one. Launch the application
    and run the In-App Purchase again. Log in using the same user test account. You
    should receive a pop-up window that mentions you already purchased the product
    and asks you if you want to download it again for free. Receiving a notification
    means your In-App Purchase was successful!![Time for action—testing the In-App
    Purchase with the Breakout In-App Purchase demo](img/1888_11_14.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想确保内购确实已成功，请从您的设备中删除应用程序并退出您的用户测试账户。将相同的构建上传到您的设备。无需创建新的。启动应用程序并再次运行内购。使用相同的用户测试账户登录。您应该会收到一个弹出窗口，提示您已购买该产品，并询问您是否想要免费重新下载。收到通知意味着您的内购已成功！！![行动时间——使用Breakout内购演示测试内购功能](img/1888_11_14.jpg)
- en: What just happened?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: It is important to follow the In-App Purchase test steps accordingly. To make
    sure you're getting accurate results in the sandbox environment, signing out of
    your Apple account from the **Store** settings is the key to this whole process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 严格按照应用内购买测试步骤进行非常重要。为了确保你在沙盒环境中得到准确的结果，从**商店**设置中注销您的Apple账户是整个过程中的关键。
- en: Once you launch the application and call the store function by clicking on the
    **Locked** button, you will notice the display name and price of the In-App Purchase.
    It should match what you created in iTunes Connect if you implemented it correctly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启动应用程序并通过点击**锁定**按钮调用store函数，您将注意到应用内购买的显示名称和价格。如果您正确实现，它应该与您在iTunes Connect中创建的相匹配。
- en: When you log in using the test user account you created in iTunes Connect, the
    transaction should go through without any errors assuming there are no server
    issues on Apple's side or connection problems on the device. **Level 2** on the
    level select screen will be unlocked and accessible. Congratulations! You have
    created an In-App Purchase!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用在iTunes Connect中创建的测试用户账户登录时，如果没有苹果服务器端的问题或设备上的连接问题，交易应该没有错误地完成。关卡选择屏幕上的**Level
    2**将被解锁并可供访问。恭喜！你已经创建了一个应用内购买！
- en: Have a go hero—using other In-App Purchase types
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——使用其他应用内购买类型
- en: In the Breakout In-App Purchase demo, we focused more on non-consumable In-App
    Purchases. Try integrating consumable, auto-renewable subscriptions, or non-renewing
    subscriptions to your own apps.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Breakout应用内购买演示中，我们更关注不可消耗的应用内购买。尝试将可消耗、自动续订的订阅或非续订订阅集成到您自己的应用中。
- en: Apps that feature consumable products are games that require currency to buy
    or build things in a free-to-play environment. Subscription products can be focused
    towards games that are never-ending and are constantly updated with new levels
    or may require an online server to interact in a multiplayer environment. See
    what you can come up with!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可消耗产品的应用是那些在免费游玩环境中需要货币来购买或建造东西的游戏。订阅产品可以针对那些永不结束且不断更新新关卡或可能需要在线服务器以在多人环境中交互的游戏。看看你能想出什么！
- en: Pop quiz—all about In-App Purchases
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——关于应用内购买
- en: What are non-consumable purchases?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是不可消耗的购买？
- en: a. Products that only need to be purchased once by the user.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 用户只需购买一次的产品。
- en: b. Products that need to be purchased each time the user needs the item.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 每次用户需要物品时都需要购买的产品。
- en: c. Products that allow the user to purchase content for a set duration of time.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 允许用户购买一定时长内容的商品。
- en: d. A subscription that requires a user to renew it each time it expires.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 每次到期时都需要用户续订的订阅。
- en: What is true about testing In-App Purchases?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于测试应用内购买，以下哪个说法是正确的？
- en: a. You need to be logged in to your account at all times.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 您需要始终登录您的账户。
- en: b. Your Apple account is used to test In-App Purchases.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 您的Apple账户用于测试应用内购买。
- en: c. Log in to your user test account when prompted in In-App Purchase sandbox.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 在应用内购买沙盒中提示时登录您的用户测试账户。
- en: d. None of the above.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上都不是。
- en: What type of Provisioning Profile must be used to test In-App Purchases?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用内购买需要使用哪种类型的配置文件？
- en: a. Development Provisioning Profile.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 开发配置文件。
- en: b. Ad-hoc Distribution Provisioning Profile.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 临时分配配置文件。
- en: c. App Store Distribution Provisioning Profile.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 应用商店分配配置文件。
- en: d. None of the above.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上都不是。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We can finally see the light at the end of the tunnel. By now, you should have
    an idea on how to implement In-App Purchases in to your games. It is a very lengthy
    process to organize, set up the code, and testing accurate purchases in the sandbox
    environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于看到了隧道尽头的曙光。到现在为止，你应该已经对如何在游戏中实现应用内购买有了想法。在组织、设置代码以及在沙盒环境中测试准确的购买是一个非常漫长的过程。
- en: 'The following were discussed in this chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了以下内容：
- en: Setting up Product IDs for In-App Purchases in iTunes Connect
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iTunes Connect中设置应用内购买的产品ID
- en: Implementing purchase items using Corona's `store` module
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Corona的`store`模块实现购买项
- en: Adding test user accounts in iTunes Connect
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iTunes Connect中添加测试用户账户
- en: Testing In-App Purchases on a device
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上测试应用内购买
- en: Grasping the concept of In-App Purchasing can take some time. It is best to
    study the sample code and review the functions pertaining to Corona's `store`
    module.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 理解应用内购买的概念可能需要一些时间。最好研究示例代码并回顾与Corona的`store`模块相关的功能。
- en: 'Check out Apple''s In-App Purchase Programming Guide at: [https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](http://https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)
    and the In-App Purchases in the API Reference section of Anscamobile''s site:
    [http://developer.anscamobile.com/reference/index/app-purchases](http://developer.anscamobile.com/reference/index/app-purchases)
    for more references pertaining to this topic.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Apple的In-App Purchase Programming Guide，网址为：[https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)，以及Anscamobile网站API参考部分的In-App
    Purchases，网址为：[http://developer.anscamobile.com/reference/index/app-purchases](http://developer.anscamobile.com/reference/index/app-purchases)，以获取更多与此主题相关的参考资料。
- en: After 11 chapters, we have reached the end of this book. You now have obtained
    enough knowledge to create your own applications to sell in the App Store or Google
    Play Store. Hopefully all the information you have acquired has been helpful.
    I look forward to hearing about the games you have developed using Corona SDK!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 经过11章的学习，我们已到达这本书的结尾。你现在已经拥有了足够的知识来创建自己的应用并在App Store或Google Play Store上销售。希望你所获得的所有信息都对你有所帮助。我期待着听到你使用Corona
    SDK开发的游戏！
