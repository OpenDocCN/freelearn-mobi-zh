- en: Chapter 11. Graphics and Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 图形和动画
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Animating views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化视图
- en: Transforming views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换视图
- en: Animation with images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像进行动画
- en: Animating layers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化层
- en: Drawing lines and curves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制线条和曲线
- en: Drawing shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Drawing text
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制文本
- en: A simple drawing application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的绘图应用程序
- en: Creating an image context
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像上下文
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we are going to discuss about custom drawing and animations.
    The iOS SDK contains two very useful frameworks for these tasks: Core Graphics
    and Core Animation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论自定义绘制和动画。iOS SDK包含两个用于这些任务的非常有用的框架：Core Graphics和Core Animation。
- en: These two frameworks simplify the process of animating UI elements and drawing
    2D graphics on them. The effective usage of these two frameworks will make a difference
    between a dull and a stunning application. After all, these two frameworks play
    a very important role in making the iOS platform unique in its kind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架简化了在UI元素上动画化以及绘制2D图形的过程。有效使用这两个框架将在平淡无奇和令人惊叹的应用程序之间产生差异。毕竟，这两个框架在使iOS平台在其类别中独一无二方面发挥着非常重要的作用。
- en: We will learn how to provide simple or even more complicated animations for
    controls to provide a unique user experience. We will also see how to custom draw
    lines, curves, shapes, and text on the screen. Finally, with all the examples
    provided, we will create two drawing applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何为控件提供简单甚至更复杂的动画，以提供独特的用户体验。我们还将看到如何在屏幕上自定义绘制线条、曲线、形状和文本。最后，通过所有提供的示例，我们将创建两个绘图应用程序。
- en: Animating Views
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化视图
- en: In this recipe, we will learn how to take advantage of `UIKit` animations to
    move a `UILabel` on the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何利用`UIKit`动画在屏幕上移动`UILabel`。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `ViewAnimationApp`. Add a label
    and a button on the view of `MainController`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`ViewAnimationApp`。在`MainController`的视图中添加一个标签和一个按钮。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add the `MonoTouch.ObjCRuntime` namespace, and enter the following `ViewDidLoad`
    override:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`MonoTouch.ObjCRuntime`命名空间，并在以下`ViewDidLoad`重写中输入：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the application on the simulator.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the **Animate!** button, and watch the label move to the lower part of
    the view.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Animate!**按钮，并观察标签移动到视图的下半部分。
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIView` class contains a number of various static methods that are targeted
    to animations. In this example, we simply change the position of a label with
    an animation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView`类包含许多针对动画的静态方法。在这个例子中，我们只是通过动画改变了一个标签的位置。'
- en: 'To animate the change of position, we need to apply the changes after a call
    to the `BeginAnimations` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化位置的变化，我们需要在调用`BeginAnimations`方法之后应用这些更改：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It accepts one string parameter, which declares the name of the animation.
    Changes we make to views after this call will be animated. But, we can also adjust
    various animation parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个字符串参数，该参数声明了动画的名称。在这次调用之后我们对视图所做的更改将被动画化。但，我们也可以调整各种动画参数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `SetAnimationDuration` method defines the duration of the animation in seconds.
    The `SetAnimationCurve` method defines the default easing functions that will
    be applied to the animation at its start point and/or its end point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetAnimationDuration`方法定义了动画的持续时间（以秒为单位）。`SetAnimationCurve`方法定义了将在动画的起点和/或终点应用到的默认缓动函数。'
- en: 'We have the option of executing code when the animation completes. To do this,
    we first need to set the animation delegate object with the `SetAnimationDelegate`
    method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画完成时，我们有执行代码的选项。为此，我们首先需要使用`SetAnimationDelegate`方法设置动画代理对象：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we set our controller object, `MainController`, as the animation
    delegate object. After setting the delegate object, we need to set the selector
    that will be called when the animation completes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将我们的控制器对象`MainController`设置为动画代理对象。在设置代理对象后，我们需要设置当动画完成时将被调用的选择器：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create a `Selector` instance, we need to use the `MonoTouch.ObjCRuntime`
    namespace:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Selector`实例，我们需要使用`MonoTouch.ObjCRuntime`命名空间：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After making all the adjustments for our animation, we set the new value to
    the object that will be animated and call the `CommitAnimations` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在对动画进行所有调整后，我们将新值设置到将被动画化的对象上，并调用`CommitAnimations`方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the code below the `BeginAnimations` call will be executed at the
    `CommitAnimations` line. Also, every animation started with the `BeginAnimations`
    method should have a corresponding call to the `CommitAnimations` method, or unexpected
    results will occur; for example, every change that is made to UI elements will
    be animated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `BeginAnimations` 调用下面的代码将在 `CommitAnimations` 行执行。此外，每个使用 `BeginAnimations`
    方法开始的动画都应该有一个相应的 `CommitAnimations` 方法调用，否则可能会出现意外结果；例如，对 UI 元素所做的每个更改都将被动画化。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `UIView` class also contains an overloaded `Animate` method. This method
    basically wraps all the methods we used here in one. The previous example, with
    the `Animate` method, is represented with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView` 类还包含一个重载的 `Animate` 方法。此方法基本上将我们在这里使用的方法封装在一个方法中。使用 `Animate` 方法的前一个示例表示为以下代码：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second parameter of this overload is the delay after which the animation
    will start.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载的第二个参数是动画开始后的延迟。
- en: UIKit animations and iOS versions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIKit 动画和 iOS 版本
- en: The `Animate` method was introduced on iOS version 4.0\. When targeting an iOS
    version prior to 4, use the animation block, as defined by the `BeginAnimations`
    and `CommitAnimations` methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animate` 方法是在 iOS 4.0 版本中引入的。当针对低于 4 的 iOS 版本时，使用由 `BeginAnimations` 和 `CommitAnimations`
    方法定义的动画块。'
- en: Animatable properties
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可动画属性
- en: '`UIKit` animations support a specific set of `UIView` properties. These properties
    are called **animatable** properties. Following is a list of `UIView` properties
    that can be animated:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIKit` 动画支持一组特定的 `UIView` 属性。这些属性被称为 **可动画属性**。以下是可被动画化的 `UIView` 属性列表：'
- en: '`Frame`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frame`'
- en: '`Bounds`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bounds`'
- en: '`Center`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Center`'
- en: '`Transform`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform`'
- en: '`Alpha`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alpha`'
- en: '`BackgroundColor`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundColor`'
- en: '`ContentStretch`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentStretch`'
- en: Transforming views
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图变换
- en: In this recipe, we will rotate a `UILabel` by applying a transformation. Furthermore,
    the rotation will be animated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过应用变换来旋转 `UILabel`。此外，旋转将会有动画效果。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `TransformViewApp`. Add a label
    and a button on the view of `MainController`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `TransformViewApp`。在 `MainController` 的视图中添加一个标签和一个按钮。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Add the `MonoTouch.CoreGraphics` namespace:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `MonoTouch.CoreGraphics` 命名空间：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类中输入以下代码：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile and run the application on the simulator.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the button and watch the label rotate.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮并观察标签旋转。
- en: '![How to do it...](img/1468EXP_11_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/1468EXP_11_01.jpg)'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the `CoreGraphics`
    framework. This framework is the basic graphics framework of iOS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreGraphics` 命名空间是 `CoreGraphics` 框架的包装器。这个框架是 iOS 的基本图形框架。'
- en: 'To rotate a view, we need a transformation object that will be applied to the
    view through its `Transform` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转视图，我们需要一个变换对象，该对象将通过视图的 `Transform` 属性应用于视图：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The transformation object is an instance of the class `CGAffineTransform` and
    is initialized through the `MakeRotation` static method. This method accepts a
    float value of the angle of rotation that we want to be applied, in radians. The
    `DegreesToRadians` method can be used to convert degrees to radians. After creating
    the transformation object, we assign it to the label''s `Transform` property inside
    an animation block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 变换对象是 `CGAffineTransform` 类的实例，并通过 `MakeRotation` 静态方法初始化。此方法接受一个浮点值，表示我们想要应用的角度，单位为弧度。可以使用
    `DegreesToRadians` 方法将度转换为弧度。创建变换对象后，我们将其分配给标签的 `Transform` 属性，在动画块内部：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we need to increment the rotation angle each time the button is pressed,
    because the transformation we apply is not being auto-incremented. If we apply
    another rotation transformation object with the same angle, there will be no effect
    since it is basically the same transformation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次按下按钮时，我们需要增加旋转角度，因为我们应用的变化不会被自动增加。如果我们应用另一个具有相同角度的旋转变换对象，将不会有任何效果，因为它基本上是相同的变化。
- en: 'When the label has been rotated to a full circle (=360 degrees), we reset the
    `rotationAngle` value and the transformation object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签旋转到完整圆（=360度）时，我们重置 `rotationAngle` 值和变换对象：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MakeIdentity` static method creates an identity transformation object,
    which is the default transformation of all views, before applying transformation
    objects to them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeIdentity`静态方法创建一个恒等变换对象，这是在应用变换对象之前所有视图的默认变换。'
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CGAffineTransform` class contains various static methods for creating
    transformation objects. These are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGAffineTransform`类包含用于创建变换对象的静态方法。这些是：'
- en: '`CGAffineTransformInvert:` This method inverts a current transformation and
    returns the result'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGAffineTransformInvert:` 此方法反转当前变换并返回结果'
- en: '`MakeIdentity:` This method creates an identity transformation'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeIdentity:` 此方法创建一个恒等变换'
- en: '`MakeRotation:` This method creates a rotation transformation'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeRotation:` 此方法创建一个旋转变换'
- en: '`MakeScale:` This method creates a scale transformation'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeScale:` 此方法创建一个缩放变换'
- en: '`MakeTranslation:` This method creates a translation transformation'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeTranslation:` 此方法创建一个平移变换'
- en: '`Multiply:` This method multiplies two transformations and returns the result'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Multiply:` 此方法将两个变换相乘并返回结果'
- en: Transformation and frame
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换和框架
- en: After applying transformations on a view, its `Frame` property must not be taken
    into account. If there is a need for altering the view's size or position after
    a transformation has been applied, use the `Bounds` and `Center` properties, respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一个视图应用变换后，其`Frame`属性不应被考虑。如果需要在变换后更改视图的大小或位置，请分别使用`Bounds`和`Center`属性。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中：
- en: '*Animating views*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图*'
- en: '*Animating layers*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画层*'
- en: Animation with images
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图像的动画
- en: In this recipe, we will create a simple slideshow of images using the built-in
    animation feature of `UIImageView`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`UIImageView`内置的动画功能创建一个简单的图片幻灯片。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `ImageAnimationApp`. Add a
    `UIImageView` and two buttons on the view of `MainController`. The sample project
    for this task contains three images. Add two or more images to the project, and
    set their **Build Action** to **Content**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`ImageAnimationApp`。在`MainController`的视图中添加一个`UIImageView`和两个按钮。此任务的示例项目包含三张图片。将两张或更多图片添加到项目中，并将它们的**构建操作**设置为**内容**。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Enter the following `ViewDidLoad` override:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下`ViewDidLoad`重写：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Compile and run the application on the simulator.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the **Animate images** button to start the animation.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**动画图像**按钮以开始动画。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIImageView` can accept an array of `UIImage` objects and automatically
    display them in a sequence.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`可以接受一个`UIImage`对象的数组，并自动按顺序显示它们。'
- en: 'To load the images that the view will animate, assign an array of the images
    to its `AnimationImages` property:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载视图将动画的图像，将图像的数组分配给其`AnimationImages`属性：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The sequence in which the images will be displayed is defined by their order
    in the array. After setting the images that will be animated, we set the duration
    of the animation in seconds and the number of times it will occur:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示的顺序由它们在数组中的顺序定义。在设置将动画的图像后，我们设置动画的持续时间（以秒为单位）和它将发生的次数：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To start or stop the animation, call the `StartAnimating` or `StopAnimating`
    methods, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始或停止动画，分别调用`StartAnimating`或`StopAnimating`方法。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is no relation between the `AnimationImages` and `Image` properties of
    the `UIImageView` class. Set an image to be displayed to the `Image` property
    before or after an animation, if one needs to be displayed when no animation takes
    place.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`的`AnimationImages`属性和`Image`属性之间没有关系。如果需要在没有动画时显示图像，请在动画前后将图像设置到`Image`属性中。'
- en: Checking for animation
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查动画
- en: To determine if an animation takes place, check the `IsAnimating` property of
    `UIImageView`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定是否发生动画，请检查`UIImageView`的`IsAnimating`属性。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中：
- en: '*Animating views*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图*'
- en: 'In this book:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。用户界面：视图")，用户界面：视图：'
- en: '*Displaying images*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像*'
- en: Animating layers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画层
- en: In this recipe, we will learn how to use the `Core Animation` framework to copy
    a `UILabel` on the screen, by animating its layer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`Core Animation`框架通过动画其层来复制屏幕上的`UILabel`。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `LayerAnimation`. Add two labels
    and a button on the view of `MainController`. Set text and background color for
    the first view and a different background color for the second view.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `LayerAnimation`。在 `MainController` 的视图中添加两个标签和一个按钮。为第一个视图设置文本和背景颜色，并为第二个视图设置不同的背景颜色。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add `MonoTouch.CoreAnimation` namespace:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `MonoTouch.CoreAnimation` 命名空间：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a field of the type `CALayer` in the class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个 `CALayer` 类型的字段：
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code in the `ViewDidLoad` override:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 覆盖中添加以下代码：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile and run the application on the simulator.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the **Copy** button to copy the contents of the first label to the second
    label with animation.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **复制** 按钮以动画方式将第一个标签的内容复制到第二个标签。
- en: '![How to do it...](img/1468EXP_11_02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_11_02.jpg)'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.CoreAnimation` namespace is a wrapper around the `Core Animation`
    framework.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreAnimation` 命名空间是 `Core Animation` 框架的包装器。'
- en: Every view has a `Layer` property, which returns the view's `CALayer` object.
    In this task, we are creating an animation that graphically displays copying label
    contents from one label to another.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都有一个 `Layer` 属性，它返回视图的 `CALayer` 对象。在这个任务中，我们正在创建一个动画，它以图形方式显示从一个标签复制内容到另一个标签。
- en: Instead of creating another label and moving it with `UIView` animation, we
    will create a layer and move that instead. We create the layer by setting its
    `Frame` and `Contents` property, the latter from the source label's layer. We
    then add the layer to the main view's layer with the `AddSublayer` method. After
    this point, the main view contains a layer, which displays the same contents and
    is on top of the source label.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是创建另一个标签并用 `UIView` 动画移动它，而是创建一个层并移动它。我们通过设置其 `Frame` 和 `Contents` 属性来创建层，后者来自源标签的层。然后我们使用
    `AddSublayer` 方法将层添加到主视图的层中。从这一点开始，主视图包含一个层，它显示相同的内容，并且位于源标签之上。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To animate the transition from the source label to the target label, we will
    use the `CABasicAnimation` class. The previous highlighted code shows how to initialize
    and set up the instances of the class. The `FromKeyPath` static method creates
    a new instance, accepting as a parameter the name of the layer's property that
    will be animated. The `To` property represents the value the property will be
    animated to. The `Duration` property represents the duration of the animation
    in seconds, while the `RemovedOnCompletion` property declares that the animation
    object should be removed from the layer when the animation finishes. The `TimingFunction`
    property sets the behavior of the animation. The `AnimationStopped` event is triggered
    when the animation finishes. Inside the handler we assign to it, we set the contents
    of the source label to the target label, thus completing the copy. The `AutoReverses`
    property states that when the value of the `To` property has been reached, the
    animation should be reversed. It is this property that gives the effect of the
    label getting bigger and subsequently smaller when it reaches its final position.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化从源标签到目标标签的过渡，我们将使用 `CABasicAnimation` 类。前面的高亮代码展示了如何初始化和设置类的实例。`FromKeyPath`
    静态方法创建一个新的实例，接受作为参数的将被动画化的层的属性名称。`To` 属性表示属性将被动画到的值。`Duration` 属性表示动画的持续时间（以秒为单位），而
    `RemovedOnCompletion` 属性声明当动画完成时应该从层中移除动画对象。`TimingFunction` 属性设置动画的行为。当动画完成时，会触发
    `AnimationStopped` 事件。在分配给它的处理程序内部，我们将源标签的内容设置为目标标签，从而完成复制。`AutoReverses` 属性表示当
    `To` 属性的值达到时，动画应该反转。正是这个属性使得标签在达到最终位置时先变大然后变小。
- en: 'The animations start when they are added to the layer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画被添加到层中时，动画开始：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A list of strings that the `FromKeyPath` method accepts can be found in the
    following link: `http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreAnimation_guide/Articles/KVCAdditions.html#//apple_ref/doc/uid/TP40005299`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下链接中找到 `FromKeyPath` 方法接受的字符串列表：`http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreAnimation_guide/Articles/KVCAdditions.html#//apple_ref/doc/uid/TP40005299`。
- en: 'Apart from the `To` property, the `CABasicAnimation` class has two more properties
    for defining the animation: `From` and `By`. They are all of the type `NSObject`,
    but the actual values that should be assigned to them should be of the type `NSValue`.
    The `NSValue` class contains various static methods for creating instances of
    it.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `To` 属性外，`CABasicAnimation` 类还有两个用于定义动画的属性：`From` 和 `By`。它们都是 `NSObject`
    类型，但应该分配给它们的实际值应该是 `NSValue` 类型。`NSValue` 类包含创建其实例的各种静态方法。
- en: Layers
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层
- en: '**Layers** are very powerful and efficient objects that can be used for both
    drawing and animations. Using layers to perform animations on views, instead of
    the actual views themselves, is strongly suggested.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**层**是非常强大且高效的用于绘制和动画的对象。强烈建议使用层在视图上执行动画，而不是使用实际的视图本身。'
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this chapter
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章
- en: '*Animating Views*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图*'
- en: Drawing lines and curves
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条和曲线
- en: In this recipe, we will implement custom drawing to draw two lines on a `UIView`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现自定义绘制，在 `UIView` 上绘制两条线。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DrawLineApp`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `DrawLineApp`。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add a new class to the project, and name it `DrawingView`. Derive it from `UIView:`
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新类，并将其命名为 `DrawingView`。从 `UIView` 派生它：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following `using` directive in the `DrawingView.cs` file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DrawingView.cs` 文件中添加以下 `using` 指令：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override the `Draw` method of `UIView`, and implement it with the following
    code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `UIView` 的 `Draw` 方法，并使用以下代码实现它：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `ViewDidLoad` override of the `MainController`, initialize and add the
    view:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的 `ViewDidLoad` 覆盖中，初始化并添加视图：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile and run the application on the simulator. The result should be similar
    to the following:![How to do it...](img/1468EXP_11_03a.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应该类似于以下内容：![如何操作...](img/1468EXP_11_03a.jpg)
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the native `Core
    Graphics` framework. The `Core Graphics` framework contains the necessary objects
    for custom drawing on views.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreGraphics` 命名空间是对原生 `Core Graphics` 框架的封装。`Core Graphics` 框架包含了在视图中进行自定义绘制的必要对象。'
- en: 'To draw on a view, we have to override its `Draw(RectangleF)` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图上绘制，我们必须覆盖其 `Draw(RectangleF)` 方法：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the `Draw` method, we need an instance of the current graphics context:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Draw` 方法内部，我们需要当前图形上下文的实例：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A graphics context is represented by the `CGContext` class. The `UIGraphics.GetCurrentContext`
    static method returns an instance of the current context.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图形上下文由 `CGContext` 类表示。`UIGraphics.GetCurrentContext` 静态方法返回当前上下文的一个实例。
- en: 'The `CGContext` class contains various methods that allows us to draw on the
    view. We need to set the line width, the color, and then add the type of drawing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGContext` 类包含各种方法，允许我们在视图上绘制。我们需要设置线宽、颜色，然后添加绘制类型：'
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To add a line, we use the `AddLines` method that accepts an array of `PointF
    structs` containing the start and end points of each line. Just adding the lines
    to the context is not enough. To present the drawing on the view, we call the
    `StrokePath` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加线条，我们使用接受包含每条线的起点和终点的 `PointF` 结构数组 `AddLines` 方法。仅仅将线条添加到上下文中是不够的。为了在视图上呈现绘制内容，我们调用
    `StrokePath` 方法：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To add another item to the drawing, we repeat the steps accordingly. The `MoveTo`
    method moves the current point so that the additional item will have a starting
    point for the curve.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要向绘制中添加另一个项目，我们相应地重复步骤。`MoveTo` 方法将当前点移动，以便附加项目将有一个曲线的起点。
- en: There's more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Draw` method is being called by the runtime when it needs to draw the contents
    of a view. We can only get the instance of the current graphics context inside
    the `Draw` method. We should not call it directly, since the `UIGraphics.GetCurrentContext`
    method will return `null` if we do. If we need to force the runtime to call the
    `Draw` method, we need to call `SetNeedsDisplay()`. Care should be taken when
    calling it, since drawing operations are expensive in terms of CPU usage.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时需要绘制视图的内容时，会调用 `Draw` 方法。我们只能在 `Draw` 方法内部获取当前图形上下文的实例。我们不应该直接调用它，因为如果这样做，`UIGraphics.GetCurrentContext`
    方法将返回 `null`。如果我们需要强制运行时调用 `Draw` 方法，我们需要调用 `SetNeedsDisplay()`。在调用它时应该小心，因为绘制操作在
    CPU 使用方面代价高昂。
- en: When there is no need for causing the entire view area to be redrawn, we can
    call the `SetNeedsDisplayInRect` method, passing the `RectangleF` in the view's
    coordinate system of the area that we want to be updated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要重新绘制整个视图区域时，我们可以调用`SetNeedsDisplayInRect`方法，传递视图坐标系中要更新的区域的`RectangleF`。
- en: Graphics context on a UIImageView
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在UIImageView上的图形上下文
- en: The current graphics context of a `UIImageView` is reserved for drawing the
    contents of the image. Calling `SetNeedsDisplay` on a custom view deriving from
    `UIImageView` has the same effect as calling the `Draw` method directly. If we
    need to draw on a custom image view, we have to either add another view on top
    of it and draw on that, or draw on a custom layer and add it to the view's main
    layer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`的当前图形上下文保留用于绘制图像内容。在继承自`UIImageView`的自定义视图中调用`SetNeedsDisplay`与直接调用`Draw`方法具有相同的效果。如果我们需要在自定义图像视图中绘制，我们必须要么在其上方添加另一个视图并在该视图上绘制，要么在自定义图层上绘制并将其添加到视图的主图层中。'
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Drawing text*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制文本*'
- en: 'In this book:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。用户界面：视图"), 用户界面：视图：'
- en: '*Creating* a *custom view*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建*一个*自定义视图*'
- en: Drawing shapes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Following the example in the previous recipe, we will draw a circle and a square
    on the screen.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前一个食谱中的示例，我们将在屏幕上绘制一个圆和一个正方形。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DrawShapeApp`. Add a custom
    view like in the previous task, and name it `DrawingView`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`DrawShapeApp`。添加一个类似于之前的任务的自定义视图，并将其命名为`DrawingView`。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following code in the `Draw` method override:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Draw`方法的重写中添加以下代码：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile and run the application on the simulator. The result on the screen
    should be similar to the following:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。屏幕上的结果应类似于以下内容：
- en: '![How to do it...](img/1468EXP_11_04.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_11_04.jpg)'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To draw shapes on a view, we need to call the appropriate method. We first
    set the fill color of the `CGContext` instance:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中绘制形状，我们需要调用适当的方法。我们首先设置`CGContext`实例的填充颜色：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To draw a circle, we call the `AddEllipseInRect` method, passing a `RectangleF`
    object containing the bounding rectangle of the circle:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制圆，我们调用`AddEllipseInRect`方法，传递一个包含圆边界矩形的`RectangleF`对象：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Whether the shape will be an ellipse or an absolute circle is defined through
    the bounding rectangle''s size. We then call the `FillPath` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 形状是否为椭圆或绝对圆由边界矩形的尺寸定义。然后我们调用`FillPath`方法：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The shadow effect is defined by the `SetShadow` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影效果由`SetShadow`方法定义：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first parameter, which is of the type `SizeF`, defines the offset of the
    shadow, while the second parameter defines the amount of blur.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，其类型为`SizeF`，定义了阴影的偏移量，而第二个参数定义了模糊量。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When the `SetShadow` method is called, all objects that are added to the context
    are displayed with a shadow. To remove the shadow, call the `SetShadowWithColor`
    method, passing either a fully transparent color or `null` for the color parameter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`SetShadow`方法时，所有添加到上下文中的对象都会显示阴影。要移除阴影，调用`SetShadowWithColor`方法，传递一个完全透明的颜色或为颜色参数传递`null`。
- en: Transparent colors
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明颜色
- en: 'To fill a shape with a transparent color, create a `CGColor` instance with
    the appropriate values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要用透明色填充形状，创建一个具有适当值的`CGColor`实例：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will create a red color with its alpha set to 50 percent.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个红色，其不透明度设置为50%的颜色。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Drawing lines and curves*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*'
- en: Drawing text
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: In this recipe, we will learn how to draw styled text with an outline.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用轮廓绘制样式文本。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DrawTextApp`. Add the `DrawingView`
    class that we created in the previous tasks to the project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`DrawTextApp`。将我们在之前的任务中创建的`DrawingView`类添加到项目中。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Implement the following `Draw` method override in the `DrawingView` class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawingView`类中实现以下`Draw`方法的重写：
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compile and run the application on the simulator. The text will be displayed
    on the screen. The result should be similar to the following:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。文本将在屏幕上显示。结果应类似于以下内容：
- en: '![How to do it...](img/1468EXP_11_05.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_11_05.jpg)'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `NSString` class contains the very useful method `DrawString`, which draws
    the text it contains to the current context. To provide the outline effect, we
    call the `SetTextDrawingMode` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSString` 类包含一个非常有用的方法 `DrawString`，它将包含的文本绘制到当前上下文中。为了提供轮廓效果，我们调用 `SetTextDrawingMode`
    方法：'
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We pass the `CGTextDrawingMode.FillStroke` value. Since we have not set a stroke
    color to the context, it defaults to black.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了 `CGTextDrawingMode.FillStroke` 值。由于我们没有为上下文设置描边颜色，它默认为黑色。
- en: 'Finally, the `DrawString` method is called:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `DrawString` 方法：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method is overloaded. The overload we use here accepts a `PointF struct`,
    which represents the location of the string in the view's coordinate system, and
    a `UIFont` instance that represents the font by which the text will be rendered
    on the screen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有多个重载。我们在这里使用的是接受一个 `PointF` 结构的重载，它表示字符串在视图坐标系中的位置，以及一个 `UIFont` 实例，它表示文本将在屏幕上通过该字体渲染。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CGContext` class contains the method for drawing text. We first need to
    call `SelectFont` method to assign the font:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGContext` 类包含用于绘制文本的方法。我们首先需要调用 `SelectFont` 方法来分配字体：'
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then call the `ShowTextAtPoint` method to draw the text:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用 `ShowTextAtPoint` 方法来绘制文本：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will give the following result:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下结果：
- en: '![There''s more...](img/1468EXP_11_06.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1468EXP_11_06.jpg)'
- en: 'The text will be displayed at the correct position, but reversed. To correct
    this, we need to set a transformation matrix to the `TextMatrix` property:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 文本将显示在正确的位置，但方向相反。为了纠正这一点，我们需要将一个变换矩阵设置到 `TextMatrix` 属性：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The biggest advantage in using the `CGContext` class'' methods is that we can
    easily transform the text appearance. For example, by applying a slightly different
    transformation matrix, we can easily display skewed text:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CGContext` 类的方法的最大优点是我们可以轻松地变换文本的外观。例如，通过应用一个稍微不同的变换矩阵，我们可以轻松地显示倾斜的文本：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![There''s more...](img/1468EXP_11_07.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1468EXP_11_07.jpg)'
- en: Size of drawn text
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制文本的大小
- en: 'The `DrawString` method of the `NSString` class returns the size of the bounding
    rectangle of the text. We can, however, get the size of the text before drawing
    through the `StringSize` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSString` 类的 `DrawString` 方法返回文本的边界矩形的大小。然而，我们可以通过 `StringSize` 方法在绘制之前获取文本的大小：'
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Drawing lines and curves*'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*'
- en: '*Drawing shapes*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制形状*'
- en: A simple drawing application
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的绘图应用程序
- en: In this recipe, we will use the techniques that we learned to create a drawing
    application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用我们学到的技术来创建一个绘图应用程序。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `FingerDrawingApp`. Once again,
    we will need a custom view. Add a class deriving from `UIView`, and name it `CanvasView`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `FingerDrawingApp`。再次，我们需要一个自定义视图。添加一个继承自 `UIView`
    的类，并将其命名为 `CanvasView`。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Implement the `CanvasView` class with the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现 `CanvasView` 类：
- en: '[PRE44]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compile and run the application on the simulator or on the device.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。
- en: Touch and drag your finger (or click-and-drag with the cursor) and start drawing!
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用手指触摸并拖动（或使用光标点击并拖动）开始绘画！
- en: '![How to do it...](img/1468EXP_11_08.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/1468EXP_11_08.jpg)'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this task, we are combining touch events and custom drawing to create a simple
    drawing application. When the user touches and moves the finger on the screen,
    we keep the touch location points information and use them in the `Draw` method
    to draw lines.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将结合触摸事件和自定义绘制来创建一个简单的绘图应用程序。当用户触摸并在屏幕上移动手指时，我们保留触摸位置点的信息，并在 `Draw`
    方法中使用这些信息来绘制线条。
- en: After setting the touch locations to the class fields, we call `SetNeedsDisplay`
    to force the `Draw` method to be called. The `fingerDraw` field is used to determine
    if the `Draw` method was called by a touch on the screen and not by the runtime
    when the view is first loaded.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在将触摸位置设置为类字段后，我们调用 `SetNeedsDisplay` 来强制调用 `Draw` 方法。`fingerDraw` 字段用于确定 `Draw`
    方法是由屏幕上的触摸触发的，而不是在视图首次加载时由运行时触发的。
- en: Every time we call a method to draw something to a graphics context, the previous
    drawings in that context are cleared. To avoid this behavior, we use a `CGPath`
    object. We can add various drawing objects in a `CGPath` and display these objects
    on the screen by adding them to the graphics context. So, every time the user
    moves the finger on the screen, the new lines defined by the touch location points
    are added to the path, and the path is drawn on the current context.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用一个方法将某个东西绘制到图形上下文中时，该上下文中的先前绘图都会被清除。为了避免这种行为，我们使用`CGPath`对象。我们可以在`CGPath`中添加各种绘图对象，并通过将它们添加到图形上下文中来显示这些对象。因此，每次用户在屏幕上移动手指时，由触摸位置点定义的新线就会被添加到路径中，并且路径会在当前上下文中绘制。
- en: Note that we need to hold information of both the current touch location and
    the previous one. This is because the `AddLineToPoint` method accepts one point,
    which defines the end point of the line, assuming there already is a point in
    the path. The starting point of each line is defined by calling `MoveToPoint`,
    passing the previous touch location point.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要保留当前触摸位置和上一个位置的信息。这是因为`AddLineToPoint`方法接受一个点，该点定义了线的终点，假设路径中已经有一个点。每条线的起点是通过调用`MoveToPoint`，传递上一个触摸位置点来定义的。
- en: The path that is drawn on the screen by sliding the finger on it is basically
    comprised of a series of consecutive straight lines. The result, however, is a
    smooth path that follows the finger movement, because the `TouchesMoved` method
    is triggered every time there is a single movement of the finger on the screen.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在屏幕上滑动手指绘制的路径基本上由一系列连续的直线组成。然而，由于`TouchesMoved`方法在手指在屏幕上每次移动时都会被触发，因此结果是平滑的路径，它遵循手指的移动。
- en: 'After adding the line to the path, we add it to the context and draw it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在将线添加到路径后，我们将其添加到上下文中并绘制它：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Two new `CGContext` methods are introduced in this task: `SetLineJoin` and
    `SetLineCap`. The `SetLineJoin` method sets how each line will be joined to the
    previous one, while the `SetLineCap` sets the appearance of the endpoint of a
    line.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本任务中引入了两个新的`CGContext`方法：`SetLineJoin`和`SetLineCap`。`SetLineJoin`方法设置每条线如何与前一条线连接，而`SetLineCap`设置线的端点外观。
- en: 'The values they accept are explained as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它们接受的值解释如下：
- en: '`SetLineJoin`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLineJoin`'
- en: '`CGLineJoin.Miter:` Joins two lines with an angled corner'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineJoin.Miter:` 以斜角连接两条线'
- en: '`CGLineJoin.Round:` Joins two lines with a rounded end'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineJoin.Round:` 以圆角连接两条线'
- en: '`CGLineJoin.Bevel:` Joins two lines with a squared end'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineJoin.Bevel:` 以方形端点连接两条线'
- en: '`SetLineCap`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLineCap`'
- en: '`CGLineCap.Butt:` The line will end with a squared edge on the endpoint'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineCap.Butt:` 线将以端点上的方形边缘结束'
- en: '`CGLineCap.Round:` The line will end with a rounded edge that expands beyond
    the endpoint'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineCap.Round:` 线将以圆角结束，并扩展到端点之外'
- en: '`CGLineCap.Square:` The line will end with a squared edge that expands beyond
    the endpoint'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGLineCap.Square:` 线将以扩展到端点之外的方形边缘结束'
- en: Clear the drawing
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除绘图
- en: To clear the drawing, we simply have to set the `fingerDraw` variable to `false`
    and call `SetNeedsDisplay`. This way, the `Draw` method will be called without
    our custom drawing code, clearing the current context.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清除绘图，我们只需将`fingerDraw`变量设置为`false`并调用`SetNeedsDisplay`。这样，`Draw`方法将不会调用我们的自定义绘图代码，从而清除当前上下文。
- en: See also
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Drawing lines and curves*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*'
- en: '*Drawing shapes*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制形状*'
- en: '*Drawing text*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制文本*'
- en: Creating an image context
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像上下文
- en: In this recipe, we will expand the finger drawing application that we created
    previously by providing the user with the feature of saving the created drawings.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过为用户提供保存创建的绘图的功能来扩展我们之前创建的手指绘图应用程序。
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `ImageContextApp`. Add the
    `CanvasView` class that we created in the previous task to the project.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`ImageContextApp`。将我们在上一个任务中创建的`CanvasView`类添加到项目中。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add two buttons on the view of `MainController`. One will be used for saving
    the image and the other for clearing the current drawing.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加两个按钮。一个将用于保存图像，另一个用于清除当前绘图。
- en: 'Add the following methods in the `CanvasView` class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CanvasView`类中添加以下方法：
- en: '[PRE46]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following code in the `MainController` class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中添加以下代码：
- en: '[PRE47]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Compile and run the application on the simulator.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Draw something on the canvas, and tap the **Save drawing** button to save your
    drawing.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上绘制一些东西，然后点击 **保存绘图** 按钮来保存你的绘图。
- en: Tap on the **Clear** drawing button to clear the canvas. You can then check
    the simulator's photo albums for your drawing.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **清除** 绘图按钮来清除画布。然后你可以检查模拟器的照片库以查看你的绘图。
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using the `UIGraphics` class, we can create an image context through which we
    can retrieve our drawing in a `UIImage` object.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UIGraphics` 类，我们可以创建一个图像上下文，通过这个上下文我们可以从 `UIImage` 对象中检索我们的绘图。
- en: 'To create an image context, inside the `GetDrawingImage` method we call the
    `BeginImageContext` static method, passing the size we want the image context
    to have:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图像上下文，在 `GetDrawingImage` 方法中我们调用 `BeginImageContext` 静态方法，传递我们想要图像上下文具有的大小：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The current context is now the image context that we created with the `BeginImageContext`
    call. We then repeat the code we have in the `Draw` method, only this time there
    is no need to add new lines to the path. We simply add the path we already have
    to the context and draw it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当前上下文现在是我们使用 `BeginImageContext` 调用创建的图像上下文。然后我们重复 `Draw` 方法中的代码，只是这次不需要向路径中添加新线条。我们只需将已有的路径添加到上下文中并绘制它。
- en: 'After adding the path, we get the context image by calling the `GetImageFromCurrentContext`
    method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路径后，我们通过调用 `GetImageFromCurrentContext` 方法获取上下文图像：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we have to end the image context block and return the `UIImage` object:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须结束图像上下文块并返回 `UIImage` 对象：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To clear the drawing from the screen, we simply have to set the `fingerDraw`
    variable to `false` and dispose and prepare our `CGPath` object for re-use, inside
    the `ClearDrawing` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要从屏幕上清除绘图，我们只需将 `fingerDraw` 变量设置为 `false`，并在 `ClearDrawing` 方法中处理并准备我们的 `CGPath`
    对象以供重新使用：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To reflect the clearing on the screen immediately, we call the `SetNeedsDisplay`
    method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要立即在屏幕上反映清除操作，我们调用 `SetNeedsDisplay` 方法：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: We cannot create an image context inside the `Draw` method. That is because
    when we call the `BeginImageContext` method, a context is actually created, but
    the view's default context remains as the current context. Hence, the `GetImageFromCurrentImageContext`
    method would return `null`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在 `Draw` 方法内部创建图像上下文。这是因为当我们调用 `BeginImageContext` 方法时，实际上创建了一个上下文，但视图的默认上下文仍然是当前上下文。因此，`GetImageFromCurrentImageContext`
    方法会返回 `null`。
- en: Drawing on UIImageView
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 `UIImageView` 上绘制
- en: The technique discussed here can be used to draw on custom `UIImageViews`. To
    display the drawing when the finger slides on the screen, we would simply have
    to set its `Image` property to the image we get from the image context.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的技术可以用来在自定义 `UIImageViews` 上绘制。要显示当手指在屏幕上滑动时的绘图，我们只需将其 `Image` 属性设置为从图像上下文中获取的图像。
- en: Background on saved drawings
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存绘图的背景信息
- en: You will notice that although we are setting the `CanvasView` background to
    gray, the saved drawings are with a white background. This is because the view's
    background color is not included in the drawing. To include it, we would just
    have to draw a rectangle with the same color as the background color to the graphics
    context.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，尽管我们将 `CanvasView` 的背景设置为灰色，但保存的绘图却是白色背景。这是因为视图的背景颜色不包括在绘图内。要包括它，我们只需将与背景颜色相同的矩形绘制到图形上下文中。
- en: See also
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Drawing lines and curves*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*'
- en: '*Drawing shapes*'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制形状*'
- en: '*Drawing text*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制文本*'
- en: '*A simple drawing*'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单绘图*'
