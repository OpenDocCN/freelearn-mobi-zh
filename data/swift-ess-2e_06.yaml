- en: Chapter 6. Parsing Networked Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 解析网络数据
- en: Many iOS applications need to communicate with other servers or devices. This
    chapter presents both HTTP and non-HTTP networking in Swift, and how data can
    be parsed from either JSON or XML. It first demonstrates how to load data efficiently
    from URLs, followed by how to stream larger data responses. It then concludes
    with how to perform both synchronous and asynchronous network requests over protocols
    other than HTTP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 iOS 应用程序需要与其他服务器或设备进行通信。本章介绍了 Swift 中的 HTTP 和非 HTTP 网络以及如何从 JSON 或 XML 中解析数据。它首先演示了如何有效地从
    URL 加载数据，然后是如何流式传输较大的数据响应。最后，它总结了如何执行除 HTTP 之外的协议的同步和异步网络请求。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Loading data from URLs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 URL 加载数据
- en: Updating the user interface from a background thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从后台线程更新用户界面
- en: Parsing JSON and XML data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 JSON 和 XML 数据
- en: Stream-based connections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于流的连接
- en: Asynchronous data communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步数据通信
- en: Loading data from URLs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 URL 加载数据
- en: The most common way to load data from a remote network source is to use an HTTP
    (or HTTPS) URL of the form [https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json](https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程网络源加载数的最常见方式是使用形式为 [https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json](https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json)
    的 HTTP（或 HTTPS）URL。
- en: URLs can be manipulated with the `NSURL` class, which comes from the `Foundation`
    module (which is transitively imported from the `UIKit` module). The main `NSURL`
    initializer takes a `String` initializer with a full URL, although other initializers
    exist to create relative URLs or for references to file paths.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用来自 `Foundation` 模块（该模块通过 `UIKit` 模块间接导入）的 `NSURL` 类来操作 URL。主要的 `NSURL` 初始化器接受一个带有完整
    URL 的 `String` 初始化器，尽管存在其他初始化器用于创建相对 URL 或对文件路径的引用。
- en: The `NSURLSession` class is typically used to perform operations with URLs,
    and individual sessions can be created through the initializer or the standard
    **shared session** can be used. The `NSURLConnection` class was used in older
    versions of iOS and Mac OS X. References to this class can still be seen in some
    tutorials, or may be required if Mac OS X 10.8 or iOS 6 needs to be supported;
    otherwise, the `NSURLSession` class should be preferred.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 类通常用于执行与 URLs 相关的操作，可以通过初始化器创建单个会话，或者可以使用标准的**共享会话**。在旧版本的 iOS
    和 Mac OS X 中使用了 `NSURLConnection` 类。在某些教程中仍可以看到对该类的引用，或者如果需要支持 Mac OS X 10.8 或
    iOS 6，则可能需要该类；否则，应首选 `NSURLSession` 类。'
- en: 'The `NSURLSession` class provides a means to create tasks. These include:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 类提供了一种创建任务的方法。这些包括：'
- en: '**Data task:** This can be used to process network data programmatically'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据任务**：这可以用于以编程方式处理网络数据'
- en: '**Upload task:** This can be used to upload data to a remote server'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上传任务**：这可以用于将数据上传到远程服务器'
- en: '**Download task:** This can be used to download to local storage or to resume
    a previous or partial download'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载任务**：这可以用于将数据下载到本地存储或恢复先前的或部分下载'
- en: Tasks are created from the `NSURLSession` class methods, and can take a URL
    argument and an optional *completion handler*. A completion handler is a lot like
    a delegate, except that it can be customized per task, and it is usually represented
    as a function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是从 `NSURLSession` 类的方法创建的，可以接受一个 URL 参数和一个可选的*完成处理程序*。完成处理程序类似于代理，但它可以针对每个任务进行自定义，通常表示为一个函数。
- en: Tasks can be *suspended* or *resumed* to stop and start the process. Tasks are
    created in a suspended state by default, and so they have to be initially resumed
    to start processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以被*暂停*或*恢复*以停止和启动过程。默认情况下，任务处于暂停状态，因此它们必须最初恢复以开始处理。
- en: 'When a data task completes, the completion handler is called back with three
    arguments: an `NSData` object that represents the returned data, an `NSURLResponse`
    object that represents the response from the remote URL server, and an optional
    `NSError` object if anything failed during the request.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '当数据任务完成时，完成处理程序会回调三个参数：一个表示返回数据的 `NSData` 对象，一个表示远程 URL 服务器响应的 `NSURLResponse`
    对象，以及一个可选的 `NSError` 对象，如果请求过程中发生任何错误。 '
- en: With this in place, the `SampleTable` that was created in the previous chapter
    can load data from a network URL by obtaining a session, initiating a data task,
    and then resuming it. The completion handler will get called when the data is
    available, which can be used to add the content to the table.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，上一章中创建的 `SampleTable` 可以通过获取会话、启动数据任务然后恢复来从网络 URL 加载数据。当数据可用时，完成处理程序会被调用，这可以用来将内容添加到表格中。
- en: 'Modify the `viewDidLoad` method of the `SampleTable` class to load the `SampleTable.json`
    file by adding the following to the end of the method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `SampleTable` 类的 `viewDidLoad` 方法，通过在方法末尾添加以下代码来加载 `SampleTable.json` 文件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates an `NSURL` and an `NSURLSession`, and then creates a data, task
    and immediately resumes it. After the content is downloaded, the completion handler
    is called, which passes the data as an `NSData` object. The `String` initializer
    is used to decode `UTF8` text from the `NSData` object, and is explicitly cast
    to a `String` so that it can be added to the `items` array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 `NSURL` 和一个 `NSURLSession`，然后创建数据、任务并立即恢复。内容下载完成后，会调用完成处理程序，将数据作为 `NSData`
    对象传递。使用 `String` 初始化器从 `NSData` 对象中解码 `UTF8` 文本，并将其显式转换为 `String` 类型，以便将其添加到 `items`
    数组中。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `NSURLSession` class also provides other factory methods, including one
    that takes a configuration argument that includes options, such as whether responses
    should be cached, whether network connections should go over the cellular network,
    and whether any cookies or other headers should be sent with the task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 类还提供了其他工厂方法，包括一个接受配置参数的方法，该参数包括选项，例如是否应该缓存响应、网络连接是否应该通过蜂窝网络进行，以及是否应该将任何cookie或其他头信息与任务一起发送。'
- en: Finally, the item is added to the `items` and the `tableView` is reloaded to
    show the new data. Please note that this does not work immediately if it is not
    run on the main UI thread; the table has to be rotated or moved in order to redraw
    the display. Running on the UI thread is covered in the *Networking and user interface*
    section later in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将项目添加到 `items` 中，并重新加载 `tableView` 以显示新数据。请注意，如果不在主 UI 线程上运行，则不会立即生效；表格需要旋转或移动以重新绘制显示。在
    UI 线程上运行将在本章后面的 *网络和用户界面* 部分进行介绍。
- en: Dealing with errors
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: Errors are a fact of life, especially on mobile devices with intermittent connectivity.
    The completion handler is called with a third argument, which represents any error
    raised during the operation. If this is `nil`, then the operation was a success;
    if not, then the `localizedDescription` property of the `error` can be used to
    notify the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是生活中不可避免的事实，尤其是在网络连接间歇性的移动设备上。完成处理程序会调用第三个参数，它表示在操作过程中引发的任何错误。如果这是 `nil`，则表示操作成功；如果不为
    `nil`，则可以使用 `error` 的 `localizedDescription` 属性来通知用户。
- en: 'For testing purposes, if an error is detected add the `localizedDescription`
    to the `items` in the list. Modify the `viewDidLoad` method as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，如果检测到错误，请将 `localizedDescription` 添加到列表中的 `items`。按照以下方式修改 `viewDidLoad`
    方法：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An error can be simulated using a nonexistent hostname or an unknown protocol
    in the URL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 URL 中使用不存在的域名或未知协议来模拟错误。
- en: Dealing with missing content
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺失内容
- en: Errors are reported if the remote server cannot be contacted, such as when the
    hostname is incorrect or the server is down. If the server is operational, then
    an error will not be reported; but it is still possible that the file that is
    requested will not be found, or that the server will experience an error while
    serving the request. These are reported with HTTP status codes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法联系远程服务器，例如当域名不正确或服务器关闭时，会报告错误。如果服务器正在运行，则不会报告错误；但仍然有可能请求的文件找不到，或者服务器在处理请求时遇到错误。这些错误会通过
    HTTP 状态码报告。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an HTTP URL is not found, the server sends back a `404` status code. This
    can be used by the client to determine whether a different file should be accessed
    or whether another server should be queried. For example, browsers will often
    ask the server for a `favicon.ico` file and use this to display a small logo;
    if this file is missing, then a generic page icon is displayed instead. In general,
    `4xx` responses are client errors, while `5xx` responses are server errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到 HTTP URL，服务器会返回一个 `404` 状态码。客户端可以使用这个状态码来判断是否应该访问不同的文件或者是否应该查询另一个服务器。例如，浏览器通常会请求一个
    `favicon.ico` 文件，并使用它来显示一个小图标；如果这个文件缺失，则显示一个通用的页面图标。一般来说，`4xx` 响应是客户端错误，而 `5xx`
    响应是服务器错误。
- en: 'The `NSURLResponse` object doesn''t have the concept of an HTTP status code,
    because it can be used for any protocol, including `ftp`. However, if the request
    used HTTP, then the response is likely to be HTTP and so it can be cast to an
    `NSURLHttpResponse`, which has a `statusCode` property. This can be used to provide
    more specific feedback when the file is not found. Modify the code as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLResponse`对象没有HTTP状态码的概念，因为它可以用于任何协议，包括`ftp`。然而，如果请求使用了HTTP，那么响应很可能是HTTP，因此它可以转换为一个`NSURLHttpResponse`，它有一个`statusCode`属性。这可以用来在文件找不到时提供更具体的反馈。按照以下方式修改代码：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if the server responds but indicates that either the client made a bad
    request or the server suffered a problem, the user interface will be updated appropriately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果服务器响应但表示客户端提出了一个错误请求或服务器遇到了问题，用户界面将相应地更新。
- en: Nested if and switch statements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套的if和switch语句
- en: Sometimes, the error handling logic can get convoluted with handling different
    cases, particularly if there are different values that need to be tested. In the
    previous section, both the `NSError` and HTTP `statusCode` needed to be checked.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，错误处理逻辑可能会因为处理不同的案例而变得复杂，尤其是当需要测试不同值时。在前面的章节中，需要检查`NSError`和HTTP的`statusCode`。
- en: An alternative approach is to use a `switch` statement with `where` clauses.
    These can be used to test multiple different conditions and also show which part
    of the condition is being tested. Although a `switch` statement requires a single
    expression, it is possible to use a *tuple* to group multiple values into a single
    expression.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`where`子句的`switch`语句是另一种方法。这些可以用来测试多个不同的条件，并显示正在测试的条件部分。尽管`switch`语句需要一个单一的表达式，但可以使用*元组*将多个值组合成一个单一表达式。
- en: Another advantage of using a tuple is that it permits the cases to be matched
    on types. In the networking case, some URLs are based on `http` or `https`, which
    means that the response will be an `NSHTTPURLResponse` type. However, if the URL
    is a different type (such as a `file` or `ftp` protocol), then it will be of a
    different subtype of `NSURLResponse`. Unconditionally casting to `NSHTTPURLResponse`
    with `as` will fail in these cases and cause a crash.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组的一个优点是它允许根据类型进行情况匹配。在网络案例中，一些URL基于`http`或`https`，这意味着响应将是一个`NSHTTPURLResponse`类型。然而，如果URL是不同类型（例如`file`或`ftp`协议），那么它将是`NSURLResponse`的不同子类型。使用`as`无条件地转换到`NSHTTPURLResponse`在这些情况下将失败并导致崩溃。
- en: 'The tests can be rewritten as a `switch` block as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以重写为一个`switch`块，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the `default` block is used to execute the success condition,
    and the prior `case` statements are used to match the error conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`default`块用于执行成功条件，而之前的`case`语句用于匹配错误条件。
- en: The `case (_,_,let e) where e != nil` case is an example of a *conditional pattern
    match*. The underscore, which is called a *wildcard pattern* in Swift (also known
    as a **hole** in other languages), is something that will match any value. The
    third parameter, `let e`, is a *value binding pattern*, and has the effect of
    `let e = error` in this case. Finally, the `where` clause adds the test to ensure
    this case only occurs when `e` is not `nil`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`case (_,_,let e) where e != nil`情况是一个*条件模式匹配*的例子。在Swift中，下划线被称为*通配符模式*（在其他语言中也称为**空槽**），它可以匹配任何值。第三个参数`let
    e`是一个*值绑定模式*，在这个情况下相当于`let e = error`。最后，`where`子句添加了测试以确保只有当`e`不是`nil`时，此情况才会发生。'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It would be possible to use the identifier `error` instead of `let e` in the
    `case` statement, using `case (_,_,_) where error != nil` would have had the same
    effect. However, it is bad practice to capture values outside of the `switch`
    statement for case matching purposes because if the `error` variable is renamed,
    then the `case` statement may become invalid. Generally, use `let` patterns inside
    `case` statements to ensure that the correct expression value is being matched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case`语句中，可以使用标识符`error`而不是`let e`，使用`case (_,_,_) where error != nil`将产生相同的效果。然而，在`switch`语句外部捕获值用于情况匹配是不良的做法，因为如果`error`变量被重命名，那么`case`语句可能会变得无效。通常，在`case`语句中使用`let`模式以确保匹配正确的表达式值。
- en: The second and third cases perform both a `let` assignment and a type test/conversion.
    When `case (_,let r as NSHTTPURLResponse,_)` is matched, not only is the value
    of that part in the tuple assigned the constant `r`, but it is also cast to an
    `NSHTTPURLRepsonse`. If the value is not of type `NSHTTPURLResponse`, then the
    case statement is automatically skipped. This is equivalent to an `if` test with
    an `is` expression followed by a cast with `as`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第三个情况同时执行一个`let`赋值和一个类型测试/转换。当`case (_,let r as NSHTTPURLResponse,_)`匹配时，不仅元组中该部分的值被赋给常量`r`，它还被转换为`NSHTTPURLResponse`类型。如果该值不是`NSHTTPURLResponse`类型，则自动跳过该情况语句。这相当于一个带有`is`表达式的`if`测试，后面跟着一个使用`as`的转换。
- en: Although the patterns are the same in both, the `where` clauses are different.
    The first `where` clause looks for the case where `r.statusCode` is 400 or greater
    and less than 500, while the second is matched where `r.statusCode` is 500 or
    greater.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种模式相同，但`where`子句不同。第一个`where`子句寻找`r.statusCode`为400或更大但小于500的情况，而第二个匹配的是`r.statusCode`为500或更大的情况。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whether nested `if` statements or the `switch` statement is used, the code that
    performs the test is likely to be very similar. It typically comes down to developer
    preference, but more developers are likely to be familiar with nested `if` statements.
    In Swift, the `switch` statement is more powerful than in other languages, and
    so, this kind of pattern is likely to become more popular.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用嵌套的`if`语句还是`switch`语句，执行测试的代码可能非常相似。这通常取决于开发者的偏好，但更多的开发者可能更熟悉嵌套的`if`语句。在Swift中，`switch`语句比其他语言更强大，因此这种模式可能变得更加流行。
- en: 'An alternative with Swift 2 is to use the `guard` statement to ensure that
    if certain error conditions occur, then appropriate action can be taken instead.
    The `guard` statement is like an `if` statement where there is no `true` block
    and the `false` block must always leave the function. For example, the code could
    be rewritten as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2中，可以使用`guard`语句来确保如果发生某些错误条件，可以采取适当的行动。`guard`语句类似于`if`语句，但没有`true`块，并且`false`块必须始终离开函数。例如，代码可以被重写为：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that the `guard` block must exit the calling function; so, if additional
    operations are required, either the body of the implementation must be moved to
    a different function or the `switch` or `if` blocks used instead. The examples
    later in this chapter assume the use of the `if` blocks for simplicity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`guard`块必须退出调用函数；因此，如果需要额外的操作，要么将实现体的主体移动到不同的函数中，要么使用`switch`或`if`块。本章后面的示例假设使用`if`块以保持简单。
- en: Networking and user interfaces
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和用户界面
- en: One outstanding problem with the current callback approach is that the callback
    cannot be guaranteed to be called from the *main thread*. As a result, user interface
    operations may not work correctly or throw errors. The right solution is to set
    up another call using the main thread.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当前回调方法的一个突出问题是无法保证回调函数一定会在*主线程*中被调用。因此，用户界面操作可能无法正确执行或引发错误。正确的解决方案是使用主线程设置另一个调用。
- en: 'Accessing the main thread in Swift is done in the same way as it is in Objective-C:
    using **Grand Central Dispatch** (**GCD**). The *main queue* can be accessed with
    `dispatch_get_main_queue`, which is used by the thread that all UI updates should
    use. Background tasks are submitted with `dispatch_async` to a queue. To invoke
    the `reloadData` call on the main thread, wrap it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中访问主线程的方式与在Objective-C中相同：使用**Grand Central Dispatch**（**GCD**）。可以使用`dispatch_get_main_queue`访问*主队列*，这是所有UI更新应使用的线程。后台任务通过`dispatch_async`提交到队列。要在主线程上调用`reloadData`，可以这样包装：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This style of call will be valid for both Objective-C and Swift (although Objective-C
    uses the ^ (caret) as a block prefix). However, Swift has a special syntax for
    functions that take blocks; the block can be promoted out of the function''s argument
    and left as a trailing argument. This is known as a *trailing closure*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用方式对Objective-C和Swift都有效（尽管Objective-C使用^（尖括号）作为块前缀）。然而，Swift为接受块的函数有特殊的语法；块可以被提升出函数的参数，并作为尾随参数留下。这被称为*尾随闭包*：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although this is a minor difference, it makes it look like `dispatch_async`
    is more like a keyword, such as `if` or `switch`, which takes a block of code.
    This can be used for any function whose final argument is a function; there is
    no special syntax needed in the function definition. Additionally, the same technique
    works for functions that are defined outside of Swift; in the case of `dispatch_async`,
    the function is defined as a C-language function and can be transparently used
    in a portable way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是微小的差异，但它使得`dispatch_async`看起来更像是一个关键字，例如`if`或`switch`，它接受一段代码块。这可以用于任何最终参数是函数的函数；在函数定义中不需要特殊语法。此外，相同的技巧也适用于在Swift外部定义的函数；在`dispatch_async`的情况下，该函数被定义为C语言函数，并且可以透明地以可移植的方式使用。
- en: Running functions on the main thread
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主线程上运行函数
- en: Whenever the UI needs to be updated, the update must be run on the main thread.
    This can be done using the previous pattern to perform updates as they will always
    be threaded. However, it can be a pain to remember to do this each time it is
    required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当UI需要更新时，更新必须在主线程上运行。这可以通过使用之前的模式来完成，因为它们将始终在线程中执行。然而，每次需要时都记住这样做可能会很痛苦。
- en: 'It is possible to build a Swift function that takes another function and runs
    it on the main thread automatically. `NSThread.isMainThread` can be used to determine
    whether the current thread is the UI thread or not; so to run a block of code
    on the main thread, regardless of whether it''s on the main thread or not, the
    following can be used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以构建一个Swift函数，该函数接受另一个函数并在主线程上自动运行。`NSThread.isMainThread`可以用来确定当前线程是否是UI线程；因此，要在主线程上运行代码块，无论它是否在主线程上，可以使用以下方法：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This allows code to be submitted to the background thread using:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用以下方式将代码提交到后台线程：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Due to the lack of parenthesis, the `reloadData` function is not called, but
    it is passed in as a function pointer. It is dispatched to the correct thread
    inside the `runOnUIThread` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺少括号，`reloadData`函数没有被调用，但它被作为函数指针传递。它在`runOnUIThread`函数内部被调度到正确的线程。
- en: 'If there is more than one function that needs to be called, an inline block
    can be created. As this can be passed as a trailing closure to the `runOnUIThread`
    method, the parenthesis are optional:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调用多个函数，可以创建一个内联块。由于这可以作为`runOnUIThread`方法的尾随闭包传递，因此括号是可选的：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Parsing JSON
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON
- en: The most popular mechanism to send structured data over a network is to encode
    it in **JSON**, which stands for **JavaScript Object Notation**. This provides
    a hierarchical tree data structure, which can store simple numeric, logical, and
    string-based types, along with array and dictionary representations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上发送结构化数据最流行的机制是将数据编码为**JSON**，代表**JavaScript对象表示法**。这提供了一个分层树形数据结构，可以存储简单的数字、逻辑和基于字符串的类型，以及数组和字典表示。
- en: Both Mac OS X and iOS come with a built-in parser for JSON documents, in the
    `NSJSONSerialization` class. This provides a means to parse a data object and
    return an `NSDictionary` that contains the key/value pairs of a JSON object, or
    an `NSArray` to represent JSON arrays. Other literals are parsed and are represented
    as either `NSNumber` or `NSString` values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X和iOS都内置了JSON文档的解析器，在`NSJSONSerialization`类中。这提供了一种解析数据对象并返回包含JSON对象键/值对的`NSDictionary`或表示JSON数组的`NSArray`的方法。其他字面量被解析，并作为`NSNumber`或`NSString`值表示。
- en: The JSON parser uses `JSONObjectWithData` to create an object from an `NSData`
    object containing a string. This is typically the format that is returned by network
    APIs, and it can be created from an existing string using `dataUsingEncoding`
    with one of the built-in encoding types, such as `NSUTF8StringEncoding`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解析器使用`JSONObjectWithData`从包含字符串的`NSData`对象创建一个对象。这通常是网络API返回的格式，并且可以使用`dataUsingEncoding`与内置编码类型之一（如`NSUTF8StringEncoding`）从现有字符串创建。
- en: 'A simple JSON array of numbers can be parsed as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的数字JSON数组可以按以下方式解析：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The return type of this is an optional `AnyObject`. The optionality represents
    the fact that the data content may not be valid JSON data. This can be cast to
    an appropriate type using the `as` keyword; if there is a parsing failure, then
    an error will be thrown.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个返回类型是一个可选的`AnyObject`。可选性表示数据内容可能不是有效的JSON数据。可以使用`as`关键字将其转换为适当类型；如果解析失败，则会抛出错误。
- en: The `options` can be used to indicate whether the return type should be mutable
    or not. Mutable data allows the caller to add or delete items after being returned
    from the parsing function; if not specified, the return value will be immutable.
    The `NSJSONReadingOptions` options include `MutableContainers` (containing data
    structures are mutable), `MutableLeaves` (the child leaves are mutable), and `AllowFragments`
    (allow nonobject, non-array values to be parsed).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `options` 来指示返回类型是否应该是可变的。可变数据允许调用者在解析函数返回后添加或删除项目；如果没有指定，返回值将是不可变的。`NSJSONReadingOptions`
    选项包括 `MutableContainers`（包含数据结构是可变的）、`MutableLeaves`（子叶是可变的）和 `AllowFragments`（允许解析非对象、非数组值）。
- en: 'The `SampleTable.json` file (referred to in the `viewDidLoad` method) stores
    an array of entries, with `title` and `content` fields holding text data per entry:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleTable.json` 文件（在 `viewDidLoad` 方法中引用）存储一个条目数组，每个条目的 `title` 和 `content`
    字段包含文本数据：'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To parse the JSON file and entries to the table, replace the `default` clause
    in the `SampleTable` with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析 JSON 文件并将条目添加到表中，将 `SampleTable` 中的 `default` 子句替换为以下内容：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the application will show the **Sample Title** and **Sample Content**
    entries in the table, which have been loaded and parsed from the book's GitHub
    repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序将在表中显示 **样本标题** 和 **样本内容** 条目，这些条目已从书籍的 GitHub 仓库加载并解析。
- en: Handling errors
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'If there are problems parsing the JSON data then the return type of the `try?
    JSONObjectWithData` function will return a `nil` value. If the type is implicitly
    unwrapped, then accessing the element will cause an error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析 JSON 数据时出现问题，则 `try? JSONObjectWithData` 函数的返回类型将为 `nil` 值。如果类型是隐式解包的，则访问元素将导致错误：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `parsed` value will be of type `AnyObject?` although the `let` block will
    implicitly unwrap the value, known as *optional binding*. In the previous section,
    the code was cast to an `NSArray` directly, but if the returned result contains
    different types (for example, an `NSDictionary` or one of the fragment types `NSNumber`
    or `NSString`), then attempting to cast to a type that is incompatible with the
    runtime type will cause a failure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`parsed` 值的类型将是 `AnyObject?`，尽管 `let` 块会隐式解包该值，这被称为 *可选绑定*。在上一节中，代码被直接转换为 `NSArray`，但如果返回的结果包含不同类型（例如，`NSDictionary`
    或片段类型 `NSNumber` 或 `NSString`），则尝试转换为与运行时类型不兼容的类型将导致失败。'
- en: 'The type of the object can be tested with `if [object] is [type]`. However,
    as the next step is usually to cast it to a different class with `as`, a shorthand
    form `as?` can perform both the test and the cast in one step:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `if [object] is [type]` 来测试对象的类型。然而，由于下一步通常是将它转换为不同的类，使用 `as`，一个简写形式 `as?`
    可以在一步中完成测试和转换：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A `switch` statement can be used to check the type of multiple values at the
    same time. As the values are optional `AnyObject` objects, they need to be converted
    to a `String` before they can be used in Swift:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句可以同时检查多个值的类型。由于这些值是可选的 `AnyObject` 对象，因此在 Swift 中使用之前需要将它们转换为 `String`：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now when the application is run, any errors are detected and handled without
    the application crashing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，任何错误都会被检测和处理，而不会导致应用程序崩溃。
- en: Parsing XML
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 XML
- en: Although JSON is more commonly used, there are still many XML-based network
    services. Fortunately XML parsing has existed in iOS since version 5 in the `NSXMLParser`
    class and is simple to access from Swift. For example, some data feeds (such as
    blog posts) use XML documents, such as Atom or RSS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JSON 更常用，但仍有许多基于 XML 的网络服务。幸运的是，iOS 自 5 以来就存在 XML 解析，在 `NSXMLParser` 类中，并且从
    Swift 中访问很简单。例如，一些数据源（如博客文章）使用 XML 文档，如 Atom 或 RSS。
- en: 'The `NSXMLParser` is a stream-oriented parser; that is, it reports individual
    elements as they are seen. The parser calls the `delegate` to notify when elements
    are seen and have finished. When an element is seen, the parser also includes
    any attributes that were present; and for text nodes, the string content. Parsing
    an XML file involves some state management in the parser. The example used in
    this section will be to parse an Atom (news feed) file, whose (simplified) structure
    looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParser` 是一个面向流的解析器；也就是说，它会按顺序报告看到的各个元素。解析器调用 `delegate` 通知元素被看到和完成。当看到元素时，解析器还会包括任何存在的属性；对于文本节点，包括字符串内容。解析
    XML 文件涉及解析器中的某些状态管理。本节中使用的示例将解析 Atom（新闻源）文件，其（简化后的）结构如下所示：'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the goal is to extract all the `entry` elements from the feed,
    specifically the `title` and the `link`. This presents a few challenges that will
    become apparent later on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，目标是提取出所有来自源的数据元素`entry`，特别是`title`和`link`。这会带来一些挑战，这些挑战将在稍后变得明显。
- en: Creating a parser delegate
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建解析代理
- en: Parsing an XML file requires creating a class that conforms to the `NSXMLParserDelegate`
    protocol. To do this, create a new class, `FeedParser`, that extends `NSObject`
    and conforms to the `NSXMLParserDelegate` protocol.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解析XML文件需要创建一个遵守`NSXMLParserDelegate`协议的类。为此，创建一个新的类`FeedParser`，它扩展`NSObject`并遵守`NSXMLParserDelegate`协议。
- en: 'It should have an `init` method that takes an `NSData`, and an `items` property
    that will be used to acquire the results after they have been parsed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该有一个`init`方法，该方法接受一个`NSData`，并且有一个`items`属性，用于在解析后获取结果：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `NSXMLParserDelegate` protocol requires that the object also conform to
    the `NSObjectProtocol`. The easiest way to do this is to subclass `NSObject`.
    The first mentioned super type is the super class; the second and subsequent super
    types must be protocols.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSXMLParserDelegate`协议要求对象也遵守`NSObjectProtocol`。最简单的方法是子类化`NSObject`。首先提到的超类型是父类；第二个和后续的超类型必须是协议。'
- en: Downloading the data
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载数据
- en: The XML parser can either parse a stream of data as it is downloaded, or it
    can take an `NSData` object that has been downloaded previously. On successful
    download, the `FeedParser` can be used to parse the `NSData` instance and return
    the list of items.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: XML解析器可以解析下载时的数据流，或者它可以接受之前已下载的`NSData`对象。在成功下载后，可以使用`FeedParser`解析`NSData`实例并返回项目列表。
- en: 'Although individual expressions can be assigned temporary values that are similar
    to last time, the statement can be written in a single line (although please note
    that the error handling is not present). Add the following to the end of the `viewDidLoad`
    method of `SampleTable`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以给单个表达式分配与上次相似的临时值，但可以将语句写在一行中（尽管请注意，这里没有错误处理）。将以下内容添加到`SampleTable`类的`viewDidLoad`方法末尾：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will download the Atom XML feed for the Swift posts from the author's blog
    at [https://alblue.bandlem.com](https://alblue.bandlem.com). Currently, the data
    is not parsed, so nothing will be added to the table in this step.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载作者博客中Swift文章的Atom XML源，博客地址为[https://alblue.bandlem.com](https://alblue.bandlem.com)。目前，数据尚未解析，因此在此步骤中不会向表中添加任何内容。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that both the download operation and the parsing are handled off the
    main thread as both of these operations may take some time. Once the data is downloaded,
    it can be parsed, and after it is parsed, the UI can be notified to redisplay
    the contents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确保下载操作和解析都在主线程之外处理，因为这两个操作可能需要一些时间。一旦数据下载完成，就可以解析它，解析完成后，可以通知UI重新显示内容。
- en: Parsing the data
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析数据
- en: To process the downloaded XML file, it is necessary to parse the data. This
    involves writing a parser delegate to listen for the `title` and `link` elements.
    However, the `title` and `link` elements exist both at the individual `entry`
    level and also at the top level of the blog. It is therefore necessary to represent
    some kind of state in the parser, which detects when the parser is inside an `entry`
    element to allow the correct values to be used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理下载的XML文件，需要解析数据。这涉及到编写一个解析代理来监听`title`和`link`元素。然而，`title`和`link`元素既存在于单个`entry`级别，也存在于博客的顶级。因此，在解析器中需要表示某种状态，以便检测解析器是否在`entry`元素内部，从而允许使用正确的值。
- en: 'Elements are reported with the `parser:didStartElement:` method and the `parser:didEndElement:`
    method. This can be used to determine if the parser is inside an `entry` element
    by setting a boolean value when an `entry` element starts and resetting it when
    the `entry` element ends. Add the following to the `FeedParser` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 元素通过`parser:didStartElement:`方法和`parser:didEndElement:`方法报告。这可以用来确定解析器是否在`entry`元素内部，通过在`entry`元素开始时设置一个布尔值，并在元素结束时重置它。将以下内容添加到`FeedParser`类中：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `link` stores the value of the references in an `href` attribute of the
    element. This is passed when the start element is called, so it is trivial to
    store. At this point, the title may not be known, so the value of the `link` has
    to be stored in an optional field:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`link`将元素的引用值存储在元素的`href`属性中。这会在调用开始元素时传递，因此存储是微不足道的。在此点，标题可能未知，因此`link`的值必须存储在可选字段中：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `title` stores its data as a text node, which needs to be implemented with
    another boolean flag indicating whether the parser is inside a `title` node. Text
    nodes are reported with the `parser:foundCharacters:` delegate method. Add the
    following to the `FeedParser`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`title` 将其数据存储为文本节点，需要使用另一个布尔标志来指示解析器是否在 `title` 节点内部。文本节点通过 `parser:foundCharacters:`
    代理方法报告。将以下内容添加到 `FeedParser`：'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By storing the `title` and `link` as optional fields when the end of the `entry`
    element is seen, the fields can be appended into the `items` list, followed by
    resetting the state of the parser:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到 `entry` 元素的末尾时，将 `title` 和 `link` 存储为可选字段，可以将这些字段附加到 `items` 列表中，然后重置解析器的状态：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, having implemented the callback methods, the remaining steps are to
    create an `NSXMLParser` from the data passed in previously, set the `delegate`
    (and optionally, the namespace handling), and then invoke the parser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在实现了回调方法之后，接下来的步骤是从之前传递的数据中创建一个 `NSXMLParser`，设置 `delegate`（以及可选的命名空间处理），然后调用解析器：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The assignment of `self` to the `delegate` cannot be done until after `super.init`
    has been called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `super.init` 之后才能将 `self` 赋值给 `delegate`。
- en: Now when the application is run, a set of news feed items will be displayed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，将显示一组新闻源项目。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If running on iOS 9 targets and downloading from http sites, a **App Transport
    Security has blocked a cleartext HTTP resource load** message may be seen in the
    console. The solution to fix this is to add an exception in the `Info.plist` file,
    which permits connections via HTTP, either for the explicit domain or for all
    domains. Add the following to the `Info.plist` after the first `<dict>` element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 iOS 9 目标上运行并从 http 网站下载，控制台可能会看到 **App Transport Security 已阻止明文 HTTP 资源加载**
    的消息。修复此问题的解决方案是在 `Info.plist` 文件中添加一个异常，允许通过 HTTP 进行连接，无论是显式域名还是所有域名。在第一个 `<dict>`
    元素之后添加以下内容到 `Info.plist`：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now when the application is run, the error should no longer be seen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，错误应该不再出现。
- en: Direct network connections
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接网络连接
- en: Although most application networking will involve downloading content over standard
    protocols, such as HTTP(S), and using standard representations, there are times
    when having a specific data stream protocol is required. In this case, a *stream*-oriented
    process will allow individual bytes to be read or written, or a *datagram* or
    *packet*-oriented process can be used to send individual packets of data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数应用程序网络将涉及通过标准协议（如 HTTP(S)）下载内容，并使用标准表示，但有时需要特定的数据流协议。在这种情况下，*流*导向的过程将允许读取或写入单个字节，或者可以使用*数据报*或*数据包*导向的过程来发送单个数据包。
- en: There are networking libraries to support both; an `NSStream` higher-level Objective-C
    based class provides a mechanism to drive stream-based responses, and although
    lower-level packet connections are possible with the `CoreFoundation` or the `POSIX`
    layer, local multiplayer gaming using the `MultipeerConnectivity` module is often
    appropriate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有网络库支持这两种情况；一个基于 Objective-C 的高级 `NSStream` 类提供了一个驱动基于流的响应的机制，尽管使用 `CoreFoundation`
    或 `POSIX` 层可以实现低级别的数据包连接，但使用 `MultipeerConnectivity` 模块进行本地多人游戏通常是合适的。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Local networking with the `MultipeerConnectivity` module involves creating an
    `MCSession`, followed by `sendData` to send `NSData` objects to connected peers,
    and using the `MCSessionDelegate` to `receiveData` from connected peers. This
    is often used to synchronize the state of the world, such as the player's current
    location or health.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MultipeerConnectivity` 模块进行本地网络涉及创建一个 `MCSession`，然后通过 `sendData` 发送 `NSData`
    对象到已连接的节点，并使用 `MCSessionDelegate` 从已连接的节点接收数据。这通常用于同步世界的状态，例如玩家的当前位置或健康。
- en: Opening a stream-based connection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开基于流的连接
- en: A stream is a reliable, ordered sequence of bytes, which is used by most internet
    protocols. Streams can be created from a network host and port using the `NSStream`
    class method `getStreamsToHostWithName`. This allows an `NSInputStream` and `NSOutputStream`
    to be acquired at the same time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个可靠、有序的字节序列，大多数互联网协议都使用流。可以使用 `NSStream` 类的 `getStreamsToHostWithName` 方法从网络主机和端口创建流。这允许同时获取
    `NSInputStream` 和 `NSOutputStream`。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As this is an existing Objective-C API, the streams are returned via *inout
    parameters*. In Swift, this translates to the parameters being passed back with
    an ampersand (`&`) and declaring the variables as optional.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个现有的 Objective-C API，流通过 *输入输出参数* 返回。在 Swift 中，这表示参数通过 ampersand (`&`)
    返回，并将变量声明为可选的。
- en: The input and output streams can then be used to send data asynchronously or
    synchronously. Asynchronous mechanisms involve scheduling the data processing
    on the application's run-loop and is covered in the *Asynchronous reading and
    writing* section. Synchronous mechanisms use `read` and `write` to receive or
    send buffers of data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用这些输入/输出流异步或同步地发送数据。异步机制涉及在应用程序的运行循环上调度数据处理，这在 *异步读写* 部分有所介绍。同步机制使用 `read`
    和 `write` 来接收或发送数据缓冲区。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Once the streams have been acquired, they need to be *open* to receive or send
    data. Forgetting this step will result in no networking data being sent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了流，它们需要被 *打开* 以接收或发送数据。忘记这一步将导致没有网络数据被发送。
- en: 'To simplify acquiring the streams, the following can be created as an extension
    of the `NSStream` class. An extension makes a method appear to come from an original
    class but is implemented externally to that class. Add a `StreamExtensions.swift`
    file to the `CustomViews` project with the following content:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化获取流，可以将以下内容作为 `NSStream` 类的扩展来创建。扩展使方法看起来来自原始类，但实际上是在类外部实现的。在 `CustomViews`
    项目中添加一个 `StreamExtensions.swift` 文件，内容如下：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A connection to a remote host can be obtained by calling `NSStream.open(host,port)`,
    which returns an open pair of input/output streams.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `NSStream.open(host,port)` 可以获得对远程主机的连接，该方法返回一个打开的输入/输出流对。
- en: Synchronous reading and writing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步读写
- en: The `NSInputStream` method `read` allows bytes to be read from a stream synchronously,
    while the `NSOutputStream` method `write` allows bytes to be written to a stream.
    These take different types, but the most common approach is to create an array
    of bytes `[UInt8]` in Swift as the buffer, and then read into or out of it with
    an `UnsafeMutablePointer` (equivalent to an ampersand in C).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSInputStream` 的 `read` 方法允许同步地从流中读取字节，而 `NSOutputStream` 的 `write` 方法允许将字节写入流。它们接受不同的类型，但在
    Swift 中最常见的方法是创建一个字节数组 `[UInt8]` 作为缓冲区，然后使用 `UnsafeMutablePointer`（在 C 中相当于 ampersand）读取到或从中。'
- en: The `read` and `write` methods both return a number of bytes read/written. This
    can be negative (in the case of an error), zero, or positive in the case of bytes
    having been processed. Both calls take a buffer and a maximum length, though it
    is not guaranteed that the full maximum length will be processed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 和 `write` 方法都返回读取/写入的字节数。这可能为负（错误情况），为零，或者为正（已处理字节的情况）。这两个调用都接受一个缓冲区和最大长度，尽管不能保证会处理完整的最大长度。'
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always check the return value of `write` or `read` as it is possible that only
    part of the buffer has been written. Best practice (for synchronous connections)
    is to wrap the call in a `while` loop or have some other form of `retry` in order
    to ensure that all the data is written.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查 `write` 或 `read` 的返回值，因为可能只有缓冲区的一部分被写入。对于同步连接，最佳实践是使用 `while` 循环包装调用或具有其他形式的
    `retry`，以确保所有数据都被写入。
- en: Writing data to NSOutputStream
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 NSOutputStream 写入数据
- en: 'To make it easier to write `NSData` content to streams, an extension method
    on `NSOuptutStream` can be created that performs a full write, based on the size
    of the data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易将 `NSData` 内容写入流，可以在 `NSOutputStream` 上创建一个扩展方法，该方法根据数据的大小执行完整写入：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code takes an `NSData` and writes it to the underlying stream, returning
    the number of bytes written (or a negative value if there are problems). The return
    value of the `write` method is checked, and if the value is negative, it is returned
    to the caller directly. Otherwise, the `completed` counter is incremented with
    the number of bytes written.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码接受一个 `NSData` 并将其写入底层流，返回写入的字节数（如果有问题，则返回负值）。检查 `write` 方法的返回值，如果值为负，则直接返回给调用者。否则，使用写入的字节数增加
    `completed` 计数器。
- en: If the number of written bytes reaches the size of the data requested, then
    the value is returned. Otherwise the loop recurs, this time starting at the point
    where it left off.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果写入的字节数达到请求的数据大小，则返回该值。否则，循环递归，这次从上次离开的点开始。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although uncommon in Swift, pointer arithmetic is possible by acquiring an `UnsafePointer`
    to the `data.bytes` array, and then incrementing it by the number of bytes already
    written. The length of the remaining bytes is calculated with `size-completed`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Swift 中不常见，但可以通过获取 `data.bytes` 数组的 `UnsafePointer` 来执行指针算术，然后通过已写入的字节数增加它。剩余字节的长度通过
    `size-completed` 计算。
- en: Reading from an NSInputStream
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 NSInputStream 读取
- en: 'A similar approach can be used to read a full buffer from an `NSInputStream`
    by creating a `readBytes` method that returns an array of bytes of a known size,
    and a means to convert this to an `NSData` for easier processing/parsing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似的方法从 `NSInputStream` 读取完整缓冲区，通过创建一个返回已知大小字节数组的 `readBytes` 方法，以及将其转换为
    `NSData` 以便于处理/解析的方法：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `readData` method returns an `NSData`, while the `readBytes` method returns
    an array of `UInt8` values. The `NSData` approach is useful in some cases (particularly,
    creating a `String` from the returned data), and in other cases, being able to
    process the bytes directly is useful (for example, parsing binary formats). Having
    both allows either to be used as appropriate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`readData` 方法返回一个 `NSData`，而 `readBytes` 方法返回一个 `UInt8` 值的数组。使用 `NSData` 方法在某些情况下很有用（尤其是，从返回的数据中创建一个
    `String`），而在其他情况下，能够直接处理字节很有用（例如，解析二进制格式）。两者都存在使得可以根据需要使用任一方法。'
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Synchronous reads can block forever; if the client application requests exactly
    10 bytes but the server only sends 9 bytes, then it will hang permanently until
    the tenth byte is sent. It is best practice to use asynchronous reads, which cannot
    block in this way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同步读取可能会永远阻塞；如果客户端应用程序请求恰好 10 个字节，但服务器只发送了 9 个字节，那么它将永久挂起，直到发送了第十个字节。最佳实践是使用异步读取，这样就不会以这种方式阻塞。
- en: Reading and writing hexadecimal and UTF8 data
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取和写入十六进制和 UTF8 数据
- en: Being able to process data as UTF8 values or hexadecimal values can be useful
    in some protocols. Although both `NSString` and `NSData` provide means to convert
    to and from UTF8, the syntax is overly verbose as it is based on pre-existing
    Objective-C methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将数据作为 UTF8 值或十六进制值处理在某些协议中可能很有用。尽管 `NSString` 和 `NSData` 都提供了转换到和从 UTF8 的方法，但其语法过于冗长，因为它基于现有的
    Objective-C 方法。
- en: 'To facilitate the conversions, extension methods can be created to provide
    a simple way of converting to and from UTF8 representations. In addition to class
    and instance functions, it is possible to use extensions to add dynamic properties
    to an existing object. This can be used to create `utf8data` and `utf8string`
    properties on `NSData` and `String` by adding extensions in a file `Extensions.swift`,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于转换，可以创建扩展方法以提供简单地将转换到和从 UTF8 表示的方法。除了类和实例函数之外，还可以使用扩展向现有对象添加动态属性。这可以通过在文件
    `Extensions.swift` 中添加扩展来实现，如下所示：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This allows expressions, such as `data.utf8string` and `string.utf8data`, which
    are much more compact. Each time the expression is evaluated, the associated getter
    function will be called.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用更紧凑的表达式，例如 `data.utf8string` 和 `string.utf8data`。每次表达式被评估时，相关的 getter 函数将被调用。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is no standard convention to name extensions in Swift at the time this
    book was written. If there are extensions to a single type of data—such as the
    streams previously—then the file can be named `[Type]Extensions.swift`. Alternatively,
    the name can be used for the type of methods that are called; for example, in
    this case, `UTF8Extensions.swift` could have been used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，Swift 中没有命名扩展的标准约定。如果有对单一类型数据的扩展——例如之前提到的流——那么文件可以命名为 `[Type]Extensions.swift`。或者，可以使用该名称来命名被调用的方法类型；例如，在这种情况下，可以使用
    `UTF8Extensions.swift`。
- en: 'Parsing hexadecimal data from strings and integers can also be added to the
    `String` and `Int` types, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将解析十六进制数据从字符串和整数添加到 `String` 和 `Int` 类型中，如下所示：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This allows hex values to be created with `int.toHex` and `string.fromHex`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用 `int.toHex` 和 `string.fromHex` 创建十六进制值。
- en: Implementing the Git protocol
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Git 协议
- en: It is possible to write a client to query a remote git server using the `git://`
    protocol to determine the hashes of remote tags/branches/references.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写一个客户端，使用 `git://` 协议查询远程 git 服务器，以确定远程标签/分支/引用的哈希值。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `git://` protocol works by sending *packet lines* of data with each line
    prefixed with four hexadecimal digits in ASCII, indicating the length of the rest
    of the data (including the four initial digits). Sending a `git-upload-pack` request
    will return a list of references on the remote repository.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`git://` 协议通过发送带有ASCII码前缀的四位十六进制数字的数据包行来工作，这些数字表示其余数据（包括这四个初始数字）的长度。发送 `git-upload-pack`
    请求将返回远程仓库上的引用列表。'
- en: 'As the `git://` protocol uses packet lines, create a `PacketLineExtensions.swift`
    file with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `git://` 协议使用数据包行，因此创建一个 `PacketLineExtensions.swift` 文件，内容如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When an empty `NSData` object is passed, the special packet line `0000` is written,
    indicating the end of the conversation. When a non-empty `NSData` is written,
    the length of the data is written as a hexadecimal value (including the 4 bytes
    for the length), followed by the data itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递一个空的 `NSData` 对象时，将写入特殊的包行 `0000`，表示对话结束。当写入非空的 `NSData` 时，数据长度以十六进制值（包括用于长度的4个字节）表示，然后是数据本身。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This will result in a protocol conversation such as:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下协议对话：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Reading a packet line is similar:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据包行类似：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, the first 4 bytes are read to determine what the remaining length
    is. If it is zero, a `nil` value is returned to indicate the end of stream. If
    it is non-zero, the data is read (less the 4 that is used for the packet line
    length header). An additional `readPacketLineString` is provided to allow an easy
    creation of the packet line as an `NSString`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，读取前4个字节以确定剩余长度。如果它是零，则返回 `nil` 值以指示流结束。如果它不是零，则读取数据（减去用于数据包行长度头的4个字节）。还提供了一个
    `readPacketLineString` 以便于轻松创建作为 `NSString` 的数据包行。
- en: Listing git references remotely
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程列出git引用
- en: 'To remotely query a git repository for references, the `git-upload-pack` command
    needs to be sent along with a reference to the repository in question, and optionally,
    a host. To provide an API to query this programmatically, create a `RemoteGitRepository`
    class with an initializer that stores the host, port, and repository, and an `lsRemote`
    function, which returns the value of the references:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要远程查询git仓库的引用，需要发送 `git-upload-pack` 命令，并附带要查询的仓库的引用，以及可选的主机。为了提供一种程序化查询的API，创建一个
    `RemoteGitRepository` 类，该类具有一个初始化器，用于存储主机、端口和仓库，以及一个 `lsRemote` 函数，该函数返回引用的值：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To load the data from the repository, a connection to the remote host needs
    to be made on the default port (in this case, `9418` is the default for the `git://`
    protocol). Once the streams are opened, the `git-upload-pack [repository]\0host=[host]\0`
    packet line is sent, and subsequently, lines can be read of the form `hash reference`.
    Add the following to the `lsRemote` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从仓库加载数据，需要在默认端口（在这种情况下，`9418` 是 `git://` 协议的默认端口）上连接到远程主机。一旦流被打开，发送 `git-upload-pack
    [repository]\0host=[host]\0` 数据包行，然后可以读取形式为 `hash reference` 的行。将以下内容添加到 `lsRemote`
    函数中：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Calling the `lsRemote` function on a `RemoteGitRepository` instance with an
    appropriate `host` and `repo` will return a list of hashes by reference.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有适当的 `host` 和 `repo` 的 `RemoteGitRepository` 实例上调用 `lsRemote` 函数将返回一个通过引用的哈希列表。
- en: Integrating the network call into the UI
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将网络调用集成到UI中
- en: 'As the network can introduce delays or can even result in a complete failure,
    network calls should never be performed on the UI thread. Previously, the `SampleTable`
    was used to introduce a `runOnUIThread` function. A similar approach can be used
    to run a function on a background thread. Add the following to the `SampleTable`
    class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络可能会引入延迟，甚至可能导致完全失败，因此网络调用不应在UI线程上执行。以前，`SampleTable` 被用来引入一个 `runOnUIThread`
    函数。可以使用类似的方法在后台线程上运行函数。将以下内容添加到 `SampleTable` 类中：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will permit `viewDidLoad` to invoke a call in order to query the remote
    references from the repository, and add them to the table. As before, the call
    to update the table must be called from the UI thread. Add the following to the
    end of the `viewDidLoad` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许 `viewDidLoad` 调用一个调用，以从仓库查询远程引用并将其添加到表中。与之前一样，必须从UI线程调用更新表的调用。将以下内容添加到
    `viewDidLoad` 方法的末尾：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now when the application is launched, entries corresponding to the branches
    and tags in the remote repository should be added to the table.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序启动时，应将远程仓库中对应的分支和标签条目添加到表中。
- en: Asynchronous reading and writing
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步读写
- en: As well as synchronous reading and writing, it is also possible to perform *asynchronous*
    reading and writing. Instead of spinning in a `while` loop, the application can
    be use callbacks scheduled on the application's run loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了同步的读写操作，还可以执行*异步*读写操作。应用程序不需要在`while`循环中旋转，而是可以使用在应用程序的运行循环上安排的回调。
- en: To receive callbacks, a class that implements `NSStreamDelegate` must be created
    and assigned to the stream's `delegate` field. When events occur, the `stream`
    method is called with the type of event and the associated stream.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收回调，必须创建一个实现了`NSStreamDelegate`的类并将其分配给流的`delegate`字段。当事件发生时，`stream`方法会根据事件类型和关联的流被调用。
- en: The stream is registered with `scheduleInRunLoop` (using `NSRunLoop.mainRunLoop()`
    with a `NSDefaultRunLoopMode` mode). Finally, the stream can be opened.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 流通过`scheduleInRunLoop`（使用`NSRunLoop.mainRunLoop()`和`NSDefaultRunLoopMode`模式）进行注册。最后，流可以被打开。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the stream is opened before the delegate is set or scheduled in the run loop,
    then events will not be delivered.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设置代理或调度到运行循环之前打开流，则不会传递事件。
- en: Events are defined in the `NSStreamEvent` class, and they include `HasSpaceAvailable`
    (for output streams) and `HasBytesAvailable` (for input streams). By responding
    to callbacks, the application can process results asynchronously.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在`NSStreamEvent`类中定义，包括`HasSpaceAvailable`（用于输出流）和`HasBytesAvailable`（用于输入流）。通过响应回调，应用程序可以异步处理结果。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using Swift, the `NSStreamDelegate` is treated as a `weak` delegate on
    the input stream or output stream. This presents problems when using an inline
    class to provide input parsing; doing so will result in an `EXC_BAD_ACCESS` as
    the delegate is automatically reclaimed by the runtime. This can be avoided by
    storing a strong circular reference to `self` in the initializer and assigning
    it to `nil` when the streams are closed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Swift时，`NSStreamDelegate`在输入流或输出流上被视为一个`weak`代理。当使用内联类提供输入解析时，这会引发问题；这样做会导致`EXC_BAD_ACCESS`，因为代理会被运行时自动回收。这可以通过在初始化器中存储对`self`的强循环引用并在流关闭时将其赋值为`nil`来避免。
- en: Reading data asynchronously from an NSInputStream
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从NSInputStream异步读取数据
- en: This is especially useful for asynchronous protocols, such as XMPP, which may
    send additional messages at arbitrary times. It also allows battery-powered devices
    to not spin the CPU if the remote server is slow or hangs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于异步协议特别有用，例如XMPP，它可能在任意时间发送额外的消息。这也允许电池供电的设备在远程服务器慢或挂起时不需要旋转CPU。
- en: To receive data asynchronously, a delegate must implement the `NSStreamDelegate`
    method `stream(stream:handleEvent)`. When data is available, the `HasBytesAvailable`
    event will be sent, and data can be read accordingly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步接收数据，代理必须实现`NSStreamDelegate`方法`stream(stream:handleEvent)`。当数据可用时，会发送`HasBytesAvailable`事件，然后可以相应地读取数据。
- en: 'To convert the previous example to an asynchronous form, a few changes need
    to be made. Firstly, the `open` extension method that was created in *Opening
    a stream connection* section needs to be augmented with a `connect` method, but
    which does not perform the `open` immediately:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将之前的示例转换为异步形式，需要做一些更改。首先，在*打开流连接*部分创建的`open`扩展方法需要增加一个`connect`方法，但不立即执行`open`：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to receive events asynchronously, the delegate must be set and the
    stream must be scheduled on a run loop before the stream is opened.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了异步接收事件，必须在流打开之前设置代理并将流调度到运行循环中。
- en: Creating a stream delegate
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建流代理
- en: 'To create a stream delegate, create a file called `PacketLineParser.swift`
    with the following content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个流代理，创建一个名为`PacketLineParser.swift`的文件，并包含以下内容：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This parser has a callback, which is invoked for each packet line read; when
    the `HasBytesAvailable` event is sent, the line is read (using the same synchronous
    mechanism as before) and then passed to the callback. Unlike the synchronous approach,
    there is no `while` loop here—when data is available, it triggers the parsing
    of the data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此解析器有一个回调，对于读取的每个数据包行都会被调用；当发送`HasBytesAvailable`事件时，行会被读取（使用与之前相同的同步机制）然后传递给回调。与同步方法不同，这里没有`while`循环——当数据可用时，它触发数据的解析。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As this will be assigned to an input stream delegate (which holds a weak reference),
    it is necessary to capture a cyclic reference to itself with `capture = self`
    in order to avoid the runtime from evicting the instance. When the streams are
    closed, the `capture` will be set to `nil`, which will release the instance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将分配给一个输入流代理（它持有弱引用），因此需要使用 `capture = self` 来捕获自身的循环引用，以避免运行时从实例中移除。当流关闭时，`capture`
    将被设置为 `nil`，从而释放实例。
- en: The `readPacketLine` returns `nil` to indicate either an error or a completed
    stream; in this case, an empty packet line is sent (to tell the remote server
    that no further interaction is required), and then both streams are closed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`readPacketLine` 返回 `nil` 以指示错误或完成的流；在这种情况下，发送一个空的数据包行（以告知远程服务器不需要进一步交互），然后关闭两个流。'
- en: Dealing with errors
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误
- en: It is necessary to clean up the streams and remove them from run loops, both
    when the stream content is successful and when communication errors occur. In
    addition to the `HasBytesAvailable` event, there are also events that are sent
    when the stream's end is encountered or an error occurs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在流内容成功和发生通信错误时，都需要清理流并将它们从运行循环中移除。除了 `HasBytesAvailable` 事件外，还有在遇到流的末尾或发生错误时发送的事件。
- en: These should be handled in the same way as when the connection comes to a natural
    end; resources should be tidied, and in particular, the streams should be removed
    from run loop processing. Finally, the cyclic reference should be removed to permit
    the `delegate` object to be removed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该以连接自然结束时相同的方式进行处理；资源应该被整理，特别是流应该从运行循环处理中移除。最后，应该移除循环引用，以便可以移除 `delegate`
    对象。
- en: 'The existing `close` code can be moved to its own separate function, and additional
    cases of the stream ending or errors occurring can perform the same cleanup:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将现有的 `close` 代码移动到它自己的单独函数中，并且当流结束或发生错误时，可以执行相同的清理操作：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Listing references asynchronously
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步列出引用
- en: To provide a list of references asynchronously, the delegate has to be set up
    with a suitable callback that will parse the returned data. Instead of the method
    returning a dictionary (which would require synchronous blocking), a callback
    will be passed, which can be called with references as they are found.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步提供引用列表，代理需要设置一个合适的回调来解析返回的数据。而不是方法返回一个字典（这将需要同步阻塞），将传递一个回调，可以在找到引用时调用。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please note that there are two separate callbacks: the `PacketLineParser` callback
    (which reads in network data and returns `NSString` instances on a per-packet-line
    basis), and the reference parsing callback (which translates the `NSString` into
    a `(String,String)` tuple).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有两个独立的回调：`PacketLineParser` 回调（它读取网络数据，并在每个数据包行的基础上返回 `NSString` 实例），以及引用解析回调（它将
    `NSString` 转换为 `(String,String)` 元组）。
- en: 'To start the process, the `git-upload-pack` needs to be sent synchronously
    after which subsequent responses will be processed asynchronously. This can be
    done by creating a new method, `lsRemoteAsync`, in the `RemoteGitRepository` class,
    which takes a callback function for the `(String,String)` tuple:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，需要在同步发送 `git-upload-pack` 之后异步处理后续响应。这可以通过在 `RemoteGitRepository` 类中创建一个新的方法
    `lsRemoteAsync` 来实现，该方法接受一个用于 `(String,String)` 元组的回调函数：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This creates a connection (but without opening the streams), sets the `delegate`,
    and schedules the run loop for the input stream, and finally, opens both streams
    for interaction. Once this is done, the initial `git-upload-pack` message is sent
    as before. At this point the `lsRemoteAsync` method returns, and subsequent events
    occur when input data is received from the server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个连接（但不会打开流），设置 `delegate`，并为输入流安排运行循环，最后打开两个流以进行交互。完成这些操作后，就像之前一样发送初始的
    `git-upload-pack` 消息。此时，`lsRemoteAsync` 方法返回，随后在从服务器接收到输入数据时发生后续事件。
- en: When a line is received through the `PacketLineParser` callback, it is split
    into a reference and a hash and then hands the results to the callback passed
    into the argument in the first place.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 `PacketLineParser` 回调接收到一行时，它将被分割成一个引用和一个哈希值，然后把结果交给最初在参数中传入的回调。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Asynchronous programming often involves many callbacks. Instead of a synchronous
    program that may look like `A;B;C;`, an asynchronous program often looks like
    `A(callback:B(callback:C))`. When an input trigger occurs—a network request, user
    interaction, or timer firing—a sequence of actions can occur via these nested
    callbacks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程通常涉及许多回调。与看起来像 `A;B;C;` 的同步程序不同，异步程序通常看起来像 `A(callback:B(callback:C))`。当发生输入触发——网络请求、用户交互或定时器触发时，可以通过这些嵌套回调发生一系列操作。
- en: Asynchronous pipelines are generally preferred for battery performance reasons
    as blocking in a `while` spin loop will waste CPU energy until the condition is
    satisfied.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 `while` 循环中阻塞会浪费 CPU 能量直到条件满足，因此出于电池性能的原因，通常更喜欢异步管道。
- en: Displaying asynchronous references in the UI
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 UI 中显示异步引用
- en: To display the asynchronous data to the screen, the callback must be modified
    to allow individual elements to update the GUI.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示异步数据，必须修改回调以允许单个元素更新 GUI。
- en: 'In `SampleTable`, instead of calling `repo.lsRemote` (which performs a synchronous
    lookup), use `repo.lsRemoteAsync` instead. This requires a callback, which can
    be used to update the table data and causes the view to reload the contents:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SampleTable` 中，不要调用 `repo.lsRemote`（它执行同步查找），而应使用 `repo.lsRemoteAsync`。这需要一个回调，它可以用来更新表格数据并导致视图重新加载内容：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now when the application is run, the references will be updated asynchronously
    and the UI will not be blocked by a slow or hung server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，引用将被异步更新，UI 不会被缓慢或挂起的服务器阻塞。
- en: Writing data asynchronously to an NSOutputStream
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据异步写入 NSOutputStream
- en: Asynchronous sending is not as useful as asynchronous reading unless large uploads
    are required. If there is a lot of data, then it is unlikely to be written synchronously
    in a single `write` call. It is better to perform any additional writes asynchronously.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除非需要大文件上传，否则异步发送不如异步读取有用。如果有大量数据，那么在单个 `write` 调用中不太可能同步写入。最好异步执行任何额外的写入。
- en: 'To write data asynchronously requires storing the `completed` count as a variable
    outside of the function. The `write` method can be used to replace the `while`
    loop as before by writing a segment of the data on each iteration of the stream
    method. Although the code isn''t needed in this example, code would look something
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步写入数据，需要将 `completed` 计数存储为函数外的变量。`write` 方法可以用来替换之前的 `while` 循环，通过在流方法的每次迭代中写入数据的一个片段。尽管在这个例子中不需要代码，代码可能看起来像这样：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Asynchronous data always starts with a call to synchronously write the data.
    If not all of the data is written (in other words, `completed < size`) then subsequent
    callbacks will occur on the `NSStreamDelegate`. This can then pick up where the
    `data` value left off using a similar technique to the synchronous case but without
    a `while` loop. Instead of the iteration blocking to write the whole data value,
    the stream call will be called multiple times (in effect replacing each iteration
    of the `while` loop). On the final run, when `completed == size`, the data is
    released, and the completion counter is reset.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 异步数据始终以同步写入数据的调用开始。如果并非所有数据都被写入（换句话说，`completed < size`），则后续回调将在 `NSStreamDelegate`
    上发生。然后可以使用与同步情况类似的技术来继续 `data` 值，但不使用 `while` 循环。而不是迭代阻塞以写入整个数据值，流调用将被多次调用（实际上替换了
    `while` 循环的每次迭代）。在最后一次运行时，当 `completed == size` 时，数据被释放，完成计数器被重置。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The stream callback is called enough times to write all the data. If no data
    is written, then events are no longer called. New data is only written when an
    additional value is passed. Care must be taken when writing data from different
    threads as the data value is processed as an instance variable, and overwriting
    it may cause data to be lost. The reader is invited to extend the single element
    data into an array of outstanding data elements so that they can be queued up
    appropriately.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 流回调被调用足够多次以写入所有数据。如果没有数据被写入，则事件不再被调用。只有当传递了额外的值时，才会写入新数据。在从不同线程写入数据时必须小心，因为数据值被处理为一个实例变量，覆盖它可能会导致数据丢失。读者被邀请将单个元素数据扩展到未完成数据元素的数组中，以便它们可以适当地排队。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented the common techniques that are used to deal with networked
    data in Swift-based applications with a particular focus on how to maximize battery
    usage on portable devices using asynchronous techniques to access data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在基于Swift的应用程序中处理网络数据时常用的技术，特别关注如何使用异步技术访问数据来最大化便携设备的电池使用。
- en: As most network requests are likely to provide either a JSON or XML-based representation
    over HTTP(S), the first section of this chapter covered using `NSURLSession` and
    the asynchronous `dataTask` operations to pull data down from a remote server.
    The second and third sections then presented how this data can be parsed from
    either JSON or XML depending on the format required.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数网络请求很可能会通过HTTP(S)提供基于JSON或XML的表示，本章的第一节涵盖了使用`NSURLSession`和异步的`dataTask`操作从远程服务器拉取数据。然后第二和第三部分介绍了如何根据所需格式从JSON或XML中解析这些数据。
- en: 'The last section presented how to make network connections directly to deal
    with protocols other than HTTP; and as an example, showed how a remote `git` command
    can be executed to find out what references are available in a remote git repository.
    This was presented in two forms: as a synchronous API (to demonstrate the technique
    of how to work with streams, and to explain the git protocol), followed by its
    conversion to an asynchronous API, which can be used to minimize CPU cycles and,
    thus, battery usage, to allow other such translations to be performed in the future.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节展示了如何直接建立网络连接来处理除HTTP之外的协议；作为一个例子，展示了如何执行远程`git`命令以找出远程git仓库中可用的引用。这以两种形式呈现：首先作为一个同步API（以展示如何与流一起工作的技术，并解释git协议），然后转换为异步API，这可以用来最小化CPU周期，从而降低电池使用，以便将来执行其他此类转换。
- en: The next chapter will present how to integrate all of the ideas covered in this
    book into an iOS application to display GitHub repositories.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示如何将本书中涵盖的所有想法整合到一个iOS应用程序中，以显示GitHub仓库。
