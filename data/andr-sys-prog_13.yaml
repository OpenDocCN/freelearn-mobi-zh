- en: Creating OTA Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建OTA包
- en: 'In the last chapter, we analyzed the internals of recovery and learnt how it
    works. As we saw, one of the major functionalities of recovery is to support OTA
    update. In this chapter, we will look at the OTA package and study the process
    of the OTA package update. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们分析了恢复的内部结构，并学习了它是如何工作的。正如我们所见，恢复的主要功能之一是支持OTA更新。在本章中，我们将研究OTA包，并研究OTA包更新的过程。我们将涵盖以下主题：
- en: We will look at what is inside an OTA package. We will study the internals of
    `updater` and `updater-script`.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将查看OTA包内部的内容。我们将研究`updater`和`updater-script`的内部结构。
- en: We will learn the process about how to build an OTA package.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何构建OTA包的过程。
- en: Finally, we need to improve recovery to remove the dependencies from the Android
    system.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要改进恢复以从Android系统中移除依赖。
- en: What is inside an OTA package
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OTA包内部有什么
- en: Before we start to build an OTA package, let's look at what's inside an OTA
    package. The OTA package can be used to update the system to a new release. The
    new release can be a major release or a minor release. For example, it could be
    a minor update to the existing Android version to fix critical issues or security
    flaws. It could also be the major update from Android 6 to Android 7\. Let's look
    at the content of the OTA package that we are going to create in this chapter
    to find out what is inside an OTA package. The OTA package that we are going to
    create in this chapter is an OTA update package of our entire ROM. We can use
    recovery to flash the OTA package to our VirtualBox device. This is another way
    to install the system image that we build to the virtual device.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建OTA包之前，让我们看看OTA包内部的内容。OTA包可以用来将系统更新到新版本。新版本可以是主要版本或次要版本。例如，它可能是对现有Android版本的小幅更新，以修复关键问题或安全漏洞。它也可能是从Android
    6到Android 7的主要更新。让我们看看本章将要创建的OTA包的内容，以了解OTA包内部有什么。本章将要创建的OTA包是我们整个ROM的OTA更新包。我们可以使用恢复来将OTA包刷入我们的VirtualBox设备。这是将我们构建的系统镜像安装到虚拟设备上的另一种方法。
- en: 'Let''s look at the content of the OTA package that we will build in this chapter.
    The OTA package itself is a ZIP file. After we extract the ZIP file, we can list
    the content of the ZIP file as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章将要构建的OTA包的内容。OTA包本身是一个ZIP文件。在我们解压ZIP文件后，我们可以列出ZIP文件的内容如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can see that it includes two files and three folders. After we flash this
    update package using recovery, it will update the `/boot` partition and the `/system`
    partition:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它包括两个文件和三个文件夹。在我们使用恢复刷写这个更新包后，它将更新`/boot`分区和`/system`分区：
- en: '`boot.img`: The image of the `/boot` partition, which includes kernel and ramdisk.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot.img`: 这是`/boot`分区的镜像，其中包含内核和ramdisk。'
- en: '`file_contexts`: This file is used to assign labels to files according to SELinux
    policy. SELinux is enabled by default in the latest Android system. After the
    recovery updates the system partition, it must apply labels using this file.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts`: 此文件用于根据SELinux策略为文件分配标签。SELinux在最新的Android系统中默认启用。在恢复更新系统分区后，它必须使用此文件应用标签。'
- en: '`META-INF`: This folder includes the signature of the OTA package, the updater,
    and updater script. We will look at the details of this folder later.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`META-INF`: 这个文件夹包含OTA包、更新程序和更新脚本的签名。我们将在稍后查看这个文件夹的详细信息。'
- en: '`recovery`: This folder includes an `install-recovery.sh` shell script and
    a `recovery-from-boot.p` patch file.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recovery`: 这个文件夹包含一个`install-recovery.sh`shell脚本和一个`recovery-from-boot.p`补丁文件。'
- en: '`system`: This is the `system` folder that recovery will update to the `/system`
    partition.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system`: 这是恢复将要更新到`/system`分区的`system`文件夹。'
- en: 'OTA packages are usually used to update `/boot` and `/system` partitions. It
    does not update itself. The update of the `/recovery` partition is in the normal
    boot up process. During the boot up, the init will execute `install-recovery.sh`
    in the `init.rc` script through the following `flash_recovery` service:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OTA包通常用于更新`/boot`和`/system`分区。它不会更新自身。`/recovery`分区的更新在正常的启动过程中进行。在启动过程中，init将通过以下`flash_recovery`服务在`init.rc`脚本中执行`install-recovery.sh`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `install-recovery.sh` script installs recovery using the `recovery-from-boot.p`
    patch file as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`install-recovery.sh`脚本使用`recovery-from-boot.p`补丁文件安装恢复，如下所示：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our environment setup, the `/recovery` partition is in the `/dev/block/sda7`
    partition. This script will check the `sha1` hash of the `/dev/block/sha7` partition.
    If the `sha1` hash value is not the same, it will update the `/recovery` partition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的环境设置中，`/recovery`分区位于`/dev/block/sda7`分区。此脚本将检查`/dev/block/sha7`分区的`sha1`哈希值。如果`sha1`哈希值不同，它将更新`/recovery`分区。
- en: 'Now let''s look at the `META-INF` folder, as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看下面的截图所示的`META-INF`文件夹：
- en: '![](img/image_13_001.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_13_001.png)'
- en: As we can see, the signature of the update package, updater, and updater script
    are included in the `META-INF` folder. Before the recovery applies the update,
    it will verify the package signature in the `META-INF` folder against the trusted
    certificates at `/system/etc/security/otacerts.zip`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，更新包、更新器和更新脚本的签名包含在`META-INF`文件夹中。在恢复应用更新之前，它将验证`META-INF`文件夹中的包签名与`/system/etc/security/otacerts.zip`中的受信任证书。
- en: The updater is an executable at `META-INF/com/google/android/update-binary`.
    It interprets a script in the `META-INF/com/google/android/updater-script` file.
    The script is written in an extensible scripting language (edify) that supports
    commands for typical update related tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更新器位于`META-INF/com/google/android/update-binary`的可执行文件。它解释`META-INF/com/google/android/updater-script`文件中的脚本。该脚本是用一种可扩展的脚本语言（edify）编写的，支持典型更新相关任务的命令。
- en: Since the updater and the updater script are the key components in the OTA package
    to support an OTA update, we will look into the details of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更新器和更新脚本是在OTA包中支持OTA更新的关键组件，我们将深入了解它们的细节。
- en: Updater
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新器
- en: 'updater is an individual executable for the target device in the AOSP source
    tree. It can be found in the `$AOSP/bootable/recovery/updater` folder. Let''s
    look at the main function in the `updater.cpp` file. Since the `main` function
    is a little long, let''s look at it in several paragraphs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更新器是AOSP源树中针对目标设备的单个可执行文件。它可以在`$AOSP/bootable/recovery/updater`文件夹中找到。让我们看看`updater.cpp`文件中的主函数。由于`main`函数比较长，我们将分几个段落来看：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The updater has four arguments. The first thing it will do is check whether
    there are four arguments passed to it. As we can see from the code, these four
    arguments are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更新器有四个参数。它首先会检查是否传入了四个参数。从代码中我们可以看到，这四个参数是：
- en: The first argument is the executable name, which is `update-binary` here
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是可执行文件名，在这里是`update-binary`
- en: The second argument is the updater version
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是更新器版本
- en: The third argument is the pipe that can be used to communicate to the recovery
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是可以用来与恢复进行通信的管道
- en: The fourth argument is the OTA package path
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是OTA包的路径
- en: 'It will check the updater version before it continues:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，它将检查更新器版本：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next thing to do is to open the pipe to establish the communication channel
    with recovery. Then it extracts `updater-script` from the OTA package to prepare
    for the execution of the script:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是打开管道以建立与恢复的通信通道。然后它从OTA包中提取`updater-script`以准备执行脚本：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before it can start to execute the update script, it needs to register functions
    to interpret edify language inside the update script. As we can see from the preceding
    code, these functions include the following four categories:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始执行更新脚本之前，它需要注册函数以解释更新脚本内部的edify语言。从前面的代码中我们可以看到，这些函数包括以下四个类别：
- en: Built-in functions to support the edify language syntax. These functions are
    implemented in `bootable/recovery/edify/expr.cpp`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数以支持edify语言语法。这些函数在`bootable/recovery/edify/expr.cpp`中实现。
- en: Package installation related functions. These functions are implemented in `bootable/recovery/updater/install.cpp`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与包安装相关的函数。这些函数在`bootable/recovery/updater/install.cpp`中实现。
- en: 'Functions to handle block-based OTA packages. In Android 4.4 and earlier versions,
    the file-based OTA updates are used. In Android 5.0 and later versions, the block-based
    OTA updates are used. Refer to the following URL about file versus block OTAs:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基于块OTA包的函数。在Android 4.4及更早版本中，使用基于文件的OTA更新。在Android 5.0及以后版本中，使用基于块的OTA更新。有关文件与块OTA的比较，请参阅以下URL：
- en: '[https://source.android.com/devices/tech/ota/block.html](https://source.android.com/devices/tech/ota/block.html)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://source.android.com/devices/tech/ota/block.html](https://source.android.com/devices/tech/ota/block.html)'
- en: The block-based functions are implemented in `bootable/recovery/updater/blockimg.cpp`.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于块的函数在`bootable/recovery/updater/blockimg.cpp`中实现。
- en: The developers can extend recovery and updater to provide device-specific OTA
    extensions.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以扩展恢复和更新器以提供特定设备的 OTA 扩展。
- en: After it registers all functions, it calls the `parse_string` function to parse
    the script. Finally, it calls the `Evaluate` function to execute the script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册所有函数后，它调用 `parse_string` 函数来解析脚本。最后，它调用 `Evaluate` 函数来执行脚本。
- en: The updater script
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新器脚本
- en: 'After we explore the implementation of updater, we will look at the updater
    script in this section. The updater script is the one that performs the update
    operations in the target device. The updater script is written in a simple script
    language called edify. An edify script is a list of expressions, one expression
    per line. It supports the following operators:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索更新器的实现之后，我们将在本节中查看更新器脚本。更新器脚本是在目标设备上执行更新操作的那个脚本。更新器脚本是用一种简单的脚本语言 edify
    编写的。edify 脚本是一系列表达式，每行一个表达式。它支持以下运算符：
- en: The comparison operators, such as `==` (string equal) and `!=` (string not equal)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符，例如 `==`（字符串相等）和 `!=`（字符串不等）
- en: The logical operators, such as `||` (logical or), `&&` (logical and), and `!`
    (logical not)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符，例如 `||`（逻辑或）、`&&`（逻辑与）和 `!`（逻辑非）
- en: The concatenation operator `+`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接运算符 `+`
- en: The only reserved keywords are conditional keywords `if`, `then`, `else`, and
    `endif`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的保留关键字是条件关键字 `if`、`then`、`else` 和 `endif`。
- en: All values in edify are strings. Empty strings are `false` in a Boolean context
    and all other strings are `true`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: edify 中的所有值都是字符串。在布尔上下文中，空字符串为 `false`，所有其他字符串为 `true`。
- en: 'You can refer to the following URL to learn more about edify syntax:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下 URL 了解 edify 语法的更多信息：
- en: '[https://source.android.com/devices/tech/ota/inside_packages](https://source.android.com/devices/tech/ota/inside_packages)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://source.android.com/devices/tech/ota/inside_packages](https://source.android.com/devices/tech/ota/inside_packages)'
- en: Edify functions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Edify 函数
- en: The major functionalities of the edify language are implemented as edify functions
    and the edify functions are registered in the preceding updater source code. To
    support the OTA update, the edify functions include built-in functions, installation
    functions, block image functions, and device extensions. We will look at each
    category in the following sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: edify 语言的主体功能以 edify 函数的形式实现，而 edify 函数则注册在先前的更新器源代码中。为了支持 OTA 更新，edify 函数包括内置函数、安装函数、块镜像函数和设备扩展。我们将在接下来的几节中查看每个类别。
- en: Built-in functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: 'The built-in functions are used to support edify language syntax. The built-in
    functions are registered by `RegisterBuiltins`. We can look at the following source
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数用于支持 edify 语言语法。内置函数通过 `RegisterBuiltins` 注册。我们可以查看以下源代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `RegisterBuiltins` function registers the following built-in functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterBuiltins` 函数注册以下内置函数：'
- en: '`ifelse(cond, e1[, e2])`: Evaluates `cond`, and if it is true it evaluates
    and returns the value of `e1`, otherwise it evaluates and returns `e2` (if present).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifelse(cond, e1[, e2])`: 评估 `cond`，如果为 true，则评估并返回 `e1` 的值，否则评估并返回 `e2`（如果存在）。'
- en: '`abort([msg])`: Aborts execution of the script immediately, with the optional
    `msg`. If the user has turned on text display, `msg` appears in the recovery log
    and on screen.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort([msg])`: 立即终止脚本的执行，可选的 `msg` 参数。如果用户已开启文本显示，`msg` 将出现在恢复日志和屏幕上。'
- en: '`assert(expr[, expr, ...])`: Evaluates each `expr` in turn. If any is false,
    it immediately aborts execution with the message `assert failed`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert(expr[, expr, ...])`: 依次评估每个 `expr`。如果其中任何一个为 false，则立即终止执行并显示消息 `assert
    failed`。'
- en: '`concat(expr[, expr, ...])`: Evaluates each expression and concatenates them.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat(expr[, expr, ...])`: 评估每个表达式并将它们连接起来。'
- en: '`is_substring(substring, string)`: Returns true if a substring can be found.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_substring(substring, string)`: 如果可以找到子字符串，则返回 true。'
- en: '`stdout(expr[, expr, ...])`: Evaluates each expression and dumps its value
    to `stdout`. This is useful for debugging.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout(expr[, expr, ...])`: 评估每个表达式并将它们的值输出到 `stdout`。这在调试中非常有用。'
- en: '`sleep(secs)`: Sleeps for `secs` seconds.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep(secs)`: 等待 `secs` 秒。'
- en: '`less_than_int(a, b)`: Returns true if and only if `a` (interpreted as an integer)
    is less than `b` (interpreted as an integer).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less_than_int(a, b)`: 如果且仅当 `a`（解释为整数）小于 `b`（解释为整数）时返回 true。'
- en: '`greater_than_int(a, b)`: Returns true if and only if `a` (interpreted as an
    integer) is greater than `b` (interpreted as an integer).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`greater_than_int(a, b)`: 如果且仅当 `a`（解释为整数）大于 `b`（解释为整数）时返回 true。'
- en: Installation functions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装函数
- en: 'The installation-related functions are registered by `RegisterInstallFunctions`.
    The following is the source code of it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与安装相关的函数通过 `RegisterInstallFunctions` 注册。以下是其源代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see, most functions are registered here; we will now have a look
    at them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，大多数函数都注册在这里；我们现在将查看它们：
- en: '`mount(fs_type, partition_type, name, mount_point)`: This function mounts a
    filesystem of `fs_type` at `mount_point`. The `partition_type` argument must be
    one of MTD or EMMC. The `name` argument is the name of a partition (system, userdata
    or cache, and so on). Recovery does not mount any filesystems by default and the
    updater script must mount any partitions it needs to modify.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mount(fs_type, partition_type, name, mount_point)`: 此函数在 `mount_point` 处挂载
    `fs_type` 文件系统。`partition_type` 参数必须是 MTD 或 EMMC 之一。`name` 参数是分区名称（系统、userdata
    或 cache 等）。恢复默认不挂载任何文件系统，更新脚本必须挂载它需要修改的任何分区。'
- en: '`is_mounted(mount_point)`: Returns true if there is a filesystem mounted at
    `mount_point`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_mounted(mount_point)`: 如果在 `mount_point` 处挂载了文件系统，则返回 true。'
- en: '`unmount(mount_point)`: Unmounts the filesystem mounted at `mount_point`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unmount(mount_point)`: 卸载在 `mount_point` 处挂载的文件系统。'
- en: '`format(fs_type, partition_type, location, fs_size, mount_point)`: This function
    formats a given partition. The `fs_type` argument can be yaffs2, ext4, or f2fs.
    The `partition_type` argument can be MTD or EMMC. The `location` argument is either
    the name of the partition or device. The `fs_size` argument is the filesystem
    size and `mount_point` is the mount point name.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format(fs_type, partition_type, location, fs_size, mount_point)`: 此函数格式化给定的分区。`fs_type`
    参数可以是 yaffs2、ext4 或 f2fs。`partition_type` 参数可以是 MTD 或 EMMC。`location` 参数是分区或设备的名称。`fs_size`
    参数是文件系统大小，`mount_point` 是挂载点名称。'
- en: '`show_progress(frac, secs)`: Advances the progress meter over the next `frac`
    of its length over the `secs` seconds. The `secs` argument may be zero, in which
    case the meter is not advanced automatically, but by the use of the `set_progress`
    function defined as follows:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show_progress(frac, secs)`: 在 `secs` 秒内将进度条向前推进到其长度的 `frac` 部分。`secs` 参数可以是零，在这种情况下，进度条不会自动前进，而是通过以下定义的
    `set_progress` 函数使用：'
- en: '`set_progress(frac)`: This function sets the position of the progress meter
    within the chunk defined by the most recent `show_progress` call.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_progress(frac)`: 此函数设置进度条在最近一次 `show_progress` 调用定义的块中的位置。'
- en: '`delete([filename, ...])`: Deletes all the filenames listed. Returns the number
    of files successfully deleted.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete([filename, ...])`: 删除列出的所有文件名。返回成功删除的文件数量。'
- en: '`delete_recursive([dirname, ...])`: Recursively deletes `dirname` and all their
    contents. Returns the number of directories successfully deleted.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_recursive([dirname, ...])`: 递归删除 `dirname` 及其所有内容。返回成功删除的目录数量。'
- en: '`package_extract_dir(package_dir, dest_dir)`: Extracts all files from the package
    underneath `package_dir` and writes them to the corresponding tree beneath `dest_dir`.
    Any existing files are overwritten.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package_extract_dir(package_dir, dest_dir)`: 从 `package_dir` 下的包中提取所有文件，并将它们写入
    `dest_dir` 下的相应树中。任何现有文件都将被覆盖。'
- en: '`package_extract_file(package_file[, dest_file])`: Extracts a single `package_file`
    from the `update` package and writes it to `dest_file`, overwriting existing files
    if necessary.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package_extract_file(package_file[, dest_file])`: 从 `update` 包中提取单个 `package_file`
    并将其写入 `dest_file`，如果需要则覆盖现有文件。'
- en: '`symlink(target[, source, ...])`: Creates all sources as symlinks to target.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symlink(target[, source, ...])`: 将所有源创建为指向目标的符号链接。'
- en: '`set_metadata(filename, key1, value1[, key2 , value2, ...])`: Sets the keys
    of the given filename to values.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_metadata(filename, key1, value1[, key2, value2, ...])`: 将给定文件名的键设置为值。'
- en: '`set_metadata_recursive(dirname, key1, value1[, key2, value2, ...])`: Recursively
    sets the keys of the given `dirname` and all its children to values.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_metadata_recursive(dirname, key1, value1[, key2, value2, ...])`: 递归地将给定
    `dirname` 及其所有子目录的键设置为值。'
- en: '`getprop(key)`: Returns the value of the system property key (or the empty
    string, if it''s not defined).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getprop(key)`: 返回系统属性键的值（如果没有定义，则返回空字符串）。'
- en: '`file_getprop(filename, key)`: Reads the given filename, interprets it as a
    properties file (for example, `/system/build.prop`), and returns the value of
    the given key, or the empty string if the key is not present.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_getprop(filename, key)`: 读取给定的文件名，将其解释为属性文件（例如，`/system/build.prop`），并返回给定键的值，如果键不存在，则返回空字符串。'
- en: '`write_raw_image(filename_or_blob, partition)`: Writes the image in `filename_or_blob`
    to the MTD partition.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_raw_image(filename_or_blob, partition)`: 将 `filename_or_blob` 中的镜像写入
    MTD 分区。'
- en: '`apply_patch(src_file, tgt_file, tgt_sha1, tgt_size, patch1_sha1, patch1_blob,
    [...])`: Applies a binary patch to `src_file` to produce `tgt_file`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_patch(src_file, tgt_file, tgt_sha1, tgt_size, patch1_sha1, patch1_blob,
    [...])`: 将二进制补丁应用到 `src_file` 上以生成 `tgt_file`。'
- en: '`apply_patch_check(filename, sha1[, sha1, ...])`: Returns true if the contents
    of `filename` or the temporary copy in the cache partition (if present) have a
    SHA1 checksum equal to one of the given `sha1` values.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_patch_check(filename, sha1[, sha1, ...])`: 如果 `filename` 的内容或缓存分区中的临时副本（如果存在）的
    SHA1 校验和等于给定的 `sha1` 值之一，则返回 true。'
- en: '`apply_patch_space(bytes)`: Returns true if at least bytes of scratch space
    is available for applying binary patches.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_patch_space(bytes)`: 如果至少有 bytes 的临时空间可用于应用二进制补丁，则返回 true。'
- en: '`wipe_block_device(block_dev, len)`: Wipes the `len` bytes of the given block
    device, `block_dev`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wipe_block_device(block_dev, len)`: 清除给定块设备 `block_dev` 的 `len` 字节。'
- en: '`read_file(filename)`: Reads `filename` and returns its contents as a binary
    blob.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_file(filename)`: 读取 `filename` 并将其内容作为二进制块返回。'
- en: '`sha1_check(blob[, sha1])`: The `blob` argument is a blob of the type returned
    by `read_file` or the one-argument form of `package_extract_file`. With no `sha1`
    arguments, this function returns the SHA1 hash of the blob. With one or more `sha1`
    arguments, this function returns the SHA1 hash if it equals one of the arguments,
    or the empty string if it does not equal any of them.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha1_check(blob[, sha1])`: `blob` 参数是 `read_file` 返回的类型或 `package_extract_file`
    的一参数形式。如果没有 `sha1` 参数，此函数返回 blob 的 SHA1 哈希。如果有一个或多个 `sha1` 参数，此函数返回等于其中一个参数的 SHA1
    哈希，如果不等于任何一个参数，则返回空字符串。'
- en: '`rename(src_filename, tgt_filename)`: Renames `src_filename` to `tgt_filename`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename(src_filename, tgt_filename)`: 将 `src_filename` 重命名为 `tgt_filename`。'
- en: '`wipe_cache()`: Causes the cache partition to be wiped at the end of a successful
    installation.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wipe_cache()`: 在成功安装结束时清除缓存分区。'
- en: '`ui_print([text, ...])`: Concatenates all text arguments and prints the result
    to the UI.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui_print([text, ...])`: 连接所有文本参数并将结果打印到 UI。'
- en: '`run_program(path[, arg, ...])`: Executes the binary at `path` with arguments
    `arg`. Returns the program''s exit status.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_program(path[, arg, ...])`: 使用参数 `arg` 执行 `path` 上的二进制文件。返回程序的退出状态。'
- en: '`reboot_now(name[, arg, ...])`: Reboots the device immediately. The `name`
    argument is the partition name passed to the Android reboot property.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot_now(name[, arg, ...])`: 立即重启设备。`name` 参数是传递给 Android 重启属性的分区名称。'
- en: '`get_stage(name)`: This function returns the value saved by the `set_stage`
    function. The `name` argument is the block device for the `/misc` partition.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_stage(name)`: 此函数返回由 `set_stage` 函数保存的值。`name` 参数是 `/misc` 分区的块设备。'
- en: '`set_stage(name, stage)`: This function stores a string value that future invocations
    of recovery can access. The `name` argument is the block device for the `/misc`
    partition. The stage is the string to store.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_stage(name, stage)`: 这个函数存储一个字符串值，以便未来的恢复调用可以访问。`name` 参数是 `/misc` 分区的块设备。`stage`
    是要存储的字符串。'
- en: '`enable_reboot()`: Sends the `enable_reboot` command to recovery through the
    pipe.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_reboot()`: 通过管道发送 `enable_reboot` 命令到恢复。'
- en: '`tune2fs(arg, ...)`: Changes the filesystem parameters on an ext2/ext3 filesystem.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tune2fs(arg, ...)`: 在 ext2/ext3 文件系统上更改文件系统参数。'
- en: Block image functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块图像函数
- en: 'In Android 5.0 or above, the block-based OTA packages can be used. The block-based
    OTA packages treat the entire partition as a single file and update it at block
    level. The functions for block-based OTA packages are registered by the `RegisterBlockImageFunctions`
    function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 5.0 或更高版本中，可以使用基于块的 OTA 包。基于块的 OTA 包将整个分区视为单个文件，并在块级别进行更新。基于块的 OTA
    包的函数通过 `RegisterBlockImageFunctions` 函数注册：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The block-based update implementation includes three functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于块的更新实现包括三个函数：
- en: '`block_image_verify(partition, transfer_list, new, patch)`: The `partition`
    argument is the device that the update will do. Usually, it is the `/system` partition.
    The `transfer_list` argument is a text file containing commands to transfer data
    from one place to another on the `target` partition. This command only performs
    a dry run without writing to test if an update can proceed.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block_image_verify(partition, transfer_list, new, patch)`: `partition` 参数是更新将进行的设备。通常，它是
    `/system` 分区。`transfer_list` 参数是一个包含在 `target` 分区上从一个地方传输到另一个地方的命令的文本文件。此命令仅执行干运行，不写入，以测试更新是否可以继续。'
- en: '`block_image_update(partition, transfer_list, new, patch)`: This function is
    the same as `block_image_verify` except it performs the actual update.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block_image_update(partition, transfer_list, new, patch)`: 此函数与 `block_image_verify`
    相同，但它执行实际更新。'
- en: '`range_sha1(partition, range)`: This function checks the SHA1 hash of a partition
    in the specified range.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range_sha1(partition, range)`: 这个函数检查指定范围内的分区的SHA1哈希值。'
- en: Device extensions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备扩展
- en: 'As Android system developers, we can extend the edify language to meet our
    device-specific requirements. To extend the edify language with our own functions,
    we can register our functions using the following function call:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Android系统开发者，我们可以扩展edify语言以满足我们设备的特定需求。要使用我们自己的函数扩展edify语言，我们可以使用以下函数调用注册我们的函数：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will explain how to extend the edify language in the next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章解释如何扩展edify语言。
- en: Preparing an OTA package for x86vbox
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备x86vbox的OTA包
- en: 'We have understood updater and the updater script inside an OTA package so
    far. We can build an OTA package for our x86vbox device now. To build an OTA package,
    we can use the following commands:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了OTA包内的更新器和更新器脚本。现在我们可以为我们的x86vbox设备构建OTA包了。要构建OTA包，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The default OTA package build in Android 5 or above is to build the block-based
    OTA package, but we will get an error building block-based OTA packages for x86vbox.
    There are a lot more configurations that are needed to be done to support block-based
    OTA packages in our environment. All the third-party recovery packages cannot
    use block-based update packages as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Android 5及以上版本默认构建的OTA包是构建基于块的OTA包，但我们在为x86vbox构建基于块的OTA包时会遇到错误。在我们的环境中，还需要进行很多配置才能支持基于块的OTA包。所有第三方恢复包也无法使用基于块的更新包。
- en: 'To avoid this error, we need to change the following `build/core/Makefile`
    file to remove the `--block` option:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个错误，我们需要将以下`build/core/Makefile`文件更改为移除`--block`选项：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the build is completed, we can check the OTA package as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以按照以下方式检查OTA包：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take a look at the updater script inside the OTA package that we just
    built:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚构建的OTA包内的更新器脚本：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the updater script, it checks the build information of the current system
    first. If the current system is newer than the OTA package, it won't update the
    system. After that, it also checks the device name of the running system and the
    OTA package, both should match each other. Otherwise, we may update the system
    using a wrong OTA package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新器脚本中，它首先检查当前系统的构建信息。如果当前系统比OTA包新，则不会更新系统。之后，它还会检查运行系统的设备名称和OTA包，两者应该匹配。否则，我们可能会使用错误的OTA包来更新系统。
- en: After all verification work has been done, the script will format the `/system`
    partition and create a new `system` folder from the OTA package. Once the system
    files are installed, the script will create all necessary soft-links and apply
    properties for SELinux.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有验证工作后，脚本将格式化`/system`分区，并从OTA包中创建一个新的`system`文件夹。一旦系统文件安装完成，脚本将创建所有必要的软链接，并应用SELinux属性。
- en: Finally, it will update the `/boot` partition with a new kernel and ramdisk.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将使用新的内核和ramdisk更新`/boot`分区。
- en: Once we build the OTA package for the x86vbox device, and we also build recovery
    in [Chapter 12](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml), *Introducing Recovery*,
    we can update our system to the OTA package. We should be able to update the system
    using this OTA package, but the system may not be able to boot up at the moment.
    We have two issues that need to be resolved before we can do more.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为x86vbox设备构建了OTA包，并在[第12章](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml)“介绍恢复”中构建了恢复，我们就可以更新我们的系统到OTA包。我们应该能够使用这个OTA包来更新系统，但此时系统可能无法启动。在我们能够进行更多操作之前，我们有两个问题需要解决。
- en: 'Recalling how we built recovery for x86vbox, we reuse the source code that
    we developed from [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml), *Creating
    Your Own Device on VirtualBox,* to [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces* as much as possible. This means
    we inherited the following features in the recovery build in [Chapter 12](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml),
    *Introducing Recovery*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们为x86vbox构建恢复的过程，我们尽可能重用了从[第8章](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)“在VirtualBox上创建您的设备”到[第11章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)“启用VirtualBox特定硬件接口”中开发的源代码。这意味着我们在[第12章](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml)“介绍恢复”中构建的恢复中继承了以下功能：
- en: The first problem inherited from the two stages boot is that we use the components
    in the Android `system` folder to boot recovery. Ideally, the recovery should
    not depend on anything else. It should be a self-contained system. For example,
    the recovery should work properly, even though the system image is damaged. We
    can repair the system using recovery.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从两个阶段的启动继承的第一个问题是，我们使用 Android `system` 文件夹中的组件来启动恢复。理想情况下，恢复不应该依赖于其他任何东西。它应该是一个自包含的系统。例如，即使系统镜像损坏，恢复也应该能够正常工作。我们可以使用恢复来修复系统。
- en: We use the two stages boot process from the Android-x86 project. As we can see
    from the previous chapters, the system disk layout for a two stages boot is different
    from the standard Android system. The system that we create using the OTA package
    is the standard Android system disk layout. We can only use the standard boot
    process to boot the system after the OTA update. This means we have to boot the
    system using `ramdisk.img` instead of `initrd.img`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Android-x86 项目的两个阶段启动过程。正如我们从前几章中看到的那样，两个阶段启动的系统磁盘布局与标准 Android 系统不同。我们使用
    OTA 包创建的系统是标准的 Android 系统磁盘布局。我们只能在 OTA 更新后使用标准的启动过程来启动系统。这意味着我们必须使用 `ramdisk.img`
    而不是 `initrd.img` 来启动系统。
- en: Removing dependencies on /system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除对 /system 的依赖
- en: 'The dependencies to the Android `/system` folder include two parts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Android `/system` 文件夹的依赖包括两部分：
- en: 'All kernel modules for device drivers are located at: `$OUT/system/lib/modules/4.x.x-android-x86`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有设备驱动程序的内核模块都位于：`$OUT/system/lib/modules/4.x.x-android-x86`。
- en: 'We need to run some basic Linux commands during the recovery boot process.
    For example, we do hardware initialization using the following command:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恢复启动过程中，我们需要运行一些基本的 Linux 命令。例如，我们使用以下命令进行硬件初始化：
- en: '`on init exec -- /system/bin/logwrapper /system/bin/sh /system/etc/init.sh`'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`on init exec -- /system/bin/logwrapper /system/bin/sh /system/etc/init.sh`'
- en: Let's work on the preceding two points one by one in the following sections.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中逐一讨论前两点。
- en: Hardware initialization in recovery
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复中的硬件初始化
- en: To load the minimum device drivers needed by recovery, we have to change the
    execution of the shell script for Android system start. This is a customization
    process from general to specific, which is different from the goal of the Android-x86
    project. In the Android-x86 project, all possible device drivers are available,
    while we should only include the drivers needed by recovery for VirtualBox here.
    As we can see when we introduce a two stages boot, all possible device drivers
    are compiled and available in the `$OUT/system/lib/modules/4.x.x-android-x86`
    folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载恢复所需的最低限度的设备驱动程序，我们必须更改 Android 系统启动的 shell 脚本执行。这是一个从一般到具体的定制过程，这与 Android-x86
    项目的目标不同。在 Android-x86 项目中，所有可能的设备驱动程序都是可用的，而在这里我们只应该包含恢复所需的 VirtualBox 驱动程序。正如我们在介绍两个阶段启动时看到的那样，所有可能的设备驱动程序都在
    `$OUT/system/lib/modules/4.x.x-android-x86` 文件夹中编译并可用。
- en: 'The kernel modules will be loaded to the system depending on the hardware found
    by the kernel dynamically. In our case, we will remove the dynamically loading
    process and keep the minimum kernel modules only necessary for the recovery boot
    up. Let''s look at the original startup script for x86vbox:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块将根据内核动态找到的硬件加载到系统中。在我们的例子中，我们将移除动态加载过程，只保留恢复启动所必需的最小内核模块。让我们看看 x86vbox 的原始启动脚本：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: During the startup, the `init` process will run the preceding command line to
    execute the `/system/etc/init.sh` script. The commands `/system/bin/logwrapper`
    and `/system/bin/sh` are both part of the Android system in the `/system/bin`
    folder. They are not available to recovery, since the `/system` partition is not
    mounted after recovery boot up.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，`init` 进程将运行前面的命令行来执行 `/system/etc/init.sh` 脚本。`/system/bin/logwrapper`
    和 `/system/bin/sh` 命令都是 Android 系统中 `/system/bin` 文件夹的一部分。它们在恢复模式下不可用，因为恢复启动后没有挂载
    `/system` 分区。
- en: To resolve this issue, we will use the `busybox` binary in `initrd.img` to provide
    a minimum environment to execute Linux shell commands in recovery environments.
    We cannot execute the `/system/etc/init.sh` script either, since it is stored
    in the `/system/etc` folder, which is also not available to recovery. We will
    replace it by creating another script, `init.x86vbox.sh,` in `/sbin` in the recovery
    environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用 `initrd.img` 中的 `busybox` 二进制文件在恢复环境中提供一个最小的环境来执行 Linux shell
    命令。我们也不能执行 `/system/etc/init.sh` 脚本，因为它存储在 `/system/etc` 文件夹中，这个文件夹在恢复模式下也不可用。我们将通过在恢复环境中的
    `/sbin` 下创建另一个脚本 `init.x86vbox.sh` 来替换它。
- en: 'We changed `init.recovery.x86vbox.rc` to the following one to remove the dependency
    from `/system`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`init.recovery.x86vbox.rc`更改为以下内容以移除对`/system`的依赖：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: During the `early-init` stage, we create the soft-links to make `/bin/sh` available.
    We replaced `/system/bin/sh` with `/bin/sh` residing in recovery ramdisk.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`early-init`阶段，我们创建软链接以使`/bin/sh`可用。我们将`/system/bin/sh`替换为位于恢复ramdisk中的`/bin/sh`。
- en: 'In the `init.x86vbox.sh` script, we load the device drivers needed by recovery
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init.x86vbox.sh`脚本中，我们加载恢复所需的设备驱动程序如下：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, in the shell script `init.x86vbox.sh`, we created all soft-links
    for `busybox` first. Then, we loaded all necessary device drivers. We also mounted
    a shared folder of VirtualBox under the `/vendor` folder so that we can exchange
    data between the host and the guest. We will use this folder in the next chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在shell脚本`init.x86vbox.sh`中，我们首先创建了`busybox`的所有软链接。然后，我们加载了所有必要的设备驱动程序。我们还挂载了VirtualBox在`/vendor`文件夹下的共享文件夹，以便我们可以在主机和客户机之间交换数据。我们将在下一章中使用此文件夹。
- en: Minimum execution environment in recovery
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复时的最小执行环境
- en: As we can see from both scripts, `init.recovery.x86vbox.rc` and `init.x86vbox.sh`,
    we need to execute some Linux commands so that we can perform our tasks during
    the boot up process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从两个脚本中可以看出，`init.recovery.x86vbox.rc`和`init.x86vbox.sh`，我们需要执行一些Linux命令，以便我们可以在启动过程中执行我们的任务。
- en: We need to include all these Linux commands in `ramdisk-recovery.img` so that
    they are available to recovery. However, the problem is not as simple as we think
    so far. Most of the commands are dynamically linked instead of static linked in
    AOSP build output.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`ramdisk-recovery.img`中包含所有这些Linux命令，以便它们在恢复时可用。然而，问题并不像我们迄今为止所认为的那么简单。大多数命令在AOSP构建输出中是动态链接的，而不是静态链接的。
- en: 'In our case, we have two sets of shared libraries that we need to include in
    `ramdisk-recovery.img`. The `busybox` binary in `initrd.img` from Android-x86
    is prebuilt out of the AOSP tree, so they have their own dependencies. If we go
    to the `newinstaller` folder `bootable/newinstaller/initrd`, we can see the list
    of executable and shared libraries:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要在`ramdisk-recovery.img`中包含两套共享库。Android-x86中的`initrd.img`中的`busybox`二进制文件是从AOSP树中预构建的，因此它们有自己的依赖关系。如果我们转到`newinstaller`文件夹`bootable/newinstaller/initrd`，我们可以看到可执行文件和共享库的列表：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are eight shared libraries besides the `busybox` binary, as we can see
    in the preceding snippet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`busybox`二进制文件外，还有八个共享库，如前所述的片段所示。
- en: 'Besides `busybox`, we also have some executables that are built as part of
    the AOSP source tree. They have a different set of shared libraries, which need
    to be included in `ramdisk-recovery.img` as well. For example, the display `uvesafb`
    driver needs a user space daemon `/sbin/v86d`, which is built as part of the AOSP
    tree. Without a set of shared libraries in place, it won''t be able to work properly.
    To allow us to run these executable files, we need to include the following shared
    libraries in `ramdisk-recovery.img`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`busybox`外，我们还有一些作为AOSP源树一部分构建的可执行文件。它们有一组不同的共享库，这些库也需要包含在`ramdisk-recovery.img`中。例如，显示`uvesafb`驱动程序需要一个用户空间守护进程`/sbin/v86d`，它是作为AOSP树的一部分构建的。如果没有一组共享库，它将无法正常工作。为了使我们能够运行这些可执行文件，我们需要在`ramdisk-recovery.img`中包含以下共享库：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You may be wondering how to find the shared library dependencies. One way that
    we can do this is to get the linkage information using the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何找到共享库的依赖关系。我们可以通过以下命令获取链接信息的一种方法：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see from the preceding output, we can find the shared libraries needed
    by `/sbin/v86d` using the `readelf` command. We also need to verify the dependencies
    through the testing in the recovery environment, which we will discuss more in
    the next chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，我们可以使用`readelf`命令找到`/sbin/v86d`所需的共享库。我们还需要通过恢复环境中的测试来验证依赖关系，我们将在下一章中进一步讨论。
- en: 'To include all the discussed kernel modules and shared libraries in `ramdisk-recovery.img`,
    we changed a part of `x86vbox.mk` as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有讨论过的内核模块和共享库包含在`ramdisk-recovery.img`中，我们更改了`x86vbox.mk`的一部分，如下所示：
- en: '![](img/image_13_002.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_13_002.png)'
- en: Building and testing
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试
- en: After we have done all the analysis in this chapter, we can build and test our
    code now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章完成所有分析后，我们现在可以构建和测试我们的代码了。
- en: 'As usual, we have a manifest file for each chapter. We make changes for this
    chapter based on the source code of [Chapter 12](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml),
    *Introducing Recovery*. The following are the projects that we changed in this
    chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们为每一章都准备了一个清单文件。我们根据[第12章](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml)，“介绍恢复”的源代码对这一章进行了修改。以下是我们在这一章中更改的项目：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see that we need to change four projects: `recovery`, `newinstaller`,
    `common`, and `x86vbox`. We have an `android-7.1.1_r4_x86vbox_ch13_r1` tag as
    the baseline of the source code for this chapter.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们需要更改四个项目：`recovery`、`newinstaller`、`common`和`x86vbox`。我们有一个`android-7.1.1_r4_x86vbox_ch13_r1`标签作为本章源代码的基线。
- en: 'To get the source code from GitHub and AOSP directly, the following command
    can be used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要从GitHub和AOSP直接获取源代码，可以使用以下命令：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the source code is ready for use, we can set the environment and build
    the system as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码准备就绪后，我们可以设置环境并按照以下步骤构建系统：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To build `initrd.img`, we can run the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建`initrd.img`，我们可以运行以下命令：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To build the OTA package for the x86vbox device, we can run the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要为x86vbox设备构建OTA包，我们可以运行以下命令：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To test the AOSP images in VirtualBox, we need to use PXE boot and NFS as we
    introduced in [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml), *Booting
    Up x86vbox Using PXE/NFS*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要在VirtualBox中测试AOSP镜像，我们需要使用我们在[第9章](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml)，“使用PXE/NFS启动x86vbox”中介绍过的PXE引导和NFS。
- en: 'After the build is completed, we can add an entry in the PXE boot configuration
    file, `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`, as follows to test recovery:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以在PXE引导配置文件`$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`中添加一个条目，如下以测试恢复：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the recovery is started, we can see the following screen of recovery
    on the x86vbox device:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复启动后，我们可以在x86vbox设备上看到以下恢复屏幕：
- en: '![](img/image_13_003.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_13_003.png)'
- en: The user interface of recovery for x86vbox looks the same on any Android device.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: x86vbox的恢复用户界面在任何Android设备上看起来都一样。
- en: Before you download the source code and build everything by yourself, you can
    also download and test the pre-built image in this chapter at [https://sourceforge.net/projects/android-system-programming/files/android-7/ch13/ch13.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch13/ch13.zip/download).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在你下载源代码并自行构建所有内容之前，你也可以下载并测试本章中提供的预构建镜像，链接为[https://sourceforge.net/projects/android-system-programming/files/android-7/ch13/ch13.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch13/ch13.zip/download)。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt about the workflow of updater, which is the one actually
    to do the work of the OTA update. The updater interprets the updater script inside
    the OTA package to perform the update. We don't have to create the updater script
    by ourselves. It is created during the build process automatically. You may have
    some questions here, since you may use some recovery packages created by open
    source developers or ROM developers. You may even use recovery distributed by
    LineageOS/CyanogenMod or TWRP. How do they relate to the topics that we discussed
    in this chapter? These are the topics that we will cover in the next chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了更新器的流程，它是实际执行OTA更新工作的工具。更新器解释OTA包内的更新脚本以执行更新。我们不必自己创建更新脚本。它是在构建过程中自动创建的。你可能在这里有一些疑问，因为你可能使用了一些开源开发者或ROM开发者创建的恢复包。你甚至可能使用LineageOS/CyanogenMod或TWRP分发的恢复。它们与我们本章讨论的主题有何关联？这些是我们将在下一章中讨论的主题。
