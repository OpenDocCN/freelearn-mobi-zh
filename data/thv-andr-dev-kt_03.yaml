- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Setting Up WhatsPackt’s Messaging Abilities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置WhatsPackt的消息功能
- en: In the previous chapter, we created the structure and UI needed for our messaging
    app, WhatsPackt.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了所需的WhatsPackt消息应用的结构和UI。
- en: One of the core features of any messaging app is the ability to facilitate 1:1
    conversations between two users, so in this chapter, we will delve into the process
    of connecting our messaging app to a backend server using WebSockets, handling
    messages within `ViewModel` instances, and managing synchronization, error handling,
    and push notifications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消息应用的核心功能之一是能够促进两个用户之间的1:1对话，因此在本章中，我们将深入研究将我们的消息应用连接到后端服务器使用WebSocket的过程，处理`ViewModel`实例内的消息，以及管理同步、错误处理和推送通知。
- en: We will begin by exploring **WebSockets**, a powerful technology that enables
    bidirectional communication between client and server, providing a solid foundation
    for real-time messaging in your app. You will learn how to establish a WebSocket
    connection, send messages, and handle incoming messages from the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索**WebSocket**，这是一种强大的技术，它允许客户端和服务器之间进行双向通信，为你的应用中的实时消息提供坚实的基础。你将学习如何建立WebSocket连接，发送消息，并处理来自服务器的接收到的消息。
- en: Next, we will demonstrate how to receive messages in your **ViewModel**. We
    will discuss best practices for updating the UI, managing message storage, and
    handling user interactions, ensuring a smooth and responsive messaging experience
    for your users.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示如何在你的**ViewModel**中接收消息。我们将讨论更新UI、管理消息存储和处理用户交互的最佳实践，确保为用户提供流畅和响应式的消息体验。
- en: The chapter will also cover the essential aspects of synchronization and error
    handling. You will learn how to manage message delivery status, handle intermittent
    connectivity issues, and gracefully recover from errors, resulting in a resilient
    and reliable messaging system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将涵盖同步和错误处理的必要方面。你将学习如何管理消息投递状态，处理间歇性连接问题，并优雅地从错误中恢复，从而实现一个弹性可靠的消息系统。
- en: Finally, we will dig into the topic of push notifications, which are vital for
    alerting users of new messages even when the app is not in the foreground.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入探讨推送通知这一主题，这对于在应用不在前台时提醒用户新消息至关重要。
- en: By the end of this chapter, you will have gained a comprehensive understanding
    of the key components and technologies involved in creating a modern messaging
    app that supports 1:1 conversations using WebSockets and push notifications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面了解创建支持使用WebSocket和推送通知的1:1对话的现代消息应用所涉及的关键组件和技术。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Using a WebSocket connection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSocket连接
- en: Receiving messages in our **ViewModel**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的**ViewModel**中接收消息
- en: Handling synchronization and errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理同步和错误
- en: Adding push notifications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加推送通知
- en: Replacing the WebSocket with Firestore
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Firestore替换WebSocket
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，你需要安装Android Studio（或你偏好的其他编辑器）。
- en: 'We are also going to assume that you followed along with the previous chapter.
    If you haven’t, you can download the previous chapter’s complete code from here:
    [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设你已经跟随了上一章的内容。如果你还没有，你可以从这里下载上一章的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt).
- en: 'The code completed in this chapter can also be found at this link: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中完成的部分代码也可以在此链接中找到：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt).
- en: Using a WebSocket connection
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSocket连接
- en: As mentioned, WebSockets is a powerful technology that enables bidirectional
    communication between client and server. In this section, we are going to use
    a WebSocket connection to connect with our server to obtain and send messages.
    But before we do that, it is essential to understand the alternatives and the
    rationale behind choosing WebSockets for our messaging app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，WebSockets是一种强大的技术，它使客户端和服务器之间实现双向通信。在本节中，我们将使用WebSocket连接与我们的服务器连接，以获取和发送消息。但在我们这样做之前，了解替代方案以及选择WebSockets作为我们的消息应用的理由是至关重要的。
- en: Why WebSockets?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择WebSockets？
- en: 'There are several options for enabling real-time communication between clients
    and servers, including the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实现客户端和服务器之间实时通信有几种选择，包括以下几种：
- en: '**Long polling**: This is when the client sends a request to the server, and
    the server holds the request until new data is available. Once the server responds
    with the new data, the client sends another request, and the process repeats.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长轮询**: 这是指客户端向服务器发送请求，服务器在新的数据可用之前保持请求。一旦服务器用新数据响应，客户端发送另一个请求，然后这个过程重复。'
- en: '**Server-Sent Events (SSE)**: SSE is a unidirectional communication method
    where the server pushes updates to the client over a single HTTP connection.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器发送事件（SSE）**: SSE是一种单向通信方法，其中服务器通过单个HTTP连接向客户端推送更新。'
- en: '**Real-time cloud databases** (for example, Firebase Firestore): Real-time
    cloud databases provide an easy-to-use, scalable solution for real-time data synchronization.
    They automatically push updates to clients whenever data changes, making them
    suitable for messaging apps.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时云数据库**（例如，Firebase Firestore）：实时云数据库提供了一个易于使用、可扩展的解决方案，用于实时数据同步。它们在数据发生变化时自动向客户端推送更新，这使得它们适用于消息应用。'
- en: '**WebSockets**: WebSockets provide full-duplex, bidirectional communication
    between clients and servers over a single, long-lived connection. They are widely
    supported across platforms and are an ideal choice for real-time communication
    in messaging apps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSockets**: WebSockets提供客户端和服务器之间通过单一、持久连接的全双工、双向通信。它们在各个平台上得到广泛支持，是消息应用中实时通信的理想选择。'
- en: 'Considering these alternatives, we choose to use WebSockets for our messaging
    app because they offer the following advantages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些替代方案，我们选择在我们的消息应用中使用WebSockets，因为它们提供了以下优势：
- en: '**Bidirectional communication**: WebSockets enable simultaneous data transmission
    between clients and servers, allowing for faster message exchanges and a more
    responsive user experience'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向通信**: WebSockets允许客户端和服务器之间同时进行数据传输，从而实现更快的消息交换和更响应式的用户体验。'
- en: '**Low latency**: Unlike long polling, SSE, and some real-time cloud databases,
    WebSockets provide low-latency communication, which is crucial for a real-time
    messaging app'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低延迟**: 与长轮询、SSE和一些实时云数据库不同，WebSockets提供低延迟通信，这对于实时消息应用至关重要。'
- en: '**Efficient use of resources**: WebSockets maintain a single connection per
    client, reducing the overhead on both client and server compared to long polling'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的高效利用**: WebSockets为每个客户端维护一个单一连接，与长轮询相比，这减少了客户端和服务器上的开销。'
- en: '**Flexibility and control**: Implementing custom WebSocket communication allows
    for more fine-grained control over the messaging infrastructure, avoiding potential
    limitations or constraints imposed by real-time cloud databases'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和控制性**: 实现自定义WebSocket通信允许对消息基础设施有更精细的控制，避免了由实时云数据库强加的潜在限制或约束。'
- en: 'For sure, WebSockets also have their disadvantages that we must take into account,
    such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，WebSockets也有其缺点，我们必须考虑，如下所示：
- en: '**Battery and data usage**: Maintaining a persistent connection can lead to
    increased battery drain and data usage, which may be a concern for mobile users.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池和数据使用**: 维持持久连接可能导致电池消耗增加和数据使用量增加，这可能会成为移动用户的担忧。'
- en: '**Complexity**: Implementing WebSocket communication is typically more complex
    than using RESTful services. You have to handle various scenarios such as reconnection
    on network changes, which are common in mobile environments.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**: 实现WebSocket通信通常比使用RESTful服务更复杂。您必须处理各种场景，例如在网络变化时进行重新连接，这在移动环境中很常见。'
- en: '**Scalability**: If your application scales to a large number of users, maintaining
    WebSocket connections for all of them can be resource-intensive on the server
    side.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**: 如果您的应用程序扩展到大量用户，维护所有用户的WebSocket连接可能会在服务器端消耗大量资源。'
- en: Although there are some disadvantages, the advantages of using WebSockets —
    such as real-time bidirectional communication and lower overheads compared to
    traditional HTTP polling — significantly outweigh these issues, making them a
    powerful choice for interactive applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些缺点，但使用 WebSocket 的优势——如实时双向通信和与传统 HTTP 轮询相比的更低开销——显著超过了这些问题，使其成为交互式应用程序的一个强大选择。
- en: Let’s start learning how we can integrate WebSockets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何集成 WebSocket。
- en: Integrating WebSockets
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 WebSocket
- en: 'There are several libraries available for integrating WebSockets in Android
    applications. Some popular options include the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 应用程序中，有多个库可用于集成 WebSocket。以下是一些流行的选项：
- en: '**OkHttp**: A popular HTTP client for Android and Java applications that also
    supports WebSocket communication'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OkHttp**：一个流行的 Android 和 Java 应用程序 HTTP 客户端，也支持 WebSocket 通信'
- en: '**Scarlet**: A declarative WebSocket library for Kotlin and Java applications,
    built on top of OkHttp'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scarlet**：一个基于 OkHttp 的 Kotlin 和 Java 应用程序的声明式 WebSocket 库'
- en: '**Ktor**: A modern, Kotlin-based framework for building asynchronous servers
    and clients, including WebSocket support'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ktor**：一个基于 Kotlin 的现代框架，用于构建异步服务器和客户端，包括 WebSocket 支持'
- en: For our app, we will use Ktor due to its ease of use, native support for Kotlin,
    and extensive documentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用 Ktor，因为它易于使用，对 Kotlin 有原生支持，并且有广泛的文档。
- en: What is Ktor?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 Ktor？
- en: Ktor stands out for its coroutine-based architecture, which allows for non-blocking
    asynchronous operations, making it particularly suitable for I/O-intensive tasks
    such as network communication. It’s lightweight and modular, allowing developers
    to pick and choose only the features they need, thereby avoiding the overhead
    of unnecessary functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 因其基于协程的架构而脱颖而出，这允许进行非阻塞的异步操作，使其特别适合网络通信等 I/O 密集型任务。它轻量级且模块化，允许开发者选择和选择他们需要的功能，从而避免不必要的功能的开销。
- en: The framework is built on top of coroutines, a feature in Kotlin that makes
    your code cleaner and more readable, and simplifies asynchronous programming by
    allowing functions to be paused and resumed at later times. This provides a powerful
    way to handle concurrency with a more straightforward and expressive syntax compared
    to traditional callback mechanisms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架建立在协程之上，这是 Kotlin 中的一个特性，可以使你的代码更简洁、更易读，并通过允许函数在稍后时间暂停和恢复来简化异步编程。这提供了一种处理并发的方式，与传统的回调机制相比，语法更直接、更易于表达。
- en: Ktor is versatile, supporting both server-side and client-side development.
    On the server side, it can be used to build robust and scalable web applications
    and services. On the client side, it provides a multiplatform HTTP client that
    can be used on Android, allowing for seamless interaction with web services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 多功能，支持服务器端和客户端开发。在服务器端，它可以用来构建健壮且可扩展的 Web 应用程序和服务。在客户端，它提供了一个多平台 HTTP 客户端，可以在
    Android 上使用，允许无缝与 Web 服务交互。
- en: Ktor’s WebSocket client allows for easy setup and management of WebSocket connections,
    handling complexities such as connection lifecycle, error handling, and message
    processing. Its **domain-specific language** (**DSL**) provides a concise and
    expressive way to define the behavior of WebSocket interactions, making the code
    more readable and maintainable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 的 WebSocket 客户端允许轻松设置和管理 WebSocket 连接，处理诸如连接生命周期、错误处理和信息处理等复杂性。它的**领域特定语言**（**DSL**）提供了一种简洁且易于表达的方式来定义
    WebSocket 交互的行为，使代码更易于阅读和维护。
- en: Integrating WebSockets with Ktor
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成 WebSocket 与 Ktor
- en: 'To integrate Ktor in our Android app, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Android 应用程序中集成 Ktor，请按照以下步骤操作：
- en: 'In our app’s **build.gradle** file of the **:feature:chat** module, add the
    following Ktor dependencies for the WebSocket client. Make sure to replace **$ktor_version**
    with the latest version available (for the examples in this book, we are using
    version 2.2.4):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们应用程序的 **:feature:chat** 模块的 **build.gradle** 文件中，为 WebSocket 客户端添加以下 Ktor
    依赖项。确保将 **$ktor_version** 替换为最新版本（对于本书中的示例，我们使用版本 2.2.4）：
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each dependency serves a distinct purpose:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个依赖项都有其独特的作用：
- en: '**io.ktor:ktor-client-websockets**: This dependency provides the necessary
    functionality to manage WebSocket connections in our application. It includes
    high-level abstractions for opening, sending messages to, and receiving messages
    from WebSocket servers, facilitating real-time data exchange in a seamless manner.
    By using this library, we can easily implement WebSocket communication without
    handling the complex underlying protocols and handshakes manually.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**io.ktor:ktor-client-websockets**: 这个依赖项提供了管理我们应用程序中WebSocket连接所需的功能。它包括对打开、向WebSocket服务器发送消息和从WebSocket服务器接收消息的高级抽象，以无缝的方式促进实时数据交换。通过使用这个库，我们可以轻松实现WebSocket通信，无需手动处理复杂的底层协议和握手。'
- en: '**io.ktor:ktor-client-okhttp**: While Ktor is a multiplatform framework, it
    requires an engine to handle network requests. This dependency integrates OkHttp
    as the underlying engine for handling HTTP requests and responses in Android applications.
    OkHttp supports WebSockets along with its robust HTTP client features, providing
    efficient network operations, connection pooling, and a powerful interface for
    making and intercepting requests.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**io.ktor:ktor-client-okhttp**: 虽然 Ktor 是一个多平台框架，但它需要一个引擎来处理网络请求。这个依赖项将OkHttp集成为我们应用程序中处理HTTP请求和响应的底层引擎。OkHttp支持WebSocket，以及其强大的HTTP客户端功能，提供高效的网络操作、连接池和强大的接口，用于发送和拦截请求。'
- en: Together, these dependencies allow our app to utilize WebSockets for real-time
    communication and leverage OkHttp’s efficient networking capabilities. This combination
    is particularly powerful for applications needing to maintain persistent connections
    and manage high-frequency data exchange, such as messaging apps or live data feeds.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一起，这些依赖项使我们的应用程序能够利用WebSocket进行实时通信，并利用OkHttp的高效网络功能。这种组合对于需要维护持久连接和管理高频数据交换的应用程序特别强大，例如消息应用或实时数据流。
- en: 'In your **AndroidManifest.xml** file, add the required permission to access
    the internet as we will need it to connect our WebSocket and receive/send messages:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**AndroidManifest.xml**文件中，添加访问互联网所需的权限，因为我们需要它来连接WebSocket和接收/发送消息：
- en: '[PRE1]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We now have the library included in our project. As we will be using Ktor with
    Kotlin Flow, let’s introduce it before diving into our WebSocket implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在项目中包含了这个库。由于我们将使用Ktor与Kotlin Flow，在深入WebSocket实现之前，让我们先介绍它。
- en: Getting to know Kotlin Flow
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解Kotlin Flow
- en: Flow is part of Kotlin’s coroutines library, and it’s a type that can emit multiple
    values sequentially, as opposed to suspend functions that return only a single
    value. Flow builds upon the foundational concepts of coroutines to offer a declarative
    way to work with asynchronous streams of data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flow是Kotlin协程库的一部分，它是一种可以按顺序发出多个值的类型，与只返回单个值的挂起函数相反。Flow建立在协程的基础概念之上，提供了一种声明式的方式来处理异步数据流。
- en: Unlike sequences in Kotlin, which are synchronous and blocking, Flow is asynchronous
    and non-blocking. This makes Flow ideal for handling a continuous stream of data
    that can be observed and collected asynchronously, such as real-time messages
    from a WebSocket.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kotlin中的序列不同，序列是同步和阻塞的，Flow是异步和非阻塞的。这使得Flow非常适合处理可以异步观察和收集的连续数据流，例如WebSocket的实时消息。
- en: When integrating Flow with Ktor WebSockets, we can create a powerful combination
    where the WebSocket messages are emitted as a stream of data that can be processed
    using all the Flow operators. It allows for a clean, reactive-style approach to
    handling incoming and outgoing messages with WebSockets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当将Flow与Ktor WebSockets集成时，我们可以创建一个强大的组合，其中WebSocket消息作为数据流发出，可以使用所有Flow操作符进行处理。它允许以干净、响应式的方式处理WebSocket的传入和传出消息。
- en: For example, in a chat application, incoming messages from a WebSocket can be
    represented as a flow of strings. The app can collect this flow to update the
    UI accordingly. Similarly, user actions that generate outgoing messages can be
    collected and sent through the WebSocket connection.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在聊天应用程序中，来自WebSocket的传入消息可以表示为字符串流。应用程序可以收集这个流来相应地更新UI。同样，生成传出消息的用户操作可以收集并通过WebSocket连接发送。
- en: 'The Flow API is really simple and easy to use. As another example, imagine
    that we have a flow that emits three strings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Flow API非常简单易用。例如，想象我们有一个发出三个字符串的流：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code block, `helloFlow` is defined, using the `flow` builder to emit
    three strings one after another.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码块中，`helloFlow`是通过`flow`构建器定义的，依次发出三个字符串。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are several other builders apart from **flow**, such as **flowOf**, which
    creates a flow from a set of values, or **toFlow()**, which creates a flow from
    a collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **flow** 之外，还有几个其他的构建器，例如 **flowOf**，它从一个值集中创建一个流，或者 **toFlow()**，它从一个集合中创建一个流。
- en: The `collect()` function is then called on `helloFlow`. It acts as a subscriber
    that reacts to each emitted value by printing it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `helloFlow` 上调用 `collect()` 函数。它作为一个订阅者，对每个发出的值做出反应，并打印出来。
- en: 'If you run this code, you should see the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你应该看到以下输出：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we are a bit familiar with Kotlin Flow, we are ready to do the next
    step: build our implementation of a WebSocket using Ktor and Flow. As it is going
    to be one of the data sources that will provide messages to our app, we will call
    it `WebsocketDataSource`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Kotlin Flow 有点熟悉了，我们准备进行下一步：使用 Ktor 和 Flow 构建我们的 WebSocket 实现。由于它将是提供消息给我们的应用的数据源之一，我们将称之为
    `WebsocketDataSource`。
- en: Implementing WebSocketDataSource
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 WebSocketDataSource
- en: To implement the WebSocket data source, we are first going to create an `HttpClient`
    instance. `HttpClient` is a Ktor class that allows you to make HTTP requests and
    manage network connections. In the case of WebSockets, it is responsible for establishing
    and maintaining the connection between the client and server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 WebSocket 数据源，我们首先将创建一个 `HttpClient` 实例。`HttpClient` 是一个 Ktor 类，允许你进行 HTTP
    请求并管理网络连接。在 WebSocket 的情况下，它负责在客户端和服务器之间建立和维护连接。
- en: 'To create an `HttpClient` instance with WebSocket support, we are going to
    create a new file called `WebSocketClient` in the `feature.chat.data.network`
    package (you will need to create the data and network packages as they don’t exist
    yet) and include the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有 WebSocket 支持的 `HttpClient` 实例，我们将在 `feature.chat.data.network` 包中创建一个名为
    `WebSocketClient` 的新文件（你需要创建数据和网络包，因为它们还不存在）并包含以下代码：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we’re using the `OkHttp` engine to create an `HttpClient` instance, and
    then we’re installing the `WebSockets` plugin to enable WebSocket support.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `OkHttp` 引擎创建一个 `HttpClient` 实例，然后安装 `WebSockets` 插件以启用 WebSocket 支持。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Ktor, **plugins** (also called features) are modular components that extend
    the functionality of Ktor applications. Plugins can be installed on both the client
    and server sides to provide additional features, such as authentication, logging,
    serialization, or custom behavior. Ktor’s plugin-based architecture encourages
    a lightweight and modular approach, allowing you to include only the necessary
    components in your application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ktor 中，**插件**（也称为功能）是扩展 Ktor 应用程序功能的功能模块化组件。插件可以安装在客户端和服务器端以提供额外的功能，例如身份验证、日志记录、序列化或自定义行为。Ktor
    的基于插件的架构鼓励轻量级和模块化的方法，允许你只将必要的组件包含在应用程序中。
- en: Then, we will create our `MessagesSocketDataSource` class (in the same package).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建我们的 `MessagesSocketDataSource` 类（在同一个包中）。
- en: 'To start creating our WebSocket, we will need a `WebSocketSession` instance.
    `WebSocketSession` represents a single WebSocket connection between the client
    and server, providing methods for sending and receiving messages, as well as managing
    the connection’s lifecycle. In our implementation, we will create a `WebSocketSession`
    instance when we call the `connect()` method, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建我们的 WebSocket，我们需要一个 `WebSocketSession` 实例。`WebSocketSession` 代表客户端和服务器之间单一的
    WebSocket 连接，提供发送和接收消息的方法，以及管理连接的生命周期。在我们的实现中，当我们调用 `connect()` 方法时，将创建一个 `WebSocketSession`
    实例，如下所示：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s break down what this code is going to do:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这段代码将要做什么：
- en: '**suspend fun connect(url: String): Flow<Message>**: The **connect** function
    is defined as a suspending (**suspend**) function that takes a **url** parameter
    of type **String** and returns a **Flow<Message>** instance. **Flow** is a cold
    asynchronous stream used for processing data in a reactive way in Kotlin (a cold
    stream is one that will only emit messages when there is a consumer connected).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**suspend fun connect(url: String): Flow<Message>**：**connect** 函数被定义为接受一个类型为
    **String** 的 **url** 参数并返回一个 **Flow<Message>** 实例的挂起（**suspend**）函数。**Flow** 是
    Kotlin 中用于以响应式方式处理数据的冷异步流（冷流是只有当有消费者连接时才会发出消息的流）。'
- en: '**httpClient.webSocketSession { url(url) }**: This line uses **httpClient**
    to create a WebSocket session by calling the **webSocketSession** function and
    passing a lambda that sets the session’s URL to the provided URL.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**httpClient.webSocketSession { url(url) }**：这一行使用 **httpClient** 通过调用 **webSocketSession**
    函数并传递一个设置会话 URL 为提供的 URL 的 lambda 表达式来创建一个 WebSocket 会话。'
- en: '**.apply { webSocketSession = this }**: This line stores the newly created
    WebSocket session using the **apply** function in the **webSocketSession** property.
    We also need to store it as we will need the session later for sending messages.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.apply { webSocketSession = this }**：这一行使用 **webSocketSession** 属性中的 **apply**
    函数存储新创建的 WebSocket 会话。我们还需要将其存储起来，因为我们稍后会需要这个会话来发送消息。'
- en: '**.incoming**: This line accesses the incoming property of **webSocketSession**.
    The incoming property is a channel that receives incoming **Frame** objects from
    the WebSocket server.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.incoming**：这一行访问 **webSocketSession** 的 **incoming** 属性。**incoming** 属性是一个通道，它从
    WebSocket 服务器接收 **Frame** 对象。'
- en: '**.receiveAsFlow()**: This line converts the incoming channel to a **Flow<Frame>**
    instance so that it can be processed using the Flow API.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.receiveAsFlow()**：这一行将传入的通道转换为 **Flow<Frame>** 实例，以便可以使用 Flow API 进行处理。'
- en: '**.map { frame -> webSocketSession.handleMessage(frame) }**: This line maps
    each incoming **Frame** object to the result of calling the **handleMessage**
    function. We will define the **handleMessage** function later.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.map { frame -> webSocketSession.handleMessage(frame) }**：这一行将每个传入的 **Frame**
    对象映射到调用 **handleMessage** 函数的结果。我们将在稍后定义 **handleMessage** 函数。'
- en: '**.filterNotNull****()**: This line filters out any **null** values from the
    stream, ensuring that only non-**null** values are processed further.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.filterNotNull****()**：这一行从流中过滤掉任何 **null** 值，确保只有非 **null** 值被进一步处理。'
- en: '**.map { it.toDomain() }**: This line maps each non-**null** value to the result
    of calling the **toDomain()** function. This function will map the current data-related
    object to the domain **Message** model that we will create soon.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.map { it.toDomain() }**：这一行将每个非 **null** 值映射到调用 **toDomain()** 函数的结果。这个函数将当前数据相关对象映射到我们很快将创建的域
    **Message** 模型。'
- en: 'Before processing and handling the messages, we will also want to add two more
    functions to our WebSocket data source:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理和消息之前，我们还想向我们的 WebSocket 数据源添加两个额外的函数：
- en: We want one function to send messages, as we want our users to be able to send
    messages to their WhatsPackt friends
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还想要一个函数来发送消息，因为我们希望我们的用户能够向他们的 WhatsPackt 朋友发送消息。
- en: We want another function to disconnect the WebSocket, as we should disconnect
    it from the server when it is not in use
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还想要一个函数来断开 WebSocket 连接，因为当它不再使用时，我们应该从服务器断开连接。
- en: 'We can add these like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样添加它们：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When a WebSocket connection is closed, it’s accompanied by a `CloseReason` class,
    which contains a code and an optional descriptive text. The code indicates the
    reason for the connection closure, such as normal closure, protocol error, or
    unsupported data. In our implementation, we use the `CloseReason` class to close
    the `WebSocketSession` with a normal closure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 WebSocket 连接关闭时，它会伴随着一个 `CloseReason` 类，该类包含一个代码和一个可选的描述性文本。代码表示连接关闭的原因，例如正常关闭、协议错误或不支持的数据。在我们的实现中，我们使用
    `CloseReason` 类以正常关闭关闭 `WebSocketSession`。
- en: 'Some common `CloseReason` codes include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的 `CloseReason` 代码包括以下内容：
- en: '**CloseReason.Codes.NORMAL**: Indicates a normal closure of the connection.
    This is the reason that will be provided when the user is no longer using the
    chat screen.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloseReason.Codes.NORMAL**：表示连接的正常关闭。这是当用户不再使用聊天界面时将提供的理由。'
- en: '**CloseReason.Codes.GOING_AWAY**: Indicates that the server is going away or
    shutting down.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloseReason.Codes.GOING_AWAY**：表示服务器正在离开或关闭。'
- en: '**CloseReason.Codes.PROTOCOL_ERROR**: Indicates that an error in the WebSocket
    protocol occurred.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloseReason.Codes.PROTOCOL_ERROR**：表示 WebSocket 协议中发生了错误。'
- en: '**CloseReason.Codes.UNSUPPORTED_DATA**: Indicates that the received data type
    is not supported.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloseReason.Codes.UNSUPPORTED_DATA**：表示接收到的数据类型不受支持。'
- en: 'Now that we know how to close our WebSocket connection, we need to define the
    `handleMessages` extension function to process all the messages while the connection
    is alive:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何关闭我们的 WebSocket 连接，我们需要定义 `handleMessages` 扩展函数来处理连接存活期间的所有消息：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the WebSocket protocol, data is transmitted in discrete units called frames.
    Ktor provides a `Frame` class to represent these units, with different subclasses
    for each frame type, such as `Frame.Text`, `Frame.Binary`, `Frame.Ping`, and `Frame.Close`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebSocket 协议中，数据以离散的单位（称为帧）进行传输。Ktor 提供了一个 `Frame` 类来表示这些单位，每个帧类型都有一个不同的子类，例如
    `Frame.Text`、`Frame.Binary`、`Frame.Ping` 和 `Frame.Close`。
- en: In our case, we are only processing `Frame.Text` and `Frame.Close` messages.
    To receive a `Frame.Close` message, we will close the WebSocket (for now – in
    the future, maybe we would want to do a retry here or give feedback about the
    problem to the user). Then, to receive the `Frame.Text` messages, we are going
    to `deserialize` just describes this conversion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只处理 `Frame.Text` 和 `Frame.Close` 消息。为了接收 `Frame.Close` 消息，我们将关闭 WebSocket（目前是这样
    – 未来，我们可能在这里进行重试或向用户反馈问题）。然后，为了接收 `Frame.Text` 消息，我们将进行 `deserialize` 描述的这个转换。
- en: 'We can configure a converter in our WebSocket that allows us to easily deserialize
    our messages. First, we need to add new dependencies to our `build.gradle` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 WebSocket 中配置一个转换器，使我们能够轻松反序列化我们的消息。首先，我们需要向我们的 `build.gradle` 文件中添加新的依赖项：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we are ready to set `contentConverter` in our WebSocket plugin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备在 WebSocket 插件中设置 `contentConverter`：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we are configuring the `kotlinx.serialization` converter for the
    JSON format (there are also converters available for other standards, such as
    XML, Protobuf, and CBOR).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们正在配置 JSON 格式的 `kotlinx.serialization` 转换器（也有其他标准的转换器可用，例如 XML、Protobuf
    和 CBOR）。
- en: 'In addition, we must add the `@Serializable` annotation to those data classes
    that we want to be deserialized by the converter. In our case, we will create
    a `WebsocketMessageModel` class as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须为那些我们希望由转换器反序列化的数据类添加 `@Serializable` 注解。在我们的例子中，我们将创建一个 `WebsocketMessageModel`
    类，如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last step in our flow chain is to convert the `WebsocketMessageModel` class
    to a domain. As we still don’t have a domain model, we should create it first:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流程链中的最后一步是将 `WebsocketMessageModel` 类转换为领域。由于我们还没有领域模型，我们应该首先创建它：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can implement the mapper as a function of the `WebsocketMessageModel`
    class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将映射器实现为 `WebsocketMessageModel` 类的一个函数：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are adding the `toDomain()` function that maps the current `WebsocketMessageModel`
    class to the `Message` model. Note that almost all fields in the data model are
    similar to those in our domain `Message` model. The key exception is the `messageType`
    field, which we must convert to the enum we are using in the domain `Message`
    model. To simplify this conversion, we use the `toContentType()` function, which
    specifically transforms `messageType` from a `String` object to a `ContentType`
    enum.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了 `toDomain()` 函数，该函数将当前的 `WebsocketMessageModel` 类映射到 `Message` 模型。请注意，数据模型中的几乎所有字段都与我们的领域
    `Message` 模型中的字段相似。一个主要的例外是 `messageType` 字段，我们必须将其转换为领域 `Message` 模型中使用的枚举。为了简化这种转换，我们使用了
    `toContentType()` 函数，该函数专门将 `messageType` 从 `String` 对象转换为 `ContentType` 枚举。
- en: 'We also would need to convert the domain `Message` object to the `WebsocketMessageModel`
    class. To do that, we need to add a new function to the `WebsocketMessageModel`
    class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将领域 `Message` 对象转换为 `WebsocketMessageModel` 类。为此，我们需要向 `WebsocketMessageModel`
    类中添加一个新函数：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are converting the `Message` domain object into a `WebsocketMessageModel`
    class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将 `Message` 领域对象转换为 `WebsocketMessageModel` 类。
- en: 'Then, in the `send` function, we will proceed as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `send` 函数中，我们将按以下步骤进行：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these changes to the `sendMessage` function, we are now receiving a domain
    model object, converting it to `WebsocketMessageModel`, and finally serializing
    it into a `Frame` object and sending it through our WebSocket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 `sendMessage` 函数的这些更改，我们现在接收一个领域模型对象，将其转换为 `WebsocketMessageModel`，并将其最终序列化为
    `Frame` 对象并通过我们的 WebSocket 发送。
- en: The next step is to connect this component (`MessagesWebsocketDataSource`) with
    `ViewModel`, which will be responsible for providing the view state to the view
    so that it can render accordingly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此组件（`MessagesWebsocketDataSource`）与 `ViewModel` 连接起来，该 `ViewModel` 将负责向视图提供视图状态，以便它可以相应地渲染。
- en: Receiving messages in our ViewModel
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 ViewModel 中接收消息
- en: Our app is ready to receive and send messages using a WebSocket. Now, we need
    to make them reach the UI we created in the previous chapter. We will do that
    in this section, but first, we need to think about the architecture and components
    needed to do that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以接收和发送 WebSocket 消息。现在，我们需要让它们达到我们在上一章中创建的 UI。我们将在本节中这样做，但首先，我们需要考虑实现该功能所需架构和组件。
- en: Understanding Clean Architecture implementation
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Clean Architecture 的实现
- en: In the previous chapter, we modularized our app and talked about using a Clean
    Architecture-based structure to organize our common and feature modules. We have
    already created our first component of this architecture, `MessagesWebsocketDataSource`,
    but it is important to understand the reasons behind this organization and which
    role every component plays in the architecture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对应用程序进行了模块化，并讨论了使用基于清洁架构的结构来组织我们的通用和功能模块。我们已经创建了该架构的第一个组件`MessagesWebsocketDataSource`，但理解这种组织背后的原因以及每个组件在架构中扮演的角色是很重要的。
- en: There are extensive books, articles, and videos about why and how to apply Clean
    Architecture principles to an Android app, even from official documentation by
    Google. Here, we are going to give you a short description and then break down
    into its layers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么以及如何将清洁架构原则应用于Android应用程序，有大量的书籍、文章和视频，甚至包括谷歌的官方文档。在这里，我们将提供简短的描述，然后将其分解为其各个层。
- en: '**Clean Architecture** is an architectural pattern that promotes the organization
    of code into layers with well-defined responsibilities, making the application
    more modular, maintainable, testable, and scalable. The key benefits of using
    Clean Architecture are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**清洁架构**是一种促进代码组织成具有明确责任层的架构模式，使应用程序更加模块化、可维护、可测试和可扩展。使用清洁架构的关键好处如下：'
- en: '**Separation of concerns (SoC)**: Clean Architecture organizes code into distinct
    layers with specific responsibilities, ensuring that each layer handles a separate
    aspect of the application. This SoC leads to a more modular and maintainable code
    base, making it easier to understand, modify, and extend.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离（SoC）**：清洁架构将代码组织成具有特定责任的独立层，确保每一层处理应用程序的单独方面。这种SoC导致代码库更加模块化和可维护，使其更容易理解、修改和扩展。'
- en: '**Testability**: By separating the different concerns into independent layers,
    it becomes easier to test each layer in isolation. This allows developers to write
    comprehensive unit and integration tests, ensuring that the application behaves
    correctly and is less prone to bugs.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：通过将不同的关注点分离成独立的层，可以更容易地在隔离状态下测试每一层。这允许开发者编写全面的单元和集成测试，确保应用程序的行为正确，并且更不容易出现错误。'
- en: '**Reusability**: The modular structure of Clean Architecture promotes reusability
    by encouraging the creation of components that can be easily shared across different
    parts of the application or even between different projects. This reduces code
    duplication and improves the overall efficiency of the development process.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：清洁架构的模块化结构通过鼓励创建可以轻松在不同部分的应用程序或不同项目之间共享的组件来促进可重用性。这减少了代码重复，并提高了整体开发过程的效率。'
- en: '**Flexibility**: Clean Architecture decouples the various layers of the application,
    making it easier to change or update any of these layers independently without
    affecting the others. This provides more flexibility when refactoring, making
    changes to the application, or adapting to new requirements.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：清洁架构通过解耦应用程序的各个层，使得独立更改或更新这些层中的任何一个都更容易，而不会影响其他层。这为重构、修改应用程序或适应新需求提供了更多灵活性。'
- en: '**Scalability**: The modular nature of Clean Architecture makes it easier to
    scale the application as it grows in complexity or size. By organizing code into
    well-defined layers and components, developers can more easily add new features,
    update existing functionality, or improve performance without introducing unintended
    side effects or making the code base unmanageable.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：清洁架构的模块化特性使得在应用程序复杂度或规模增长时更容易扩展。通过将代码组织成定义良好的层和组件，开发者可以更容易地添加新功能、更新现有功能或提高性能，而不会引入意外的副作用或使代码库难以管理。'
- en: '**Easier collaboration**: Clean Architecture helps teams work more effectively
    by providing a clear structure and guidelines for organizing code. This makes
    it easier for developers to understand the code base, find the components they
    need, and contribute to the project more efficiently.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易协作**：清洁架构通过提供清晰的代码组织结构和指南，帮助团队更有效地工作。这使得开发者更容易理解代码库，找到他们需要的组件，并更高效地贡献到项目中。'
- en: '**Future-proofing**: By adhering to the principles of Clean Architecture, you
    ensure that the application is built on a solid foundation that can evolve and
    adapt over time. This makes it more resilient to changes in technology, requirements,
    or team members, improving the long-term viability of the project.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向未来**：通过遵循Clean Architecture的原则，你确保了应用建立在坚实的基础之上，可以随着时间的推移而演变和适应。这使得它更能抵御技术、需求或团队成员的变化，从而提高了项目的长期可行性。'
- en: In summary, using Clean Architecture in your projects leads to better-organized,
    more maintainable, and scalable code bases. It improves the overall quality of
    the application, reduces technical debt, and makes it easier for teams to work
    together effectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在项目中使用Clean Architecture可以导致更组织化、更易于维护和可扩展的代码库。它提高了应用程序的整体质量，减少了技术债务，并使团队更有效地协作变得更容易。
- en: 'Now, with the benefits of Clean Architecture firmly in mind, let’s delve into
    the specifics. What follows are the layers and the components of code that we
    will incorporate within each layer:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，带着清晰认识到Clean Architecture的好处，让我们深入探讨其具体细节。以下是我们将在每一层中包含的代码层和组件：
- en: '**Presentation layer**:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：'
- en: '**View**: This consists of UI components, such as **Activity**, **Fragment**,
    **View**, and, in our case, **Composable** components. The view is responsible
    for displaying data and capturing user input.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这包括UI组件，如**Activity**、**Fragment**、**View**，在我们的案例中还有**Composable**组件。视图负责显示数据和捕获用户输入。'
- en: '**ViewModel**: The **ViewModel** serves as a bridge between the **View** components
    and the data layers. It handles the UI logic, exposes **LiveData** or **StateFlow**
    objects for data binding, and communicates with **UseCase** classes.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：**视图模型**作为**视图**组件和数据层之间的桥梁。它处理UI逻辑，暴露**LiveData**或**StateFlow**对象以进行数据绑定，并与**用例**类进行通信。'
- en: '**Domain layer**:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**：'
- en: '**UseCase**: This layer contains the business logic and coordinates the flow
    of data between the data layer and the presentation layer. **UseCase** implementations
    encapsulate specific actions that can be performed within the app, such as sending
    a message, fetching chat history, or updating user settings.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：这一层包含业务逻辑，并协调数据层和表示层之间的数据流。**用例**实现封装了可以在应用中执行的具体操作，例如发送消息、获取聊天历史或更新用户设置。'
- en: '**Data layer**:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：'
- en: '**Repository**: The **Repository** component is responsible for managing the
    data flow and providing a clean API to request data from different sources (local
    database, remote API, and so on). It abstracts the underlying data sources and
    handles caching, synchronization, and data merging.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：**仓库**组件负责管理数据流并提供一个干净的API来从不同的源（本地数据库、远程API等）请求数据。它抽象了底层数据源并处理缓存、同步和数据合并。'
- en: '**Data source**: This layer contains the implementations for accessing specific
    data sources such as local databases (using Room or another **object-relational
    mapper** (**ORM**)) and remote APIs (using Retrofit or another networking library,
    as in our case where we are using Ktor).'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**：这一层包含访问特定数据源的实现，例如本地数据库（使用Room或其他**对象关系映射器**（ORM））和远程API（使用Retrofit或其他网络库，正如我们案例中使用的Ktor）。'
- en: 'In the following diagram, we can see the relationships between the different
    layers and the typical components every layer includes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到不同层之间的关系以及每一层典型的组件：
- en: '![Figure 2.1: Clean Architecture in Android with the typical components per
    layer](img/B19443_02_001.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：Android中的Clean Architecture及其每层的典型组件](img/B19443_02_001.jpg)'
- en: 'Figure 2.1: Clean Architecture in Android with the typical components per layer'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Android中的Clean Architecture及其每层的典型组件
- en: Having this clear understanding of Clean Architecture’s benefits and structure,
    let’s now put these principles into practice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Clean Architecture的好处和结构有了清晰理解之后，现在让我们将这些原则付诸实践。
- en: Creating our Clean Architecture components
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的Clean Architecture组件
- en: We have started building the data layer components, where we have created the
    `MessagesWebsocket` **DataSource** component. Now, it is time we build the rest
    of our Clean Architecture layers and components to reach the presentation layer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建数据层组件，其中我们创建了`MessagesWebsocket` **数据源**组件。现在，是我们构建Clean Architecture的其余层和组件以到达表示层的时候了。
- en: 'In the end, this is what our app’s Clean Architecture layers and components
    should look like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的应用Clean Architecture的层和组件应该看起来是这样的：
- en: '![Figure 2.2: Layers and components that we will build in our project, following
    Clean Architecture principles](img/B19443_02_002.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：我们将根据Clean Architecture原则构建的项目中的层和组件](img/B19443_02_002.jpg)'
- en: 'Figure 2.2: Layers and components that we will build in our project, following
    Clean Architecture principles'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：我们将根据Clean Architecture原则构建的项目中的层和组件
- en: 'As we have already built the `MessagesWebsocketDataSource` component, the next
    component is the repository. The repository component will only connect with `MessagesWebsocketDataSource`
    (for now; we have bigger plans for it in the next chapter). We are going to call
    it `MessagesRepository`. Let’s start building it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了`MessagesWebsocketDataSource`组件，下一个组件是仓库。仓库组件将仅与`MessagesWebsocketDataSource`（目前如此；我们将在下一章中为它制定更大的计划）。我们将称之为`MessagesRepository`。让我们开始构建它：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`MessagesRepository` will just have one dependency (`MessagesSocketDataSource`)
    and will implement the functionality to connect to messages (the `getMessages`
    function), send messages (the `sendMessage` function), and disconnect from the
    WebSocket (the `disconnect` function).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagesRepository`将只有一个依赖项（`MessagesSocketDataSource`）并实现连接到消息（`getMessages`函数）、发送消息（`sendMessage`函数）和从WebSocket断开连接（`disconnect`函数）的功能。'
- en: 'Now, we need to do a little modification to `MessagesRepository`: we need to
    create an interface in the domain layer with the `MessagesRepository` functionality.
    Creating an interface for the repository in the domain layer and implementing
    it in the data layer is a technique that follows the **Dependency Inversion Principle**
    (**DIP**) from the SOLID principles of **object-oriented** **programming** (**OOP**).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`MessagesRepository`进行一点修改：我们需要在领域层创建一个具有`MessagesRepository`功能的接口。在领域层为仓库创建接口并在数据层实现它是一种遵循SOLID原则中的**依赖倒置原则**（**DIP**）的技术。
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: DIP is one of the five principles of OOP and design known as SOLID. DIP states
    that high-level modules should not depend on low-level modules and both should
    depend on abstractions. Similarly, abstractions should not depend on details;
    details should depend on abstractions. The main idea behind DIP is to decouple
    modules, classes, or components in a software system, promoting flexibility, reusability,
    and maintainability. By depending on abstractions rather than concrete implementations,
    the system becomes more adaptable to changes and easier to test and maintain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DIP是OOP和设计模式中的SOLID原则之一。DIP指出，高级模块不应依赖于低级模块，两者都应依赖于抽象。同样，抽象不应依赖于细节；细节应依赖于抽象。DIP背后的主要思想是在软件系统中解耦模块、类或组件，促进灵活性、可重用性和可维护性。通过依赖于抽象而不是具体实现，系统变得更加适应变化，并且更容易进行测试和维护。
- en: 'Let’s create our `IMessagesRepository` interface:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的`IMessagesRepository`接口：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we will change our `MessagesRepository` class to implement this interface,
    adding the override in its functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将修改我们的`MessagesRepository`类以实现此接口，并在其函数中添加重写：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we will continue in our journey to the presentation layer, implementing
    the domain layer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续我们的旅程，进入表示层，实现领域层。
- en: The domain layer is not strictly mandatory, but it is highly recommended. While
    you can eliminate the domain layer and directly use repositories in your `ViewModel`
    instances, doing so would mix the responsibilities of the layers, which can lead
    to more complex and harder-to-maintain code. There may be cases where not implementing
    it could be considered; for example, if you are doing a `UseCase` layer to maintain
    a clean and scalable architecture.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层不是强制性的，但强烈推荐。虽然您可以消除领域层并直接在`ViewModel`实例中使用仓库，但这样做会将层的职责混合在一起，可能导致更复杂且难以维护的代码。在某些情况下，不实现它可能被认为是合理的；例如，如果您正在创建`UseCase`层以维护一个干净且可扩展的架构。
- en: 'Following the `UseCase` instances as different functions/responsibilities in
    our business logic. So, in our case, we will create three `UseCase` instances:
    one for retrieving messages, one for sending messages, and one for disconnecting
    or stopping message retrieval.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随`UseCase`实例作为我们业务逻辑中不同的函数/职责。因此，在我们的案例中，我们将创建三个`UseCase`实例：一个用于检索消息，一个用于发送消息，一个用于断开连接或停止消息检索。
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SRP is one of the five principles of OOP and design known as SOLID. It states
    that a class, module, or function should have only one reason to change, meaning
    it should have only one responsibility. The principle aims to promote SoC by encouraging
    developers to break down their code into smaller, more focused components that
    handle a single task or aspect of the application. This leads to a more modular,
    maintainable, and easier-to-understand code base.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: SRP（单一职责原则）是OOP和设计模式中的SOLID原则之一。它指出，一个类、模块或函数应该只有一个改变的理由，这意味着它应该只有一个职责。该原则旨在通过鼓励开发者将代码分解成更小、更专注的组件来处理单个任务或应用程序的某个方面，从而促进SoC（分离关注点）。这导致代码库更加模块化、易于维护和易于理解。
- en: 'First, we will implement the `RetrieveMessages` use case:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现`RetrieveMessages`用例：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have just one dependency: the repository. Note that we are declaring
    it using its interface. It is relevant because, as we detailed before, the domain
    shouldn’t know anything about the data layer.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只有一个依赖项：仓库。请注意，我们正在使用其接口声明它。这是相关的，因为我们之前详细说明过，领域不应该了解任何关于数据层的信息。
- en: '`RetrieveMessages` will have one function that will return a `Flow` instance
    with `Message` objects. For doing that, it will return `repository.getMessages()`.
    No mapping or alteration is needed as this function already returned a `Flow`
    instance of `Message` objects.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`RetrieveMessages`将有一个函数，该函数将返回一个包含`Message`对象的`Flow`实例。为此，它将返回`repository.getMessages()`。不需要映射或修改，因为这个函数已经返回了一个`Message`对象的`Flow`实例。'
- en: 'Second, we are going to implement the `SendMessage` use case:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将实现`SendMessage`用例：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, this use case will depend only on the `IMessagesRepository` interface.
    It will call its `sendMessage` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个用例将仅依赖于`IMessagesRepository`接口。它将调用其`sendMessage`函数。
- en: 'And finally, we will code the `DisconnectMessages` use case:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写`DisconnectMessages`用例：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `DisconnectMessages` use case, as with the previous use cases implemented,
    depends on the `IMessagesRepository` interface and will call its `disconnect`
    function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前实现的用例一样，`DisconnectMessages`用例依赖于`IMessagesRepository`接口，并将调用其`disconnect`函数。
- en: We are now done with the domain layer. Now, it’s time to implement the `ViewModel`
    component that we will connect to the `ChatScreen` component, using `ChatViewModel`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了领域层。现在，是时候实现将连接到`ChatScreen`组件的`ViewModel`组件了，使用`ChatViewModel`。
- en: Implementing ChatViewModel
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ChatViewModel`
- en: In Android, `ViewModel` is an architectural component introduced as part of
    the `ViewModel` component is to hold and process the data required for a UI component
    (such as an `Activity`, `Fragment`, or `Composable` component) while properly
    handling configuration changes (such as device rotations) and surviving the lifecycle
    of the associated UI component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，`ViewModel`是作为`ViewModel`组件的一部分引入的架构组件。`ViewModel`组件的作用是保存和处理UI组件（如`Activity`、`Fragment`或`Composable`组件）所需的数据，同时正确处理配置更改（如设备旋转）并生存UI组件的生命周期。
- en: 'Our `ChatViewModel` class will be responsible for handling the data required
    in our `ChatScreen` component (which we previously built in [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015)).
    This data will come and change from the use cases we have just created. So first,
    our `ChatViewModel` class will have those use cases as dependencies:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ChatViewModel`类将负责处理`ChatScreen`组件（我们在[*第1章*](B19443_01.xhtml#_idTextAnchor015)中之前构建）所需的数据。这些数据将来自我们刚刚创建的用例。因此，首先，我们的`ChatViewModel`类将具有这些用例作为依赖项：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we will need a property to hold the state. This property needs to be
    observable from the view but read-only (so that the view shouldn’t be able to
    modify it). We will solve this by creating two different properties. The first
    property is `_messages`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个属性来保存状态。这个属性需要从视图中可观察，但只读（这样视图就不能修改它）。我们将通过创建两个不同的属性来解决此问题。第一个属性是`_messages`：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This line creates a private mutable state flow that holds a list of `Message`
    objects. We will use it to manage and update messages internally within the `ViewModel`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个包含`Message`对象列表的私有可变状态流。我们将使用它来在`ViewModel`内部管理和更新消息。
- en: 'The second property will be `messages`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性将是`messages`：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line exposes the private mutable state flow as a public read-only state
    flow. This allows the UI components to observe messages without being able to
    modify them directly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将私有可变状态流公开为只读状态流。这允许UI组件观察消息，但不能直接修改它们。
- en: 'Now, we need to implement the `loadAndUpdateMessages` function that will call
    the `RetrieveMessages` use case:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现`loadAndUpdateMessages`函数，该函数将调用`RetrieveMessages`用例：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous code block, it can be seen that we need to declare a `messageCollectionJob`
    variable. This variable is used to cancel the `messages` collection job when the
    `ViewModel` is cleared.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，可以看到我们需要声明一个`messageCollectionJob`变量。该变量用于在`ViewModel`被清除时取消`messages`集合作业。
- en: The `loadAndUpdateMessages` function is responsible for fetching and updating
    messages. It launches a coroutine with the `Dispatchers.IO` context for performing
    network or disk operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadAndUpdateMessages`函数负责获取和更新消息。它使用`Dispatchers.IO`上下文启动一个协程以执行网络或磁盘操作。'
- en: Inside the coroutine, the `retrieveMessages` function is called, and the resulting
    messages are mapped into the `Message` UI object and then collected using the
    `collect` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程内部，调用`retrieveMessages`函数，并将结果消息映射到`Message` UI 对象，然后使用`collect`函数进行收集。
- en: For each collected message, the `_messages state` flow is updated with the new
    message by switching the coroutine context to `Dispatchers.Main`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个收集到的消息，通过将协程上下文切换到`Dispatchers.Main`，使用新消息更新`_messages state`流。
- en: 'Next, to make the mapping more readable, we are going to create two extension
    functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了使映射更易于阅读，我们将创建两个扩展函数：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, when retrieving and mapping messages, we just have to call the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在检索和映射消息时，我们只需调用以下内容：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we continue to process the `messages` collection job.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续处理`messages`集合作业。
- en: 'Then, we should add a function to send a new message. Basically, the idea is
    to launch the coroutine in the `Dispatchers.IO` context to send the message. As
    it is a network operation, it is recommended to use the I/O dispatcher and map
    the `String` object we are getting from the user to the domain object, as you
    can see in the following code block:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们应该添加一个发送新消息的函数。基本思路是在`Dispatchers.IO`上下文中启动协程以发送消息。由于这是一个网络操作，建议使用 I/O
    分派器，并将我们从用户那里获取的`String`对象映射到域对象，如下面的代码块所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that, to create the domain object, we are going to lack some information
    because, for example, we have no way to obtain the `senderImage` or the `senderName`
    properties that are mandatory to send a message. So, this function is not going
    to compile for now, but we will solve this problem in the following section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了创建域对象，我们将缺少一些信息，因为例如，我们没有方法获取发送消息所必需的`senderImage`或`senderName`属性。因此，这个函数现在无法编译，但我们将解决这个问题在下文中。
- en: 'Finally, we can use the `onCleared` function to disconnect from the message’s
    retrieval:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`onCleared`函数断开与消息检索的连接：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function is called when the `ViewModel` is no longer in use and will be
    disposed of by the system. This involves canceling the `messageCollectionJob`
    variable, provided it’s not `null`, effectively halting the `messages` collection
    coroutine. Concurrently, in the context of `Dispatchers.IO`, a new coroutine is
    launched to execute the `disconnectMessages` function. This guarantees that any
    essential cleanup associated with disconnecting from the message source is carried
    out properly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ViewModel`不再使用并将由系统回收时，将调用此函数。这涉及到取消`messageCollectionJob`变量（如果它不是`null`），有效地停止`messages`收集协程。同时，在`Dispatchers.IO`上下文中启动一个新的协程来执行`disconnectMessages`函数。这保证了与消息源断开连接时进行的任何必要清理都得到妥善处理。
- en: 'This is how the `ChatViewModel` component will look (for now):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`ChatViewModel`组件目前的样子：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have our `ChatViewModel` component ready, we need to connect it
    to the view. We will make the changes needed in the `ChatScreen` component so
    that it connects to our `ChatViewModel` component. As the first step, we have
    added the `ViewModel` to the arguments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`ChatViewModel`组件，我们需要将其连接到视图。我们将对`ChatScreen`组件进行必要的更改，以便它连接到我们的`ChatViewModel`组件。作为第一步，我们已经将`ViewModel`添加到参数中：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will also add a `LaunchEffect` composable that will start the messages’
    load:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还将添加一个`LaunchEffect`可组合组件，用于启动消息的加载：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, the `SendMessageBox` composable takes a lambda parameter, where we are
    going to send the message using the `ViewModel` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SendMessageBox`可组合组件接受一个lambda参数，我们将使用`ViewModel`函数发送消息：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, we add the following new parameter to the `SendMessageBox` composable
    definition and call it in its `IconButton` `onClick` property:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`SendMessageBox`组合组件定义中添加以下新参数，并在其`IconButton`的`onClick`属性中调用它：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we will inject the `messages` property to the `ListOfMessages` composable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`messages`属性注入到`ListOfMessages`组合组件中：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This, of course, will also require a change in the composable definition and
    code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也需要在组合定义和代码中进行更改：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of using the `getFakeMessages()` function we were using when we built
    the `ListOfMessages` composable, we will use the `messages` list that we are now
    obtaining via properties.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再使用构建`ListOfMessages`组合组件时使用的`getFakeMessages()`函数，而是使用我们现在通过属性获得的`messages`列表。
- en: And with that, we’ve covered almost everything, but there remain some challenges
    to address. For instance, we don’t have the necessary information to display the
    correct avatar and name of the chat members or the necessary information to fill
    in the required properties for sending a message. While we will receive new messages
    once we connect to the WebSocket, the question of how to get historical messages
    remains. We will tackle these issues, along with other concerns related to error
    handling and synchronization, in the upcoming section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们几乎涵盖了所有内容，但仍有一些挑战需要解决。例如，我们没有显示聊天成员正确头像和名字的必要信息，也没有发送消息所需填充的必要属性的信息。虽然我们连接到WebSocket后会收到新消息，但如何获取历史消息的问题仍然存在。我们将在下一节中解决这些问题，以及其他与错误处理和同步相关的问题。
- en: Handling synchronization and errors
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理同步和错误
- en: 'To make the chat messages functionality complete, we still have some issues
    we have to take into account: getting historical messages and receiver information
    and handling possible errors. We will go through them in this section.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使聊天消息功能完整，我们仍有一些问题需要考虑：获取历史消息和接收者信息以及处理可能的错误。我们将在本节中讨论这些问题。
- en: Obtaining chat screen initialization data
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取聊天屏幕初始化数据
- en: 'Apart from the messages that we are going to be receiving or sending via the
    data source, we still need to get some additional information. This includes the
    following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将通过数据源接收或发送的消息之外，我们还需要获取一些其他信息。这包括以下内容：
- en: Messages that have been sent and received before the WebSocket was connected
    (not all of them, though, because the conversation could have many messages, and
    it would take a long time to gather/load all of the information; instead we should
    prioritize fetching a certain number of the most recent messages)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WebSocket连接之前发送和接收的消息（尽管不是所有消息，因为对话可能有大量消息，收集/加载所有信息将花费很长时间；相反，我们应该优先获取一定数量的最新消息）
- en: Receiver information, such as their name or avatar URL
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者信息，例如他们的名字或头像URL
- en: There are several options to solve this – for example, we could have a different
    type of message with all this information when the WebSocket connection is established,
    or we could have a specific API call to retrieve this information. As we have
    already played with the Ktor WebSocket for the chat feature, we are going to use
    it to implement an API call to retrieve this information.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题——例如，当WebSocket连接建立时，我们可以有一种包含所有这些信息的不同类型的消息，或者我们可以有一个特定的API调用来检索这些信息。因为我们已经使用Ktor
    WebSocket实现了聊天功能，所以我们将使用它来实现一个API调用以检索这些信息。
- en: 'When we built `WebsocketMessagesDataSource`, we had to provide an `HttpClient`
    instance. Usually, these clients are shared within the same application, but we
    should create a new one to be used for our API requests. For that, we would need
    to add a new dependency:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建`WebsocketMessagesDataSource`时，我们必须提供一个`HttpClient`实例。通常，这些客户端在同一个应用程序中是共享的，但我们应该创建一个新的实例来用于我们的API请求。为此，我们需要添加一个新的依赖项：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we can create the client like so (we can do it in the same file we defined
    the WebSocket client):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样创建客户端（我们可以在定义WebSocket客户端的同一文件中这样做）：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we are going to create a `ChatRoomDataSource` class that will be in charge
    of handling this data retrieval:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`ChatRoomDataSource`类，该类将负责处理这些数据检索：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As seen here, we are going to inject the client and the URL as dependencies.
    Then, in the `getInitialChatRoom` function, we will call the `client.get(url)`
    function in order to make a request to the endpoint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所见，我们将把客户端和URL作为依赖项注入。然后，在`getInitialChatRoom`函数中，我们将调用`client.get(url)`函数以向端点发起请求。
- en: 'Using the Ktor client, you can use various HTTP methods. Here’s a list of common
    ones:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ktor 客户端，你可以使用各种 HTTP 方法。以下是一些常见方法的列表：
- en: '**GET**: Retrieves data from the specified endpoint. To use this method in
    Ktor, you can call the **get** function:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：从指定的端点检索数据。要在 Ktor 中使用此方法，你可以调用 **get** 函数：'
- en: '[PRE39]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**POST**: Sends data to the specified endpoint, usually for creating a new
    resource. To use this method in Ktor, you can call the **post** function:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：向指定的端点发送数据，通常用于创建新资源。要在 Ktor 中使用此方法，你可以调用 **post** 函数：'
- en: '[PRE40]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**PUT**: Sends data to the specified endpoint, usually for updating an existing
    resource. To use this method in Ktor, you can call the **put** function:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：向指定的端点发送数据，通常用于更新现有资源。要在 Ktor 中使用此方法，你可以调用 **put** 函数：'
- en: '[PRE41]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**DELETE**: Deletes a specified resource. To use this method in Ktor, you can
    call the **delete** function:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：删除指定的资源。要在 Ktor 中使用此方法，你可以调用 **delete** 函数：'
- en: '[PRE42]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**PATCH**: Applies partial modifications to a resource. To use this method
    in Ktor, you can call the **patch** function:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**：对资源应用部分修改。要在 Ktor 中使用此方法，你可以调用 **patch** 函数：'
- en: '[PRE43]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the case of our `getInitialChatRoom` function, we are using the `client.get(URL)`
    function (note that we have to provide the URL in a format such that we can then
    replace the ID of `ChatRoom`). We also need to return a new model, `ChatRoomModel`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `getInitialChatRoom` 函数中，我们使用 `client.get(URL)` 函数（注意我们必须以可以替换 `ChatRoom`
    ID 的格式提供 URL）。我们还需要返回一个新的模型，`ChatRoomModel`：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, in order to provide the dependencies that `ChatRoomDataSource` needs,
    we have to set our `ChatModule` class in the following way:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了提供 `ChatRoomDataSource` 所需的依赖项，我们必须以以下方式设置我们的 `ChatModule` 类：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As both the `providesWebsocketClient` and `providesApiHttpClient` functions
    are returning the same type (`HttpClient`), we need them to be identifiable so
    that we can indicate to Hilt which dependency it should provide to `WebsocketDataSource`
    and which one goes to `ChatRoomDataSource`. That’s the reason we are using qualifiers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `providesWebsocketClient` 和 `providesApiHttpClient` 函数都返回相同的类型（`HttpClient`），我们需要使它们可识别，以便我们可以向
    Hilt 指明它应该为 `WebsocketDataSource` 提供哪个依赖项，以及哪个依赖项用于 `ChatRoomDataSource`。这就是我们使用限定符的原因。
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using qualifiers allows the **dependency injection** (**DI**) framework to determine
    the correct instance of a dependency to inject when there are multiple instances
    available of the same type. This ensures that the right instance is provided,
    preventing conflicts or ambiguity in your dependency management.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用限定符允许 **依赖注入**（**DI**）框架在存在多个相同类型的实例时确定要注入的正确依赖项实例。这确保了提供正确的实例，防止了依赖项管理中的冲突或歧义。
- en: 'In the next code block, we are using a `WEBSOCKET_CLIENT` constant as the qualifier
    for the WebSocket `HttpClient` instance and `API_CLIENT` for the REST API `HttpClient`
    instance:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们使用 `WEBSOCKET_CLIENT` 常量作为 WebSocket `HttpClient` 实例的限定符，以及 `API_CLIENT`
    作为 REST API `HttpClient` 实例的限定符：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We should also use qualifiers to provide URLs for the WebSocket and for the
    API. Also, it is important to note that these URL values are now being provided
    by a companion object in `ChatModule` for simplification, but a better approach
    would be to have them defined as part of our Gradle file. That way, we will be
    able to override them depending on the build variant (release, debug, test, and
    so on) or flavor.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该使用限定符来提供 WebSocket 和 API 的 URL。此外，重要的是要注意，这些 URL 值现在是由 `ChatModule` 中的伴随对象提供的，以简化流程，但更好的方法是将它们定义为
    Gradle 文件的一部分。这样，我们就可以根据构建变体（发布、调试、测试等）或风味来覆盖它们。
- en: 'Regarding the qualifiers, we also need to indicate in the consumers of these
    dependencies which one should be injected. This will be done using the `@Named`
    annotation in the affected dependencies as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关于限定符，我们还需要在依赖项的消费者中指明应该注入哪一个。这将通过受影响依赖项中的 `@Named` 注解来完成，如下所示：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Also, we have to modify the constructor in `MessagesSocketDataSource` so that
    Hilt knows which one it has to inject:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要修改 `MessagesSocketDataSource` 中的构造函数，以便 Hilt 知道它需要注入哪一个：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have everything ready for our dependencies to be injected the correct
    way, it is time to implement the `ChatRoomRepository` component. We will implement
    it in a similar way that we implemented the `MessagesRepository` component.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为依赖项正确注入做好了准备，是时候实现 `ChatRoomRepository` 组件了。我们将以与实现 `MessagesRepository`
    组件类似的方式来实现它。
- en: 'First, we want to create an interface in our domain package:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想在我们的领域包中创建一个接口：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we will create the actual implementation in the `data.repository` package:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在`data.repository`包中创建实际实现：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we are obtaining the initial chat room information from the data source,
    and then we will map the obtained data model into the domain model.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们从数据源获取初始聊天室信息，然后我们将获取到的数据模型映射到领域模型。
- en: 'Of course, this will not work unless we create the domain model, `ChatRoom`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除非我们创建领域模型`ChatRoom`，否则这不会工作：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we should create the mapping from `ChatRoomModel`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该从`ChatRoomModel`创建映射：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have just added the `toDomain()` function, which will map the data
    object (`ChatRoomModel`) to the domain object (`ChatRoom`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们刚刚添加了`toDomain()`函数，它将数据对象（`ChatRoomModel`）映射到领域对象（`ChatRoom`）。
- en: 'Now, we need to bind the repository interface to its implementation. For that,
    we should add a binding declaration to our Hilt module:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将仓库接口绑定到其实际实现。为此，我们应该在我们的Hilt模块中添加一个绑定声明：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we are saying to Hilt that every time it needs to provide an `IChatRoomRepository`
    dependency, it should provide `ChatRoomRepository`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Hilt，每次它需要提供`IChatRoomRepository`依赖项时，应该提供`ChatRoomRepository`。
- en: 'Now, we have the data source and the repository ready. We will need to implement
    a new use case whose responsibility will be to provide this initial information:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了数据源和仓库。我们需要实现一个新的用例，其责任是提供此初始信息：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we will be calling the repository `getInitialChatRoom()` function, to
    obtain it in the `ChatRoom` model.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将调用仓库的`getInitialChatRoom()`函数，以在`ChatRoom`模型中获取它。
- en: 'We are now arriving at our destination: the `ViewModel`. We need to include
    `GetInitial` **ChatRoomInformation** as a dependency on the `ViewModel`, obtain
    this information when it is initialized, and make it available for the UI to observe
    it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到达了目的地：`ViewModel`。我们需要将`GetInitial` **ChatRoomInformation**作为`ViewModel`的依赖项，在初始化时获取此信息，并使其对UI可用以观察它：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we need to create a new `StateFlow` instance to be consumed by the UI.
    As it is going to hold the state of almost all the UI (except the messages; we
    will talk about this later), we are going to call it `uiState`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的`StateFlow`实例，以便由UI消费。由于它将几乎包含所有UI的状态（除了消息；我们稍后会讨论这一点），我们将称之为`uiState`：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we are going to add a new function to be called upon view initialization:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个在视图初始化时调用的新函数：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we are using `messagesCollectionJob` (we could change its name to make
    it more generic as now it is going to be used by the `messages` collection job
    and the initial data retrieval).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`messagesCollectionJob`（我们可以将其名称改为更通用的名称，因为现在它将被用于`messages`收集作业和初始数据检索）。
- en: Then, we retrieve the initial chat room information, update the `uiState` value,
    and set the messages we are receiving as the first messages in the `messages`
    `StateFlow` object (so that the chat will show the old messages).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检索初始聊天室信息，更新`uiState`值，并将我们接收到的消息设置为`messages` `StateFlow`对象中的第一条消息（这样聊天会显示旧消息）。
- en: Finally, we call the `updateMessages()` function, where we will connect to the
    WebSocket and start getting asynchronous messages.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`updateMessages()`函数，在这里我们将连接到WebSocket并开始获取异步消息。
- en: 'Note that we will also need a `Chat` model that will be our `uiState` instance;
    this model is important as it will be the object consumed from the UI to configure
    it. Add this like so:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要一个`Chat`模型，它将成为我们的`uiState`实例；这个模型很重要，因为它将是UI消费以配置的对象。添加方式如下：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we need to listen to this `uiState` instance from our screen composable
    and update the UI accordingly:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从我们的屏幕组合组件监听这个`uiState`实例，并相应地更新UI：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we can see that we are calling the `loadChatInformation` function as soon
    as the `Composable` component is started. Then, once this information is obtained,
    we would show the name of the participant of the chat in the `TopAppBar` component,
    obtaining this info from the chat initialization. At the same time, the list of
    messages will be updated with the last messages.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们正在调用`loadChatInformation`函数，一旦`Composable`组件启动。然后，一旦获取到这些信息，我们将在`TopAppBar`组件中显示聊天参与者的名称，从聊天初始化中获取这些信息。同时，消息列表将更新为最后一条消息。
- en: 'Usually, it is desirable to encapsulate all the `uiState` properties in a single
    observable value as one of the advantages of Jetpack Compose is that it will handle
    the recomposition when it detects that the values related to a `Composable` component
    have changed. In this case, the criteria followed have been to separate them because
    in reality, the frequency of changes is very different between the two values:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将所有的 `uiState` 属性封装在一个单一的观察值中，作为 Jetpack Compose 优势之一，它将在检测到与 `Composable`
    组件相关的值发生变化时处理重新组合。在这种情况下，遵循的标准是将它们分开，因为实际上，这两个值的变化频率差异很大：
- en: The **uiState** properties are not going to change for the same chat
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uiState** 属性对于相同的聊天不会改变'
- en: The **messages** list is likely to change with a high frequency (every time
    we send and receive a message)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息** 列表很可能会以很高的频率改变（每次我们发送和接收消息时）'
- en: During this section, we have set up our chat initialization, including all the
    components needed for the architecture, from the data source to the `ViewModel`
    changes. Now, it is time we take care of possible errors we could encounter and
    give some resilience to our chat screen.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经设置了我们的聊天初始化，包括架构所需的所有组件，从数据源到 `ViewModel` 的更改。现在，是我们处理可能遇到的可能错误并给我们的聊天屏幕提供一些弹性的时候了。
- en: Handling errors in the WebSocket
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 WebSocket 中的错误
- en: Errors are not unusual, especially in a long-lived connection such as a WebSocket,
    and in such a sensitive environment as a mobile one, it is important to take care
    of these errors because otherwise, our users could stop being able to send or
    receive messages and, in the worst case, have a fatal error that crashes the application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 错误并不罕见，尤其是在像 WebSocket 这样的长期连接中，在一个如此敏感的环境中，如移动环境，处理这些错误非常重要，否则，我们的用户可能无法继续发送或接收消息，在最坏的情况下，可能发生致命错误导致应用程序崩溃。
- en: There are several ways we can control these errors. One of them is to make every
    layer responsible for errors that could happen in its scope and only propagate
    to the UI (or the user knowledge) when the app cannot recover itself from them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以控制这些错误的方式有很多。其中之一是让每一层负责其范围内可能发生的错误，并且只有当应用程序无法从这些错误中恢复时，才将错误传播到 UI（或用户知识）。
- en: 'Here, we could have several errors:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可能会有几个错误：
- en: Connection errors that are recuperable errors and will be handled by a retry
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可恢复的错误连接错误将通过重试来处理
- en: Parsing errors that are likely not recuperable as several retries will not change
    the way the app or the backend are formatting the messages (we cannot do much
    with these kinds of errors, apart from detecting them before deploying the app
    or having analytics tools to detect them)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析错误可能无法恢复，因为多次重试不会改变应用程序或后端格式化消息的方式（对于这些类型的错误，我们除了在部署应用程序之前检测它们或拥有用于检测它们的分析工具之外，无能为力）
- en: 'In this section, we are going to focus on `MessagesSocketDataSource`. If we
    take a look at our `connect` function, we can see it could have some points of
    failure (for example, when initiating the session or when the message received
    is handled). The simplest way to solve this is to wrap those points with `try`-`catch`
    blocks:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注 `MessagesSocketDataSource`。如果我们看一下我们的 `connect` 函数，我们可以看到它可能有一些故障点（例如，在初始化会话或处理收到的消息时）。解决这个问题的最简单方法是将这些点用
    `try`-`catch` 块包装起来：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We need to define also as constants `TAG` (to log messages in Logcat), `MAX_RETRIES`,
    which will be the number of retries we are going to use (because we cannot be
    eternally retrying), and `RETRY_DELAY` (the milliseconds we are going to wait
    between retries):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义常量 `TAG`（用于在 Logcat 中记录消息），`MAX_RETRIES`（我们将要使用的重试次数，因为我们不能永远重试），以及 `RETRY_DELAY`（我们在重试之间等待的毫秒数）：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we are defining these values as constants, so if the WebSocket connection
    fails, we will retry the connection in another 30 seconds (`30000` milliseconds).
    This will occur `5` times before giving up if it doesn’t successfully connect.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将这些值定义为常量，所以如果 WebSocket 连接失败，我们将在 30 秒后（`30000` 毫秒）重试连接。如果它没有成功连接，将会重试
    `5` 次，然后放弃。
- en: Now that our users are receiving messages while using the app, we still need
    to provide a way of notifying them when they receive a new message but are not
    using the app. We can solve this problem by using push notifications.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户在使用应用时正在接收消息，我们仍然需要提供一个方式在用户收到新消息但未使用应用时通知他们。我们可以通过使用推送通知来解决这个问题。
- en: Adding push notifications
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加推送通知
- en: Push notifications are messages that are sent to a user’s device from a server,
    even when the user is not actively using the app. These messages appear as system
    notifications outside of the app and can be used to provide updates, alerts, or
    other relevant information to users.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是从服务器发送到用户设备的消息，即使用户没有积极使用应用。这些消息作为系统通知出现在应用之外，可以用来向用户提供更新、警报或其他相关信息。
- en: To send push notifications, we need to decide which of the available options
    we want to use. The most popular is **Firebase Cloud Messaging** (**FCM**), but
    there are more push notification services such as OneSignal, Pusher, or **Amazon
    Simple Notification Service** (**SNS**). In our case, we are going to take the
    popular route and use FCM.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送推送通知，我们需要决定我们想要使用哪种可用的选项。最受欢迎的是 **Firebase Cloud Messaging**（**FCM**），但还有更多推送通知服务，如
    OneSignal、Pusher 或 **Amazon Simple Notification Service**（**SNS**）。在我们的案例中，我们将走流行的路线并使用
    FCM。
- en: '**Firebase** is a mobile and web application development platform provided
    by Google. It offers a suite of tools, services, and infrastructure designed to
    help developers build, improve, and grow their apps. Some of its features include
    authentication, push notifications, cloud databases, and so on. We are going to
    use it for the last two sections of this chapter.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firebase** 是由 Google 提供的移动和 Web 应用程序开发平台。它提供了一套工具、服务和基础设施，旨在帮助开发者构建、改进和扩展他们的应用。其一些功能包括身份验证、推送通知、云数据库等。我们将使用它来构建本章的最后两个部分。'
- en: To accomplish that, we first need to set up Firebase in our project.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先需要在项目中设置 Firebase。
- en: Setting up Firebase
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Firebase
- en: 'To set up Firebase in our project, we need to follow these steps:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中设置 Firebase，我们需要遵循以下步骤：
- en: Go to the Firebase console ([https://console.firebase.google.com/](https://console.firebase.google.com/))
    and click **Add project**. Then, follow the onscreen instructions to set up your
    project.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Firebase 控制台（[https://console.firebase.google.com/](https://console.firebase.google.com/））并点击
    **添加项目**。然后，按照屏幕上的说明设置您的项目。
- en: In the Firebase console, click on the Android icon to register your app. Enter
    your app’s package name, and optionally, provide the SHA-1 fingerprint for Google
    Sign-In and other authentication features. Click **Register app** to proceed.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Firebase 控制台中，点击 Android 图标以注册您的应用。输入您的应用包名，并且可选地提供 Google Sign-In 和其他身份验证功能的
    SHA-1 指纹。点击 **注册应用** 以继续。
- en: After registering our app, we’ll be prompted to download a **google-services.json**
    file. Download it and place it in the **app** module of our Android project, at
    the root level.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册我们的应用后，我们将被提示下载一个 **google-services.json** 文件。下载它并将其放置在我们的 Android 项目的 **app**
    模块根目录下。
- en: 'Add Firebase SDK dependencies to your project’s **build.gradle** files, like
    so:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Firebase SDK 依赖项添加到项目中的 **build.gradle** 文件中，如下所示：
- en: '[PRE62]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then in the **app** module’s **build.gradle** file where we are going to use
    it (in our case, **:common:data**), we should add these dependencies for the following
    specific Firebase services:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在我们将使用它的 **app** 模块的 **build.gradle** 文件中（在我们的案例中，**:common:data**），我们应该添加以下特定
    Firebase 服务的依赖项：
- en: '[PRE63]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that, as we did with Jetpack Compose dependencies, here we are going to
    use the **Bill of Materials** (**BoM**). The advantage is that we don’t need to
    specify the version of every dependency because the compatible ones will be provided
    by the BoM.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，正如我们处理 Jetpack Compose 依赖项时那样，这里我们将使用 **物料清单**（**BoM**）。其优势在于我们不需要指定每个依赖项的版本，因为兼容的版本将由
    BoM 提供。
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A BoM is a mechanism used in dependency management systems to specify and manage
    the versions of multiple libraries and their transitive dependencies as a single
    entity. It helps simplify dependency management and ensures compatibility between
    different libraries that are part of the same ecosystem or suite.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: BoM 是在依赖管理系统中使用的一种机制，用于指定和管理多个库及其传递依赖项的版本，作为一个单一实体。它有助于简化依赖管理，并确保同一生态系统或套件中的不同库之间的兼容性。
- en: 'Also, in order to facilitate the use of coroutines to handle Firebase tasks,
    we are going to add this extra dependency:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了便于使用协程来处理 Firebase 任务，我们将添加这个额外的依赖项：
- en: '[PRE64]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, before we can receive a push notification, we need to identify our user.
    We do that by sending their token to Firebase.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们能够接收推送通知之前，我们需要识别我们的用户。我们通过将他们的令牌发送到 Firebase 来做到这一点。
- en: Sending the FCM token to Firebase
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 FCM 令牌发送到 Firebase
- en: To identify our users and send notifications specifically to them using FCM,
    we need to use FCM **tokens**. Each user is assigned a unique FCM token, which
    is used to send notifications to their devices. This token should be obtained
    and updated every time the user signs in or when the app starts.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用FCM识别我们的用户并向他们发送特定通知，我们需要使用FCM **令牌**。每个用户都被分配了一个唯一的FCM令牌，用于向他们的设备发送通知。此令牌应在用户登录或应用程序启动时获取和更新。
- en: 'We can obtain the FCM token by calling the `getToken()` method from the `FirebaseMessaging`
    class. To do that, we are going first to create a data source that will wrap the
    token-handling functionality:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`FirebaseMessaging`类中调用`getToken()`方法来获取FCM令牌。为此，我们首先将创建一个数据源，该数据源将包装令牌处理功能：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we are injecting the `FirebaseMessaging` instance and obtaining the FCM
    token from Firebase.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在注入`FirebaseMessaging`实例并从Firebase获取FCM令牌。
- en: 'Now, we need this FCM to be stored somewhere so that when a new message is
    sent to our users, we know which token is associated with them. There is no standard
    way to store it. Usually, this will be handled in the backend, which is far from
    the scope of this book. But we can prepare the app components needed. We are going
    to create a use case that would be the orchestrator of obtaining and then sending
    the FCM to be stored in the backend. This use case will need a repository to do
    both tasks: obtaining the token and storing it in our systems.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这个FCM存储在某个地方，以便当向我们的用户发送新消息时，我们知道哪个令牌与他们相关联。没有标准的存储方式。通常，这将在后端处理，但这本书的范围之外。但我们可以准备应用程序组件。我们将创建一个用例，该用例将作为获取并随后将FCM存储在后端的协调器。这个用例将需要一个存储库来完成这两个任务：获取令牌并将其存储在我们的系统中。
- en: 'As always, create the interface for our repository in the domain layer (in
    this case, in the `:``common:domain` module):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在领域层（在这种情况下，在`:common:domain`模块）为我们的存储库创建接口：
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we will create the repository implementation in the data layer (`:common:data`):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在数据层创建存储库实现（`:common:data`）：
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will use this repository to obtain the token from Firebase. As said before,
    we also need to store the token somewhere, so we will create another repository
    for that:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个存储库从Firebase获取令牌。如前所述，我们还需要将令牌存储在某个地方，因此我们将为该目的创建另一个存储库：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will again leave the implementation empty as it is outside our scope. The
    relevant bit to understand here is that the token should be stored so that later,
    when our user receives a message, we can identify the token and send a push notification
    to the related device.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次留空实现，因为它超出了我们的范围。这里需要理解的相关点是令牌应该被存储，以便稍后当我们的用户收到消息时，我们可以识别令牌并向相关设备发送推送通知。
- en: 'In the next code block, we can see how we are implementing the aforementioned
    interface, where you will provide the means to store the data source of your preference:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们可以看到我们如何实现上述接口，其中您将提供存储您首选数据源的方法：
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that we have the token sorted, we need to prepare our app to receive push
    notifications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了令牌问题，我们需要准备我们的应用程序以接收推送通知。
- en: Preparing the app to receive push notifications
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备应用程序接收推送通知
- en: Push notifications are messages that pop up on a mobile device. They are especially
    useful when the user is not actively using the application and we need to call
    their attention. In this section, we are going to make our app capable of receiving
    them when a new message is received.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是在移动设备上弹出的消息。当用户没有积极使用应用程序而我们需要引起他们的注意时，它们特别有用。在本节中，我们将使我们的应用程序能够在收到新消息时接收它们。
- en: 'To start receiving push notifications, we need to make some modifications to
    our existing code first. For example, we have to think about what would we expect
    to happen if the user clicks on a notification: we may want it to open the `ChatScreen`
    component related to the message notification. Let’s start with those changes.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始接收推送通知，我们首先需要对现有代码进行一些修改。例如，我们必须考虑如果用户点击通知会发生什么：我们可能希望它打开与消息通知相关的`ChatScreen`组件。让我们从这些更改开始。
- en: To open the `ChatScreen` component directly, we will need to create a link that
    tells the system that it should open our application showing the `ChatScreen`
    component. This link is called a deep link.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接打开`ChatScreen`组件，我们需要创建一个链接，告诉系统它应该打开显示`ChatScreen`组件的应用程序。这个链接被称为深度链接。
- en: A **deep link** is a type of link that directs a user to a specific piece of
    content or page within an Android application rather than just launching the application.
    Deep links are used to provide a more seamless user experience by allowing users
    to jump directly to a particular function, feature, or piece of content within
    an app from a website, another app, or even a simple text message or email.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度链接**是一种将用户引导到Android应用中特定内容或页面的链接，而不仅仅是启动应用。深度链接通过允许用户从网站、另一个应用，甚至简单的文本消息或电子邮件直接跳转到应用中的特定功能、功能或内容，从而提供更流畅的用户体验。'
- en: 'To create our deep link, we are going to create an object called `DeepLinks`
    in the `:common:framework` module to organize all the deep links we are going
    to use in our application:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的深度链接，我们将在`:common:framework`模块中创建一个名为`DeepLinks`的对象，以组织我们在应用中将要使用的所有深度链接：
- en: '[PRE70]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we need to modify our `NavHost` component– once the application receives
    an intent with this deep comlink, the app should navigate to the `ChatScreen`
    component. To accomplish that, we need to add a `Deeplink` instance as an option
    for the `ChatScreen` navigation graph in `WhatsPacktNavigation`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要修改我们的`NavHost`组件——一旦应用接收到带有此深度comlink的intent，应用应导航到`ChatScreen`组件。为了实现这一点，我们需要在`WhatsPacktNavigation`中将`Deeplink`实例作为`ChatScreen`导航图的一个选项添加：
- en: '[PRE71]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we are adding the deep link pattern that we have in our `DeepLinks` object
    to be included as one of the route options for our `ChatScreen` component.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们`DeepLinks`对象中已有的深度链接模式添加为`ChatScreen`组件的路线选项之一。
- en: 'Then, we need to implement a `FirebaseMessagingService` function that will
    catch all the push notifications that we receive and will allow us to define a
    channel where notifications will be posted and handled by the Android system,
    ultimately showing them to the user (if the user has given our app permissions
    to do that):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现一个`FirebaseMessagingService`函数，该函数将捕获我们收到的所有推送通知，并允许我们定义一个通知将被发布并由Android系统处理，最终显示给用户（如果用户已授予我们的应用执行此操作的权限）：
- en: '[PRE72]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we are extracting some information from the message received, such as
    `senderName`, `messageContent`, `chatId`, and so on. Ideally, we could obtain
    the information we want to show in the notification.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从收到的消息中提取一些信息，例如`senderName`、`messageContent`、`chatId`等。理想情况下，我们可以获取我们想要在通知中显示的信息。
- en: This is just an example, though – the information structure would depend on
    the payload contract we already defined with the backend implementation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个示例，但信息结构将取决于我们与后端实现已定义的负载合同。
- en: 'Once we have extracted this information, we need to show the notification:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了这些信息，我们需要显示通知：
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: First, we create a `NotificationChannel` instance, then the elements we need
    for our notification (such as `PendingIntent`, which will be used when the user
    clicks on the notification), and then the notification itself (using `NotificationCompat`).
    Finally, we use `NotificationManager` to notify our notification to the system.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`NotificationChannel`实例，然后是通知所需的元素（例如`PendingIntent`，当用户点击通知时将使用），然后是通知本身（使用`NotificationCompat`）。最后，我们使用`NotificationManager`将通知通知给系统。
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Creating a **NotificationChannel** instance is necessary for Android 8.0 (API
    level 26) and higher, as it provides users with better control over the app’s
    notifications. Each **NotificationChannel** instance represents a unique category
    of notifications that an app can display, and users can modify the settings for
    each channel independently. This enables users to customize the behavior of your
    app’s notifications based on their preferences.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 8.0（API级别26）及更高版本中，创建一个**NotificationChannel**实例是必要的，因为它为用户提供了对应用通知的更好控制。每个**NotificationChannel**实例代表应用可以显示的通知的独特类别，用户可以独立修改每个通道的设置。这使得用户可以根据他们的偏好自定义应用通知的行为。
- en: For example, users can set the importance level, enable/disable sound, or set
    a custom vibration pattern for each channel. They can also block an entire channel
    so that they no longer receive notifications from that specific category.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可以为每个通道设置重要性级别、启用/禁用声音或设置自定义振动模式。他们还可以阻止整个通道，这样他们就不会再收到该特定类别的通知。
- en: When you create a **NotificationChannel** instance, you need to set an importance
    level, which determines how the system presents notifications from that channel
    to the user. The importance levels range from high (urgent and makes a sound)
    to low (no sound or visual interruption).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 **NotificationChannel** 实例时，你需要设置一个重要性级别，这决定了系统如何向用户展示该渠道的通知。重要性级别从高（紧急并有声音）到低（无声音或视觉干扰）不等。
- en: 'The last step is to add our service to the `AndroidManifest.xml` file, inside
    the `application` tag:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们的服务添加到 `AndroidManifest.xml` 文件中的 `application` 标签内：
- en: '[PRE74]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: And with that, we have our app ready to receive push notifications.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的应用程序就准备好接收推送通知了。
- en: In the next section, we are going to see how after all the work we have done
    to keep our code scalable and decoupled, we can easily use Firebase instead of
    the WebSocket to send and receive messages.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到在完成所有使我们的代码可扩展和松耦合的工作之后，我们可以轻松地使用 Firebase 而不是 WebSocket 来发送和接收消息。
- en: Replacing the Websocket with Firestore
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 Firestore 替换 Websocket
- en: As we saw in the previous section, Firebase is a powerful product that simplifies
    the implementation of the backend for our apps. Now, we are going to see how we
    can use it also to simplify the chat messages feature.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，Firebase 是一个强大的产品，它简化了我们应用程序后端的实现。现在，我们将看到我们如何使用它来简化聊天消息功能。
- en: What is Firestore?
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Firestore？
- en: '**Firestore**, more formally known as Cloud Firestore, is a flexible, scalable,
    and real-time NoSQL database provided by Firebase. Firestore is designed to store
    and sync data for client-side applications, making it an ideal choice for building
    modern, data-driven applications.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firestore**，更正式地称为 Cloud Firestore，是由 Firebase 提供的一个灵活、可扩展的实时 NoSQL 数据库。Firestore
    设计用于存储和同步客户端应用程序的数据，使其成为构建现代、数据驱动应用程序的理想选择。'
- en: One of its most important features is the real-time data synchronization. Firestore
    automatically synchronizes data in real time across all connected clients, ensuring
    that your application’s data is always up to date. This is especially useful for
    applications requiring real-time collaboration or live updates, such as our chat
    app.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最重要的功能之一是实时数据同步。Firestore 会自动在所有连接的客户端之间实时同步数据，确保您的应用程序数据始终保持最新。这对于需要实时协作或实时更新的应用程序特别有用，例如我们的聊天应用。
- en: It is important to note that as a NoSQL database, we would have first to define
    the data structure. How are we to structure our documents? Well, let’s start with
    that.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，作为一个 NoSQL 数据库，我们首先需要定义数据结构。我们如何构建我们的文档？好吧，让我们从那开始。
- en: Chat data structure
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天数据结构
- en: 'To handle chat messages in Firestore NoSQL, we can use the following structure:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Firestore NoSQL 中处理聊天消息，我们可以使用以下结构：
- en: Create a collection called **chats**. Each document in this collection will
    represent a chat room or conversation between users. The document ID can be generated
    automatically by Firestore or created using a custom method (for example, a combination
    of user IDs). Here, we can include common data that we need for the conversation
    (think about our **ChatRoom** model), such as the user’s name, avatars, and so
    on...
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 **chats** 的集合。这个集合中的每个文档将代表用户之间的聊天室或对话。文档 ID 可以由 Firestore 自动生成，或者使用自定义方法（例如，用户
    ID 的组合）创建。在这里，我们可以包括我们需要的对话的常见数据（例如我们的 **ChatRoom** 模型），如用户的姓名、头像等...
- en: For each chat document, create a subcollection called **messages**. This subcollection
    will store the individual messages for that chat room or conversation.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个聊天文档，创建一个名为 **messages** 的子集合。这个子集合将存储该聊天室或对话中的单个消息。
- en: Each document in the **messages** subcollection will represent a single message.
    The structure of a message document might include fields such as **senderId**,
    **senderName**, **content**, and **timestamp**.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**messages** 子集合中的每个文档将代表一条单独的消息。消息文档的结构可能包括 **senderId**（发送者 ID）、**senderName**（发送者姓名）、**content**（内容）和
    **timestamp**（时间戳）等字段。'
- en: 'Following that, our structure will look like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们的结构将如下所示：
- en: '[PRE75]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: One important aspect is that, ideally, we should have authentication set up
    to identify our users. We will learn how to build it in [*Chapter 7*](B19443_07.xhtml#_idTextAnchor142),
    but for now, we are assuming that our users will be authenticated in Firebase.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的方面是，理想情况下，我们应该设置身份验证来识别我们的用户。我们将在 [*第 7 章*](B19443_07.xhtml#_idTextAnchor142)
    中学习如何构建它，但到目前为止，我们假设我们的用户将在 Firebase 中进行身份验证。
- en: 'Assuming that our chat will be used by authenticated users, we can limit and
    restrict access to the chat collection for modifications only for users who have
    already been authenticated. To accomplish that, we can define a set of rules in
    Firestore, using the Firebase console. Here is an example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的聊天将由认证用户使用，我们可以限制和限制对聊天集合的修改访问权限，仅限于已经认证的用户。为了实现这一点，我们可以在 Firestore 中定义一组规则，使用
    Firebase 控制台。以下是一个示例：
- en: '[PRE76]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now that we have defined these rules, we can switch to our Android app code
    and create a `FirestoreMessagesDataSource` class.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了这些规则，我们可以切换到我们的 Android 应用代码并创建一个 `FirestoreMessagesDataSource` 类。
- en: Creating a FirestoreMessagesDataSource class
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 FirestoreMessagesDataSource 类
- en: 'The first step to creating the `FirestoreMessagesDataSource` class is to create
    the model that we are going to use to serialize the documents. This model has
    to include the same fields we included when we designed the `Message` document
    structure:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `FirestoreMessagesDataSource` 类的第一步是创建我们将用于序列化文档的模型。这个模型必须包括我们在设计 `Message`
    文档结构时包含的相同字段：
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that we are including a field called `id` that has the `@Transient` annotation
    – this field will store the document `id` value (that for us will be the unique
    identification for the message as every message has its own document). The reason
    we have to put the `@Transient` annotation is to avoid this `id` field being stored
    in the document itself when writing in Firestore.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们包括了一个名为 `id` 的字段，它带有 `@Transient` 注解——这个字段将存储文档 `id` 值（对我们来说，这将作为消息的唯一标识，因为每条消息都有自己的文档）。我们必须放置
    `@Transient` 注解的原因是避免在将数据写入 Firestore 时，这个 `id` 字段被存储在文档本身中。
- en: 'Now, as we did with the `MessagesSocketDataSource` class, we need to convert
    this data model into the domain model. We already have the `messages` domain model,
    so, in this case, we only have to implement the function to convert the `FirestoreMessageModel`
    data class into our `Message` domain model:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们处理 `MessagesSocketDataSource` 类一样，我们需要将这个数据模型转换为域模型。我们已经有 `messages`
    域模型了，所以在这种情况下，我们只需要实现将 `FirestoreMessageModel` 数据类转换为我们的 `Message` 域模型的函数：
- en: '[PRE78]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this case, we are supposing we are only going to have text messages (no images)
    for simplification. However, it could have been easily done by including a field
    in the `Firestore` model indicating the type of message. Almost all the mapping
    between properties is straightforward, with the exception of the timestamp. In
    the `Message` model, we are expecting a `String` object with the date and time,
    and we are getting a `Timestamp` object from Firestore. So, we are using the `Timestamp.toDateString()`
    extension to obtain the formatted `String` object from the `Timestamp` object.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设我们只会有文本消息（没有图片）以简化问题。然而，通过在 `Firestore` 模型中包含一个字段来指示消息类型，这可以很容易地完成。几乎所有的属性映射都是直接的，除了时间戳。在
    `Message` 模型中，我们期望一个包含日期和时间的 `String` 对象，而我们从 Firestore 获取的是一个 `Timestamp` 对象。因此，我们使用
    `Timestamp.toDateString()` 扩展从 `Timestamp` 对象中获取格式化的 `String` 对象。
- en: 'Also, as we would want to send messages too, we need to convert a domain `Message`
    object into the data object:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们还想要发送消息，所以我们需要将域 `Message` 对象转换为数据对象：
- en: '[PRE79]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that we are not setting the timestamp (it will be created when the object
    is created), and the `id` field doesn’t have a real value (as it won’t be stored
    in Firestore).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有设置时间戳（它将在对象创建时自动生成），并且 `id` 字段没有实际的值（因为它不会被存储在 Firestore 中）。
- en: 'Now, we can proceed with the `FirestoreMessagesDataSource` implementation.
    First, we define the class and its dependency:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行 `FirestoreMessagesDataSource` 的实现。首先，我们定义类及其依赖项：
- en: '[PRE80]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, we are going to add a `getMessages` function, to obtain chat messages:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个 `getMessages` 函数，以获取聊天消息：
- en: '[PRE81]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Inside this function, we will get a reference to the `messages` subcollection
    inside the specified chat:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们将获取指定聊天中的 `messages` 子集合的引用：
- en: '[PRE82]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we will create a query to get the messages ordered by timestamp (ascending):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个查询以按时间戳（升序）获取消息：
- en: '[PRE83]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the next step, we add a snapshot listener to the query to listen for real-time
    updates. Every time a document in the messages is added, we will get a snapshot
    of the changed document there so that we can emit it through the flow to the consumers
    connected (in our case, `MessagesRepository`):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们向查询添加一个快照监听器以监听实时更新。每当消息中的文档被添加时，我们都会在那里获取已更改文档的快照，以便我们可以通过流将其发射给连接的消费者（在我们的案例中，是
    `MessagesRepository`）：
- en: '[PRE84]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Just before sending the new messages through the flow, we need to map them
    to their domain counterpart and provide their ID. Also, `userId` will be needed
    to identify if the user has written the new message or if it is written by the
    other user in the conversation:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过流发送新消息之前，我们需要将它们映射到它们的领域对应物并提供它们的 ID。此外，`userId` 将被需要以确定是新用户编写了新消息，还是其他用户在对话中编写了消息：
- en: '[PRE85]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we can send the list of messages to `Flow`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将消息列表发送到 `Flow`：
- en: '[PRE86]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the case `Flow` is no longer needed, we should remove the snapshot listener:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要 `Flow`，我们应该移除快照监听器：
- en: '[PRE87]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We also need to add a function to send messages. To send a message, we will
    simply add it to the `messages` collection in the document with the `chatId` value
    of the related conversation:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个发送消息的功能。要发送消息，我们只需将其添加到具有相关对话 `chatId` 值的文档中的 `messages` 集合：
- en: '[PRE88]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we need to replace our previous `MessagesSocketDataSource` instance in
    `MessagesRepository` with `FirestoreMessagesDataSource`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要用 `FirestoreMessagesDataSource` 替换 `MessagesRepository` 中的先前 `MessagesSocketDataSource`
    实例：
- en: '[PRE89]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: And with some minor changes, we will have integrated this new provider. The
    good thing is that, as we have been working following a Clean Architecture, with
    mappings between layers, we don’t have to change anything in other layers; for
    example, in `Usecases`, `ViewModel`, or the UI (apart from providing the `chatId`
    value and the `userId` value when calling the `getMessages` and `sendMessage`
    methods).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些小的修改，我们将集成这个新的提供者。好事是，因为我们一直在遵循 Clean Architecture 的工作方式，并且层与层之间存在映射，所以我们不需要在其他层中进行任何更改；例如，在
    `Usecases`、`ViewModel` 或 UI（除了在调用 `getMessages` 和 `sendMessage` 方法时提供 `chatId`
    值和 `userId` 值之外）。
- en: We could also have the two data sources living together in the same app (one
    as a fallback of the other), as the role of the repository is to serve as an orchestrator
    of the different data sources for a certain entity (in this case, the messages).
    We will see more about this in the next chapter as we will want to add local storage
    to our messages.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让两个数据源在同一个应用中共同存在（一个作为另一个的备用），因为仓库的作用是作为某个实体（在这种情况下，是消息）的不同数据源的协调者。我们将在下一章中了解更多关于这一点，因为我们将想要为我们的消息添加本地存储。
- en: Summary
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various aspects of building a messaging app for
    Android. We discussed different approaches for sending and receiving messages,
    such as using WebSockets with Ktor or Firebase Firestore. We also covered how
    to structure the app using Clean Architecture principles, with separate layers
    for data, domain, and presentation, to ensure a well-organized and maintainable
    code base, and saw how easy is to introduce changes (for example, a change in
    the messages provider) if our architecture components are well decoupled.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为 Android 构建消息应用的各个方面。我们讨论了发送和接收消息的不同方法，例如使用 Ktor 的 WebSockets 或 Firebase
    Firestore。我们还介绍了如何使用 Clean Architecture 原则来构建应用，包括数据、领域和展示的独立层，以确保代码库的井然有序和易于维护，并展示了如何容易地引入更改（例如，消息提供者的更改），如果我们的架构组件很好地解耦。
- en: Then, we delved into handling connection errors and synchronization issues using
    Kotlin coroutines and Flow, implementing error handling and retry mechanisms for
    a seamless user experience. Additionally, we examined the importance of push notifications
    in messaging apps and demonstrated their implementation using FCM, from setting
    up FCM in a project to handling incoming notifications.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了使用 Kotlin coroutines 和 Flow 处理连接错误和同步问题，实现了错误处理和重试机制，以确保无缝的用户体验。此外，我们还探讨了推送通知在消息应用中的重要性，并展示了如何使用
    FCM 实现其功能，从在项目中设置 FCM 到处理传入的通知。
- en: By the end of this chapter, you should have a comprehensive understanding of
    the components and techniques required to build a robust real-time messaging app
    on Android.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对构建一个健壮的实时消息应用所需的组件和技术有一个全面的理解。
- en: Now, let’s move on to learn how we can optimize our WhatsPackt app so that we
    can back up messages.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何优化我们的 WhatsPackt 应用，以便我们可以备份消息。
