- en: Chapter 9. Importance of Immutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 不可变性的重要性
- en: In object-oriented and functional programming, immutable objects are objects
    whose state cannot be changed or altered after they are initiated. Therefore,
    a mutable object stays the same until the end of its life cycle, when it is deinitialized.
    In contrast, a mutable object can be altered countless times by other objects
    after it is initiated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象和函数式编程中，不可变对象是在初始化后其状态不能被改变或修改的对象。因此，可变对象在其生命周期结束时保持不变，此时它被解除初始化。相比之下，可变对象在初始化后可以被其他对象无数次地更改。
- en: Immutable objects improve readability and runtime efficiency and using them
    simplifies our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象提高了可读性和运行时效率，使用它们简化了我们的应用程序。
- en: 'This chapter will cover the concept of immutability by discussing the following
    topics with coding examples:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过讨论以下主题并附带代码示例来介绍不可变性的概念：
- en: Immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: The benefits of immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性的好处
- en: Cases for mutability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性的案例
- en: An example with approach comparisons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与方法比较的示例
- en: Side-effects and unintended consequences
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用和意外后果
- en: Testability
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试性
- en: Copy constructors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: Lenses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头
- en: Immutability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: An immutable object is an object whose state cannot be modified after it is
    initiated. This quality of immutable objects is essential in multithreaded applications
    because it allows a thread to act on the data represented by immutable objects
    without worrying about changes from other threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是在初始化后其状态不能被修改的对象。不可变对象这一特性在多线程应用程序中至关重要，因为它允许一个线程在不担心其他线程更改的情况下操作由不可变对象表示的数据。
- en: An object is considered immutable if the object itself, and in fact all of its
    properties, are immutable. In some cases, an object is considered immutable even
    if some of its internal properties change but the object's state appears to be
    immutable from an external point of view. For instance, an object that uses the
    memoization technique to cache the results of resource-greedy calculations can
    be considered as an immutable object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象及其所有属性都是不可变的，则认为该对象是不可变的。在某些情况下，即使某些内部属性发生变化，但对象的状态从外部看起来是不可变的，这样的对象也被认为是不可变的。例如，使用缓存技术来缓存资源密集型计算结果的对象可以被视为不可变对象。
- en: 'Immutable objects have the following features:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象具有以下特性：
- en: They are simple to construct, test, and use
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于构建、测试和使用
- en: They are simple to understand and reason about
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于理解和推理
- en: They are inherently thread-safe and have no synchronization issues
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们天生是线程安全的，没有同步问题
- en: They do not require a copy constructor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要复制构造函数
- en: They always have failure atomicity so if an immutable object throws an exception,
    it will not be stuck in an undesirable/indeterminate state
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们总是具有失败原子性，所以如果不可变对象抛出异常，它将不会陷入不希望/不确定的状态
- en: They offer higher security
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供更高的安全性
- en: Immutable variables
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变变量
- en: In the imperative programming style, values held in application variables whose
    contents never change are known as constants to differentiate them from variables
    that could be altered during execution. Examples might include a view's height
    and width or the value of Π to several decimal places.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程风格中，应用变量中保持不变的内容被称为常量，以区分那些在执行过程中可能被更改的变量。例如，可能包括视图的高度和宽度或π的几位小数值。
- en: 'Unlike programming languages such as Objective-C in which some types are mutable
    and some are not, Swift provides a way to create an immutable or mutable version
    of the same type. In Swift, we use the `let` and `var` keywords to create and
    store values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C等编程语言不同，其中一些类型是可变的，而另一些不是，Swift提供了一种创建同一类型不可变或可变版本的方法。在Swift中，我们使用`let`和`var`关键字来创建和存储值：
- en: The `var` keyword is used to create a variable that can be altered later, in
    other words, to create mutable variables
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 关键字用于创建可以稍后更改的变量，换句话说，用于创建可变变量'
- en: The `let` keyword is used to create a constant that cannot be altered later,
    in other words, immutable variables or constants
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 关键字用于创建不能稍后更改的常量，换句话说，不可变变量或常量'
- en: Therefore, in Swift, we do not need to have any type such as `NSMutableArray`
    opposed to `NSArray` or `NSMutableDictionary` opposed to `NSDictionary` to differentiate
    between mutability and immutability. We can simply define `Dictionary` with `var`
    or `let` to make it mutable or immutable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Swift中，我们不需要有像`NSMutableArray`与`NSArray`或`NSMutableDictionary`与`NSDictionary`这样的类型来区分可变性和不可变性。我们可以简单地使用`var`或`let`来定义`Dictionary`，使其可变或不可变。
- en: In addition, the Swift compiler always suggests and warns us about variables
    that are not changed and will be converted to constants later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Swift编译器总是建议并警告我们那些未更改且将来将被转换为常量的变量。
- en: Weak versus strong immutability
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱不可变与强不可变
- en: Sometimes, certain properties of an object can be immutable while the others
    may be mutable. These types of objects are called weakly immutable. Weak immutability
    means that we cannot change the immutable parts of the object state even though
    other parts of the object may be mutable. If all properties are immutable, then
    the object is immutable. If the whole object cannot be mutated after its creation,
    the object is called strongly immutable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个对象的一些属性可能是不可变的，而其他属性可能是可变的。这类对象被称为弱不可变对象。弱不可变性意味着即使对象的其他部分可能是可变的，我们也不能更改对象状态中的不可变部分。如果所有属性都是不可变的，那么该对象就是不可变的。如果对象创建后整个对象都不能被修改，则该对象被称为强不可变对象。
- en: Reference types versus value types
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型与值类型
- en: We covered this topic in a previous chapter, but it is important to emphasize
    that in most **object-oriented programming** (**OOP**) languages, instances can
    be shared and objects can be passed around with their references. This is true
    for Swift classes and closures as well. In those cases, it is important to understand
    that the state of an object can be altered when objects are shared via references.
    In other words, in case any user of a reference to a mutable object changes the
    object, all other users of that object will be affected by the change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经讨论了这个问题，但重要的是要强调，在大多数面向对象编程（OOP）语言中，实例可以被共享，对象可以通过它们的引用传递。Swift类和闭包也是如此。在这些情况下，重要的是要理解，当对象通过引用共享时，对象的状态可能会被改变。换句话说，如果任何用户更改了可变对象的引用，所有其他使用该对象的用户都将受到影响。
- en: The benefits of immutability
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性的好处
- en: We already know that immutability helps safety and performance, but in real-world
    application development, immutability can provide us with more benefits, which
    will be explained in the following sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道不可变性有助于安全性和性能，但在实际应用开发中，不可变性可以为我们带来更多的好处，这将在以下章节中解释。
- en: Thread safety
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Immutable objects are useful in multithreaded applications because multiple
    threads can act on the data of immutable objects without worrying about changes
    to the data by other threads.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，不可变对象非常有用，因为多个线程可以操作不可变对象的数据，而不用担心其他线程对数据所做的更改。
- en: As immutable objects are closed to change, it is safe to assume that they will
    stay unchanged while we access the object from different threads. This assumption
    simplifies most of the multithreading problems that are complex to solve and maintain.
    For instance, we do not need to think about the synchronization/locking mechanism
    at all.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变对象几乎不可更改，因此我们可以安全地假设在从不同线程访问对象时它们将保持不变。这个假设简化了大多数复杂且难以解决和维护的多线程问题。例如，我们根本不需要考虑同步/锁定机制。
- en: 'Suppose that we have a mutable object that includes a mutable array of a type,
    for example, a `Product` class that has four properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含可变数组类型的可变对象，例如，一个具有四个属性的`Product`类：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As seen from the preceding example, all properties are defined as mutable.
    Now let''s create an array of `Product`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，所有属性都被定义为可变的。现在让我们创建一个`Product`类型的数组：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Suppose that we need the `products` array to be shared between different threads.
    Different threads may change the array in different ways. Some may change the
    price while others may change the quantity. Some may add or remove items from
    the array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要`products`数组在不同的线程之间共享。不同的线程可能会以不同的方式更改数组。有些人可能会更改价格，而其他人可能会更改数量。有些人可能会向数组中添加或删除项目。
- en: The first issue to solve is keeping track of changes and knowing who changes
    the array and when. This is already complex, so let's simplify the issue and only
    add an item to the array. Also, let's assume that we are only interested in the
    latest change.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的首要问题是跟踪更改并知道谁更改了数组以及何时更改。这已经很复杂了，所以让我们简化问题，只向数组添加一个项目。此外，让我们假设我们只对最新的更改感兴趣。
- en: 'To be able to track the latest change, let''s create another object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟踪最新的更改，让我们创建另一个对象：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ProductTracker` class has an array of `products` and a `lastModified`
    variable to track the latest change. In addition, it has three methods: one to
    add a new product to the array, another to retrieve the last modification date,
    and the last one to retrieve the product list.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductTracker`类有一个`products`数组和一个`lastModified`变量来跟踪最新的更改。此外，它有三个方法：一个用于向数组中添加新产品，另一个用于检索最后修改日期，最后一个用于检索产品列表。'
- en: Suppose that we want to make our `ProductTracker` class thread-safe and allow
    multiple objects to access our `ProductTracker` object. We cannot allow multiple
    threads execute `addNewProduct` while multiple others list products. First of
    all, we will need a locking mechanism to lock the class during the modifications,
    second, we need to protect `lastModified` against modification without locking,
    and finally, an unlocking mechanism.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使我们的`ProductTracker`类线程安全，并允许多个对象访问我们的`ProductTracker`对象。我们不能允许多个线程同时执行`addNewProduct`，同时其他线程列出产品。首先，我们需要一个锁定机制来锁定类在修改期间，其次，我们需要保护`lastModified`不被锁定修改，最后，需要一个解锁机制。
- en: Apple provides multiple multithreading mechanisms such as `NSThread`, Grand
    Central Dispatch (GCD), and operation queues to overcome these types of issues
    but still multithreading remains complex.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了多种多线程机制，如`NSThread`、Grand Central Dispatch (GCD)和操作队列，以克服这些问题，但多线程仍然复杂。
- en: Referential transparency
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Referential transparency generally means that we can always replace a function
    with its return value without an effect on the application's behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性通常意味着我们可以始终用函数的返回值替换函数，而不会影响应用程序的行为。
- en: Referential transparency is a guarantee of code reusability. Also, it denies
    the mutable state of data. In the case of a mutable state, two calls of the same
    function can potentially produce two different results, which is very difficult
    to test and maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性是代码可重用性的保证。它还否认了数据可变状态的存在。在可变状态的情况下，同一函数的两次调用可能产生两个不同的结果，这非常难以测试和维护。
- en: Low coupling
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低耦合
- en: Coupling is the measure of code dependency. We always want to reduce coupling
    and make our code components independent of each other as much as possible. Low
    coupling allows us to change the component without affecting other code components.
    The low-coupled code is easier to read because each component has its own, relatively
    small area of responsibility, though we need to understand only this code without
    spending time on figuring out how the entire system works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是代码依赖性的度量。我们总是希望尽可能减少耦合，并使我们的代码组件尽可能独立。低耦合允许我们更改组件而不影响其他代码组件。低耦合的代码更容易阅读，因为每个组件都有其相对较小的责任区域，尽管我们只需要理解这部分代码，而不必花时间弄清楚整个系统是如何工作的。
- en: Immutability helps achieving low coupling. Immutable data can be safely passed
    through different code blocks without worrying about it being transformed and
    causing effects on other parts of the code. Pure functions transform the data
    and return the result without affecting the input data. So, if the function contains
    errors, we can easily find it. Also, using value types and immutable data structures
    means that we can significantly reduce object referencing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性有助于实现低耦合。不可变数据可以安全地通过不同的代码块，无需担心其被转换并影响代码的其他部分。纯函数转换数据并返回结果，而不影响输入数据。因此，如果函数包含错误，我们可以轻松找到它。此外，使用值类型和不可变数据结构意味着我们可以显著减少对象引用。
- en: 'The following shows the data transformation idea. We have immutable array numbers,
    and we need the sum of all the even numbers that it contains:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了数据转换的想法。我们有一个不可变数组`numbers`，我们需要计算它包含的所有偶数的总和：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `numbers` array is not changed and can be passed to any other function
    without any side-effects:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers`数组没有改变，可以传递给任何其他函数而不会产生任何副作用：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using in-place transformation of the immutable data will help us reduce coupling.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变数据的就地转换可以帮助我们减少耦合。
- en: Avoiding temporal coupling
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免时间耦合
- en: 'Suppose that we have a code statement that is dependent on another code statement,
    as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个依赖于另一个代码语句的代码语句，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code example, we set two different HTTP requests. Suppose
    that we do not need our first request anymore and we delete the following code
    block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们设置了两个不同的HTTP请求。假设我们不再需要第一个请求，我们删除以下代码块：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler will not complain but as we deleted `request.httpMethod = "GET"`, our
    second request is not going to work. This situation is called temporal coupling.
    If we had immutable definitions with `let`, we would avoid temporal coupling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会抱怨，但因为我们删除了`request.httpMethod = "GET"`，我们的第二个请求将无法工作。这种情况被称为时间耦合。如果我们使用`let`的不可变定义，我们就可以避免时间耦合。
- en: Avoiding identity mutability
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免身份可变性
- en: We may need objects to be identical if their internal states are the same. When
    modifying the state of an object, we are not expecting it to change its identity.
    Immutable objects avoid this completely.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的内部状态相同，我们可能需要对象是相同的。当修改对象的状态时，我们并不期望它改变其身份。不可变对象完全避免了这个问题。
- en: Failure atomicity
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败原子性
- en: A class can be left in a broken state if it throws a runtime exception. Immutability
    prevents this problem. An object will never be left in a broken state because
    its state is modified only during its initialization. The initialization will
    either fail, rejecting object initialization, or succeed, making a valid solid
    object, which never changes its encapsulated state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类抛出运行时异常，它可能会处于损坏状态。不可变性防止了这个问题。由于对象的状态仅在初始化期间修改，因此对象永远不会处于损坏状态。初始化要么失败，拒绝对象初始化，要么成功，创建一个有效的坚固对象，该对象永远不会改变其封装的状态。
- en: Parallelization
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化
- en: Immutability makes it easier to parallelize code execution as there are no conflicts
    among objects and instances.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性使得并行化代码执行更容易，因为对象和实例之间没有冲突。
- en: Exception handling and error management
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理和错误管理
- en: If we use immutable types only, the internal state of our application will be
    consistent even if we have exceptions because our immutable objects do not maintain
    different states.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用不可变类型，即使有异常，我们应用程序的内部状态也将保持一致，因为我们的不可变对象不会保持不同的状态。
- en: Caching
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: References to immutable objects can be cached as they are not going to change;
    therefore, the same immutable object will be retrieved quickly the next time we
    try to access it. An example technique is memoization, which we have explained
    in [Chapter 2](ch02.html "Chapter 2. Functions and Closures"), *Functions and
    Closures*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对不可变对象的引用可以被缓存，因为它们不会改变；因此，下次我们尝试访问它时，将快速检索到相同的不可变对象。一个示例技术是[第2章](ch02.html
    "第2章。函数和闭包")中解释的**记忆化**，*函数和闭包*。
- en: State comparison
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态比较
- en: The state of an application is the state of all its objects at a given time.
    State changes rapidly over time and an application needs to change state in order
    to continue running.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的状态是在给定时间点所有对象的集合状态。状态随时间快速变化，并且应用程序需要改变状态以继续运行。
- en: Immutable objects, however, have fixed state over time. Once created, the state
    of an immutable object does not change although the state of the application as
    a whole might change. This makes it easy to keep track of what is happening and
    simplify state comparison.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不可变对象在时间上具有固定的状态。一旦创建，不可变对象的状态就不会改变，尽管整个应用程序的状态可能会改变。这使得跟踪发生的事情和简化状态比较变得容易。
- en: Compiler optimization
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器优化
- en: The compiler optimizes `let` statements better for items whose values will not
    change during their lifetime. For example, Apple writes, *"It is good practice
    to create immutable collections in all cases where the collection does not need
    to change. Doing so enables the Swift compiler to optimize the performance of
    the collections you create."* (Do prefer using `let` over `var` where appropriate.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对在其生命周期内值不会改变的项的`let`语句进行优化更好。例如，Apple写道：“在所有情况下，如果集合不需要改变，创建不可变集合都是良好的实践。这样做可以使Swift编译器优化您创建的集合的性能。”（在适当的情况下，请优先使用`let`而不是`var`。）
- en: Cases for mutability
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性案例
- en: Whenever we require to change an immutable object, we will need to create a
    new, modified copy of it. This might not be costly and tedious for small and simple
    objects but will be in cases where we have large or complex objects with lots
    of properties and operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要更改不可变对象时，我们都需要创建一个新的、修改后的副本。这可能对于小型和简单的对象来说可能并不昂贵和繁琐，但在我们拥有具有大量属性和操作的大型或复杂对象的情况下，这将是如此。
- en: Also, changing an existing object is simpler and much more intuitive than creating
    a new, modified copy of it for objects with a distinct identity, for instance,
    a profile of a user. We may want to maintain a single object of a user's profile
    and modify it when necessary. This might not be a great example as it is hard
    to see the performance penalty for this case but the speed of execution can be
    a very important differentiator for some types of applications such as games.
    As an example, representing our game characters with mutable objects may make
    our game run faster than an alternative implementation where we will need to create
    a new, modified copy of the game character whenever we need to change it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有独特身份的对象，例如用户的个人资料，更改现有对象比创建一个新的、修改过的副本要简单得多，也更直观。我们可能希望维护用户个人资料的单一对象，并在必要时对其进行修改。这可能不是一个很好的例子，因为很难看到这种情况下性能的惩罚，但执行速度对于某些类型的应用程序（如游戏）来说可能是一个非常重要的区别因素。例如，用可变对象表示我们的游戏角色可能会使我们的游戏比需要每次更改时都创建一个新的、修改过的游戏角色副本的替代实现运行得更快。
- en: Furthermore, our real-world perception is inevitably based on the concept of
    mutable objects. We deal with all objects around us in our real life. These objects
    are identical most of the time and we change some of their characteristics if
    required.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的现实世界感知不可避免地基于可变对象的概念。我们在现实生活中处理周围的所有对象。这些对象大多数时候是相同的，如果需要，我们会改变它们的一些特性。
- en: For instance, we paint a wall in our home instead of replacing the whole wall.
    We perceive the wall as the same object with a modified property, in this case,
    color. The wall's identity is maintained while its state changes when we paint
    it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在家里粉刷墙壁而不是更换整个墙壁。我们将墙壁视为具有修改过的属性（在这种情况下是颜色）的相同对象。当我们粉刷墙壁时，墙壁的身份保持不变，但其状态发生变化。
- en: Therefore, whenever we model a real-world domain to represent real-world objects
    in our applications, it is inevitably easier to perceive and implement the domain
    model using mutable objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论何时我们在应用中用模型来表示现实世界的对象，使用可变对象来感知和实现领域模型都是不可避免的更容易。
- en: An example
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个例子
- en: We understand that there are cases where immutability makes our life harder.
    We barely touched the surface of these problems in a previous section. We will
    examine issues in more detail in the following chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解在某些情况下不可变性会使我们的生活变得更难。在前一节中，我们几乎没有触及这些问题的表面。我们将在接下来的章节中更详细地检查这些问题。
- en: Let's redevelop our `Product` example with a **functional programming** (**FP**)
    style and compare the outcome to its OOP counterpart.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以函数式编程（**FP**）风格重新开发我们的`Product`示例，并将其与面向对象（OOP）的对应版本进行比较。
- en: 'Let''s make our `Product` example in this chapter immutable and examine the
    outcome:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章中使`Product`示例不可变，并检查结果：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have `struct` instead of class and all properties are immutable. Also,
    we do not need an `init` method as `struct` provides it automatically.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`struct`而不是类，所有属性都是不可变的。此外，我们不需要`init`方法，因为`struct`会自动提供它。
- en: 'We also need to modify our `ProductTracker` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`ProductTracker`类：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `FunctionalProductTracker` is simplified: it is `struct` with an immutable
    array of `products` and our `addNewProduct` does not modify the state of our object
    but provides a new array of `products` each time. In fact, we can remove the `addNewProduct`
    method from this `struct` and handle it in a client object.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FunctionalProductTracker`简化了：它是具有不可变`products`数组的`struct`，我们的`addNewProduct`不会修改对象的状态，而是每次都提供一个包含`products`的新数组。实际上，我们可以从这个`struct`中移除`addNewProduct`方法，并在客户端对象中处理它。
- en: Side-effects and unintended consequences
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用和意外后果
- en: 'Our mutable example''s design can produce unpredictable side-effects. If multiple
    clients hold a reference to the `ProductTracker` instance, there are two ways
    for the products to change from underneath any of these clients:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可变示例设计可能会产生不可预测的副作用。如果有多个客户端持有`ProductTracker`实例的引用，产品可以通过以下两种方式从任何这些客户端的下面发生变化：
- en: We could simply reassign a value to the `products` directly. This is fixable
    by making it `private` for client calls but it is not fixable for in-class modifications.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接重新分配`products`的值。这可以通过将其设置为`private`以供客户端调用来修复，但对于类内的修改则无法修复。
- en: We could call `addNewProduct()` from any client and modify the `products`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从任何客户端调用`addNewProduct()`并修改`products`。
- en: Either way, there are going to be side-effects and unintended consequences because
    of the mutation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，由于修改，都可能会出现副作用和意外的后果。
- en: In our immutable example, it is impossible to cause those unintended consequences
    because our `FunctionalProductTracker` is a value type and all the properties
    are immutable. The `products` cannot be changed directly (it is a constant), and
    `addNewProduct()` returns a whole new instance, so all clients will be dealing
    with the instance that they expect to deal with.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的不可变示例中，由于我们的 `FunctionalProductTracker` 是一个值类型，所有属性都是不可变的，因此不可能产生那些意外的后果。`products`
    不能直接更改（它是一个常量），而 `addNewProduct()` 返回一个新的实例，因此所有客户端都将处理他们期望处理的实例。
- en: Testability
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性
- en: Our mutable example's `addNewProduct()` method has no return values. While it
    is possible to write a unit test for it, it is not obvious how we should implement
    asserting because the method causes a side-effect in our existing instance that
    we need to know about.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可变示例的 `addNewProduct()` 方法没有返回值。虽然我们可以为它编写单元测试，但如何实现断言并不明显，因为该方法在我们的现有实例中产生了副作用，我们需要了解这些副作用。
- en: Our immutable example's `addNewProduct()` method returns a new `Array` of `Product`.
    We simply inspect the value of `products` and assert. We still have both the old
    and new instances, so we have everything we need to ensure that our code works
    as intended.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可变示例的 `addNewProduct()` 方法返回一个新的 `Product` 数组。我们只需检查 `products` 的值并断言。我们仍然有旧的和新的实例，所以我们有我们需要的所有东西来确保我们的代码按预期工作。
- en: Although we do not cover unit-testing in this book, it is highly recommended
    that you explore QuickCheck-based libraries such as Quick ([https://github.com/Quick/Quick](https://github.com/Quick/Quick))
    and SwiftCheck ([https://github.com/typelift/SwiftCheck](https://github.com/typelift/SwiftCheck))
    as they employ FP techniques to ease the unit testing process of our applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这本书中没有涵盖单元测试，但我们强烈建议您探索基于 QuickCheck 的库，如 Quick ([https://github.com/Quick/Quick](https://github.com/Quick/Quick))
    和 SwiftCheck ([https://github.com/typelift/SwiftCheck](https://github.com/typelift/SwiftCheck))，因为它们使用函数式编程技术来简化我们应用程序的单元测试过程。
- en: Copy constructors and lenses
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数和透镜
- en: After examining our immutable example implementation, we are not able to say
    that it covers all the functionalities of the imperative approach. For instance,
    it does not provide us with a way to change the `producer` of a `product`. After
    all, we cannot change it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们的不可变示例实现后，我们无法断言它涵盖了命令式方法的所有功能。例如，它没有提供更改 `product` 的 `producer` 的方法。毕竟，我们无法更改它。
- en: 'Whenever we need to change any property of the `product`, we need to go through
    the following process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要更改 `product` 的任何属性时，我们都需要经过以下过程：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This solution is verbose and does not look nice. Let's examine how we can improve
    this process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案很冗长，看起来也不美观。让我们看看我们如何改进这个过程。
- en: Copy constructor
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制构造函数
- en: 'The first solution is to provide a new `init` method that copies the current
    instance. This approach is called copy constructor. Let''s add our new `init`
    method and leverage it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案是提供一个新的 `init` 方法来复制当前实例。这种方法被称为复制构造函数。让我们添加我们的新 `init` 方法并利用它：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We added the default `init` as well because by adding a new `init` method to
    our `struct`, we lost the benefit of automatic `init` generation. We also need
    to change our `addNewProduct` to accommodate these changes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了默认的 `init`，因为通过向我们的 `struct` 添加新的 `init` 方法，我们失去了自动 `init` 生成的好处。我们还需要更改我们的
    `addNewProduct` 来适应这些更改：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whenever we need to modify our object partially, we will be able to do so easily
    using this technique.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们需要部分修改我们的对象，我们都可以使用这种技术轻松地做到这一点。
- en: Lens
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透镜
- en: 'In the previous section, we covered copy constructors. Here, we will examine
    a functional structure called lens. Simply put, lenses are *functional getters
    and setters* that are implemented for a whole object and its parts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了复制构造函数。在这里，我们将检查一个名为透镜的功能结构。简单来说，透镜是针对整个对象及其部分实现的 *函数式获取器和设置器*：
- en: 'Getters: We can *look through* the lens at an immutable object to get its parts'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器：我们可以 *透过* 透镜查看不可变对象以获取其部分
- en: 'Setters: We can use the lens to change a part of an immutable object'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器：我们可以使用透镜来改变不可变对象的一部分
- en: 'Let''s implement a `Lens`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个 `Lens`：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s use it to change our `FunctionalProduct` object to get and set the `producer`
    property:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它来改变我们的 `FunctionalProduct` 对象以获取和设置 `producer` 属性：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s change the producer for `mexicanBananas`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改 `mexicanBananas` 的生产者：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Through our lens, we can change it as shown in the preceding code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的透镜，我们可以像前面代码所示那样更改它。
- en: 'Let''s examine another example. Suppose that we have a `Producer` object as
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查另一个示例。假设我们有一个如下所示的 `Producer` 对象：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We want to change the `address`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要更改 `address`：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Suppose that we had `mexicanBananas2` and needed to have a Chinese banana producer,
    then we could use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `mexicanBananas2`，需要有一个中国香蕉生产者，那么我们可以使用：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This syntax does not look very simple, and it seems that we did not gain much
    after all. In the next section, we will simplify it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来并不简单，而且似乎我们并没有获得太多。在下一节中，我们将简化它。
- en: Lens composition
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜头组成
- en: 'Lens composition will help to simplify our lens; let''s examine how:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头组成将有助于简化我们的镜头；让我们看看它是如何做到的：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s test this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result is going to be:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using lenses and composition, we were able to get and set a product's producer
    address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用镜头和组成，我们能够获取和设置产品的生产地址。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by exploring the concept of immutability. We looked
    into its importance and benefits with examples. Then we looked at cases for mutability
    and went through an example to compare mutability and immutability effects on
    our code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了不可变性的概念。我们通过例子探讨了其重要性和好处。然后我们分析了可变性的情况，并通过一个例子来比较可变性和不可变性对我们代码的影响。
- en: Finally, we explored the means to get and set immutable objects in a functional
    way, such as copy constructors and lenses.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了以函数式方式获取和设置不可变对象的方法，例如复制构造函数和镜头。
- en: In the following chapter, we will be introduced to OOP, **protocol-oriented
    programming** (**POP**), and **Functional Reactive Programming** (**FRP**). Then,
    we will explore the concept of mixing OOP and FP paradigms, in other words, object
    functional programming.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍面向对象编程（OOP）、**协议导向编程**（**POP**）和**函数式响应式编程**（**FRP**）。然后，我们将探讨混合面向对象和函数式编程范式，换句话说，对象函数式编程。
