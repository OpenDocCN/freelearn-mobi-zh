- en: 'Chapter 7. Input: Let''s Get Moving!'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。输入：让我们开始移动吧！
- en: Up to this point we've done some basic moving around a scene, but nothing like
    we'll need if we're going to build commercial games for iOS devices. One thing
    that is often overlooked when writing games for iOS is that while iPads, iPhones,
    etc. can perform many of the same functions as their desktop cousins — there are
    very specific techniques you need to be aware of when moving from the keyboard
    mouse world to that of touchscreens and accelerometers. In this chapter we're
    going to spend some time getting into the nitty gritty of what those details are.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经进行了一些基本的场景移动，但那还远远不够，如果我们打算为iOS设备构建商业游戏的话。在为iOS编写游戏时，经常被忽视的一点是，尽管iPad、iPhone等设备可以执行与桌面版本相同的许多功能——但在从键盘鼠标世界转移到触摸屏和加速度计的世界时，你需要了解一些非常具体的技巧。在本章中，我们将花时间深入了解这些细节。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about the iOS touch screen interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解iOS触摸屏界面
- en: Learn about accelerometers and how they work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解加速度计及其工作原理
- en: Create an interface on the touch screen for moving through an environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触摸屏上创建一个用于在环境中移动的界面
- en: Learn how to process gestures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何处理手势
- en: This may not sound like a lot, but with iOS development there are many things
    that you can do incorrectly, which will lead to difficulties when working with
    Unity. Rather than assume that you'll get it all right we're going to talk through
    it step by step to make sure that you can spend your time building games and not
    trying to decipher mysterious error messages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来并不多，但在iOS开发中，有很多事情你可能会做错，这会导致在使用Unity时遇到困难。我们不会假设你一切都会做对，而是会一步一步地讲解，以确保你可以把时间花在构建游戏上，而不是试图解读神秘的错误信息。
- en: So let's get on with it…
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续吧…
- en: Input Capabilities
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入能力
- en: The iPhone is a collection of a wide variety of technologies that can be used
    to detect input from the user. The two most important technologies, from the perspective
    of a game developer, are the touch screen and the accelerometer. With these two
    input mechanisms nearly every game available to date has been constructed, so
    we will perform an in-depth analysis of how they work and how we can use their
    capabilities to determine the intent of the user within our game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone是一个集合了广泛技术的设备，可以用来检测用户的输入。从游戏开发者的角度来看，最重要的两种技术是触摸屏和加速度计。凭借这两种输入机制，迄今为止几乎所有可用的游戏都已被构建，因此我们将深入分析它们的工作原理以及我们如何利用它们的能力来确定用户在游戏中的意图。
- en: The technology of touch
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸技术
- en: A touch screen is a display device that can detect the presence and location
    of one or more touches within the display area. While early touch devices relied
    on passive instruments, such as a stylus to detect interactions with the touch
    surface, modern touch devices detect physical contact with the device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏是一种可以检测显示区域内一个或多个触摸存在和位置的显示设备。虽然早期的触摸设备依赖于被动工具，如笔来检测与触摸表面的交互，但现代触摸设备可以检测与设备的物理接触。
- en: While it may not seem the case, there are a variety of technologies used to
    drive touch interaction with devices. The decision on which technology is chosen
    depends upon a multitude of factors such as cost, durability, scalability, and
    versatility. It is very easy for one to suggest that one touch technology is superior
    to others, but a technology that works well for one particular application may
    be entirely inappropriate for another. For example, the technology used in the
    iPhone requires a person to make physical contact with the surface for a touch
    to be registered. However, if you're building a kiosk, you may desire that users
    are able to interact with the device with gloved hands. This seemingly innocent
    choice has radical implications on the technology chosen as well as the design
    of the device itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能不是这样，但用于驱动设备触摸交互的技术有很多种。选择哪种技术的决定取决于众多因素，如成本、耐用性、可扩展性和多功能性。很容易有人建议某一种触摸技术比其他技术优越，但一种适用于特定应用的技术可能完全不适用于另一种应用。例如，iPhone中使用的这项技术要求用户必须与表面进行物理接触才能注册触摸。然而，如果你正在构建一个展台，你可能希望用户能够戴着手套与设备交互。这个看似无害的选择对选择的技术以及设备本身的设计都有深远的影响。
- en: 'There are several common types of touch surfaces that are common in devices
    today: resistive, capacitive, and infrared. While the mechanics of their implementations
    vary, they all follow the same basic recipe — when you place your finger or stylus
    on the screen, there is some change in state on the surface that is then sent
    to a processor, which determines where that touch took place. It is how that change
    in state is measured which separates the technologies from one another.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前设备中常见的几种触摸表面类型包括：电阻式、电容式和红外式。虽然它们的实现机制各不相同，但它们都遵循相同的的基本步骤——当你将手指或笔尖放在屏幕上时，表面状态会发生某种变化，然后被发送到处理器，处理器确定触摸发生的位置。正是这种状态变化是如何被测量的，将技术区分开来。
- en: While all of today's iOS devices utilize a particular surface type — capacitive,
    it is foreseeable that Apple may change technologies at some point in the future
    as they expand the platform to cover new types of devices. In addition, it is
    important to understand the other types of surfaces that you may encounter as
    you port your content to other platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天所有的iOS设备都使用特定的表面类型——电容式，但可以预见，随着苹果将平台扩展到覆盖新类型的设备，他们可能在未来的某个时刻改变技术。此外，了解你可能在将内容移植到其他平台时遇到的其他类型的表面也很重要。
- en: Resistive technology
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电阻式技术
- en: A resistive screen is comprised of layers of conductive and resistive material.
    When pressure is placed on the screen, the pressure from the finger or stylus
    causes the resistive and conductive material to come into contact — resulting
    in a change in the electrical field. At this point, measuring the resistance on
    the circuits connected to the conductive material will denote the location of
    the touch.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻式屏幕由导电材料和电阻材料的多层组成。当施加压力到屏幕上时，手指或笔尖的压力会使导电材料和电阻材料接触——导致电场发生变化。此时，测量连接到导电材料的电路上的电阻将表示触摸的位置。
- en: Given that any pressure can cause the contact to occur, a resistive screen works
    well when you want to have a passive implement such as a stylus as a possible
    touch instrument. In addition, you can keep your gloves on with this technology,
    as a gloved hand will work just as well as a naked one. As resistive technology
    has been around for a lot longer it tends to be cheaper to produce and is the
    technology most commonly found at the lower end of the cost spectrum.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何压力都可能导致接触发生，电阻式屏幕在你想使用被动工具，如笔作为可能的触摸工具时工作得很好。此外，使用这项技术，你可以戴上手套，因为戴着手套的手和裸手一样可以工作。由于电阻式技术存在的时间较长，它往往生产成本较低，是成本谱系中常见于低端的技术。
- en: Capacitive technology
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电容式技术
- en: A capacitive screen uses a layer of capacitive material that holds an electrical
    charge. When touched, this material registers a difference in the amount of charge
    at a specific location on the surface at the point of contact. This information
    is then passed onto the processors which can determine precisely where the touch
    takes place. The iOS devices simplify this process by arranging the capacitors
    in a grid such that every point on the screen generates its own signal when touched.
    This has the added benefit of producing a very high resolution of touch data that
    can be processed by the processor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电容式屏幕使用一层能够保持电荷的电容材料。当触摸时，这种材料会在接触点表面的特定位置记录电荷量的变化。然后，这些信息被传递到处理器，处理器可以精确地确定触摸发生的位置。iOS设备通过将电容器排列成网格来简化这一过程，使得屏幕上的每一个点在触摸时都会产生自己的信号。这带来了额外的优势，即产生非常高的分辨率触摸数据，可以被处理器处理。
- en: As the capacitive approach relies on having capacitive material in order to
    function, it requires that something that can conduct electricity performs the
    touching. Since the human body conducts electricity this works fine, but it rules
    out the stylus approach, or more specifically it requires that a special capacitive
    stylus be used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电容式方法依赖于电容材料才能工作，它要求某种能够导电的物质进行触摸。由于人体导电，这可以很好地工作，但它排除了笔尖方法，或者更具体地说，它要求使用特殊的电容笔。
- en: Infrared technology
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红外技术
- en: An infrared screen uses an array of infrared or LED light beams, which it projects
    beneath the protective glass, or more commonly, acrylic surface. A camera will
    then peer up at this grid of beams and look for any interruption of the signal,
    similar to the grid approach used by iOS devices — just with an infrared camera
    and beams of light. This approach is refined and deployed with the Microsoft Surface
    and has some particular unexpected benefits. Since a camera is used to determine
    the touch location, that camera can also look at the object at that location.
    If that object is a marker, it can then extract information from that marker as
    well. This is used to good effect with the Microsoft Surface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 红外屏幕使用一排红外或LED光束，将其投射在保护玻璃或更常见的亚克力表面下方。然后，摄像头会向上看这个光束网格，寻找信号中断，类似于iOS设备使用的网格方法——只是使用红外摄像头和光束。这种方法经过改进并在Microsoft
    Surface上部署，并带来一些意想不到的好处。由于摄像头用于确定触摸位置，因此该摄像头还可以查看该位置的对象。如果该对象是一个标记，它还可以从该标记中提取信息。这种方法在Microsoft
    Surface上得到了很好的应用。
- en: The obvious downside to the Infrared approach is that it requires a fair amount
    of space to work its magic. Due to the nature of the optics, the further you are
    away from the surface the more resolution you are able to gain on that surface.
    This makes the technology impractical for the typical iPhone application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 红外方法的一个明显缺点是它需要相当大的空间来发挥作用。由于光学性质，你离表面越远，在该表面上获得的分辨率就越高。这使得这项技术在典型的iPhone应用中不切实际。
- en: Accelerometer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速度计
- en: 'An accelerometer is a device that measures the acceleration of motion on a
    structure. In iOS devices the accelerometer is a 3-axis system such that it can
    determine acceleration along the various axes of the device (x,y,z). When at rest,
    an accelerometer would be measuring the force of gravity (1g). As the device moves,
    the device will be able to measure the movements of the device based upon these
    accelerations along the various axes and determine the orientation of the new
    device. Without getting into the associated math, the only thing that you really
    need to know is that no matter what orientation you put the device in, the device
    is aware of that orientation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计是一种测量结构上运动加速度的设备。在iOS设备中，加速度计是一个三轴系统，可以确定设备各个轴（x，y，z）上的加速度。当设备静止时，加速度计会测量重力（1g）的力。当设备移动时，设备将能够根据这些轴上的加速度测量设备的运动，并确定新设备的方向。不涉及相关的数学，你真正需要知道的是，无论你将设备放在什么方向，设备都能感知到这个方向：
- en: Gyroscope
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惯性仪
- en: A gyroscope is a device for measuring the orientation of a device. Unlike an
    accelerometer, the orientation of a device can be derived without the device actually
    moving. Currently only available on a subset of the iOS devices, the gyroscope
    enables a much more refined detection of movement in the device. The 3-axis gyro
    in the iOS devices work in tandem with the built-in accelerometer to produce a
    complete 6-axis sensitivity for motion gestures. At the time of this writing there
    is no support within Unity for the Gyroscope so we will not focus on its use within
    the context of our game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 惯性仪是一种测量设备方向的设备。与加速度计不同，设备的方向可以在设备实际移动之前推导出来。目前，惯性仪仅适用于iOS设备的一部分，它使得设备中的运动检测更加精细。iOS设备中的三轴惯性仪与内置的加速度计协同工作，产生完整的6轴运动手势灵敏度。在撰写本文时，Unity中没有对惯性仪的支持，因此我们不会关注其在游戏中的应用。
- en: Touch screen
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸屏
- en: Our game design calls for having a set of joysticks at the bottom on the screen
    that we can use to move around the world and manipulate the camera. The control
    scheme mirrors what a player would expect if they were familiar with an Xbox style
    controller.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏设计需要在屏幕底部设置一套操纵杆，我们可以使用它们在世界上移动并操纵摄像头。控制方案与玩家熟悉的Xbox风格控制器相呼应。
- en: '![Touch screen](img/978-1-84969-040-9_7_14.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![触摸屏](img/978-1-84969-040-9_7_14.jpg)'
- en: We also need to perform actions with the right button. Similar to the Xbox controller
    we want to be able to invoke actions by tapping down on the right joystick as
    an action.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用右键执行操作。类似于Xbox控制器，我们希望能够在右操纵杆上轻触以调用动作。
- en: The next feature we want to plan for is the ability to perform gestures on the
    surface so that we can avoid having to fill our interface with extraneous buttons.
    There are several gestures that we want to support in our gameplay.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要计划的下一个特性是能够在表面上执行手势，这样我们就可以避免在我们的界面中填充多余的按钮。我们希望在游戏中支持几种手势。
- en: '| Gesture | Meaning |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 手势 | 含义 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Swipe Up | Throw Grenade |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 向上滑动 | 投掷手榴弹 |'
- en: '| Swipe Left/Right | Dodge Left/Right |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 向左/右滑动 | 向左/右躲避 |'
- en: '| Swipe Down | Guard/Take Cover |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 向下滑动 | 守护/躲避 |'
- en: Accelerometer/Gyroscope
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速度计/陀螺仪
- en: Our game design doesn't call for the use of the accelerometer, but for the sake
    of instruction we will use the accelerometer as an additional mechanism for manipulating
    the camera and provide a shake command that we will use if the character is ever
    knocked down and needs to heal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏设计不需要使用加速度计，但为了说明，我们将使用加速度计作为操纵相机的附加机制，并提供一个摇动命令，如果角色被击倒并需要治疗时我们将使用它。
- en: '| Motion | Meaning |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 含义 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Shake | Heal |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 摇动 | 治疗 |'
- en: '| Turn Left/Right | Rotate Camera |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 向左/右转 | 旋转摄像头 |'
- en: Implementing Joysticks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现摇杆
- en: Our game design sketch calls for playing this game while the device is in landscape
    orientation so we need to start off the application in landscape.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏设计草图要求在横屏方向玩游戏，因此我们需要从横屏开始应用程序。
- en: Time for action — Getting oriented
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 获取方向
- en: 'From our previous applications we know that we can accomplish this by performing
    a quick orientation change within the `Awake()` method of our application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的应用程序中我们知道，我们可以通过在我们的应用程序的`Awake()`方法中执行快速方向更改来实现这一点：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In previous examples we put our functions in the `Start()` method, but we are
    putting this call in the `Awake()` method. The reason for this is that we want
    this script, and the orientation settings, to be processed as soon as the scene
    is loaded, but before the joystick script tries to determine where to put the
    joysticks. If we didn't do this the position of the joysticks would be too close
    together as their positions would have been derived from the portrait orientation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们把我们的函数放在`Start()`方法中，但我们将这个调用放在`Awake()`方法中。这样做的原因是我们希望这个脚本和方向设置在场景加载后立即处理，但在摇杆脚本尝试确定摇杆位置之前。如果我们不这样做，摇杆的位置会太靠近，因为它们的位置是从纵向方向推导出来的。
- en: If you were to run your application now you would find that the application
    will hold to a single screen orientation, however, when you rotated you would
    get a black outline that rotates with the screen. This black outline represents
    the iOS keyboard interface rotating with the device. To prevent this from happening
    you need to lock the keyboard so that it is in the same orientation with the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用程序，你会发现应用程序将保持单一屏幕方向，然而，当你旋转时，你会得到一个随着屏幕旋转的黑色轮廓。这个黑色轮廓代表iOS键盘界面随着设备旋转。为了防止这种情况发生，你需要锁定键盘，使其与应用程序保持相同的方向。
- en: '| Key Class/Methods | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 键类/方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| iPhoneSettings`.screenOrientation` | Gets/Sets the orientation of the device
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| iPhoneSettings`.screenOrientation` | 获取/设置设备的方向 |'
- en: '| `iPhoneScreenOrientation` | Enumerated type of the possible device orientations
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `iPhoneScreenOrientation` | 可能设备方向的枚举类型 |'
- en: '| `iPhoneKeyboard.autorotateXXXX` | Sets whether or not the iPhoneKeyboard
    will rotate to a particular orientation when the device changes orientation |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `iPhoneKeyboard.autorotateXXXX` | 设置iPhoneKeyboard是否会在设备方向改变时旋转到特定方向 |'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What just happened?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have configured the game so that it will default to landscape orientation
    when it starts. In addition, the game will do what the users expect and you won't
    have the graphical glitch of the iOS keyboard trying to adjust for the device
    orientation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了游戏，使其在启动时默认为横屏方向。此外，游戏将执行用户期望的操作，你不会遇到iOS键盘尝试调整设备方向的图形故障。
- en: Next, our design calls for a touch interface with two joystick areas with the
    one on the left acting as the movement stick and the one on the right acting as
    the rotation joystick. We will use these to capture user interactions and drive
    our character around the game world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的设计要求有两个摇杆区域的触摸界面，左边的摇杆作为移动摇杆，右边的摇杆作为旋转摇杆。我们将使用这些来捕捉用户交互并驱动角色在游戏世界中移动。
- en: Time for action — Implementing the joysticks
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 实现摇杆
- en: Expand the Standard Assets (Mobile) unitypackage that we added to the project
    initially in one part of our solution. Inside of the `Prefabs` folder there is
    a `Dual Joysticks` prefab:![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_2.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的解决方案的一部分中展开最初添加到项目中的标准资产（移动）unitypackage。在`Prefabs`文件夹中有一个`Dual Joysticks`预制件：![执行动作
    — 实现摇杆](img/978-1-84969-040-9_7_2.jpg)
- en: Since this is going to be moving with the user interface plane of our camera
    we can simply make it a child of the camera:![Time for action — Implementing the
    joysticks](img/978-1-84969-040-9_7_3.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这将随着我们相机的用户界面平面移动，我们可以简单地将其设置为相机的子项：![执行动作 — 实现摇杆](img/978-1-84969-040-9_7_3.jpg)
- en: 'Set the **Game** view to display in iPhone Wide by selecting the dropdown in
    the upper left of the Game view. This will result in a more accurate depiction
    of how the game will look at startup. Now, when we take a look at the Game view
    we can see exactly what our camera will see when our game starts:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**游戏**视图设置为通过选择游戏视图右上角的下拉菜单以iPhone宽显示。这将更准确地展示游戏启动时的外观。现在，当我们查看游戏视图时，我们可以确切地看到我们的相机在游戏开始时将看到什么：
- en: '![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 — 实现摇杆](img/978-1-84969-040-9_7_4.jpg)'
- en: This figure represents what we expect to see — our two Joystick nubs in the
    user interface ready for user interaction. If you start your application on your
    iOS device you will see that as you place your fingers over the joystick nubs,
    they will move around as your fingers manipulate them during a touch. When you
    remove your finger from the nub it will snap back to the center position. This
    information is captured by the Prefab and passed off to the built-in Joystick
    script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了我们期望看到的情况——用户界面中的两个摇杆凸起，准备与用户交互。如果你在你的iOS设备上启动应用程序，你会看到当你将手指放在摇杆凸起上时，它们会随着你的手指在触摸过程中移动。当你从凸起上移开手指时，它将迅速回到中心位置。这个信息被预制件捕获并传递给内置的摇杆脚本。
- en: To pass the input to some other script, simply alter the script that the Prefab
    is pointing to. Note that each Joystick can have its own script so you can have
    two entirely different behaviors per joystick.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输入传递到其他脚本，只需更改预制件指向的脚本。请注意，每个摇杆都可以有自己的脚本，因此你可以为每个摇杆实现两种完全不同的行为。
- en: 'You can also change the texture that the joystick uses by updating the **Texture**
    field on the **GUITexture** which represents the joystick:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过更新代表摇杆的**GUITexture**上的**纹理**字段来更改摇杆使用的纹理：
- en: '![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 — 实现摇杆](img/978-1-84969-040-9_7_5.jpg)'
- en: What just happened?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just implemented the primary means of input for our game — the dual
    joystick nubs. As we move these joysticks around they relay data to the Joystick
    script. While this is interesting, it still doesn't move our character around
    the scene. If all we needed were some basic joystick processing we'd be done,
    but we need to control a character and move our camera around the scene. Fortunately,
    there's a prefab for that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了游戏的主要输入方式——双摇杆凸起。当我们移动这些摇杆时，它们会将数据传递给摇杆脚本。虽然这很有趣，但它仍然不能让我们的角色在场景中移动。如果我们只需要一些基本的摇杆处理，我们就完成了，但我们需要控制一个角色并在场景中移动我们的相机。幸运的是，有一个预制件可以做到这一点。
- en: Moving around
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动
- en: Now that we have an interface which is ready to accept input we need to process
    the touches from that interface and move our character around the scene. Our plain
    joystick is one part of the plan, but now we need to handle the rest.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以接受输入的界面，我们需要处理来自该界面的触摸操作，并让我们的角色在场景中移动。我们简单的摇杆是计划的一部分，但现在我们需要处理其余的部分。
- en: Time for action — Implementing the camera control
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 — 实现相机控制
- en: The first thing we need to do is delete our Main Camera and the Dual Joysticks
    from the previous scene. Don't be concerned that we've deleted the Main Camera
    as we will be adding a new camera to the scene.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从上一个场景中删除我们的主相机和双摇杆。不要担心我们已经删除了主相机，因为我们将在场景中添加一个新的相机。
- en: Perform a search for the **Camera Relative Controls** in the **Project** window:![Time
    for action — Implementing the camera control](img/978-1-84969-040-9_7_6.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中搜索**相机相对控制**：![执行动作 — 实现相机控制](img/978-1-84969-040-9_7_6.jpg)
- en: Drag the Camera Relative Controls prefab into the **Hierarchy** view. When you
    drag this prefab into your **Hierarchy** view you will find that it consists of
    both the Dual Joysticks that we were using earlier, as well as something called
    **Camera Relative Controls**. Beneath the **Camera Relative Controls** you will
    find the camera pivot and the player objects.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机相对控制预制体拖动到**层次结构**视图中。当您将此预制体拖动到您的**层次结构**视图中时，您会发现它由我们之前使用的双摇杆以及称为**相机相对控制**的东西组成。在**相机相对控制**下方，您将找到相机枢轴和玩家对象。
- en: The **camera pivot** as the name suggests is the point in space around which
    the camera will pivot. When you move the right joystick to rotate the camera in
    3D space, its actions are relative to this point.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**相机枢轴**正如其名，是相机将围绕其旋转的空间中的点。当您移动右摇杆在3D空间中旋转相机时，其动作相对于这个点。'
- en: 'The other object is the Player which hosts our Character Controller object
    and has an aptly named child "ReplaceWithRealCharacter". When we have our real
    character we will insert it here:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个对象是玩家，它承载我们的角色控制器对象，并有一个恰如其分的子节点名称“ReplaceWithRealCharacter”。当我们有真实角色时，我们将将其插入此处：
- en: '![Time for action — Implementing the camera control](img/978-1-84969-040-9_7_37.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作 — 实现相机控制](img/978-1-84969-040-9_7_37.jpg)'
- en: Switch to the **Game** view and we will see what this scene represents at runtime:![Time
    for action — Implementing the camera control](img/978-1-84969-040-9_7_7.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**游戏**视图，我们将看到在运行时这个场景代表什么：![执行动作 — 实现相机控制](img/978-1-84969-040-9_7_7.jpg)
- en: As you can see, the joysticks are in place and the white capsule represents
    the Character Controller and Player Game Objects. If you deploy this project to
    your iOS device now you will see that you will be able to move around the scene
    with the Joysticks, the left moving you around the scene and the right one rotating
    the camera.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，摇杆已经就位，白色胶囊代表角色控制器和玩家游戏对象。如果您现在将此项目部署到您的iOS设备上，您将看到您将能够使用摇杆在场景中移动，左摇杆让您在场景中移动，右摇杆旋转相机。
- en: Next let's import our player's character. Open the **Asset Store** and perform
    a search for the **Solder Character Pack:**![Time for action — Implementing the
    camera control](img/978-1-84969-040-9_7_10.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们导入我们的玩家角色。打开**资产商店**，搜索**士兵角色包**：![执行动作 — 实现相机控制](img/978-1-84969-040-9_7_10.jpg)
- en: This pack contains a fully rigged character that we can use with our game.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此包包含一个完全装备的角色，我们可以将其用于我们的游戏。
- en: After importing the character pack, drag the **Solider** prefab over to the
    **Camera Relative Controls**, Player node as a child. This will break the prefab
    link, but this is not a problem as we need to sever that link to add our own geometry
    to the game.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入角色包后，将**士兵**预制体拖动到**相机相对控制**，玩家节点作为子节点。这将断开预制体链接，但这不是问题，因为我们需要断开这个链接来为游戏添加自己的几何形状。
- en: Now delete the `ReplaceWithReachCharacter` child of the Player node and you
    will have a soldier in your game ready to be used. This soldier isn't the most
    efficient model we could use for our application, but it is freely available on
    the asset store and will work just fine for our purposes:![Time for action — Implementing
    the camera control](img/978-1-84969-040-9_7_9.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除玩家节点的`ReplaceWithReachCharacter`子节点，您将有一个可供使用的士兵。这个士兵不是我们应用中效率最高的模型，但它可以在资产商店中免费获取，并且对我们的目的来说效果很好：![执行动作
    — 实现相机控制](img/978-1-84969-040-9_7_9.jpg)
- en: Deploy this application to your iOS device and use the joysticks and you will
    find, that for your limited effort, you have a character in the world that will
    navigate the world with the left joystick and that you are able to manipulate
    the camera with the right joystick. We're starting to get something that looks
    more like a game, except that the player doesn't animate. We need a way to put
    some animations on this character and have the person walk around, move through
    the attack animations, take damage, and die if we're going to have a real game.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此应用程序部署到您的iOS设备上，并使用摇杆，您会发现，对于您有限的努力，您在世界上有一个角色，它将使用左摇杆导航世界，并且您能够使用右摇杆操纵相机。我们开始得到一些更像游戏的东西，但是玩家没有动画。如果我们想要一个真正的游戏，我们需要一种方法来给这个角色添加一些动画，让人物四处走动，进行攻击动画，受到伤害，并在必要时死亡。
- en: What just happened?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have extended the functionality of the existing application to include controls
    to move around our world, along with camera controls for our player character.
    Now that we have imported a character for our character controller, we need to
    animate this character based on user input.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经扩展了现有应用程序的功能，包括移动我们世界的控制以及玩家角色的相机控制。现在我们已经为角色控制器导入了一个角色，我们需要根据用户输入来对这个角色进行动画处理。
- en: Time for action — Animating the player character
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 动画玩家角色
- en: The character that we imported is what is known as a rigged character. A rigged
    character is one that has all of its bones for animation. These bones are what
    drive the movement of the mesh itself during animation. Let's disable the rendering
    of the mesh so we can see the bones themselves..
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的角色被称为绑定角色。绑定角色是指具有所有动画骨骼的角色。这些骨骼在动画期间驱动网格本身的运动。让我们禁用网格的渲染，这样我们就可以看到骨骼本身。
- en: Select the Soldier mesh in the **Hierarchy** view.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择士兵网格。
- en: In the **Inspector** view, scroll down to the Mesh Render component and click
    its check box. This will disable rendering of the mesh in Unity and in the Game:![Time
    for action — Animating the player character](img/978-1-84969-040-9_7_36.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，向下滚动到网格渲染组件并点击其复选框。这将禁用在Unity和游戏中的网格渲染：![行动时间 — 动画玩家角色](img/978-1-84969-040-9_7_36.jpg)
- en: 'Open the **Scene** view of the project and select the mesh in the Hierarchy.
    You should only see the bones for the soldier character we imported:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目的**场景**视图并选择层次结构中的网格。你应该只能看到我们导入的士兵角色的骨骼：
- en: '![Time for action — Animating the player character](img/978-1-84969-040-9_7_16.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 动画玩家角色](img/978-1-84969-040-9_7_16.jpg)'
- en: As mentioned earlier, Unity's animation system is fairly robust and has an easily
    scriptable animation blending system built right into it. As a consequence, we
    can deal with simple animations such as walk, run, use weapon, and so on, and
    we can have Unity blend between the animations to allow us to walk while using
    the weapon.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unity 的动画系统相当强大，并且内置了一个易于脚本化的动画混合系统。因此，我们可以处理简单的动画，如行走、奔跑、使用武器等，并且Unity可以在我们使用武器的同时混合这些动画。
- en: Importing an animation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入动画
- en: 'The next step is to associate an animation with this rigging so that we can
    ''drive'' our character around the scene. There are a number of ways that you
    can animate a character, such as motion capture or animating by hand. Unity supports
    two approaches for importing this content into our game: animation splitting and
    multiple animation files.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将动画与这个绑定关联起来，这样我们就可以在场景中“驾驶”我们的角色。你可以通过多种方式来动画化一个角色，例如动作捕捉或手动动画。Unity 支持两种方法将此内容导入到我们的游戏中：动画分割和多个动画文件。
- en: Animation splitting
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画分割
- en: 'There are times when you will receive an asset which already has multiple animations
    baked onto a model. In many content-purchasing scenarios this is quite a common
    practice. In these situations, when you import the model you will have to tell
    Unity how to split the single large animation into multiple distinct animations.
    You will do this in the **FBXImporter** that appears when you bring the model
    into the Unity IDE:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会收到一个已经将多个动画烘焙到模型上的资产。在许多内容购买场景中，这是一种相当常见的做法。在这些情况下，当你导入模型时，你必须告诉Unity如何将单个大型动画分割成多个独立的动画。你将在将模型带入Unity
    IDE时出现的**FBXImporter**中这样做：
- en: '![Animation splitting](img/978-1-84969-040-9_7_17.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![动画分割](img/978-1-84969-040-9_7_17.jpg)'
- en: By selecting the option to **Split Animations**, Unity will enable a table that
    will allow you to specify each animation that is present. For example in this
    scenario there is an animation called **idle** which runs from frame **1** through
    frame **25**, a **walk** that plays from frame **26** through frame **50**, and
    so on. Once you have imported the animations you can reference them by the names
    that you have given them in the table for all animation actions. We will discuss
    this in more detail shortly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**分割动画**选项，Unity 将启用一个表格，允许你指定每个存在的动画。例如，在这个场景中，有一个名为**idle**的动画，从帧**1**运行到帧**25**，一个从帧**26**到帧**50**播放的**walk**，等等。一旦你导入了动画，你可以通过你在表格中给出的名称来引用它们，用于所有动画动作。我们将在稍后详细讨论这个问题。
- en: Multiple files
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个文件
- en: The preferred way to import animations is to use multiple animation files. To
    do this you create a separate model file for your animation data using the naming
    convention 'model'@'animation name'.fbx and simply drag this `.fbx` file into
    Unity, the same as you would any other asset.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导入动画的首选方式是使用多个动画文件。为此，您需要为动画数据创建一个单独的模型文件，使用命名约定 'model'@'animation name'.fbx，然后将这个`.fbx`文件简单地拖入Unity中，就像拖入任何其他资产一样。
- en: 'Through this you can import your animations distinctly for each character and
    it becomes much easier in your workflow to modify these animations, without having
    to worry about which frames changed or ending up with extra frames in your animation
    data, to allow for potential changes. It is important to note that these files
    contain only animation data — not the actual model geometry. Further, it is important
    to note that Unity will not attempt to enforce the mapping of the model name to
    the name of your models:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以分别为每个角色明确导入动画，这使得在您的流程中修改这些动画变得更加容易，无需担心哪些帧已更改或动画数据中出现了额外的帧，以便进行潜在的变化。重要的是要注意，这些文件仅包含动画数据——不是实际模型几何形状。此外，重要的是要注意，Unity不会尝试强制将模型名称映射到您的模型名称：
- en: '![Multiple files](img/978-1-84969-040-9_7_21.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_21.jpg)'
- en: For example, here we have imported some animations in an FBX file. There is
    no default model in our scene, but we can still use these animations since the
    bone hierarchy of these animations matches that of the character we already have
    in the game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们导入了一些FBX文件中的动画。在我们的场景中没有默认模型，但由于这些动画的骨骼层级与游戏中已有的角色骨骼层级相匹配，我们仍然可以使用这些动画。
- en: 'To use this animation within our game we need to select our character and in
    the **Inspector** expand the animation settings:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏中使用此动画，我们需要选择我们的角色，并在**检查器**中展开动画设置：
- en: '![Multiple files](img/978-1-84969-040-9_7_19.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_19.jpg)'
- en: 'Here we see that our character has 0 animations specified. In addition in the
    **Animation** element we see that there is no animation scheduled to play. We
    can easily fix this by increasing the animation count to **3** to match the three
    animations we have imported:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的角色指定了0个动画。此外，在**动画**元素中，我们看到没有计划播放的动画。我们可以通过将动画数量增加到**3**来轻松解决这个问题，以匹配我们导入的三个动画：
- en: '![Multiple files](img/978-1-84969-040-9_7_20.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_20.jpg)'
- en: 'These slots can all hold the animations that we have imported. The animation
    itself being represented by a document icon with a clock on it which, coincidentally,
    has the same name as the animation itself. Simply drag the animations onto these
    slots and you will have set up animations for the character:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些槽位都可以存放我们导入的动画。动画本身由一个带有时钟的文档图标表示，巧合的是，它的名称与动画本身相同。只需将动画拖到这些槽位上，您就为角色设置了动画：
- en: '![Multiple files](img/978-1-84969-040-9_7_23.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_23.jpg)'
- en: 'If you want to set up a default animation for the character you can drag an
    animation onto the **Animation** slot. I have chosen to select the idle animation
    in this case:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为角色设置默认动画，可以将动画拖到**动画**槽中。在这种情况下，我选择了选择空闲动画：
- en: '![Multiple files](img/978-1-84969-040-9_7_24.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_24.jpg)'
- en: 'Now your character is all setup and ready to animate. If you run the game in
    the editor you will see that your character moves from his default T position
    to the idle animation and plays through it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的角色已经设置完毕，准备进行动画。如果您在编辑器中运行游戏，您将看到您的角色从默认的T位置移动到空闲动画，并播放它：
- en: '![Multiple files](img/978-1-84969-040-9_7_25.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![多个文件](img/978-1-84969-040-9_7_25.jpg)'
- en: What just happened?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just took our rigged character from the asset store and added animations
    to it using the two approaches of animation splitting and unique FBX animation
    importing. Now our character can have emotion, driven by animation data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚从资产商店中获取了我们的绑定角色，并使用动画分割和独特的FBX动画导入方法向其添加了动画。现在我们的角色可以通过动画数据表现出情感。
- en: Importing an animation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入动画
- en: There may be times when you don't have animation data readily available, or
    you simply want to cut down your development time by integrating an existing animation.
    One service that is well integrated with Unity is the animation service from Mixamo.
    Mixamo provides this functionality, not only for their characters, but also for
    any rigged character that we can find.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能没有现成的动画数据，或者你只是想通过集成现有动画来减少开发时间。一个与 Unity 集成良好的服务是 Mixamo 的动画服务。Mixamo
    不仅为其角色提供此功能，还为我们能找到的任何绑定角色提供此功能。
- en: Time for action — Importing from Mixamo
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 — 从 Mixamo 导入
- en: 'We can get started by going to the [http://www.mixamo.com/](http://www.mixamo.com/)
    website (there is a plugin that is integrated into the latest versions of Unity
    as well) and browsing through their library of animations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问 [http://www.mixamo.com/](http://www.mixamo.com/) 网站开始（Unity 最新版本中也集成了插件）并浏览他们的动画库来开始：
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![动作时间 — 从 Mixamo 导入](img/978-1-84969-040-9_7_11.jpg)'
- en: 'Since we want to ensure that the animation will work properly with our character
    we can upload our character to Mixamo and see the animation being played on our
    character:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望确保动画能够与我们的角色正确工作，我们可以将我们的角色上传到 Mixamo 并查看动画在我们角色上的播放效果：
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![动作时间 — 从 Mixamo 导入](img/978-1-84969-040-9_7_12.jpg)'
- en: 'We have the opportunity to tweak any of the bones in our character to fit those
    that Mixamo has defined in their default skeleton. This will help ensure that
    our animation plays properly. In most cases Mixamo will map to the right bones
    by itself, but if you need to help it out because of some special mapping that
    you''ve done — all the tools are there:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有机会调整角色中的任何骨骼以适应 Mixamo 在其默认骨骼中定义的骨骼。这将有助于确保我们的动画能够正确播放。在大多数情况下，Mixamo 会自动映射到正确的骨骼，但如果你因为某些特殊的映射需要帮助——所有工具都在那里：
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![动作时间 — 从 Mixamo 导入](img/978-1-84969-040-9_7_13.jpg)'
- en: Once mapped, we can reference this uploaded character as we browse through the
    catalog of animations in the Mixamo library when we create our own custom animations
    using the service. Now that our model is here we can look at exactly how the animation
    will perform, as Mixamo has an integrated Unity player on the website where we
    can preview and customize the animation as necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦映射成功，我们就可以在浏览 Mixamo 库中动画目录时引用这个已上传的角色，当我们使用该服务创建自己的自定义动画时。现在我们的模型已经准备好了，我们可以查看动画的确切表现，因为
    Mixamo 网站上集成了 Unity 播放器，我们可以预览并按需自定义动画。
- en: We can adjust the sliders to customize our character motions in real time and
    get them precisely the way we want them. Once we've done that we can download
    our animation in the appropriate Unity animation format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整滑块以实时自定义角色动作，并精确地得到我们想要的效果。一旦我们完成，我们就可以下载我们的动画，以适当的 Unity 动画格式。
- en: 'If we already have an animation that we want to import into Unity, we can use
    this same approach to import those animations as well. Unity supports two approaches
    for importing this content into our game: animation splitting and multiple animation
    files.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了一个想要导入到 Unity 中的动画，我们也可以使用相同的方法来导入这些动画。Unity 支持两种将此内容导入游戏的方法：动画拆分和多个动画文件。
- en: What just happened?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just took our rigged character from the asset store and added animations
    to it using the Mixamo animation service. Using these animations we're able to
    have our character move around the scene in sync with animations. Now that we
    can move around let's deal with the other part of our input requirements — being
    able to attack enemies or perform other actions on command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚从资源商店中获取了我们的绑定角色，并使用 Mixamo 动画服务为其添加了动画。使用这些动画，我们能够让角色在场景中与动画同步移动。现在我们可以移动了，让我们来处理我们输入需求的其他部分——能够根据命令攻击敌人或执行其他动作。
- en: Driving our character
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制角色
- en: The last thing that we need to do with our character is drive him around the
    scene. This is the one area that will either make or break our game because it
    needs to be fluid with user interaction. This is important because the main character
    is likely to be one of the most used things in the game so it should be well made.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们角色做的最后一件事是在场景中驾驶他。这是游戏成败的关键区域，因为它需要与用户交互流畅。这很重要，因为主要角色可能是游戏中使用最频繁的东西之一，所以它应该做得很好。
- en: As the character moves around, our character needs to move through the animation
    and change position in the scene as well. In addition, we need to seamlessly blend
    between different animations that the character is doing. We can't have the player
    stop walking, then swing, then start walking again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当角色移动时，我们的角色需要通过动画在场景中改变位置。此外，我们还需要在角色执行的不同动画之间无缝地混合。我们不能让玩家停止行走，然后挥动，然后再开始行走。
- en: Time for action — Driving our character
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 驾驶我们的角色
- en: 'If you deployed the application after the last step you would have observed
    that our current controls could already move the character around the scene. We
    can use the left joystick and the player will glide over the ground while going
    through the idle animation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在上一步之后部署了应用程序，你会观察到我们当前的控件已经可以移动角色在场景中。我们可以使用左侧操纵杆，玩家将在通过空闲动画时在地面上滑行：
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_26.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 驾驶我们的角色](img/978-1-84969-040-9_7_26.jpg)'
- en: 'We want our character to walk when the player is moving the joystick so we
    can make a very simple change to the `CameraRelativeControl` script for this to
    happen. You can locate this script by taking a look at the **Player** object in
    the **Hierarchy** view:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望当玩家移动操纵杆时，我们的角色能够行走，因此我们需要对`CameraRelativeControl`脚本进行一个非常简单的修改来实现这一点。你可以通过查看**层次**视图中的**Player**对象来定位这个脚本：
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_27.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 驾驶我们的角色](img/978-1-84969-040-9_7_27.jpg)'
- en: 'Now look at the Inspector and you will see all of the scripts that are driving
    this object. Keep track of this, as we will change some of this later:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看检查员，你会看到驱动这个对象的全部脚本。请记住这一点，因为我们稍后会更改其中的一些内容：
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_28.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 驾驶我们的角色](img/978-1-84969-040-9_7_28.jpg)'
- en: 'First let''s add a variable to the script so we can gain access to our soldier
    GameObject. You will note here that I am defining the type in this script, as
    opposed to just declaring it as var. In Unity iOS you must define the types of
    all objects, dynamic typing is not allowed for performance reasons:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在脚本中添加一个变量，以便我们可以访问我们的士兵GameObject。你会注意到在这里，我正在定义脚本中的类型，而不是仅仅声明它为var。在Unity
    iOS中，你必须定义所有对象类型，出于性能原因不允许动态类型：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we need to just look for some change in velocity in our character, which
    is conveniently managed by the Character Controller, and change the animation
    accordingly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在我们的角色中寻找一些速度的变化，这由角色控制器方便地管理，并相应地更改动画。
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if you go back and run the application you will find that the player moves
    into a walk animation when we move the joystick around whenever the player reaches
    a certain speed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你回到应用程序并运行它，你会发现当我们将操纵杆移动到某个速度时，玩家会进入行走动画：
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_29.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 驾驶我们的角色](img/978-1-84969-040-9_7_29.jpg)'
- en: What just happened?
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just added in functionality to drive our player around the world using
    the joystick numbs and the standard locomotion system employed by Unity. However,
    there are a number of limitations to our approach when we want to employ multiple
    animations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了使用操纵杆数字和Unity使用的标准移动系统来驾驶玩家在世界上移动的功能。然而，当我们想要使用多个动画时，我们的方法存在一些限制。
- en: We could certainly put in some code to look for when the player is beyond a
    certain velocity and have them move into a run animation with some simple conditional
    logic changes, but if you play around with the application you will find something
    very wrong with this picture. The player animates from the local origin and then
    snaps back to the origin when they reach the end of the animation. In addition
    when physics is applied to this character there will be a disconnect between the
    animation and the character hierarchy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以添加一些代码来查找玩家超过一定速度时，通过简单的条件逻辑更改让他们进入跑步动画，但如果你在应用程序中尝试，你会发现这个画面有问题。玩家从本地原点开始动画，然后在动画结束时突然回到原点。此外，当物理应用于此角色时，动画和角色层次之间将出现断开。
- en: You could certainly fix some of this by having the animator perform the animations
    in place, but then you would lose the ability to really see how the animation
    will look. Seeing the gait, stride, and swing of the character is only really
    possible when the character is actually in motion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过让动画师在现场执行动画来修复这些问题，但这样您就会失去真正看到动画外观的能力。只有在角色实际运动时，才能真正看到角色的步态、步幅和摆动。
- en: To fix all of this, however, we need another solution. What we really need to
    do is track where the character is during their animation so that when they are
    at the end of the animation we can start playing the animation again at that position
    and orientation. This will become increasingly important as we try to have our
    player walk on steps, or collide with objects. In other words we need to drive
    the character's motion with the animation itself, and we can't do that by simply
    changing the character's location and telling them to play an animation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了修复所有这些问题，我们需要另一个解决方案。我们真正需要做的是在动画过程中跟踪角色的位置，这样当动画结束时，我们就可以从该位置和方向开始重新播放动画。当我们尝试让玩家在台阶上行走或与物体碰撞时，这一点将变得越来越重要。换句话说，我们需要用动画本身来驱动角色的运动，而不仅仅是通过改变角色的位置并告诉他们播放一个动画来实现这一点。
- en: Time for action — Getting a driver's license with Root Motion Controller
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用根运动控制器获得驾照
- en: 'Fortunately, there is a prebuilt solution that, unsurprisingly, is available
    from Mixamo that will solve this problem for us with very little impact to our
    application code - the Root Motion Controller:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个预构建的解决方案，不出所料，来自Mixamo，它将为我们解决这个问题，对我们的应用程序代码的影响非常小——那就是**根运动控制器**：
- en: '![Time for action — Getting a driver''s license with Root Motion Controller](img/978-1-84969-040-9_7_32.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——使用根运动控制器获得驾照](img/978-1-84969-040-9_7_32.jpg)'
- en: First, go back to the **Asset Store** and search for a package known as the
    **Root Motion Controller**. This package from Mixamo, and developed by Adam Mechtley,
    has all of the functionality necessary for us to drive our character using the
    animation data — we need only configure it:![Time for action — Getting a driver's
    license with Root Motion Controller](img/978-1-84969-040-9_7_33.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，回到**资产商店**并搜索一个名为**根运动控制器**的包。这个由Mixamo提供并由Adam Mechtley开发的包包含了我们使用动画数据驱动角色所需的所有功能——我们只需要进行配置：![行动时间——使用根运动控制器获得驾照](img/978-1-84969-040-9_7_33.jpg)
- en: 'Next we need to select the **Player** model from our hierarchy, since this
    is the component of the hierarchy that we want to control with our new controller.
    When adding this to a similar project, just be sure to add this to the same node
    that contains the Character Controller, as you want movements from the Root Motion
    Computer to result in motion on everything at this level of the Hierarchy:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要从我们的层次结构中选择**玩家**模型，因为这个是我们想要用我们的新控制器控制的层次结构组件。当将此添加到类似的项目中时，请确保将其添加到包含角色控制器的相同节点，因为您希望从根运动计算机产生的运动影响层次结构此级别的所有内容：
- en: Note
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you were to attach the **Root Motion Computer** to the Soldier node, for
    example, the **Camera Relative Controls** would not be aware that the player has
    actually moved.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果您将**根运动计算机**附加到士兵节点上，**相机相对控制**将不会意识到玩家实际上已经移动。
- en: '![Time for action — Getting a driver''s license with Root Motion Controller](img/978-1-84969-040-9_7_30.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——使用根运动控制器获得驾照](img/978-1-84969-040-9_7_30.jpg)'
- en: Now that we have the right node in the hierarchy selected we can add the **Root
    Motion Computer** component by selecting the **Mixamo** menu item:![Time for action
    — Getting a driver's license with Root Motion Controller](img/978-1-84969-040-9_7_31.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经选择了层次结构中的正确节点，我们可以通过选择**Mixamo**菜单项来添加**根运动计算机**组件：![行动时间——使用根运动控制器获得驾照](img/978-1-84969-040-9_7_31.jpg)
- en: In the **Inspector** view you will see the **Root Motion Computer** component
    added to our Game Object. And with that we're actually done with the vast majority
    of the work that needs to be done. So let's take it out for a test drive:![Time
    for action — Getting a driver's license with Root Motion Controller](img/978-1-84969-040-9_7_34.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，您将看到添加到我们的游戏对象中的**根运动计算机**组件。有了这个，我们就完成了大部分需要完成的工作。那么，让我们来测试一下：![行动时间——使用根运动控制器获得驾照](img/978-1-84969-040-9_7_34.jpg)
- en: Change the settings of the animations for the character, so that the default
    animation is set to **walk:**![Time for action — Getting a driver's license with
    Root Motion Controller](img/978-1-84969-040-9_7_35.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改角色的动画设置，将默认动画设置为**walk:**![行动时间——使用Root Motion Controller获得驾照](img/978-1-84969-040-9_7_35.jpg)
- en: Next, set the **Animation Wrap Mode** for the animation to **Loop** so that
    it will play repeatedly. Now when you run the application the player will walk
    repeatedly forward until they walk off the world.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将动画的**动画循环模式**设置为**Loop**，以便它将重复播放。现在当你运行应用程序时，玩家将反复向前走，直到他们走出世界。
- en: What just happened?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We've just accomplished a significant step! Not only have we imported animations,
    but we are also using the animations to drive the character around the scene.
    With all of our animations synchronized with the location and orientation of the
    player in the scene and controlled with the joysticks we can turn our attention
    to the gameplay elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了一个重要的步骤！我们不仅导入了动画，而且还在使用动画来驱动角色在场景中移动。由于我们的所有动画都与场景中玩家的位置和方向同步，并且由操纵杆控制，我们可以将注意力转向游戏元素。
- en: Rotation via Accelerometer
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过加速度计旋转
- en: The next thing we need to handle is rotating the camera based upon the user
    tilting the device. In our design we said that this would represent rotation of
    the camera so we need to detect these motions and adjust our camera based upon
    the user's intent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要处理的是根据用户倾斜设备来旋转相机。在我们的设计中，我们说这将代表相机的旋转，因此我们需要检测这些动作并根据用户的意图调整我们的相机。
- en: Time for action — Updating upon device tilt
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——根据设备倾斜更新
- en: 'As discussed earlier, iOS devices have a defined access that allows us to determine
    changes in the device''s orientation. We can detect this as changes in the x,
    y, or z values in Input.acceleration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，iOS设备有一个定义的访问权限，允许我们确定设备方向的变化。我们可以在Input.acceleration中的x、y或z值变化中检测到这一点：
- en: '![Time for action — Updating upon device tilt](img/978-1-84969-040-9_7_38.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——根据设备倾斜更新](img/978-1-84969-040-9_7_38.jpg)'
- en: Since our game design requires us to manipulate the camera based upon the tilt,
    the only step we need is to check for the direction of the orientation change
    and then rotate the camera accordingly. To accomplish this we can attach a script
    to a GameObject in whose `Update()` method we examine the `Input.acceleration`
    attributes and determine how the device has changed. Remember also that we have
    specified that our application be designed to run in landscape mode so we are
    looking for rotations along the device's Z-axis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏设计需要我们根据倾斜来操纵相机，我们唯一需要做的就是检查方向变化的方向，然后相应地旋转相机。为了实现这一点，我们可以在一个GameObject上附加一个脚本，在该GameObject的`Update()`方法中检查`Input.acceleration`属性，并确定设备是如何变化的。记住，我们也指定了我们的应用程序设计为在横屏模式下运行，因此我们正在寻找沿设备Z轴的旋转。
- en: '| Key Method | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 关键方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Input.acceleration` | Returns the accelerometer readings of the device |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Input.acceleration` | 返回设备的加速度计读数 |'
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With `iPhoneSettings.screenOrientation` we can now tell the Unity player to
    change its orientation. You can set the orientation to any one of the `iPhoneScreenOrientations`
    available. It is recommended that you don't do anything that would be uncharacteristic
    to the way the iOS device is expected to operate as Apple may reject your application
    for that behavior.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iPhoneSettings.screenOrientation`，我们现在可以告诉Unity玩家更改其方向。你可以将方向设置为`iPhoneScreenOrientations`中可用的任何一个。建议你不要做任何不符合iOS设备预期操作的事情，因为苹果可能会因为这种行为拒绝你的应用程序。
- en: What just happened?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: By adding a script to our camera we get an `Update()` notification on a frame
    by frame basis. We can then look to see what the device orientation is and adjust
    our orientation accordingly. By updating the `iPhoneSettings` attributes we can
    quickly flip our scene to match whatever orientation we find ourselves in.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向我们的相机添加脚本，我们可以在每一帧获得`Update()`通知。然后我们可以查看设备的方向，并相应地调整我们的方向。通过更新`iPhoneSettings`属性，我们可以快速翻转场景以匹配我们发现自己所处的任何方向。
- en: Shaking the device to perform a healing action
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摇动设备以执行恢复动作
- en: The last thing we need to do is detect when the user has chosen to shake the
    device as our design specifies that we will use this as an indication that the
    user will perform a healing action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是检测用户是否选择了摇动设备，因为我们的设计规定我们将使用这个动作作为用户将执行恢复动作的指示。
- en: Time for action — Detecting a shake
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 检测震动
- en: The first step in handling an orientation change is to actually realize that
    the orientation has changed. There are two ways we can do this — we can either
    check when the game first starts up only, in which case we need to put our orientation
    detection in the `Start()` method as it is only called once. If we want to check
    orientation changes as the user is playing the game then we need to check the
    state of the orientation on a frame-by-frame basis. We do this by putting our
    orientation code in the `Update()` method.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理方向变化的第一步是实际上意识到方向已经改变。我们可以有两种方法来做这件事——我们可以在游戏第一次启动时检查，在这种情况下，我们需要将我们的方向检测放在`Start()`方法中，因为它只被调用一次。如果我们想在用户玩游戏时检查方向变化，那么我们需要逐帧检查方向的状态。我们通过将我们的方向代码放在`Update()`方法中来实现这一点。
- en: '| Key Methods | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 关键方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Input.acceleration` | Returns the accelerometer readings of the device |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Input.acceleration` | 返回设备的加速度计读数 |'
- en: We will use the `deviceOrientation` attribute of the Input class to determine
    what the orientation of the device is. This information comes directly from the
    OS in real time so as the orientation changes, we will be notified and can respond
    to the change without having to interrupt gameplay.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`deviceOrientation`属性来确定设备的方向。这个信息直接来自操作系统，实时更新，所以当方向改变时，我们会收到通知并可以响应变化，而无需打断游戏。
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Physician heal thyself
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 医生，治愈你自己
- en: Now that we know that a device shake has taken place we can perform the specific
    action that we want associated with the shake.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道设备已经发生了震动，我们可以执行与震动相关联的特定操作。
- en: 'In our `player` class we have a simple representation of the player''s health
    as an integer within our `Player` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`player`类中，我们在`Player`类内部用一个整数简单地表示玩家的健康状态：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our `Player` class is a simple heal method that we call whenever we detect
    that a shake of the device has happened.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Player`类中有一个简单的治疗方法，每当检测到设备震动时，我们就调用它。
- en: What just happened?
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have implemented the last input features for the game by detecting shakes
    of the device. Based upon this shake we have changed the user's state and taken
    an action. While shaking isn't a common action in games today, and I encourage
    you to use it sparingly, there are certainly times when it represents the best
    input option available.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检测设备的震动实现了游戏的最后输入特征。基于这个震动，我们改变了用户的状态并采取了一个行动。虽然震动在今天的游戏中并不常见，我鼓励你们谨慎使用，但确实有某些时候它代表了最好的可用输入选项。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we discussed the primary sensors used for input on iOS, namely
    the touch screen, gyroscope, and accelerometer. With this task covered we can
    provide a touch screen interface from our player which they can interact with,
    as well as gather information from movement and orientation of the iOS device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了iOS输入的主要传感器，即触摸屏、陀螺仪和加速度计。完成这个任务后，我们可以提供一个触摸屏界面，玩家可以与之交互，并从iOS设备的移动和方向中收集信息。
- en: 'Specifically, we covered:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: The different types of touch technologies, their strengths and weaknesses
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的触摸技术类型，它们的优缺点
- en: How to build a touchable user interface for the user on the device and gather
    input from it
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为设备上的用户构建可触摸的用户界面并从中收集输入
- en: How to import existing animations and how to import Mixamo animations
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何导入现有的动画以及如何导入Mixamo动画
- en: How to detect gestures and determine the user's intent
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测手势并确定用户的意图
- en: How to detect movement of the device and orientation changes
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测设备的移动和方向变化
- en: How to use this information to move an on-screen character through a 3D world
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用这些信息在3D世界中移动屏幕上的角色
- en: How to drive a character from animation data as opposed to programmatically
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从动画数据中驱动角色，而不是通过编程
- en: Now we have a character that we can control through our 3D world and we can
    animate this character based on input from the user. We have the beginnings of
    an actual game now, but the world is very quiet and the game is without flair.
    In the next chapter, Multimedia, we will explore how to add sound, music, and
    video to our game to give it some sex appeal.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以通过我们的3D世界控制的角色，我们可以根据用户的输入来动画化这个角色。现在我们有了实际游戏的开始，但世界非常安静，游戏缺乏魅力。在下一章，多媒体，我们将探讨如何向我们的游戏添加声音、音乐和视频，以增加它的吸引力。
