- en: Part 1. Module 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1部分 第1模块
- en: '***Learning Java by Building Android Games***'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***通过构建Android游戏学习Java***'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Get ready for a fun-filled experience of learning Java by developing games
    for the Android platform*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*准备好通过为Android平台开发游戏来享受学习Java的乐趣*'
- en: Chapter 1. Why Java, Android, and Games?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 为什么选择Java、Android和游戏？
- en: 'Welcome to *Learning Java by Building Android Games*, which I hope is just
    the beginning of your exciting journey into designing and writing games. By the
    end of this book, we will have made four complete games: a math quiz with dynamically
    increasing difficulty, a memory game in the style of the classic Simon toy, a
    pong-style squash game, and a clone of the classic *Snake* game.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到《通过构建Android游戏学习Java》，我希望这只是你进入设计和编写游戏激动人心的旅程的开始。到这本书的结尾，我们将制作四个完整的游戏：一个难度动态增加的数学测验，一个类似经典Simon玩具的记忆游戏，一个乒乓球风格的壁球游戏，以及经典*蛇*游戏的克隆版。
- en: Besides these games, we will build more than a dozen working apps to practice
    and demonstrate individual concepts to aid our learning of Java, Android, and
    games. Our games and apps will feature sound FX, graphics, and animations. We
    will learn everything from using the standard Android **User Interface** (**UI**)
    designer to creating smooth animations by plotting individual pixels.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些游戏，我们还将构建十几个工作应用来练习和展示单个概念，以帮助我们学习Java、Android和游戏。我们的游戏和应用将包含音效、图形和动画。我们将从使用标准的Android
    **用户界面**（**UI**）设计器到通过绘制单个像素来创建平滑动画的一切内容。
- en: Although I will encourage you to work with me and implement the specific projects
    that are detailed step by step throughout the book, I fully expect that once you
    grasp the different concepts, you will want to use them in your own unique creations
    without delay. This is exactly what I hope you will be inspired to do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我会鼓励你和我一起工作，并实现书中详细分步说明的具体项目，但我完全期待一旦你掌握了不同的概念，你将希望立即在自己的独特创作中使用它们。这正是我希望你能受到的启发。
- en: The game projects themselves are not the objective of the book but the means
    to a much loftier goal. By the end of the book, you will be able to design and
    implement your own 2D Android games, to sell or just to give away, on Google Play.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏项目本身不是本书的目标，而是达到更高目标的手段。到本书结束时，你将能够设计和实现自己的2D Android游戏，无论是为了出售还是免费赠送，都可以在Google
    Play上发布。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is a bit of ground work to cover first, but I promise it won't take long
    and it won't be complicated either. Anyone can learn to program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要做一些基础工作，但我保证这不会花费很长时间，也不会很复杂。任何人都可以学会编程。
- en: However, there are so many differing opinions among experts, which breeds confusion
    among beginners concerning the best ways of learning to program. So it is a good
    idea to look at why learning Java, Android, and games is an ideal pathway for
    beginners. This will be the first thing we will discuss in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，专家之间有如此多的不同意见，这会在初学者中产生关于学习编程最佳方法的困惑。因此，了解为什么学习Java、Android和游戏是初学者的理想途径是一个好主意。这是我们将在本书中首先讨论的内容。
- en: 'Here is what we will learn in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Is this book for me?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书适合我吗？
- en: Why should I use games to learn to program?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我为什么要用游戏来学习编程？
- en: Why should I learn Java and Android?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我要学习Java和Android？
- en: Setting up our development environment
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: Is this book for me?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书适合我吗？
- en: If you have already decided that Java, Android, or games are what you want to
    learn, then the next question might be, "Is this specific book for me?".
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经决定要学习Java、Android或游戏，那么下一个问题可能就是，“这本书适合我吗？”。
- en: There are plenty of Java books for beginners and books by much more accomplished
    authors and programmers than myself. I have read many of them and admire the authors.
    However, when these books drift away—which they all do—to topics such as Java-native
    interfaces, web browser applets, or server-side remote communication, I sometimes
    find myself questioning their immediate relevance to me.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，有很多Java书籍，以及比我更有成就的作者和程序员的书籍。我读过很多，并且很钦佩这些作者。然而，当这些书籍偏离主题——它们都会这样做——涉及到诸如Java本地接口、网络浏览器小程序或服务器端远程通信等话题时，我有时会质疑它们对我直接的相关性。
- en: At this point, at least subconsciously, my commitment would wane and the learning
    process would slow or stop.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，至少在潜意识里，我的承诺会减弱，学习过程会放缓或停止。
- en: If you just want to learn pure Java
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果你只想学习纯Java
- en: If you just want to learn Java on its own, this book will be a solid start.
    Although the Android stuff might be considered overhead to your pure Java learning,
    this is much less than the multitude of potentially unnecessary topics that would
    be introduced in any other Java book. The only caveat with this book is that the
    necessary overhead is all at the beginning. But once this minimal overhead is
    cleared, we can focus quite intently on Java.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想单独学习Java，这本书将是一个坚实的起点。尽管Android的内容可能被认为是纯Java学习的额外开销，但这比任何其他Java书籍中可能引入的众多不必要的话题要少得多。这本书的唯一缺点是所有必要的开销都在开始时。但一旦这个最小开销被清除，我们就可以非常专注地学习Java。
- en: 'With regard to the amount of overhead:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于开销的量：
- en: It will take about six pages to set up our programming environment in this chapter
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中设置我们的编程环境需要大约六页
- en: It will take [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to get familiar with the Android tools, create
    your first working project, and glimpse your first real Java code
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要熟悉Android工具、创建你的第一个工作项目并瞥见你的第一段真正的Java代码，需要[第2章](ch02.html "Chapter 2. Getting
    Started with Android"), *开始使用Android*
- en: From then on, it will be nearly pure Java and building games
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从那时起，它将几乎完全是Java和构建游戏
- en: You will soon see that the tiny amount of overhead is not excessive and is well
    worthwhile.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到，微量的开销并不算多，而且是非常值得的。
- en: If Android is your focus
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果Android是你的重点
- en: If it was Android itself that made you look at this book, then I am proud to
    say this is the first book that will teach you Android without assuming you have
    any prior Java or programming knowledge whatsoever.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是Android本身让你看了这本书，那么我很自豪地说，这是第一本不假设你有任何先前的Java或编程知识的Android书籍。
- en: Where this book will take you
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这本书将带你去往何方
- en: 'By the end of this book, you will be able to easily take one of many paths
    including these:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书结束时，你将能够轻松地选择许多路径之一，包括以下这些：
- en: Learning Java at a higher level for any platform
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何平台上以更高水平学习Java
- en: Intermediate level Android learning including pure game frameworks (which will
    be covered in more detail in [Chapter 9](ch09.html "Chapter 9. Making Your Game
    the Next Big Thing"), *Making Your Game the Next Big Thing*)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中级水平的Android学习，包括纯游戏框架（将在第9章[Chapter 9. Making Your Game the Next Big Thing]中更详细地介绍），*制作你的游戏成为下一个大热门*
- en: A higher level of games development
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级别的游戏开发
- en: Much easier tackling of any modern object-oriented language for things such
    as iOS, Windows, or web development
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易地处理任何现代面向对象的语言，如iOS、Windows或Web开发
- en: So if you know you want to learn Android or Java, hopefully, I have gone some
    way to make you commit to the way this book will help you. But why games, Android,
    or Java at all?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你知道你想要学习Android或Java，希望我已经走了一些路来让你承诺这本书将如何帮助你。但为什么是游戏、Android或Java呢？
- en: Why build games to learn to program?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要通过制作游戏来学习编程？
- en: Fun, of course! But there are other reasons too. Successfully running any program
    we have written is immensely satisfying, even more so when it involves using some
    code that we previously didn't understand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 趣味，当然！但还有其他原因。成功运行我们编写的任何程序都令人无比满足，尤其是当它涉及到使用一些我们之前不理解的一些代码时。
- en: But making our own games, as you will soon realize, creates a feeling of pleasure
    that is not easy to describe—it has to be experienced. Then there are added bonuses
    of sharing our creations with friends on a phone or tablet or even sharing them
    publicly on the Google Play Store, and you might realize that once you start making
    games, you can't stop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你很快就会意识到的那样，自己制作游戏会带来一种难以描述的愉悦感——必须亲身体验。然后还有将我们的作品与朋友在手机或平板电脑上分享，甚至公开在Google
    Play Store上分享的额外好处，你可能会意识到一旦你开始制作游戏，你就无法停止。
- en: As we create more complex games steadily, you'll realize that all techniques
    and pieces of code can be rehashed to create other games, and you can then start
    planning your very own unique masterpieces. This is exhilarating to say the least.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们持续创建更复杂的游戏，你会发现所有技术和代码片段都可以重新组合来创建其他游戏，然后你可以开始规划你自己的独特杰作。这至少是非常令人兴奋的。
- en: And as with many subjects, the more we practice the better we get. So games
    are a perfect way to start learning to program Java. However, most beginners'
    books for Android games require a fairly high level of Java knowledge. But as
    we will see, it is perfectly possible to keep the practical examples as fun game
    projects and still start with the very basics of Java.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多学科一样，我们练习得越多，我们就越好。所以，游戏是开始学习编程Java的完美方式。然而，大多数Android游戏入门书籍都需要相当高的Java知识水平。但正如我们将看到的，完全有可能将实际示例作为有趣的游戏项目，并从Java的非常基础开始。
- en: There is a slight trade-off in doing things this way. We will not always approach
    the working game examples in a "by-the-book" manner. This is to avoid the problem
    of doing cartwheels before mastering the forward roll.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些微小的权衡。我们不会总是以“按部就班”的方式处理工作游戏示例。这是为了避免在掌握前进翻滚之前就翻跟头的风险。
- en: The learning outcome priority will always be the Java programming concept, followed
    by understanding the Android environment and game design principles. Having said
    that, we will closely examine and practice plenty of Android and game programming
    fundamentals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 学习成果的优先级始终是Java编程概念，其次是理解Android环境和游戏设计原则。话虽如此，我们将仔细检查和实践大量的Android和游戏编程基础。
- en: Of course, from what we have just discussed, you can probably surmise that it
    would have been possible to teach a bit more Java in the same number of pages
    if we hadn't been making games.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根据我们刚才讨论的内容，如果你我们没有制作游戏，那么在相同数量的页码中，我们可能已经能够教授更多的Java知识。
- en: This is true, but then we lose all the benefits that come with using games as
    the subject matter. Making games really can be a joy, and when our brains are
    open and eager for information, we will learn much faster. The minimal overhead
    of learning this way is negated a hundred times over. If games don't interest
    you in the slightest, then there are plenty of Java beginners' guides out there
    that take the traditional approach. Just don't expect quite the same thrill as
    when you publish your first game with online leaderboards and achievements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点是正确的，但这样一来，我们就失去了使用游戏作为主题所带来的所有好处。制作游戏确实可以是一种乐趣，当我们的头脑开放且渴望信息时，我们会学得更快。这种学习方式的最低成本被抵消了百倍。如果你对游戏完全不感兴趣，那么市面上有很多采用传统方法的Java入门指南。只是不要期待当你发布带有在线排行榜和成就的第一款游戏时会有同样的兴奋感。
- en: Why Android and Java?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Android和Java？
- en: A part of successful learning is the commitment by the student, not just to
    do the work, but in their belief that they are doing the right thing in the right
    way. So many technology-based courses and books don't get that commitment from
    the reader, not subconsciously anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 成功学习的一部分是学生的承诺，不仅是要完成工作，而且要相信他们正在以正确的方式做正确的事情。所以，许多基于技术的课程和书籍并没有从读者那里获得这种承诺，至少不是无意识的承诺。
- en: The problem is the students' belief that they might be, partly at least, wasting
    their time with something that is or will soon become outdated or perhaps is not
    quite right for them. This can be true to a large extent with programming. So
    why should you spend your finite time learning Java, on Android?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于学生们的信念，他们可能至少部分地认为，他们在浪费时间，因为某些东西可能很快就会过时，或者可能并不完全适合他们。这在编程方面在很大程度上是正确的。那么，为什么你应该花有限的时间学习Java，特别是Android的Java呢？
- en: Android is the fastest evolving and growing OS ever
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android是发展最快、增长最快的操作系统
- en: At one time, Android updates emerged almost every two months. Even now, they
    emerge about once in six months. By comparison, Windows takes years between versions
    and even iOS updates come only yearly and usually change relatively little between
    versions. Android is obviously evolving and improving at an unprecedented rate.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，Android的更新几乎每两个月就会推出一次。即便现在，它们大约每六个月更新一次。相比之下，Windows版本之间的间隔需要数年，甚至iOS的更新也通常是每年一次，而且版本之间的变化相对较小。Android显然正在以前所未有的速度发展和改进。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Look at the history of Android versions since Version 1 at [http://www.cnet.com/news/history-of-android/](http://www.cnet.com/news/history-of-android/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看自Android 1.0版本以来的Android版本历史，请访问[http://www.cnet.com/news/history-of-android/](http://www.cnet.com/news/history-of-android/)。
- en: The first humble version of Android was released in 2008, around the same time
    when consumers were already quite excited about the then much flashier iPhone.
    News stories were also reporting that developers were getting rich by selling
    apps in the iTunes app store.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Android的第一个版本于2008年发布，当时消费者对当时更加炫目的iPhone已经相当兴奋。新闻故事也报道说，开发者通过在iTunes应用商店销售应用而变得富有。
- en: But in the last full year before this book was written, Samsung alone shipped
    more Android units than Apple sold all iOS devices combined. I am not joining
    the war on whose devices are best. I enjoy aspects of both Android and Apple,
    but purely in terms of picking a platform to learn on, you are probably in the
    right place at the right time with Android.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但在撰写本书的最后一整年，三星独自销售的安卓设备数量超过了苹果销售的iOS设备总和。我并不参与关于哪个设备更好的战争。我享受安卓和苹果的各个方面，但纯粹从选择学习平台的角度来看，你可能是在正确的时间和地点选择了安卓。
- en: Android developers have great prospects
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓开发者有广阔的前景
- en: Now you might have picked up this book just for the fun and satisfaction that
    comes with learning to program games. But if you decide to develop your learning
    further, you will find that the demand for Android programmers is enormous and
    therefore very lucrative too.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能只是因为学习编程游戏带来的乐趣和满足感而选择了这本书。但如果你决定进一步发展你的学习，你会发现安卓程序员的需求数量巨大，因此也非常有利可图。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some data suggests salaries in excess of 100,000 US dollars. For more information,
    go to [http://www.indeed.com/salary?q1=Android+Developer&l1=United+States](http://www.indeed.com/salary?q1=Android+Developer&l1=United+States).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据显示，薪资超过10万美元。更多信息，请访问[http://www.indeed.com/salary?q1=Android+Developer&l1=United+States](http://www.indeed.com/salary?q1=Android+Developer&l1=United+States)。
- en: Android is open source
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓是开源的
- en: What open source means is that although Google develops all the flavors of Android
    that are used on the newest devices, once the code is released, anybody can do
    whatever they like with it. Google only exerts control for a limited amount of
    time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的意思是，尽管谷歌开发了用于最新设备上的所有安卓版本，但一旦代码发布，任何人都可以随意使用它。谷歌只对代码进行有限时间的控制。
- en: In practice, most Android users have the pure Google OS or the modified versions
    turned out by big manufacturers such as Samsung and HTC, but there is nothing
    to stop anybody taking the OS and changing, adapting, or converting it into whatever
    they like. In short, Android could never be taken away from the programming community.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数安卓用户使用的是纯谷歌操作系统，或者是由三星和HTC等大型制造商推出的修改版。但没有任何东西可以阻止任何人获取操作系统并对其进行更改、适应或将其转换为任何他们喜欢的东西。简而言之，安卓永远不会从编程社区中消失。
- en: Java is here to stay
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java将长期存在
- en: Okay, so we see Android isn't likely to disappear but could Java become redundant?
    And will your significant time investment be wasted? On Android, as with most
    platforms, you can use many languages and tools. Android, however, was designed
    from the ground up to facilitate Java development. All other languages and tools
    are not invalid but tend to serve a fairly specific purpose, rather than be a
    real alternative to Java. In fact, as far as games are concerned, many of the
    alternatives to a pure Java development environment are also Java-based and require
    a good level of skill in Java to use. For example, the popular LibGDX game development
    library, which allows you to simultaneously make games for Android, iOS, Windows,
    Linux, Mac and even the Web, still uses Java! We will talk more about this in
    [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next Big Thing"), *Making
    Your Game the Next Big Thing*. The point is that Java and Android are tied together
    and will likely thrive together.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们看到安卓不太可能消失，但Java是否会变得过时？而且你投入的大量时间是否会白费？在安卓平台上，就像大多数平台一样，你可以使用许多语言和工具。然而，安卓是从底层设计的，旨在促进Java开发。所有其他语言和工具都不是无效的，但往往只服务于相当具体的目的，而不是Java的真正替代品。实际上，就游戏而言，许多纯Java开发环境的替代品也是基于Java的，并且需要具备相当水平的Java技能才能使用。例如，流行的LibGDX游戏开发库，它允许你同时为安卓、iOS、Windows、Linux、Mac甚至网络开发游戏，仍然使用Java！我们将在[第9章](ch09.html
    "第9章。让你的游戏成为下一个大热门")中更多讨论这一点，*让你的游戏成为下一个大热门*。重点是Java和安卓紧密相连，并且可能会共同繁荣。
- en: Java is not just for Android
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java不仅仅是为安卓
- en: Java has been around a lot longer than Android, since the beginning of the 1990s
    in fact. Although what Java has been used for has evolved and diversified over
    more than two decades, the originally implemented strengths of the language itself
    remain the same today.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java的历史比安卓悠久得多，实际上是从20世纪90年代初开始的。尽管Java的应用范围在超过二十年的时间里已经演变和多样化，但语言本身最初实现的优势今天仍然保持不变。
- en: Java was designed to be platform- or computer-independent. This is achieved
    by the use of a **virtual machine** (**VM**). This is a program written in another
    language that decodes the Java program that we write and interacts with the computer
    platform it is running on. So as long as there is a VM for the computer you want
    to run your Java program on, with a few caveats, your Java program will work.
    So if you learn Java, you are learning a language that is used everywhere from
    the smart fridge to the Web and most places in between.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Java被设计成平台或计算机无关。这是通过使用**虚拟机**（**VM**）来实现的。这是一个用另一种语言编写的程序，它解码我们编写的Java程序，并与它运行的计算机平台交互。所以只要有一个VM可以在你想要运行Java程序的计算机上运行，有一些限制，你的Java程序就会工作。所以如果你学习Java，你就是在学习一种从智能冰箱到网络以及大多数中间位置都使用的语言。 '
- en: It is true, however, that the VM on each platform can and usually does implement
    features to specifically suit the uses it is likely to be put to. A clear example
    of this would be mobile-device-specific features such as sensors, GPS, or the
    built-in camera on many Android devices. Using Java with Android, you can take
    photos, detect the air pressure, and work out exactly where in the world you are.
    Most fridge VMs probably will not do this. So you can't always just run a Java
    program designed for device x on device y, but the language and syntax is the
    same. Learning Java on Android prepares you in a large part for Java in any situation.
    So rest assured that Java isn't going away any time soon.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实，每个平台上的虚拟机都可以并且通常确实实现了特定于其可能被用于的功能。一个明显的例子就是针对移动设备的功能，比如传感器、GPS或者许多Android设备内置的摄像头。使用Java和Android，你可以拍照、检测空气压力，并精确地计算出你在世界上的确切位置。大多数冰箱虚拟机可能不会这样做。所以你并不能总是只在设备x上运行为设备y设计的Java程序，但语言和语法是相同的。在Android上学习Java在很大程度上为你准备在任何情况下使用Java。所以请放心，Java不会很快消失。
- en: Java is fast and easy to use
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java快速且易于使用
- en: There is a decades-long debate over which language is the best overall or which
    language is the best to learn programming. Critics of Java will likely say things
    about Java's speed. It is true that the Java memory management along with the
    VM interpretation process does have some speed cost. However, these things have
    benefits; they significantly improve our productivity and the way that the Android
    VM interacts with a device largely negates the minor speed penalty. And since
    Android 4.4, it does so completely with **Android Run Time** (**ART**), which
    installs apps written in Java as fully native applications. Now Java programmers
    can build games in a friendly, interpreted language and have them run as if they
    were written in a more challenging natively compiled language.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪种语言是整体上最好的或者哪种语言是学习编程最好的，已经有数十年的争论。Java的批评者可能会说关于Java速度的一些事情。确实，Java的内存管理和虚拟机解释过程确实有一些速度成本。然而，这些事情也有好处；它们显著提高了我们的生产力，并且Android虚拟机与设备交互的方式在很大程度上抵消了轻微的速度惩罚。并且自从Android
    4.4以来，它完全通过**Android运行时**（**ART**）来实现，将用Java编写的应用程序安装为完全本机应用程序。现在Java程序员可以用一种友好的、解释型语言构建游戏，并且它们可以像用更具挑战性的本机编译语言编写的那样运行。
- en: A summary of Java and Android
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java和Android的总结
- en: In a rapidly changing world, if you are worried about where to invest your precious
    learning time, it is hard to have more confidence. Here we have a language (Java)
    whose fundamentals have remained almost the same for nearly a quarter of a century,
    and a platform (Android) that is backed by the biggest names in hardware, software,
    and retail, and though it's admittedly hugely influenced, it's not actually owned
    by anyone.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个快速变化的世界里，如果你担心在哪里投资你宝贵的学习时间，很难更有信心。这里我们有一个语言（Java），其基础几乎保持了近四分之一世纪不变，有一个平台（Android），它得到了硬件、软件和零售界最大公司的支持，尽管它确实受到了巨大的影响，但实际上并不属于任何人。
- en: I am not an evangelist of any technology over another although it is true that
    I love doing stuff on Android. But you can be sure in your mind that if you are
    considering the best path to begin learning programming, there is a very strong
    argument that Java and Android are the best choice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是任何一种技术的传教士，尽管确实我喜欢在Android上做事情。但你可以确信，如果你正在考虑学习编程的最佳路径，有一个非常有力的论据认为Java和Android是最好的选择。
- en: If you want to learn Java for any of its numerous uses, then this is a very
    good place to start. If you want to develop for Android or get into Android development
    of any sort, then Java is the absolute fundamental way to start, and making games
    has the enormous benefits we have already discussed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要学习 Java 以用于其众多用途中的任何一个，那么这是一个非常好的开始地方。如果你想要为 Android 开发或者进入任何形式的 Android
    开发，那么 Java 是绝对的基础入门方式，制作游戏也有我们已讨论过的巨大好处。
- en: By the end of the book, you will be able to write Java code for almost any Java-supported
    platform. You will be able use almost everything you learn in this book, away
    from the Android environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到了本书的结尾，你将能够为几乎任何 Java 支持的平台编写 Java 代码。你将能够使用本书中学到的几乎所有内容，即使是在 Android 环境之外。
- en: If you are planning to pursue a career or business by making Android games or
    any Android apps, then this book is possibly the only place to start for beginners.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划通过制作 Android 游戏或任何 Android 应用来追求职业或商业，那么这本书可能是初学者开始的地方。
- en: If you are completely new to Java and want the easiest possible path to mastering
    it—the fastest growing platform on the planet—then *Learning Java by Building
    Android Games* will probably be just right for you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全对 Java 一无所知，并且想要掌握它的最简单路径——地球上增长最快的平台——那么《通过构建 Android 游戏学习 Java》可能正是你所需要的。
- en: So hopefully you are assured that the path this book will take to learn Java
    is as easy, fun, and thorough as learning Java can be. Let's get set up so we
    can start building games.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，希望你能确信这本书将带你学习 Java 的路径将和 Java 学习本身一样简单、有趣且全面。让我们开始设置，以便我们可以开始构建游戏。
- en: Setting up our development environment
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: The first thing we need to do is prepare our PC to develop for Android using
    Java. Fortunately, this is made quite simple for us.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为使用 Java 开发 Android 准备我们的 PC。幸运的是，这对我们来说变得相当简单。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are learning on Mac or Linux, everything in this book will still work.
    The next two tutorials have Windows-specific instructions and screenshots. However,
    it shouldn't be too difficult to vary the steps slightly to suit Mac or Linux.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在 Mac 或 Linux 上学习，这本书中的所有内容都将适用。接下来的两个教程将包含针对 Windows 的特定说明和屏幕截图。然而，调整步骤以适应
    Mac 或 Linux 应该不会太难。
- en: 'All we need to do is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是：
- en: Install a software package called the **Java Development Kit** (**JDK**), which
    allows us to develop in Java.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个名为**Java 开发工具包**（**JDK**）的软件包，它允许我们在 Java 中进行开发。
- en: Install Android Studio, a program designed to make Android development fast
    and easy. Android Studio uses the JDK and some other Android-specific tools that
    automatically get installed when we install Android Studio.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Android Studio，这是一个旨在使 Android 开发快速且简单的程序。Android Studio 使用 JDK 以及一些其他在安装
    Android Studio 时自动安装的特定于 Android 的工具。
- en: Installing the JDK
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 JDK
- en: 'The first thing we need to do is get the latest version of the JDK. To complete
    this guide, perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取 JDK 的最新版本。为了完成本指南，请执行以下步骤：
- en: You need to be on the Java website, so visit [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要访问 Java 网站，因此请访问 [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。
- en: Find the three buttons shown in the following screenshot and click on the one
    that says **JDK** (highlighted). They are on the right-hand side of the web page.
    Click on the **DOWNLOAD** button under the **JDK** option:![Installing the JDK](img/8859OS_01_01.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中所显示的三个按钮中找到并点击标有**JDK**（高亮显示）的按钮。它们位于网页的右侧。在**JDK**选项下点击**下载**按钮：![安装
    JDK](img/8859OS_01_01.jpg)
- en: You will be taken to a page that has multiple options to download the JDK. In
    the **Product/File description** column, you need to click on the option that
    matches your operating system. Windows, Mac, Linux and some other less common
    options are all listed.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被带到具有多个下载 JDK 选项的页面。在**产品/文件描述**列中，你需要点击与你的操作系统匹配的选项。Windows、Mac、Linux 以及一些其他不太常见的选项都列出来了。
- en: A common question here is, "do I have 32- or 64-bit windows?". To find out,
    right-click on your **My Computer** (This PC on Windows 8) icon, click on the
    **Properties** option, and look under the **System** heading in the **System type**
    entry, as shown in the following screenshot:![Installing the JDK](img/8859OS_01_02.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里一个常见的问题是，“我是否有 32 位或 64 位的 Windows？”要找出答案，请右键单击你的**我的电脑**（Windows 8 上的**此电脑）图标，点击**属性**选项，然后在**系统类型**条目下的**系统**标题下查看，如下面的屏幕截图所示：![安装
    JDK](img/8859OS_01_02.jpg)
- en: Click on the somewhat hidden **Accept** **License Agreement** checkbox:![Installing
    the JDK](img/8859OS_01_03.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击稍显隐藏的**接受许可协议**复选框：![安装JDK](img/8859OS_01_03.jpg)
- en: Now click on the download option for your OS and system type as previously determined.
    Wait for the download to finish.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击您之前确定的操作系统和系统类型的下载选项。等待下载完成。
- en: In your `Downloads` folder, double-click on the file you just downloaded. The
    latest version at time of writing this for a 64-bit Windows PC was `jdk-8u5-windows-x64`.
    If you are using Mac/Linux or have a 32-bit OS, your filename will vary accordingly.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`下载`文件夹中，双击您刚刚下载的文件。截至撰写本文时，64位Windows PC的最新版本是`jdk-8u5-windows-x64`。如果您使用Mac/Linux或32位操作系统，您的文件名将相应变化。
- en: In the first of several install dialogs, click on the **Next** button and you
    will see the next dialog box:![Installing the JDK](img/8859OS_01_05.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个安装对话框中的第一个，点击**下一步**按钮，您将看到下一个对话框：![安装JDK](img/8859OS_01_05.jpg)
- en: Accept the defaults shown in the previous screenshot by clicking on **Next**.
    In the next dialog box, you can accept the default install location by clicking
    on **Next**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**下一步**接受之前屏幕截图显示的默认设置。在下一个对话框中，您可以通过点击**下一步**接受默认的安装位置。
- en: Next is the last dialog of the Java installer. Click on **Close**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是Java安装程序的最后一个对话框。点击**关闭**。
- en: The JDK is now installed. Next we will make sure that Android Studio is able
    to use the JDK.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JDK现在已安装在您的PC上。接下来我们将确保Android Studio能够使用JDK。
- en: Right-click on your **My Computer** (This PC on Windows 8) icon and navigate
    to **Properties** | **Advanced system settings** | **Environment variables** |
    **New** (under **System variables,** not under **User variables**). Now you can
    see the **New** **System Variable** dialog, as shown in the following screenshot:![Installing
    the JDK](img/8859OS_01_07.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的**我的电脑**（Windows 8上的“此电脑”）图标，导航到**属性** | **高级系统设置** | **环境变量** | **新建**（在**系统变量**下，不在**用户变量**下）。现在您可以看到如下所示的**新建系统变量**对话框：![安装JDK](img/8859OS_01_07.jpg)
- en: Type `JAVA_HOME` for **Variable name** and enter `C:\Program Files\Java\jdk1.8.0_05`
    for the **Variable value** field. If you installed the JDK somewhere else, then
    the file path you enter in the **Variable value:** field will need to point to
    wherever you put it. Your exact file path will likely have a different ending
    to match the latest version of Java at the time you downloaded it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**变量名**处输入`JAVA_HOME`，并在**变量值**字段中输入`C:\Program Files\Java\jdk1.8.0_05`。如果您在其他位置安装了JDK，那么在**变量值**字段中输入的文件路径需要指向您放置它的位置。您的确切文件路径可能以不同的结尾结束，以匹配您下载时的Java最新版本。
- en: Click on **OK** to save your new settings. Now click on **OK** again to clear
    the **Advanced system settings** dialog.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**保存您的新设置。现在再次点击**确定**以清除**高级系统设置**对话框。
- en: Now we have the JDK installed on our PC. We are about half way towards starting
    to learn Java programming, but we need a friendly way to interact with the JDK
    and to help us make Android games in Java.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的PC上安装了JDK。我们距离开始学习Java编程已经走了一半的路，但我们需要一个友好的方式与JDK交互，并帮助我们用Java制作Android游戏。
- en: Android Studio
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Studio
- en: 'We learned that Android Studio is a tool that simplifies Android development
    and uses the JDK to allow us to write and build Java programs. There are other
    tools you can use instead of Android Studio. There are pros and cons in them all.
    For example, another extremely popular option is Eclipse. And as with so many
    things in programming, a strong argument can be made as to why you should use
    Eclipse instead of Android Studio. I use both, but what I hope you will love about
    Android Studio are the following elements:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到Android Studio是一个简化Android开发的工具，并使用JDK允许我们编写和构建Java程序。您可以使用其他工具代替Android
    Studio。它们各有优缺点。例如，另一个极其流行的选择是Eclipse。就像编程中的许多事情一样，可以强烈论证为什么您应该使用Eclipse而不是Android
    Studio。我两者都使用，但我希望您会喜欢Android Studio的以下元素：
- en: It is a very neat and, despite still being under development, a very refined
    and clean interface.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个非常整洁的界面，尽管仍在开发中，但非常精致和干净。
- en: It is much easier to get started compared to Eclipse because several Android
    tools that would otherwise need to be installed separately are already included
    in the package.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Eclipse相比，开始使用它要容易得多，因为几个原本需要单独安装的Android工具已经包含在包中。
- en: Android Studio is being developed by Google, based on another product called
    IntelliJ IDEA. There is a chance it will be the standard way to develop Android
    in the not-too-distant future.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio 由 Google 开发，基于另一个名为 IntelliJ IDEA 的产品。它有可能在未来不久成为开发 Android 的标准方式。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to use Eclipse, that's fine; all of the code in this book will work.
    However, some the keyboard shortcuts and user interface buttons will obviously
    be different. If you do not have Eclipse installed already and have no prior experience
    with Eclipse, then I even more strongly recommend you to go ahead with Android
    Studio.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 Eclipse，那也行；这本书中的所有代码都将正常工作。然而，一些快捷键和用户界面按钮显然会有所不同。如果你还没有安装 Eclipse，并且没有
    Eclipse 的先验经验，那么我更强烈地建议你继续使用 Android Studio。
- en: Installing Android Studio
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Android Studio
- en: So without any delay, let's get Android Studio installed and then we can begin
    our first game project. To do this, let's visit [https://developer.android.com/sdk/installing/studio.html](https://developer.android.com/sdk/installing/studio.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们毫不拖延地开始安装 Android Studio，然后我们可以开始我们的第一个游戏项目。为此，让我们访问[https://developer.android.com/sdk/installing/studio.html](https://developer.android.com/sdk/installing/studio.html)。
- en: Click on the button labeled **Download Android Studio** to start the Android
    studio download. This will take you to another web page with a very similar-looking
    button to the one you just clicked on.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标有**下载 Android Studio**的按钮开始下载 Android Studio。这将带你去另一个看起来非常相似的网页，上面有一个你刚刚点击过的按钮。
- en: Accept the license by checking in the checkbox, commence the download by clicking
    on the button labeled **Download Android Studio for Windows**, and wait for the
    download to complete. The exact text on the button will probably vary depending
    on the current latest version.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选复选框接受许可，通过点击标有**下载 Android Studio for Windows**的按钮开始下载，并等待下载完成。按钮上的确切文本可能会根据当前最新版本而有所不同。
- en: In the folder in which you just downloaded Android Studio, right-click on the
    `android-studio-bundle-135.12465-windows.exe` file and click on **Run as administrator**.
    The end of your filename will vary depending upon the version of Android Studio
    and your operating system.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚下载 Android Studio 的文件夹中，右键单击`android-studio-bundle-135.12465-windows.exe`文件，然后点击**以管理员身份运行**。文件名末尾将根据
    Android Studio 的版本和你的操作系统而有所不同。
- en: When asked if you want to **Allow the following program from an unknown publisher
    to make changes to your computer**, click on **Yes**. On the next screen, click
    on **Next**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问你是否想要**允许来自未知发布者的以下程序更改你的计算机**时，请点击**是**。在下一个屏幕上，点击**下一步**。
- en: On the screen shown in the following screenshot, you can choose which users
    of your PC can use Android Studio. Choose whatever is right for you as all options
    will work, and then click on **Next**:![Installing Android Studio](img/8859OS_01_10.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图显示的屏幕上，你可以选择你的 PC 上哪些用户可以使用 Android Studio。选择适合你的选项，因为所有选项都会正常工作，然后点击**下一步**：![安装
    Android Studio](img/8859OS_01_10.jpg)
- en: In the next dialog, leave the default settings and then click on **Next**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，保留默认设置，然后点击**下一步**。
- en: Then on the **Choose start menu folder** dialog box, leave the defaults and
    click on **Install**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在**选择开始菜单文件夹**对话框中，保留默认设置并点击**安装**。
- en: On the **Installation complete** dialog, click on **Finish** to run Android
    Studio for the first time.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**安装完成**对话框中，点击**完成**以首次运行 Android Studio。
- en: The next dialog is for users who have already used Android Studio, so assuming
    you are a first time user, select the **I do not have a previous version of Android
    Studio or I do not want to import my settings** checkbox, and then click on **OK**:![Installing
    Android Studio](img/8859OS_01_11.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对话框是为已经使用过 Android Studio 的用户准备的，所以假设你是第一次使用，请选择**我没有之前的 Android Studio 版本或我不想导入我的设置**复选框，然后点击**确定**：![安装
    Android Studio](img/8859OS_01_11.jpg)
- en: That was the last piece of software we needed. The simple nine-step process
    we just went through has actually set up a whole range of Android tools that we
    will begin to use in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们需要的最后一个软件组件。我们刚刚经历的简单九步流程实际上已经设置了一系列我们将从下一章开始使用的 Android 工具。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed why games, Java, and Android are not only extremely exciting but
    also arguably the best way to learn to program. This is because games can be an
    extremely motivating subject matter and Java and Android have enormous strengths
    with regards to popularity and longevity, and are open to all of us to use for
    free.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了为什么游戏、Java和Android不仅非常令人兴奋，而且可以说是学习编程的最佳方式。这是因为游戏可以是一个非常激励人心的主题，Java和Android在流行度和持久性方面具有巨大优势，并且对我们所有人都是免费开放的。
- en: We also set up the Java development kit and installed Android Studio, getting
    ready for the next chapter where we will actually create a part of a working game
    and take our first look at some Java code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了Java开发工具包并安装了Android Studio，为下一章做准备，在下一章中，我们将实际创建游戏的一部分，并首次查看一些Java代码。
- en: Chapter 2. Getting Started with Android
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. Android入门
- en: In this chapter, we will take a roller coaster ride through all the Android
    topics that you need to learn in order to get started with Java. It won't just
    be theoretical though. We will be designing a **user interface** (**UI**) of a
    game menu and we will see and edit our first Java code as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过所有你需要学习的Android主题进行一次过山车之旅，以便开始使用Java。但这不仅仅只是理论。我们将设计一个游戏菜单的**用户界面**（**UI**），我们还将查看和编辑我们的第一段Java代码。
- en: In addition, we will see how we can run our apps in either an Android emulator
    on our PC/Mac or on a real Android device if we have one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将看到我们如何在PC/Mac上的Android模拟器或如果我们有的话，在真实的Android设备上运行我们的应用。
- en: Some of what we will cover in this chapter will be the tip of the iceberg. That
    is, there is a lot more below the surface to some of the topics we discuss than
    would be appropriate for the second chapter of a learning Java book. Sometimes,
    we might need to take a bit of information on faith.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的一些内容只是冰山一角。也就是说，对于我们在讨论的一些主题，表面之下还有更多内容，这比适合Java学习书籍的第二章更为合适。有时，我们可能需要基于信仰接受一些信息。
- en: This will then enable us to actually design and run our very own Android app
    by the end of this chapter. Then we can start learning Java for real at the beginning
    of the next chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在本章结束时真正设计和运行我们自己的Android应用。然后我们可以在下一章的开始真正开始学习Java。
- en: If this chapter seems a little tough, then don't worry; keep going because each
    subsequent chapter lifts the lid a bit more from some of the less clear topics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一章看起来有点难，那么不要担心；继续前进，因为随后的每一章都会从一些不太清楚的主题中揭开更多内容。
- en: For this chapter and the next two, we will be building a math game. We will
    start simply and by the end of [Chapter 4](ch04.html "Chapter 4. Discovering Loops
    and Methods"), *Discovering Loops and Methods*, we will scale to game features
    that use significant Java skills.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章以及接下来的两章，我们将构建一个数学游戏。我们将从简单开始，到[第4章](ch04.html "第4章. 发现循环和方法")的“发现循环和方法”结束时，我们将扩展到使用显著Java技能的游戏功能。
- en: 'In this chapter, we will:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Start our first game project
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始我们的第一个游戏项目
- en: Explore Android Studio
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Android Studio
- en: Use the Android Studio visual designer to make our game UI
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android Studio的视觉设计器来制作我们的游戏UI
- en: Learn about structuring our code for Android
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何为Android构建我们的代码结构
- en: Take our first look at some Java code
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次查看一些Java代码
- en: Build and install our game on an emulator and a real device
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟器和真实设备上构建和安装我们的游戏
- en: Our first game project
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个游戏项目
- en: Now we will get straight down to actually doing something with Android Studio.
    Run Android Studio by double-clicking on the Android Studio icon either on your
    desktop's start menu or in the folder where you installed it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将直接使用Android Studio进行实际操作。通过双击桌面上的Android Studio图标或安装它的文件夹中的图标来运行Android
    Studio。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you get any errors in a dialog box mentioning **Privilege elevation**, then
    try running Android Studio with administrator privileges. To do this, find the
    Android Studio icon by clicking on the Windows **Start** button and searching
    for **Android Studio**. Now right-click on the icon and click on **Run as administrator**.
    Do this every time you run Android Studio.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个提到**权限提升**的对话框中遇到任何错误，那么尝试以管理员权限运行Android Studio。为此，通过点击Windows **开始**按钮并搜索**Android
    Studio**来找到Android Studio图标。现在右键单击图标并点击**以管理员身份运行**。每次运行Android Studio时都这样做。
- en: Preparing Android Studio
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Android Studio
- en: 'So with Android Studio and Java installed, we just need to add the latest versions
    of the Android API that we will use to make our first game. Here is what to do
    to install the API:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在安装了 Android Studio 和 Java 之后，我们只需要添加我们将要使用的最新版本的 Android API，以便制作我们的第一个游戏。以下是安装
    API 的步骤：
- en: From the menu bar at the top of the Android Studio UI, navigate to **Tools**
    | **Android** | **SDK Manager**. Scroll down in the **Android SDK Manager** window
    and select the checkbox for **Android 4.4.2 (API 19)**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Android Studio UI 顶部的菜单栏中，导航到 **工具** | **Android** | **SDK 管理器**。在 **Android
    SDK 管理器** 窗口中向下滚动并选择 **Android 4.4.2 (API 19)** 的复选框。
- en: Note
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that because Android is evolving so quickly, by the time you read this
    chapter, there might be APIs newer than 19—20, 21, and so on. If this is the case
    for you, select the newer (higher numbered) API instead.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于 Android 发展非常迅速，当你阅读这一章节时，可能会有比 19 更新的 API，比如 20、21 等等。如果你遇到这种情况，请选择更新的（编号更高的）API。
- en: '![Preparing Android Studio](img/8859OS_02_21.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备 Android Studio](img/8859OS_02_21.jpg)'
- en: Click on **Install Packages**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装包**。
- en: On the next screen, click on the **Accept license** checkbox and then click
    on the **Install** button. Android Studio will download and install the appropriate
    packages.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，点击 **接受许可** 复选框，然后点击 **安装** 按钮。Android Studio 将下载并安装适当的包。
- en: What we just did was setting up Android Studio to make available the latest,
    prewritten code called an API that we will interact with throughout the book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才所做的就是设置 Android Studio，使其可用最新的、预先编写的代码，称为 API，我们将在整本书中与之交互。
- en: Building the project
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: Click on **New Project...** as indicated in the following screenshot:![Building
    the project](img/8859OS_02_01.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下截图所示：![创建新项目...](img/8859OS_02_01.jpg)
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field with `Math Game Chapter 2` and **Company Domain** with `packtpub.com`
    (or you could use your own company website name here), as shown in the following
    screenshot:![Building the project](img/8859OS_02_18.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会弹出 **创建新项目** 配置窗口。在 **应用程序名称** 字段中填写 `Math Game Chapter 2`，在 **公司域名** 中填写
    `packtpub.com`（或者你也可以在这里使用你自己的公司网站名称），如下面的截图所示：![构建项目](img/8859OS_02_18.jpg)
- en: 'Now click on the **Next** button. On the next screen, check that the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer are the cutting-edge
    Android features available in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot:![Building
    the project](img/8859OS_02_19.jpg)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击 **下一步** 按钮。在下一屏幕上，确认 **手机和平板** 复选框已被勾选。现在我们必须选择我们想要为构建我们的应用程序的最早版本的 Android。继续在下拉选择器中尝试几个选项。你会看到，我们选择的版本越早，我们的应用程序可以支持的设备百分比就越大。然而，这里的权衡是，我们选择的版本越早，我们应用程序中可用的最新
    Android 功能就越少。一个好的平衡点是选择 **API 8: Android 2.2 (Froyo)**。现在就按照下面的截图所示进行操作：![构建项目](img/8859OS_02_19.jpg)'
- en: Click on **Next**. Now select **Blank Activity** as shown in the next screenshot
    and click on **Next** again:![Building the project](img/8859OS_02_20.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。现在选择 **空白活动**，如下一截图所示，然后再次点击 **下一步**：![构建项目](img/8859OS_02_20.jpg)
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，只需将 **活动名称** 改为 `MainActivity`，然后点击 **完成**。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, Android Studio shows a **Tip of the day** dialog every time it starts.
    Some of the tips might not make sense while you are still learning Java but many
    of them are really useful and reveal great shortcuts and other time savers. It
    is well worth taking a few seconds to read them when they show up. As already
    discussed, Android Studio is built from IntelliJ IDEA, and you can find a complete
    list of keyboard shortcuts at [http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html](http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html).
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，每次 Android Studio 启动时都会显示一个 **每日提示** 对话框。有些提示在你学习 Java 的过程中可能没有意义，但其中许多都非常实用，揭示了出色的快捷键和其他节省时间的技巧。当它们出现时，花几秒钟阅读它们是非常值得的。如前所述，Android
    Studio 是基于 IntelliJ IDEA 构建的，你可以在 [http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html](http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html)
    找到完整的键盘快捷键列表。
- en: Clear **Tip of the day** by clicking on **Close**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**关闭**按钮清除**每日提示**。
- en: If you are completely new to programming, then the code, options, and files
    might seem a bit daunting. Don't worry; stick to them as we don't need to concern
    ourselves with most of them in order to learn Java. When the time does come to
    interact with the finer details, we will do things one step at a time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全对编程一无所知，那么代码、选项和文件可能看起来有些令人畏惧。别担心；坚持学习，因为我们不需要关注它们中的大多数来学习Java。当需要与更详细的细节交互时，我们会一步一步地进行。
- en: It might be hard to believe that at this stage, but we have just created our
    first working app. We could build and run it on an Android device, and soon we
    will.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很难相信，但我们已经创建了我们第一个工作的应用程序。我们可以在Android设备上构建和运行它，很快我们就会做到。
- en: Let's take a deeper look at Android Studio before we progress with our game.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行游戏开发之前，让我们更深入地了解一下Android Studio。
- en: Exploring Android Studio
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Android Studio
- en: Android Studio is a very deep tool, but it is only necessary to learn one part
    at a time in order to get started. What might be useful for us is naming a few
    parts of the UI so that we can refer to them easily as we progress through the
    book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是一个非常强大的工具，但为了开始学习，我们只需要一次学习一个部分。对我们来说，命名UI的几个部分可能很有用，这样我们就可以在阅读本书的过程中轻松地引用它们。
- en: Take a look at this numbered diagram and a quick explanation of some of the
    key parts of Android Studio. If you can, try and memorize the parts to make future
    discussions of them easier for you.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个编号图和一些关于Android Studio关键部分的快速解释。如果你能的话，尝试记住这些部分，以便在未来的讨论中更容易理解。
- en: '![Exploring Android Studio](img/8859OS_02_04.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![探索Android Studio](img/8859OS_02_04.jpg)'
- en: Here is a handy table that you can quickly refer to and remember which part
    of Android Studio we are referring to. What follows is a more detailed explanation
    of each area.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个方便的表格，你可以快速参考并记住我们正在引用的Android Studio的哪个部分。以下是对每个区域的更详细解释。
- en: '| Number | Name |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 名称 |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Project Explorer |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 项目资源管理器 |'
- en: '| 2 | The editor |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 编辑器 |'
- en: '| 3 | Menu bar |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 菜单栏 |'
- en: '| 4 | Toolbar |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 工具栏 |'
- en: '| 5 | Navigation bar |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 导航栏 |'
- en: '| 6 | Important tool windows |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 重要工具窗口 |'
- en: '**Project Explorer** (**1**): This is shown as **1** in the screenshot and
    is a bit like Windows Explorer. It shows us all the files and folders that have
    been generated for our project. We will do a number of things from here as the
    book continues. Actually, if you delve into the files and folders that Android
    Studio creates, the Project Explorer is not an exact mapping. It is slightly simplified
    and highlighted to make managing and exploring our project easier.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目资源管理器**（**1**）：在屏幕截图中显示为**1**，它有点像Windows资源管理器。它显示了为我们的项目生成的所有文件和文件夹。随着本书的继续，我们将从这里做很多事情。实际上，如果你深入研究Android
    Studio创建的文件和文件夹，项目资源管理器并不是一个精确的映射。它被稍微简化并突出显示，以便更容易管理和探索我们的项目。'
- en: '**The Editor** (**2**): As the name suggests, we will edit our Java code files
    here in the editor. However, as we will soon see, the **Editor** window changes
    depending on the type of file we are editing. We will also be viewing and editing
    UI designs here.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**（**2**）：正如其名所示，我们将在这里的编辑器中编辑我们的Java代码文件。然而，正如我们很快就会看到的，**编辑器**窗口会根据我们正在编辑的文件类型而改变。我们还将在这里查看和编辑UI设计。'
- en: '**Menu bar** (**3**): Like most programs, the **Menu** bar gives us access
    to the full functionality of Android Studio.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单栏**（**3**）：像大多数程序一样，**菜单**栏为我们提供了访问Android Studio完整功能的方法。'
- en: '**Tool bar** (**4**): This contains lots of really useful one-click options
    to do things such as deploying and debugging our games. Hover the mouse cursor
    over an icon to get a pop-up tip and gain greater insight into each toolbar icon.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**（**4**）：它包含许多非常有用的单点选项，例如部署和调试我们的游戏。将鼠标光标悬停在图标上，以获取弹出提示并深入了解每个工具栏图标。'
- en: '**Navigation bar** (**5**): Like a file path, this shows exactly where the
    file that is currently in the editor is located within the project.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航栏**（**5**）：就像文件路径一样，它显示了当前在编辑器中的文件在项目中的确切位置。'
- en: '**Important tool windows** (**6**): These are a number of tabs that can be
    popped up and popped down again by clicking on them. If you like, try some of
    them now to see how they work.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重要工具窗口**（**6**）：这些是一些可以通过点击弹出和关闭的标签页。如果你愿意，现在尝试一些，看看它们是如何工作的。'
- en: Let's talk a bit more about the parts of the Android Studio UI and how the editor
    window can transform itself into a visual UI designer. After that, when we are
    familiar enough, we will look at building a simple menu screen for our math game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再详细谈谈 Android Studio UI 的各个部分以及编辑窗口如何将自己转换成视觉 UI 设计器。之后，当我们足够熟悉时，我们将看看如何为我们的数学游戏构建一个简单的菜单屏幕。
- en: Using the Android Studio visual designer
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Android Studio 视觉设计师
- en: The Android Studio editor window is a very dynamic area. It presents different
    file types in the most useful way possible. A little earlier, when we created
    our project, it also made a basic UI for us. UIs in Android can be built-in Java
    code or, as we will see, in a visual designer without the need for a single line
    of Java. However, as we will investigate after we have built the UI of our game
    menu, to get the UI to do anything useful, we need to interact with it. This interaction
    is always done with Java code. The visual designer also generates the UI code
    for us. We will take a very quick look at that too.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 编辑窗口是一个非常动态的区域。它以最有用的方式呈现不同的文件类型。在我们创建项目的一小段时间之前，它还为我们创建了一个基本的
    UI。Android 中的 UI 可以通过 Java 代码构建，或者，正如我们将看到的，在视觉设计师中构建，无需一行 Java 代码。然而，在我们构建游戏菜单的
    UI 之后，为了使 UI 做出有用的操作，我们需要与之交互。这种交互始终是通过 Java 代码完成的。视觉设计师也会为我们生成 UI 代码。我们也会很快地看看这一点。
- en: As the book progresses, we will mainly shy away from Android UI development,
    as that is a staple of more non-game apps. We will instead spend more time looking
    at directly drawing pixels and images to make our games. Nonetheless, the regular
    Android UI has its uses, and the Android Studio visual designer is the quickest
    way to get started.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的进展，我们将主要避免 Android UI 开发，因为那通常是更多非游戏应用的基础。相反，我们将花更多的时间直接绘制像素和图像来制作我们的游戏。尽管如此，常规的
    Android UI 仍然有其用途，Android Studio 视觉设计师是快速入门的最佳方式。
- en: 'Let''s have a look at that now:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个：
- en: In the Android Studio Project Explorer, double-click on the `layout` folder
    to reveal the `activity_main.xml` file within it. This should be easy to see unless
    you have collapsed the directories. If you can't see the `layout` folder, navigate
    to it using the Project Explorer. It can be found at `Math Game Chapter2/src/main/res/layout`
    via the Android Studio Project Explorer, as shown in the following screenshot:![Using
    the Android Studio visual designer](img/8859OS_02_05.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 项目资源管理器中，双击 `layout` 文件夹以显示其中的 `activity_main.xml` 文件。除非您已折叠了目录，否则这应该很容易看到。如果您看不到
    `layout` 文件夹，请使用项目资源管理器导航到它。您可以通过 Android Studio 项目资源管理器找到它，如以下截图所示：![使用 Android
    Studio 视觉设计师](img/8859OS_02_05.jpg)
- en: Now double-click on **activity_main.xml** to open it in the editor window. After
    a brief loading time, you will see something very similar to the next screenshot.
    The following screenshot shows the entire contents of what previously contained
    just our code. As you can see, what was just a text window now has multiple parts.
    Let's take a closer look at this screenshot:![Using the Android Studio visual
    designer](img/8859OS_02_06.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在双击 **activity_main.xml** 以在编辑窗口中打开它。经过一段简短的加载时间后，您将看到与下一张截图非常相似的内容。下面的截图显示了之前仅包含我们代码的全部内容。如您所见，之前只是一个文本窗口，现在有多个部分。让我们仔细看看这个截图：![使用
    Android Studio 视觉设计师](img/8859OS_02_06.jpg)
- en: In the preceding screenshot labeled (**1**), called **Palette**, you can choose
    from the available Android UI elements and simply click and drag them onto your
    UI design. Area (2) is the visual view of the UI you are building, where you will
    click and drag elements from the palette. To the right of the visual UI view,
    you will see the **Component Tree** area (3). The component tree allows you to
    examine the structure of the complex UI and select specific elements more easily.
    Under this tree is the **Properties** panel (4). Here you can adjust the properties
    of the currently selected UI element. These can be simple things such as color
    and size or much more advanced properties.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前标记为（**1**）的截图，称为 **调色板**，您可以从可用的 Android UI 元素中选择，并简单地点击并拖动它们到您的 UI 设计中。区域（2）是您正在构建的
    UI 的视觉视图，您将在这里点击并拖动来自调色板中的元素。在视觉 UI 视图的右侧，您将看到 **组件树** 区域（3）。组件树允许您检查复杂 UI 的结构，并更轻松地选择特定元素。在此树下方是
    **属性** 面板（4）。在这里，您可以调整当前所选 UI 元素的属性。这些可以是简单的事情，如颜色和大小，或者更高级的属性。
- en: Note
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the tabs labelled (**5**). These tabs allow you to switch between the two
    main views that Android Studio provides for this type of layout file. These views,
    as you can see, are **Design** and **Text**. The design view is the default view
    and is shown in the previous screenshot. The text view also shows your under-construction
    UI, but it shows the code that has been autogenerated for us instead of the **Palette**
    element and the component tree.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意标签上标记的（**5**）。这些标签允许你在Android Studio为这种布局文件提供的两个主要视图之间切换。正如你所看到的，这些视图是**设计**和**文本**。设计视图是默认视图，如前一个屏幕截图所示。文本视图也显示了你的正在构建的UI，但它显示的是为我们自动生成的代码，而不是**调色板**元素和组件树。
- en: We don't need to worry about this code as it is all handled for us. It can be
    good to look on this tab from time to time so that we can begin to understand
    what the design tool generates for us. But it is not necessary to do this to learn
    Java. This code is called **eXtensible Markup Language** (**XML**).
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要担心这段代码，因为它都是为我们处理的。偶尔查看这个标签卡是有好处的，这样我们可以开始理解设计工具为我们生成的内容。但是，学习Java并不需要这样做。这段代码被称为**可扩展标记语言**（**XML**）。
- en: Take a quick look at the **Text** tab, click on the **Design** tab when you're
    done, and we will move on.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速查看一下**文本**标签，完成后点击**设计**标签，然后我们将继续前进。
- en: Now we have seen an overview of the visual designer and an even briefer glimpse
    of the automatically generated code that it generates for us. We can take a closer
    look at some of the actual UI elements that we will be using in our project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了视觉设计器的概述以及它为我们自动生成的代码的简要一瞥。我们可以更仔细地查看我们将在项目中使用的实际UI元素。
- en: Android UI types
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android UI类型
- en: We will now take a whirlwind tour of some really useful Android UI elements,
    a few key properties, and how to add them together to make a UI. These will introduce
    us to some of the possibilities as well as how to use them. We will then quickly
    use what we know to make our menu.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将快速浏览一些非常有用的Android UI元素、一些关键属性以及如何将它们组合起来以创建一个UI。这将向我们介绍一些可能性以及如何使用它们。然后，我们将快速运用我们所知来制作我们的菜单。
- en: TextView
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextView
- en: On the visual UI area, click on the words **Hello world!**. What we have just
    selected is a widget known as a TextView. TextViews can be small text like this
    one or large heading type text, which might be useful in our game menu.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉UI区域，点击文字**Hello world**！我们刚才选择的是一个名为TextView的小部件。TextView可以是像这样的小文本，也可以是大型标题类型文本，这在我们的游戏菜单中可能很有用。
- en: 'Let''s try dragging and dropping another TextView onto our visual UI:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将另一个TextView拖放到我们的视觉UI上：
- en: Directly under the **Widgets** heading in our palette, you can see there are
    multiple types of TextView. They are presented in the palette as **Plain TextView**,
    **Large Text**, **Medium Text** and **Small Text**. Drag and drop a **Large Text**
    widget onto our visual design. Don't let go straightaway. As you drag it around
    the image of the phone, notice how Android Studio graphically shows you different
    positioning options. In the following screenshot, you can see what the designer
    looks like when the widget being dragged is positioned at the center:![TextView](img/8859OS_02_07.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的调色板中的**小部件**标题下，你可以看到有多种类型的TextView。它们在调色板中以**普通TextView**、**大文本**、**中文字体**和**小字体**的形式呈现。将一个**大文本**小部件拖放到我们的视觉设计中。不要立即放手。当你将它拖动到手机图像周围时，注意Android
    Studio如何图形化地显示不同的定位选项。在下面的屏幕截图中，你可以看到当被拖动的小部件定位在中心时的设计师外观：![TextView](img/8859OS_02_07.jpg)
- en: Let go of the left mouse button where you want the widget to go. If you let
    go when it is positioned as shown in the previous screenshot, then the text will
    appear in the center as expected.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你想要放置小部件的位置释放鼠标左键。如果你在如图所示的定位时释放，文本将如预期地出现在中心位置。
- en: Now we can play with the properties. In the **Properties** window, click just
    to the right of **textSize**. You might need to scroll to find it. Type `100sp`
    as the value and press the *Enter* key. Notice that the text gets much larger.
    We can refine the size of our text by increasing and decreasing the value entered
    here. The unit `sp` stands for scaled pixels, and is simply a measuring system
    that attempts to scale the text to an appropriate equivalent actual size across
    different screen densities.![TextView](img/8859OS_02_08.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以玩弄属性。在**属性**窗口中，点击**textSize**的右边。你可能需要滚动以找到它。将值设置为`100sp`并按*Enter*键。注意文本变得很大。我们可以通过增加和减少在此处输入的值来细化文本的大小。单位`sp`代表缩放像素，它是一个试图在不同屏幕密度上缩放文本到适当等效实际大小的测量系统。![TextView](img/8859OS_02_08.jpg)
- en: Play with some more properties if you like and when you're done, click on the
    TextView we just created in the visual designer to highlight it. Then tap on the
    *Delete* key to get rid of it. Now delete the TextView that was present when we
    started—the one that says **Hello world!**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以再玩一些属性，完成后，点击在视觉设计器中刚刚创建的TextView来突出显示它。然后点击*删除*键来移除它。现在删除我们开始时存在的TextView——那个写着**Hello
    world**的TextView。
- en: Layout elements
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局元素
- en: Now you have an apparently empty screen. However, if you click anywhere on the
    design preview, you will see that we still have some options in the **Properties**
    window. This element is called a RelativeLayout. It is one of several layout element
    types provided as a base to control and align the layout widgets such as buttons,
    text, and so on. If you look at the top of the **Palette** window, you will see
    the main layout options. We will use this layout element when we actually build
    our game menu in a moment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能看起来有一个空白的屏幕。然而，如果你在设计预览的任何地方点击，你会看到我们仍然在**属性**窗口中有一些选项。这个元素被称为RelativeLayout。它是提供作为基础以控制和对齐布局小部件（如按钮、文本等）的几种布局元素类型之一。如果你查看**调色板**窗口的顶部，你会看到主要的布局选项。当我们实际构建游戏菜单时，我们将使用这个布局元素。
- en: ImageView widgets
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImageView小部件
- en: 'ImageViews unsurprisingly are for displaying images. In the standard Android
    UI, this is a really quick way to add our designers'' artwork to our game:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ImageViews不出所料是用来显示图片的。在标准的Android UI中，这是向我们的游戏中添加设计师的艺术作品的一个非常快速的方法：
- en: Drag and drop an **ImageView** element onto the design in the same way as you
    positioned the TextView a moment ago. The **ImageView** element can be found below
    the **Widgets** heading. Now position it centrally as before or play with the
    options by dragging it around the design. We will delete it in a minute; we are
    just having a bit of an exploration before we do this for real.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与刚才定位TextView相同的方式，将**ImageView**元素拖放到设计中。**ImageView**元素可以在**小部件**标题下找到。现在像之前一样将其居中，或者通过拖动它在设计中玩弄选项。我们将在一分钟内删除它；我们只是在真正做之前进行一点探索。
- en: In the **Properties** window, select the **src** property in the same way as
    you selected the **textSize** property previously.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中，以与之前选择**textSize**属性相同的方式选择**src**属性。
- en: Notice that after you select it, you have the option to click on **...** to
    give you more options. Click on **...** and scroll to the bottom of the list of
    options. These are all the image files that we can display in this ImageView.
    Just for fun, scroll to the bottom of the list, choose **ic_launcher**, and click
    on **OK**. We can make any image we like available and this is a simple, powerful
    way to build an attractive game menu screen.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，选择它之后，你可以点击**...**来获得更多选项。点击**...**并滚动到选项列表的底部。这些都是我们可以在ImageView中显示的图片文件。为了好玩，滚动到列表底部，选择**ic_launcher**，然后点击**确定**。我们可以使任何图片都可用，这是一种简单而强大的方法来构建一个吸引人的游戏菜单屏幕。
- en: Change the **layout:width** property to `150dp` and the **layout:height** property
    to `150dp`. The unit **dp** is a way of sizing elements and widgets that remains
    relatively constant across devices with screens that have very different numbers
    of pixels.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**layout:width**属性更改为`150dp`，将**layout:height**属性更改为`150dp`。单位**dp**是一种在具有非常不同像素数的屏幕上保持相对恒定的元素和小部件尺寸的方法。
- en: Delete the ImageView in exactly the same way as you deleted the other views
    previously.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与之前删除其他视图相同的方式删除ImageView。
- en: ButtonView
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ButtonView
- en: The use of ButtonView is probably given away by its name. Try to click and drag
    a few buttons onto our layout. Notice that there are a few types of ButtonView,
    such as **Small Button**, **Button**, and, if you look further down the **Widget**
    list, **ImageButton**. We will be using the regular ButtonView, labelled simply
    as **Button**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ButtonView 的用途可能从其名称中可以看出。尝试将几个按钮拖放到我们的布局中。注意，有几种类型的 ButtonView，例如**小按钮**、**按钮**，如果您向下查看**小部件**列表，还有**ImageButton**。我们将使用常规的
    ButtonView，标记为**按钮**。
- en: Now we will do something with each of these Android UI elements combined to
    make our game menu.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这些 Android UI 元素中的每一个来制作我们的游戏菜单。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the entire sample from the code download section of the book's
    companion website.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书配套网站的代码下载部分下载整个示例。
- en: Using the sample code
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例代码
- en: 'All of the code in this book is organized in projects. If a project spans more
    than one chapter, a project is provided for each chapter in its finished state.
    This helps you see the progression and not just the end result. All you need to
    do to open the project in Android Studio is explained as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码都组织在项目中。如果一个项目跨越多个章节，每个章节都会提供一个完成状态的项目。这有助于您看到进展，而不仅仅是最终结果。要打开 Android
    Studio 中的项目，只需按照以下说明操作：
- en: Download the code for this book.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载本书的代码。
- en: In **Android Studio** from the menu bar, navigate to **File** | **Close project**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Android Studio** 的菜单栏中，导航到 **文件** | **关闭项目**。
- en: Now create a new blank project as we did previously. Browse to where you downloaded
    the code for this book.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个新的空白项目，就像我们之前做的那样。浏览到您下载本书代码的位置。
- en: Navigate to the `Chapter2` folder. Here you will find the code for all the files
    we create in this chapter.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Chapter2` 文件夹。在这里，您可以找到我们在这个章节中创建的所有文件的代码。
- en: Open the code files using a plain text editor such as the free Notepad++.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纯文本编辑器，如免费的 Notepad++ 打开代码文件。
- en: Copy and paste in your Android Studio project or just compare the code as you
    see it.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Android Studio 项目中复制并粘贴，或者就像您看到的那样比较代码。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although every line of code required in this book is supplied for your convenience,
    you still need to create each project for yourself through Android Studio. You
    can then simply copy and paste either the code in its entirety in the file with
    the matching name, or just the part of the code that you might be struggling with.
    Keep in mind that if you create a project with a different package name, then
    you must *omit* the line of code that is the package name from the supplied code
    files. The reasons for this will be clearer when we talk more about packages later
    in the chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书中需要的所有代码都已提供以便您的方便，但您仍然需要通过 Android Studio 自己创建每个项目。然后，您可以简单地复制并粘贴整个文件中的代码，或者只复制您可能遇到困难的代码部分。请记住，如果您创建了一个具有不同包名的项目，那么您必须从提供的代码文件中*删除*包含包名的代码行。当我们在本章后面更多关于包的讨论中了解更多时，原因将更加清晰。
- en: Let's actually see how to do it all for ourselves.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际看看如何自己完成所有这些操作。
- en: Making our game menu
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作我们的游戏菜单
- en: For now we will just make our game menu functional. Later in [Chapter 5](ch05.html
    "Chapter 5. Gaming and Java Essentials"), *Gaming and Java Essentials*,we will
    see how we can make it look good by adding some cool animation to make the menu
    more visually interesting and fun.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是使我们的游戏菜单具有功能性。在[第 5 章](ch05.html "第 5 章。游戏和 Java 基础")中，我们将看到如何通过添加一些酷炫的动画来使菜单看起来更好，从而使菜单更具视觉吸引力和趣味性。
- en: 'Here is what we are aiming for in this tutorial:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们的目标是：
- en: '![Making our game menu](img/8859OS_02_10.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![制作我们的游戏菜单](img/8859OS_02_10.jpg)'
- en: 'Before you start coding, you should design your layouts on paper first. However,
    the Android Studio designer is so friendly there is a strong argument, especially
    for simple layouts, to refine your design actually in the layout designer. Perform
    the following steps to create the game menu:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您应该在纸上首先设计您的布局。然而，Android Studio 的设计师非常友好，特别是对于简单的布局，可以在布局设计师中实际细化设计。执行以下步骤以创建游戏菜单：
- en: Delete all widgets from your designer by clicking on them one at a time and
    then tapping the *Delete* key on each in turn. Be careful not to delete the **RelativeLayout**
    layout element as we are going to use it as a base for all the other elements.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过逐个点击并按顺序在每个上按*删除*键，从您的设计师中删除所有小部件。请注意不要删除**RelativeLayout**布局元素，因为我们打算将其用作所有其他元素的基础。
- en: Click and drag a **Large Text** element from the palette to the top center of
    the design area and give it the following properties. Remember that you can change
    properties in the **Properties** panel by clicking to the right of the property
    to be changed. Change the **text** property to `My Math Game` and **size** to
    `30sp`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动一个**大文本**元素到设计区域的顶部中央，并给它以下属性。记住，你可以通过点击要更改的属性右侧来在**属性**面板中更改属性。将**文本**属性更改为`我的数学游戏`，将**大小**更改为`30sp`。
- en: Click and drag an **ImageView** element from the palette to the center of the
    design, slightly below the previous TextView. Change the **layout:width** property
    to `150dp` and the **layout:height** property to `150dp`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中点击并拖动一个**ImageView**元素到设计的中心，略低于上一个TextView。将**layout:width**属性更改为`150dp`，将**layout:height**属性更改为`150dp`。
- en: Now click and drag three buttons for **Play**, **High Scores** and **Quit**.
    Center them vertically, below the previous ImageView and one below the other,
    as per our design shown previously.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击并拖动三个按钮用于**玩**、**高分**和**退出**。将它们垂直居中，位于上一个ImageView下方，一个接一个，如之前的设计所示。
- en: Click on the top button, configure the **text** property, and enter the value
    `Play`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的按钮，配置**文本**属性，并输入值`玩`。
- en: Click on the middle button, configure the **text** property, and enter the value
    `High Scores`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击中间的按钮，配置**文本**属性，并输入值`高分`。
- en: Click on the lowest button, configure the **text** property, and enter the value
    `Quit`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击最底部的按钮，配置**文本**属性，并输入值`退出`。
- en: As the buttons now contain different amounts of text relative to each other,
    they will be of slightly different sizes. You can even them up to match the intended
    layout by clicking and dragging the edges of the smaller buttons to match the
    larger ones. This is done in mostly the same way as you might resize an application
    window in Windows.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于按钮之间包含的文本量相对不同，它们的大小将略有差异。你可以通过点击并拖动较小按钮的边缘来匹配较大按钮，使它们大小一致，以匹配预期的布局。这通常与你在Windows中调整应用程序窗口大小的方式相同。
- en: Save the project with *Ctrl* + *S* or by navigating to **File** | **Save All**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *S*或通过导航到**文件** | **全部保存**来保存项目。
- en: Tip
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are going to be testing your games on a much larger or much smaller screen
    than the Nexus 4 shown in the designer, then you might like to adjust the values
    of the `sp` and `dp` units used in this tutorial.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打算在比设计师中显示的Nexus 4大得多或小得多的屏幕上测试你的游戏，那么你可能希望调整本教程中使用的`sp`和`dp`单位的值。
- en: A full discussion of Android UI on multiple devices is beyond the scope of this
    book and is not necessary to make any of the games in this book. If you want to
    start designing for different screens right away, take a look at [http://developer.android.com/training/multiscreen/index.html](http://developer.android.com/training/multiscreen/index.html).
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对多设备上的Android UI的全面讨论超出了本书的范围，并且对于制作本书中的任何游戏都不是必要的。如果你想立即开始为不同屏幕设计，请查看[http://developer.android.com/training/multiscreen/index.html](http://developer.android.com/training/multiscreen/index.html)。
- en: 'You can view what your menu looks like on other devices simply by selecting
    the device from the drop-down menu shown in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从以下截图所示的下拉菜单中选择设备来查看你的菜单在其他设备上的外观：
- en: '![Making our game menu](img/8859OS_02_11.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![制作我们的游戏菜单](img/8859OS_02_11.jpg)'
- en: Before we make our menu come to life on an actual device, let's take a look
    at the structure of an Android app and how we can use that structure when writing
    our Java code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让我们的菜单在实际设备上生动起来之前，让我们看看Android应用程序的结构以及我们如何在编写Java代码时使用该结构。
- en: Structuring our code for Android
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Android结构化我们的代码
- en: If you have ever used an Android device, you have probably noticed that it works
    quite differently from many other operating systems. For example, you are using
    an application—say you're checking what people are doing on Facebook. Then you
    get an e-mail notification and you tap the e-mail icon to read it. Midway through
    reading the e-mail, you might get a Twitter notification and because you're waiting
    on important news from someone you follow, you interrupt your e-mail reading and
    change the app to Twitter with a touch.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Android设备，你可能已经注意到它与其他许多操作系统的工作方式相当不同。例如，你正在使用一个应用程序——比如说你在检查人们在Facebook上做什么。然后你收到一封电子邮件通知，你点击电子邮件图标来阅读它。在阅读电子邮件的过程中，你可能会收到一条Twitter通知，因为你正在等待你关注的某人的重要新闻，你中断了你的电子邮件阅读，并通过触摸将应用程序切换到Twitter。
- en: After reading the tweet, you fancy a game of Angry Birds, but midway through
    the first daring fling, you suddenly remember that Facebook post. So you quit
    Angry Birds and tap the Facebook icon.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完推文后，你突然想玩一下愤怒的小鸟，但在第一次大胆尝试中途，你突然想起了Facebook上的帖子。所以你退出愤怒的小鸟，点击Facebook图标。
- en: Then you resume Facebook, probably at the same point you left it. You could
    have resumed reading the e-mail, decided to reply to the tweet, or started an
    entirely new app. All this backwards and forwards takes quite a lot of management
    on the part of the operating system, apparently independent from the individual
    apps themselves.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你重新打开Facebook，可能是在你离开的那个地方。你可能会继续阅读电子邮件，决定回复推文，或者启动一个全新的应用程序。所有这些来回操作都需要操作系统进行大量的管理，看起来与单个应用程序本身是独立的。
- en: The difference between a Windows PC and Android in the context we have just
    discussed is that with Android, although the user decides which app they are using,
    the Android OS decides if and when to actually close down (destroy) an application.
    We just need to consider this when coding our games.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论的上下文中，Windows PC和Android之间的区别在于，虽然用户决定使用哪个应用程序，但Android操作系统决定何时以及是否关闭（销毁）应用程序。我们在编写游戏代码时只需考虑这一点即可。
- en: Life cycle phases – what we need to know
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段——我们需要了解的内容
- en: The Android system has different **phases** that any given app can be in. Depending
    on the phase, the Android system determines how the app is viewed by the user
    or whether it is viewed at all. Android has these phases so that it can decide
    which app is in current use and then allocate the right amount of resources such
    as memory and processing power. But also allow us as game developers to interact
    with these phases. What if someone quits our game to answer a phone call? Will
    they lose their progress?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统有不同的**阶段**，任何应用程序都可以处于这些阶段之一。根据阶段，Android系统确定应用程序如何被用户查看，或者是否被查看。Android有这些阶段，以便它可以决定哪个应用程序正在使用，然后分配正确的资源，如内存和处理能力。但同时也允许我们作为游戏开发者与这些阶段交互。如果有人退出我们的游戏去接电话，他们会丢失进度吗？
- en: 'Android has a fairly complex system that, when simplified a little for the
    purpose of explanation, ensures that every app on an Android device is in one
    of the following phases:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Android有一个相当复杂的系统，如果为了解释的目的稍微简化一下，可以确保Android设备上的每个应用程序都处于以下阶段之一：
- en: Being created
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在创建
- en: Starting
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动
- en: Resuming
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复
- en: Running
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Pausing
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Stopping
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Being destroyed
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被销毁
- en: The list of phases will hopefully appear fairly logical. As an example, the
    user presses the Facebook app icon and the app is **created**. Then it is *started*.
    All are fairly straightforward so far but next in the list is **resuming**! It
    is not as illogical as it might first appear if, for a moment, we can just accept
    that the app resumes after it starts, and then all will become clear as we proceed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个阶段的列表看起来相当合理。例如，用户按下Facebook应用程序图标，应用程序就被**创建**了。然后它被**启动**。到目前为止，这些都是相当直接的，但列表中的下一个是**恢复**！如果我们暂时接受应用程序在启动后恢复，那么随着我们继续前进，一切都将变得清晰。
- en: After **resuming,** the app is *running*. This is when the Facebook app has
    control over the screen and probably the greater share of system memory and processing
    power. Now what about our example where we switched from the Facebook app to the
    e-mail app?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在**恢复**之后，应用程序是**运行**的。这是Facebook应用程序控制屏幕并可能占用系统内存和处理器能力更大的时候。那么我们之前从Facebook应用程序切换到电子邮件应用程序的例子呢？
- en: As we tap to go to read our e-mail, the Facebook app will probably have entered
    the **paused** phase, and the e-mail app will enter the **being created** phase
    followed by **resuming** and then **running**. If we decide to revisit Facebook,
    as in the scenario earlier, the Facebook app will probably then go straight to
    the **resume** phase and then **running** again, most likely exactly on the post
    where we left it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们轻触以阅读电子邮件时，Facebook应用程序可能会进入**暂停**阶段，电子邮件应用程序将进入**正在创建**阶段，然后是**恢复**，接着是**运行**。如果我们决定重新访问Facebook，就像之前的场景一样，Facebook应用程序可能会直接进入**恢复**阶段，然后再次**运行**，很可能是我们离开的地方。
- en: Note that at any time, Android can decide to *stop* or *destroy* an app, in
    which case, when we run the app again, it will need to be *created* all over again.
    So had the Facebook app been inactive long enough or had Angry Birds required
    so many system resources that Android would have *destroyed* the Facebook app,
    then our experience of finding the exact post we were previously reading might
    have been different.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在任何时候，Android 都可以决定*停止*或*销毁*一个应用，在这种情况下，当我们再次运行该应用时，它需要从头开始*创建*。所以，如果 Facebook
    应用长时间处于不活跃状态，或者愤怒的小鸟需要消耗如此多的系统资源以至于 Android 会*销毁*Facebook 应用，那么我们找到之前阅读的确切帖子的体验可能会有所不同。
- en: 'Now, if all this phase stuff is starting to get confusing, then you will be
    pleased to know that the only reasons to mention are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果所有这些阶段的东西开始变得令人困惑，那么您会很高兴地知道，提及的唯一原因如下：
- en: You know it exists
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您知道它的存在
- en: We occasionally need to interact with it
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们偶尔需要与之交互
- en: We will take things step by step when we do
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将逐步进行
- en: Life cycle phases – what we need to do
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段 – 我们需要做什么
- en: When we are making games, how do we possibly interact with this complexity?
    The good news is that the Android code that was autogenerated when we created
    our first project does most of the interaction for us.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们制作游戏时，我们如何与这种复杂性交互呢？好消息是，当我们创建第一个项目时自动生成的 Android 代码为我们做了大部分交互。
- en: All we have to do as game developers is make sure that Android knows what to
    do with our app in each phase when it happens. Even more good news is that all
    of these phases are handled by default, unless we override the default handling.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发者，我们唯一需要做的就是确保 Android 在发生时知道如何处理我们的应用在每个阶段。更有好消息是，所有这些阶段都默认处理，除非我们覆盖默认处理。
- en: This means we can go ahead with learning Java and making games until we come
    to one of the few instances where we need to do something in our game, specifically
    in one of the phases.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以继续学习 Java 和制作游戏，直到我们遇到需要在我们游戏中做某事的少数几个实例，具体来说是在某个阶段。
- en: Dividing our game into activities
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将我们的游戏划分为活动
- en: The Java code that we write will be divided into sections or parts called **activities**.
    We can think of activities as different screens for our game. For example, during
    the book, we will often create an activity for a home screen, an activity for
    the game screen and an activity for the high score screen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 Java 代码将被划分为称为**活动**的部分或部分。我们可以将活动视为我们游戏的不同屏幕。例如，在书本中，我们通常会创建一个主屏幕活动、一个游戏屏幕活动和一个高分屏幕活动。
- en: Each activity will have its own life cycle and will be further divided into
    parts that will correspond to (go into) one of the Android phases we just discussed.
    The parts in Java are known as **methods**. Methods are a significant concept
    in Java programming.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动都将有自己的生命周期，并将进一步划分为与（进入）我们刚才讨论的 Android 阶段相对应的部分。Java 中的这些部分被称为**方法**。方法是
    Java 编程中的一个重要概念。
- en: At this stage, however, all we need to know is that methods are used to compartmentalize
    the Java code we write and that some methods are provided by the Android system
    so that we can easily handle the otherwise complex Android life cycle.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个阶段，我们只需要知道方法是用来隔离我们编写的 Java 代码的，并且 Android 系统提供了一些方法，以便我们能够轻松地处理其他情况下复杂的
    Android 生命周期。
- en: The forthcoming list is a quick explanation of the methods provided by Android
    for our convenience, to manage the phases of the life cycle. To clarify our discussion
    of life cycle phases methods are listed next to their corresponding phases that
    we have been discussing. However, as you will see, the method names make it fairly
    clear on their own where they fit in.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是 Android 为我们提供的方便方法的一个快速说明，用于管理生命周期的阶段。为了澄清我们对生命周期阶段的讨论，方法被列在其对应的阶段旁边。然而，正如您将看到的，方法名称本身就很清楚地说明了它们的位置。
- en: 'In the list, there is also a brief explanation or suggestion about when we
    should use a given method and thereby interact during a specific phase. We will
    meet most of these methods as we progress through the book. We will see the `onCreate`
    method later in this chapter. Here is the list:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，还有关于何时使用给定方法以及因此在一个特定阶段交互的简要说明或建议。我们将随着本书的进展遇到这些方法中的大多数。我们将在本章后面看到 `onCreate`
    方法。以下是列表：
- en: '`onCreate`: This method is executed when the activity is being created. Here
    we get everything ready for the game, including graphics, sound, and perhaps the
    high scores.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：当活动被创建时执行此方法。在这里，我们为游戏准备一切，包括图形、声音，也许还有高分。'
- en: '`onStart`: This method is executed when the app is in the starting phase.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart`：当应用处于启动阶段时，将执行此方法。'
- en: '`onResume`: This method runs after `onStart` but can also be entered, perhaps
    most logically, after our activity is resumed after being previously paused. We
    might reload a previously saved game situation when the app had been interrupted,
    perhaps by a phone call or the user running another app.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`：此方法在`onStart`之后运行，但也可以在活动在之前暂停后恢复后，以最合理的方式进入。当应用被中断时，例如接电话或用户运行另一个应用，我们可能会重新加载之前保存的游戏情况。'
- en: '`onPause`: This occurs when our app is pausing. Here we might want to save
    the current game. You are probably getting the hang of these methods.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`：当我们的应用暂停时，这会发生。在这里，我们可能想要保存当前游戏。你可能已经对这些方法有了感觉。'
- en: '`onStop`: This relates to the stopping phase. This is where we might undo everything
    we did in `onCreate`. If we reach here, our activity will probably get destroyed
    sometime soon.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop`：这关系到停止阶段。这是我们可能撤销在`onCreate`中执行的所有操作的地方。如果我们到达这里，我们的活动可能很快就会被销毁。'
- en: '`onDestroy`: This is when our activity is finally being destroyed—our last
    chance to dismantle our game. If we reach here, we will definitely be going through
    the phases of the life cycle from the beginning again.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy`：这是我们的活动最终被销毁的时候——我们拆解游戏的最后机会。如果我们到达这里，我们肯定会再次从头开始经历生命周期阶段。'
- en: All the method descriptions and their related phases should appear straightforward.
    Perhaps, the only real question is about the running phase. As we will see, when
    we write our code in other methods/phases, the `onCreate`, `onStart`, and `onResume`
    methods will prepare the game, which persists, forming the running phase. The
    `onPause`, `onStop`, and `onDestroy` methods will occur afterwards. Now we can
    actually take a look at one of these methods and some other methods as well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法描述及其相关阶段应该都很直观。也许，唯一真正的问题是关于运行阶段。正如我们将看到的，当我们在其他方法/阶段编写代码时，`onCreate`、`onStart`和`onResume`方法将准备游戏，使其持续，形成运行阶段。`onPause`、`onStop`和`onDestroy`方法将在之后发生。现在我们可以真正地查看这些方法之一以及一些其他方法。
- en: Our first look at Java
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们对Java的第一印象
- en: 'So what about all that code that Android Studio generated when we created our
    new project earlier? This is the code that will bring our game menu to life. Let''s
    take a closer look. The very first line of code in the editor window is this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于我们在创建新项目时Android Studio生成的所有代码，又是什么呢？这是将我们的游戏菜单激活的代码。让我们仔细看看。编辑器窗口中的第一行代码是这样的：
- en: '[PRE0]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line of code defines the package that we named when we first created the
    project. As the book progresses, we will write more complex code that spans more
    than one file. All the code files we create will need the package they belong
    to, clearly defined like the previous line of code, at the top. The code doesn't
    actually *do* anything in our game. Notice also that the line ends with a semicolon
    (`;`). This is a part of the Java syntax and it denotes the end of a line of code.
    Remove a semicolon and you will get an error because Android Studio tries to make
    sense of two lines together. Try it if you like.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码定义了我们首次创建项目时命名的包。随着本书的进展，我们将编写跨越多个文件的更复杂代码。我们创建的所有代码文件都需要它们所属的包，像上一行代码那样清晰地定义在顶部。这些代码实际上在我们的游戏中并没有做任何事情。注意，这一行以分号（`;`）结尾。这是Java语法的一部分，表示代码行的结束。如果你移除分号，将会得到一个错误，因为Android
    Studio会尝试将两行代码合并在一起。如果你喜欢，可以试一试。
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that if you are going to be copying and pasting the code from the download
    bundle, this is the one line of code that might vary depending on how you set
    up your project. If the package name in the code file is different from the package
    name you created, always use the package name from when you created the project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你打算从下载包中复制和粘贴代码，这可能是一行可能会根据你的项目设置方式而变化的代码。如果代码文件中的包名与你在创建项目时创建的包名不同，始终使用创建项目时的包名。
- en: 'To see the next four lines of code, you might need to click on the small **+**
    icon to reveal them. Android Studio tries to be helpful by simplifying our view
    of the code. Notice that there are several little **-** icons as well down the
    side of the editor window. You can expand and collapse them to suit yourself without
    affecting the functionality of the program. This is shown in the following screenshot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看下一行代码，你可能需要点击小的**+**图标来展开它们。Android Studio试图通过简化我们的代码视图来提供帮助。注意，编辑器窗口的侧面也有一些小的**-**图标。你可以根据需要展开和折叠它们，而不会影响程序的功能。这在上面的屏幕截图中显示：
- en: '![Our first look at Java](img/8859OS_02_12.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一次Java之旅](img/8859OS_02_12.jpg)'
- en: 'Once you have expanded the code, you will see these four lines:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你展开了代码，你会看到这四行：
- en: '[PRE1]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that all the preceding lines start with the word `import`. This is an
    instruction to include other packages in our game, not just our own. This is very
    significant because it makes available to us all of the hard work of other programmers,
    the Android development team in this case. It is precisely these imports that
    give us the ability to use the methods we discussed earlier, and allow us to interact
    with the Android life cycle phases. Notice again that all the lines end with a
    semicolon (`;`).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有前面的行都是以单词`import`开头的。这是一条指令，指示在我们的游戏中包含其他包，而不仅仅是我们的包。这非常重要，因为它使我们能够利用其他程序员的辛勤工作，在这个案例中是Android开发团队的工作。正是这些导入使我们能够使用我们之前讨论过的方法，并允许我们与Android生命周期阶段交互。再次注意，所有行都以分号（`;`）结尾。
- en: 'The next line introduces a fundamental building block of Java known as a **class**.
    Classes are something that we will continually expand our knowledge and understanding
    of throughout the book. For now, take a look at this line of code, then we will
    discuss it in detail:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行引入了Java的一个基本构建块，称为**类**。类是我们将在整本书中不断扩展知识和理解的东西。现在，看看这一行代码，然后我们将详细讨论它：
- en: '[PRE2]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Word by word, here is what is going on. The preceding line is saying: make
    me a new `public class` called `MainActivity` and base it upon (`extends`) `ActionBarActivity`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字逐句，这里正在发生的事情。前一行是在说：创建一个新的`public class`，名为`MainActivity`，并基于（`extends`）`ActionBarActivity`。
- en: You might remember that `MainActivity` is the name we chose while creating this
    project. `ActionBarActivity` is the code (known as a class) written by the Android
    development team that enables us to put our Java into Android.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会记得，`MainActivity`是我们创建此项目时选择的名称。`ActionBarActivity`是由Android开发团队编写的代码（称为类），使我们能够将Java代码放入Android中。
- en: If you have a keen eye, you might notice there is no semicolon at the end of
    this line. There is, however, an opening curly brace (`{`). This is because `MainActivity`
    encompasses the rest of the code. In effect, everything is part of our `MainActivity`
    class, which is built based on the `ActionBarActivity` class/code. If you scroll
    down to the bottom of the editor window, you will see a closing curly brace (`}`).
    This denotes the end of our class called `MainActivity`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一双敏锐的眼睛，你可能会注意到这一行的末尾没有分号。然而，有一个开括号（`{`）。这是因为`MainActivity`包含了其余的代码。实际上，所有内容都是我们`MainActivity`类的一部分，这个类是基于`ActionBarActivity`类/代码构建的。如果你滚动到编辑器窗口的底部，你会看到一个闭括号（`}`）。这表示我们名为`MainActivity`的类的结束。
- en: We do not need to know how a class works yet
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在还不需要了解类是如何工作的。
- en: We will use classes to access some methods contained within its code and without
    doing any more, we are already, by default, taking advantage of the Android life
    cycle methods we discussed earlier
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用类来访问其代码中包含的一些方法，而且不做任何更多的事情，我们就已经默认地利用了我们之前讨论过的Android生命周期方法。
- en: We can now pick and choose if, when, and which methods defined in these classes
    we wish to override or leave as default
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以挑选和选择我们希望在这些类中重写或保留默认设置的方法。
- en: So, it is the `ActionBarActivity` class that contains the methods that enable
    us to interact with the Android life cycle. Actually, there are a number of different
    classes that enable us to do this and in a moment, we will change from using `ActionBarActivity`
    to a more appropriate class that also does all the things just mentioned.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是`ActionBarActivity`类包含了使我们能够与Android生命周期交互的方法。实际上，还有许多不同的类使我们能够做到这一点，稍后我们将从使用`ActionBarActivity`转换到一个更合适的类，这个类也执行了上述所有操作。
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is not important at this point to properly understand Java classes; just
    understand that you can import a package and a package can contain one or more
    classes that you can then use the functionality of or base your own Java programs
    on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，正确理解 Java 类并不重要；只需知道你可以导入一个包，一个包可以包含一个或多个类，你可以使用这些类的功能，或者基于这些类编写自己的 Java
    程序。
- en: We will bump into classes regularly in the next few chapters. Think of them
    as programming black boxes that do stuff. In [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will open the black box and really get to grips with them and we will even start
    making our own classes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将经常遇到类。把它们想象成做事情的编程黑盒子。在 [第 6 章](ch06.html "第 6 章。面向对象编程 – 使用他人的辛勤工作")，*面向对象编程
    – 使用他人的辛勤工作* 中，我们将打开这个黑盒子，真正掌握它们，我们甚至开始创建自己的类。
- en: Moving on with the code, let's look at what the code that is contained within
    our class actually does.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写代码，让我们看看我们类中包含的代码实际上做了什么。
- en: 'Here is the code chunk directly after the crucial line we have just been discussing:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是紧接在我们刚才讨论的关键行之后的代码块：
- en: '[PRE3]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hopefully, some of this code will start to make sense now and tie in with what
    we have already discussed. Although the precise syntax will still feel a little
    alien, we can continue learning Java as long as we are aware of what is happening.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在一些代码开始变得有意义，并与我们之前讨论的内容联系起来。尽管精确的语法仍然感觉有点陌生，但只要我们清楚发生了什么，我们就可以继续学习 Java。
- en: The first thing we notice in the preceding code is the word `@override`. Remember
    when we said that all the methods that interact with the Android life cycle were
    implemented by default and we can pick and choose if and when to override them?
    This is what we are doing here with the `onCreate` method.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先注意到的是 `@override` 这个单词。记得我们说过，所有与 Android 生命周期交互的方法都是默认实现的，我们可以选择何时以及是否重写它们吗？这就是我们在
    `onCreate` 方法中所做的。
- en: The `@override` word says that the method that follows next is being overridden.
    The `protected void onCreate(Bundle savedInstanceState) {` line contains the method
    we are overriding. You might be able to guess that the action starts with the
    opening `{` at the end of the line in question and ends with the closing `}` three
    lines later.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`@override` 这个单词表示接下来的方法正在被重写。`protected void onCreate(Bundle savedInstanceState)
    {` 这一行包含了我们要重写的方法。你可能能够猜到，动作从问题行末尾的 `{` 开始，并在三行后的 `}` 结束。'
- en: 'The somewhat odd-looking `protected void` before the method name `onCreate`
    and `(Bundle savedInstanceState)` after the method name are unimportant at this
    time because they are handled for us. It is to do with the data that travels between
    various parts of our program. We just need to know that what happens here will
    take place in the creating phase of the Android lifecycle. The rest will become
    clear in [Chapter 4](ch04.html "Chapter 4. Discovering Loops and Methods"), *Discovering
    Loops and Methods*. Let''s move on to the line:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法名 `onCreate` 前面的 `protected void` 和方法名后面的 `(Bundle savedInstanceState)` 看起来有些奇怪，但在这个时候并不重要，因为它们是由我们处理的。这与数据在程序各个部分之间传输有关。我们只需要知道这里发生的事情将在
    Android 生命周期的创建阶段发生。其余的将在 [第 4 章](ch04.html "第 4 章。发现循环和方法")，*发现循环和方法* 中变得清晰。让我们继续到下一行：
- en: '[PRE4]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the `super` keyword is referencing the code in the original `onCreate`
    method, which is still there even though we can''t see it. The code is saying:
    even though I am overriding you, I want you to set things up, just like you normally
    do first. Then, after `onCreate` has done loads of work that we don''t see and
    don''t need to see, the method continues and we actually get to do something ourselves
    with this line of code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`super` 关键字引用的是原始 `onCreate` 方法中的代码，尽管我们看不到它，但它仍然存在。代码的意思是：尽管我正在重写你，但我希望你能像平时一样先设置好一切。然后，在
    `onCreate` 完成了我们看不到也不需要看到的许多工作之后，方法继续进行，我们实际上可以用这一行代码来做一些自己的事情：
- en: '[PRE5]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are telling Android to set the main content view (our users screen),
    which is the cool game menu we created earlier. To be specific, we are stating
    it is an `R` or resource in the `layout` folder and the file is called `activity_main`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Android 设置主内容视图（我们的用户屏幕），这是我们之前创建的酷炫游戏菜单。具体来说，我们声明它是一个 `R` 或资源，位于 `layout`
    文件夹中，文件名为 `activity_main`。
- en: Cleaning up our code
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理我们的代码
- en: 'The next two blocks of code were created by Android Studio on the assumption
    that we would want to override another two methods. We don''t, because they are
    methods more often used in non-gaming apps:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个代码块是由 Android Studio 根据我们可能想要重写另外两个方法的假设创建的。我们不需要，因为它们是更常用于非游戏应用的类的方法：
- en: 'Delete the entire content shown in the following code. Be careful not to delete
    the closing curly brace of our `MainActivity` class:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码中显示的整个内容。小心不要删除我们的 `MainActivity` 类的结束花括号：
- en: '[PRE6]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can delete a couple of the `@import` statements. The reason for this
    is that we just deleted the overridden methods of classes (imported earlier) we
    no longer need. Notice that the following lines in the editor window are grey.
    Note that the program would still work if you leave them in. Delete them both
    now to make your code as clear as possible:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以删除几个 `@import` 语句。原因是我们刚刚删除了不再需要的（之前导入的）类的重写方法。注意，编辑器窗口中的以下行是灰色的。注意，如果你保留它们，程序仍然可以工作。现在删除它们两个，使你的代码尽可能清晰：
- en: '[PRE7]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some final amendments before our code is done: at this point, you might be
    thinking that we have deleted and changed so much of our code that we might as
    well have started from an empty page and typed it in. This is almost true. But
    the process of having Android Studio create a new project for us and then making
    these amendments is more thorough and also avoids quite a few steps. Here are
    the last code changes. Change the `import android.support.v7.app.ActionBarActivity;`
    line to `import android.support.app.Activity;`.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码完成之前的一些最终修改：在这个阶段，你可能认为我们已经删除和更改了太多的代码，以至于我们可能从一张空页开始并输入它。这几乎是正确的。但是，让
    Android Studio 为我们创建一个新的项目并做出这些修改的过程更加彻底，同时也避免了相当多的步骤。以下是最后的代码更改。将 `import android.support.v7.app.ActionBarActivity;`
    行更改为 `import android.support.app.Activity;`。
- en: Now you will get several red lines underlining our code and indicating errors.
    This is because we are attempting to use a class we have not yet imported. Simply
    amend the `public class MainActivity extends ActionBarActivity {` line to `public
    class MainActivity extends Activity {`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你将在我们的代码下看到几条红色的下划线，表示错误。这是因为我们正在尝试使用我们尚未导入的类。只需将 `public class MainActivity
    extends ActionBarActivity {` 行更改为 `public class MainActivity extends Activity
    {`。
- en: What we did with those last two changes was using a slightly more appropriate
    version of the `Activity` class. To do this, we also had to change what we imported.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对最后两个更改所做的操作是使用 `Activity` 类的一个稍微更合适版本。为此，我们也必须更改我们导入的内容。
- en: 'When you''re done, your editor window should look exactly like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的编辑器窗口应该看起来完全像这样：
- en: '[PRE8]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we know what's going on and our code is clean and lean, we can actually
    take a look at the beginnings of our game in action!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了情况，我们的代码干净且简洁，我们可以真正查看我们的游戏动作的开始部分！
- en: Tip
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If any of what we have just discussed seemed complicated, there is no need for
    concern. Android forces us to work within the Activity lifecycle, so the previous
    steps were unavoidable. Even if you didn't follow all the explanations about classes
    and methods and so on, you are still perfectly placed to learn Java from here.
    All the classes and methods will seem much more straightforward as the book progresses.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刚才讨论的任何内容看起来很复杂，你无需担心。Android 强制我们工作在 Activity 生命周期内，因此之前的步骤是不可避免的。即使你没有完全理解关于类和方法等的解释，你仍然可以从这里开始学习
    Java。随着书籍的进展，所有的类和方法看起来都会更加直接。
- en: Building and installing our game
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和安装我们的游戏
- en: Soon, we will actually see our menu in action. But before we do that, we need
    to find out how to use the Android emulators and how to build our game. Then we
    will put these together and put our game into an emulator or real device to see
    it as our players would.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将真正看到我们的菜单在行动。但在我们这样做之前，我们需要了解如何使用 Android 模拟器和如何构建我们的游戏。然后我们将把它们放在一起，并将我们的游戏放入模拟器或真实设备中，以便像我们的玩家一样看到它。
- en: Emulators and devices
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器和设备
- en: Now we have the first part of our game ready to run. We need to test it to check
    for any errors, crashes, or anything else unintended. It is also important to
    ensure that it looks good and runs correctly on the device types/sizes and that
    you want to target.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行我们的游戏的第一部分。我们需要测试它以检查任何错误、崩溃或其他意外情况。同样重要的是要确保它在目标设备类型/尺寸上看起来很好并且运行正确。
- en: Note
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not go into any details about handling different device types. All our
    games are fullscreen and we will later lock the orientation and dynamically calculate
    aspects such as screen resolution. So we can get away with writing for a single
    device type and focus on learning Java.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论处理不同设备类型的方法。我们所有的游戏都是全屏的，我们将在以后锁定方向并动态计算屏幕分辨率等参数。因此，我们可以为单一设备类型编写代码，并专注于学习
    Java。
- en: It might be useful to know for now that you can create a different layout file
    for any screen size categorization or pixel density. All you need to do is place
    the layout file using exactly the same filename in the appropriate folder. The
    Android device will then *know* the most appropriate layout for it to use. For
    a detailed discussion, see the Google developers website at [http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在知道你可以为任何屏幕尺寸分类或像素密度创建不同的布局文件可能会有用。你只需要将布局文件放置在适当的文件夹中，使用完全相同的文件名。然后，Android
    设备将*知道*最适合它的布局。有关详细讨论，请参阅 Google 开发者网站[http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html)。
- en: Note that you do not need to understand any of the information at the preceding
    link to learn Java and publish your first games.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要理解前面链接中的任何信息来学习 Java 并发布你的第一个游戏。
- en: There are a few options to do this and we will look at two. First, we will use
    Android Studio and the Android Development Tools to make a device emulator so
    that we can use, test, and debug our games on a wide range of device emulators
    on the same PC/Mac we are developing on. So we don't need to own a device. This
    will allow us to get crash reports from our games.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点，我们将探讨两种。首先，我们将使用 Android Studio 和 Android 开发工具来创建设备模拟器，这样我们就可以在我们开发的同一台
    PC/Mac 上使用、测试和调试我们的游戏。因此，我们不需要拥有设备。这将使我们能够从我们的游戏中获取崩溃报告。
- en: Then we will install the game directly to a real device so that we can see exactly
    what the owner of that device will see when they download our app.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将直接将游戏安装到真实设备上，这样我们就可以看到当设备所有者下载我们的应用时将看到的确切内容。
- en: There are more options. For example, you can connect a real device via USB and
    debug directly on the device with the errors and syntactical feedback in Android
    Studio. The process for this might vary for different devices and since we won't
    be focusing on anything but basic debugging, we will not cover that in this book.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多选项。例如，你可以通过 USB 连接真实设备，并在 Android Studio 中直接在设备上调试，包括错误和语法反馈。这个过程可能因设备而异，并且由于我们不会专注于除基本调试之外的内容，因此我们不会在本书中介绍该内容。
- en: Creating an emulator
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模拟器
- en: 'Let''s get our emulator up and emulating:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动我们的模拟器并开始模拟：
- en: On the right-hand side of the Android Studio quick launch bar, find the AVD
    manager icon:![Creating an emulator](img/8859OS_02_13.jpg)
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 快速启动栏的右侧，找到 AVD 管理器图标：![创建模拟器](img/8859OS_02_13.jpg)
- en: Click on the icon to start the Android Virtual Device Manager. Then click on
    the **Create Virtual Device...** button on the bottom-left side to bring up the
    **Virtual Device Configuration** window.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图标以启动 Android 虚拟设备管理器。然后点击左下角的**创建虚拟设备...**按钮，以打开**虚拟设备配置**窗口。
- en: Now click on the **Nexus 4** option and then click on **Next**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**Nexus 4**选项，然后点击**下一步**。
- en: Now we need to choose the version of Android we will use to build and test our
    games on. The latest version (at time of writing) is **Lollipop - 21 - x86**.
    It is the only option where we don't need to complete a download to continue.
    So select it (or whatever the default is at the time you are reading this) and
    then click on **Next** to continue.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要选择我们将用于构建和测试游戏的 Android 版本。撰写本文时的最新版本是**Lollipop - 21 - x86**。这是唯一一个我们不需要完成下载即可继续的选项。因此，选择它（或你阅读此内容时的默认版本），然后点击**下一步**继续。
- en: On the next screen we can leave all the default settings. So click on **Finish**.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，我们可以保留所有默认设置。因此，点击**完成**。
- en: We now have a ready-to-run Android emulator.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以运行的 Android 模拟器。
- en: Running the emulator
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行模拟器
- en: 'Now we will launch (switch on) our virtual device then actually run our game
    that we made earlier by performing the following steps:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将启动（开启）我们的虚拟设备，然后按照以下步骤实际运行我们之前制作的游戏：
- en: Click on **Nexus 4 API 21** under the **Name** column. Now click on the triangular
    play icon to the right of the description of our emulator.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**列下点击**Nexus 4 API 21**。现在点击描述我们模拟器的右侧的三角形播放图标。
- en: Note
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android emulators take a long time to start. Even on a high-specification PC.
    Expect to wait at least a few minutes or even 10.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android模拟器启动需要很长时间。即使在高性能的PC上也是如此。预计至少需要等待几分钟，甚至10分钟。
- en: Once it has started, unlock the device by clicking and dragging anywhere on
    the screen of the emulated device. This is analogous to swiping to unlock a real
    Nexus 4\. Here is what our Nexus 4 virtual device looks like when it is running
    and unlocked:![Running the emulator](img/8859OS_02_16.jpg)
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，通过在模拟设备屏幕上的任何位置点击和拖动来解锁设备。这相当于滑动解锁真实的Nexus 4。以下是我们的Nexus 4虚拟设备在运行和解锁时的样子：![运行模拟器](img/8859OS_02_16.jpg)
- en: You can play with this emulator in almost the same way as you can a real Android
    device. However, you cannot download apps from Google Play. You might notice that
    the emulator is a bit slow compared to a real device, even compared to an old
    one. Shortly, we will look at running our apps on a real device.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以几乎以与真实Android设备相同的方式与这个模拟器玩耍。然而，您无法从Google Play下载应用。您可能会注意到，与真实设备相比，甚至与旧设备相比，模拟器有点慢。不久，我们将看看如何在真实设备上运行我们的应用。
- en: Running our game on the emulator
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模拟器上运行我们的游戏
- en: 'Once the emulator is running, it''s usually best to leave it running so that
    each time we want to use it, we don''t have to wait for it to start. Let''s use
    the emulator:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模拟器运行，通常最好让它保持运行状态，这样每次我们想要使用它时，就无需等待它启动。让我们使用模拟器：
- en: Launch the emulator if it is not already running and make sure the device is
    unlocked as described previously.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模拟器尚未运行，请启动模拟器，并确保设备已按之前描述的方式解锁。
- en: Click on the run icon in the toolbar (shown next) to run your app. You can achieve
    the same thing by navigating to **Run** | **Math Game Chapter 2** from the menu
    bar:![Running our game on the emulator](img/8859OS_02_17.jpg)
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏中的运行图标（如下所示）来运行您的应用。您也可以通过从菜单栏导航到**Run** | **Math Game Chapter 2**来实现相同的功能：![在模拟器上运行我们的游戏](img/8859OS_02_17.jpg)
- en: After a pause while Android Studio builds our application, a pop-up dialog will
    ask you which device you want to run the app on. Choose the device with **Nexus
    4 API 21** in the description. This is the already running device that we created
    earlier. Now press **OK**.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio构建我们的应用后暂停片刻，一个弹出对话框会询问您要在哪个设备上运行应用。在描述中选择带有**Nexus 4 API 21**的设备。这是我们之前创建的已运行设备。现在按**OK**。
- en: Notice at this point that the useful Android window appears at the bottom section
    of Android Studio. In the unlikely event of you having any problems, just check
    for typos in the code. If things really don't work out, just go back to the *Using
    the sample code* section to compare with or copy and paste the supplied code.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意此时，有用的Android窗口出现在Android Studio的底部区域。在不太可能遇到任何问题的前提下，只需检查代码中的拼写错误。如果事情真的出了问题，只需回到*使用示例代码*部分，与提供的代码进行比较或复制粘贴。
- en: After another pause, our game menu screen will appear on the emulator. Of course,
    it doesn't do anything yet, but it is running and the buttons can be pressed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在短暂的暂停之后，我们的游戏菜单屏幕将在模拟器上出现。当然，它目前还没有做任何事情，但它正在运行，按钮可以被按下。
- en: When you're done, you can press the back or home icons to quit the application,
    just as you would on a real Android device.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时，您可以按后退或主页图标退出应用，就像在真实的Android设备上一样。
- en: Now we have seen one of the ways we can test our app by running it in the Android
    emulator. Let's find out how to make our code into an app we can distribute and
    use on a real device.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到一种方法，我们可以通过在Android模拟器中运行应用来测试我们的应用。让我们找出如何将我们的代码转换成可以在真实设备上分发和使用的应用。
- en: Building our game
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的游戏
- en: 'To run our game on a real Android device, we need to create a `.apk` file,
    that is, a file that ends with the extension `.apk`. A `.apk` file is a compressed
    archive of files and folders that the Android system uses to run and install our
    app. These are the steps to use Android Studio to make a `.apk` of our game:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要在真实的Android设备上运行我们的游戏，我们需要创建一个`.apk`文件，即以`.apk`扩展名结尾的文件。`.apk`文件是Android系统用来运行和安装我们应用的文件和文件夹的压缩归档。以下是使用Android
    Studio制作游戏`.apk`的步骤：
- en: From the menu bar, navigate to **Build** | **Generate Signed APK**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单栏导航到**Build** | **Generate Signed APK**。
- en: 'A slightly verbose window will pop up and say: **For Gradle-based projects,
    the signing configuration should be specified in the Gradle build scripts**. You
    can safely dismiss this window by clicking on **OK**.'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个稍微冗长的窗口会弹出，并显示：**对于基于Gradle的项目，应在Gradle构建脚本中指定签名配置**。您可以通过点击**OK**安全地关闭此窗口。
- en: Next up is the **Generate Signed APK Wizard** dialog. Here, we are creating
    a key that identifies the key holder as authorized to distribute the APK. At the
    end of this process, you will have a `.keys` file that you can use each time you
    build a `.apk` file. So this step can be missed out in future. Click on the **Create
    new** button.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是**生成签名APK向导**对话框。在这里，我们正在创建一个密钥，以标识密钥持有者有权分发APK。在此过程结束时，你将有一个`.keys`文件，每次构建`.apk`文件时都可以使用。所以这个步骤在将来可以省略。点击**创建新**按钮。
- en: In the **Key Store Path** field, type or go to a location on your hard drive
    where you would like to store your key. You will then be prompted to choose a
    filename for the keystore. This is arbitrary. Type `MyKeystore` and click on **OK**.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**密钥库路径**字段中，输入或前往你希望在硬盘上存储密钥的位置。然后你会被提示选择密钥库的文件名。这是任意的。输入`MyKeystore`并点击**确定**。
- en: Type a password in the **Password** field and then retype it in the **Confirm**
    field. This is the password to a store that will help protect your key.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**密码**字段中输入密码，然后在**确认**字段中重新输入。这是保护你的密钥的密码。
- en: Next, in the **Alias** field, type a memorable alias. You can think of this
    as a kind of username for your key. Again type a password in the **Password**
    field and then retype it in the **Confirm** field. This is the password to your
    key.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**别名**字段中输入一个容易记住的别名。你可以将其视为你密钥的一种用户名。再次在**密码**字段中输入密码，然后在**确认**字段中重新输入。这是你密钥的密码。
- en: Leave the **Validity Years** dropdown at the default of **25**.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**有效期**下拉菜单保留在默认的**25**年。
- en: You can then fill out your Name and organization details (if any) and click
    on **OK**.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以填写你的姓名和组织详情（如果有），然后点击**确定**。
- en: Now our key and keystore are complete, and we can click on **OK** on the **Generate
    Signed APK wizard** dialog.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的密钥和密钥库已经完成，我们可以在**生成签名APK向导**对话框中点击**确定**。
- en: We are then prompted to select **Run Proguard**. Encrypting and optimizing our
    `.apk` is unnecessary at this time. So just click on **Finish** to generate our
    app's `.apk` file.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后会被提示选择**运行Proguard**。在这个时候加密和优化我们的`.apk`文件是不必要的。所以只需点击**完成**来生成我们应用的`.apk`文件。
- en: The generated `.apk` file will be put in the same directory that you chose to
    put the project files. For example, `MathGameChapter2/app`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的`.apk`文件将放在你选择放置项目文件的同一目录中。例如，`MathGameChapter2/app`。
- en: We have now built a `.apk` file that can be run on any Android device that was
    specified when we first created the project.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了一个可以在我们首次创建项目时指定的任何安卓设备上运行的`.apk`文件。
- en: Installing the setup to a device
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将设置安装到设备
- en: So we have our `.apk` file and we know were to find it. Here is how we will
    run it on our Android device.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经有了`.apk`文件，并且知道在哪里找到它。以下是我们在安卓设备上运行它的方法。
- en: We can use one of a number of methods to get the `.apk` file into the device.
    The method I find one of the easiest is the use of a cloud storage service such
    as Dropbox. You can then simply click and drag the `.apk` file to your Dropbox
    folder and you're done. Alternatively, your Android device probably came with
    PC synchronization software that allows you to drag and drop files to and from
    your device. After you have placed the `.apk` file on your Android device, continue
    with the tutorial.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法之一将`.apk`文件放入设备中。我发现最简单的方法是使用像Dropbox这样的云存储服务。然后你可以简单地点击并拖动`.apk`文件到你的Dropbox文件夹，就完成了。或者，你的安卓设备可能附带PC同步软件，允许你将文件拖放到你的设备上。在你将`.apk`文件放置到你的安卓设备上后，继续教程。
- en: 'Most Android phones are set not to install apps from anywhere except the Google
    Play Store. So we need to change this. The exact menus you will navigate to might
    vary very slightly on your device but the following options tend to be almost
    the same on most devices, old and new:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数安卓手机被设置为只能从Google Play Store以外的任何地方安装应用。所以我们需要更改这一点。你将导航到的确切菜单可能因设备而略有不同，但以下选项在大多数设备上，新旧设备，都几乎相同：
- en: Find and tap the **Settings** app. Most Android phones also have a **Settings**
    menu option. Either will do. Now select **Security** and scroll down to the **Unknown
    sources** option. Tap the **Unknown sources** checkbox to allow apps to be installed
    from unknown sources.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并点击**设置**应用。大多数安卓手机也都有一个**设置**菜单选项。任选其一即可。现在选择**安全**，然后向下滚动到**未知来源**选项。点击**未知来源**复选框以允许从未知来源安装应用。
- en: Locate the file on your Android device using the Dropbox app or your devices
    file browser depending on the method you chose to put the APK on your device.
    Tap the `MathGameChapter2.apk` file.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Dropbox应用或您的设备文件浏览器根据您选择的将APK放在设备上的方法，在您的Android设备上找到文件。点击`MathGameChapter2.apk`文件。
- en: You can now install the app just like any other. When prompted, press **Install**
    and then **Open**. The game will now be running on your device.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以像安装任何其他应用一样安装该应用。当提示时，按**安装**然后**打开**。游戏现在将在您的设备上运行。
- en: Hold your device in a portrait orientation as this is how the UI was designed.
    Congratulations on running your very own Android app on your own device. In a
    later version of the math game, we will lock the orientation to make this more
    user friendly.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的设备保持纵向模式，因为这是UI设计的方向。恭喜您在自己的设备上运行自己的Android应用。在数学游戏的下一个版本中，我们将锁定方向以使其更友好。
- en: Future projects
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来项目
- en: Throughout the book, we will test and run our game projects. It is entirely
    up to you which of the methods we discussed you prefer. If you are getting crashes
    or unexplained bugs, then you will need to use an emulator. If all is working
    well, then the quickest and probably most pleasing way will be to run it on a
    device you own.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将测试和运行我们的游戏项目。完全取决于您喜欢我们讨论的哪种方法。如果您遇到崩溃或未解释的bug，那么您将需要使用模拟器。如果一切正常，那么最快且可能最令人满意的方式是在您自己的设备上运行它。
- en: Self-test questions
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit bemusing?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 如果关于生命周期、类和方法的讨论有点令人困惑，你应该怎么做？
- en: Q2) What exactly is a Java class?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 什么是Java类？
- en: Q3) What is the difference between a method and a class?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 方法与类之间有什么区别？
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the phases of the life cycle at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 查看Android开发者网站及其对生命周期阶段的更技术性解释[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)。您能看到我们未讨论的阶段及其相关方法吗？它会在应用程序中的什么时候被触发？活动从创建到销毁的精确路径是什么？
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed that so far, it has not been not important to completely understand
    exactly how the code works. This is because it will act just as a container for
    the code we write in the rest of the book. However, as we cover in detail topics
    such as methods in [Chapter 4](ch04.html "Chapter 4. Discovering Loops and Methods"),
    *Discovering Loops and Methods*, and classes in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will begin to make sense of all of the code in our games.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论过，到目前为止，完全理解代码的工作原理并不是很重要。这是因为它将仅仅作为本书中我们编写的代码的容器。然而，正如我们在[第4章](ch04.html
    "第4章。发现循环和方法")中详细讨论的，*发现循环和方法*，以及在第6章中讨论的类[第6章。面向对象编程 – 利用他人的辛勤工作](ch06.html "第6章。面向对象编程
    – 利用他人的辛勤工作")，我们将开始理解我们游戏中所有的代码。
- en: We discussed the somewhat complex Android life cycle in detail. We learned that
    all we need to understand at this stage is that we must write our code within
    the correct methods that relate to different phases of the life cycle. Then we
    will have no trouble making good progress with learning Java. As with classes
    and methods, all will be explained along the way and become clearer with practice.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了Android生命周期的复杂性。我们了解到，在这个阶段，我们只需要理解我们必须在正确的方法中编写代码，这些方法与生命周期的不同阶段相关。然后我们将没有困难地学习Java。就像类和方法一样，所有内容都会在过程中解释，并通过实践变得更加清晰。
- en: We also learned the key areas of the Android Studio UI. We built our start menu
    for our math game using the Android Studio designer. Furthermore, we created the
    Java code necessary to make the game appear on the player's device. This was achieved
    mainly by modifying the code that was automatically generated for us.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了Android Studio UI的关键区域。我们使用Android Studio设计器为我们的数学游戏构建了启动菜单。此外，我们创建了使游戏出现在玩家设备上的必要Java代码。这主要是通过修改为我们自动生成的代码来实现的。
- en: This was probably the most difficult chapter of the book because it was necessary
    to introduce a few things such as Java classes, Java methods, and the Android
    life cycle. We did this because we need to know what is going on around us as
    we learn Java.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是这本书中最困难的一章，因为有必要介绍一些像Java类、Java方法和Android生命周期这样的东西。我们这样做是因为我们需要在我们学习Java时了解周围发生的事情。
- en: From now on, however, we can take things a step at a time in a very logical
    manner. If you have reached this point, you will have no problem completing the
    toughest of the projects in this book.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从现在开始，我们可以非常逻辑地一步一步地推进。如果你已经达到这个阶段，你将没有问题完成这本书中最具挑战性的项目。
- en: If this chapter made your brain ache a little, rest assured that the fact that
    you have made it this far is a very good indication that you are going to be a
    Java ace someday soon. Starting from the basics, let's learn some Java now.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一章让你的大脑有点疼痛，请放心，你能够走到这一步是一个非常好的迹象，表明你很快就会成为一个Java高手。从基础开始，我们现在就来学习一些Java。
- en: Chapter 3. Speaking Java – Your First Game
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。说Java – 你的第一个游戏
- en: In this chapter, we will start writing our very own Java code at the same time
    as we begin understanding Java syntax. We will learn how to store, retrieve, and
    manipulate different types of values stored in the memory. We will also look at
    making decisions and branching the flow of our code based on the values of this
    data.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将开始编写我们自己的Java代码，同时我们开始理解Java语法。我们将学习如何存储、检索和操作存储在内存中的不同类型的值。我们还将探讨根据这些数据值做出决策和分支我们的代码流程。
- en: 'In this order, we will:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序，我们将：
- en: Learn some Java syntax and see how it is turned into a running app by the compiler
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些Java语法，看看编译器如何将其转换成可运行的程序
- en: Store data and use it with variables
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据并使用变量
- en: Learn how to express yourself in Java with expressions
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何用表达式在Java中表达自己
- en: Continue with the math game by asking a question
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提问继续进行数学游戏
- en: Learn about decisions in Java
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Java中的决策
- en: Continue with the math game by getting and checking the answer
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过获取和检查答案继续进行数学游戏
- en: 'Acquiring the preceding Java skills will enable us to build the next two phases
    of our math game. This game will be able to ask the player a question on multiplication,
    check the answer and give feedback based on the answer given, as shown in the
    following screenshot:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握前面的Java技能将使我们能够构建数学游戏的下一个两个阶段。这个游戏将能够向玩家提问关于乘法的问题，检查答案并根据给出的答案提供反馈，如下面的截图所示：
- en: '![Speaking Java – Your First Game](img/8859OS_03_06.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![说Java – 你的第一个游戏](img/8859OS_03_06.jpg)'
- en: Java syntax
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语法
- en: Throughout this book, we will use plain English to discuss some fairly technical
    things. You will never be asked to read a technical explanation of a Java or Android
    concept that has not been previously explained in a non-technical way.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们将使用简单的英语来讨论一些相当技术性的内容。你永远不会被要求阅读一个在非技术方式之前没有解释过的Java或Android概念的技术解释。
- en: Occasionally, I might ask or imply that you accept a simplified explanation
    in order to offer a fuller explanation at a more appropriate time, like the Java
    class as a black box; however, you will never need to scurry to Google in order
    to get your head around a big word or a jargon-filled sentence.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我可能会要求或暗示你接受一个简化的解释，以便在更合适的时候提供更全面的解释，比如Java类作为一个黑盒；然而，你永远不会需要匆匆忙忙地去谷歌搜索以理解一个难词或充满术语的句子。
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms and to join in and learn from these communities, you need to
    understand the terms they use. So the approach this book takes is to learn a concept
    or appreciate an idea using an entirely plain speaking language, but at the same
    time, it introduces the jargon as part of the learning.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Java和Android社区充满了使用技术术语的人，要加入并从这些社区中学习，你需要理解他们使用的术语。所以这本书采取的方法是使用完全平实的语言来学习一个概念或欣赏一个想法，同时，它将术语作为学习的一部分引入。
- en: Then, much of the jargon will begin to reveal its usefulness, usually as a way
    of clarification or keeping the explanation/discussion from becoming longer than
    it needs to be.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，许多术语将开始显示出其有用性，通常作为澄清或避免解释/讨论变得比必要的更长的一种方式。
- en: The very term, "Java syntax," could be considered technical or jargon. So what
    is it? The Java syntax is the way we put together the language elements of Java
    in order to produce code that works in the Java/Dalvik virtual machine. Syntax
    should also be as clear as possible to a human reader, not least ourselves when
    we revisit our programs in the future. The Java syntax is a combination of the
    words we use and the formation of those words into sentence like structures.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: “Java 语法”这个术语可能被认为是技术性的或术语性的。那么它是什么？Java 语法是我们将 Java 的语言元素组合在一起以产生在 Java/Dalvik
    虚拟机上运行的代码的方式。语法也应该尽可能地对人类读者清晰，尤其是当我们未来再次访问我们的程序时。Java 语法是我们使用的单词及其形成句子结构的方式的组合。
- en: These Java elements or words are many in number, but when taken in small chunks
    are almost certainly easier to learn than any human-spoken language. The reason
    for this is that the Java language and its syntax were specifically designed to
    be as straightforward as possible. We also have Android Studio on our side, which
    will often let us know if we make a mistake and will even sometimes think ahead
    and prompt us.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Java 元素或单词数量众多，但当我们将其分成小块时，几乎肯定比任何人类语言都容易学习。这是因为 Java 语言及其语法被特别设计成尽可能简单明了。我们还有
    Android Studio 在我们这边，它经常会告诉我们我们是否犯了错误，有时甚至会提前思考并给出提示。
- en: I am confident that if you can read, you can learn Java; because learning Java
    is very easy. What then separates someone who has finished an elementary Java
    course from an expert programmer? The same things that separate a student of language
    from a master poet. Mastery of the language comes through practice and further
    study.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，如果你能阅读，你就能学会 Java；因为学习 Java 非常容易。那么，完成基础 Java 课程的人和专家程序员之间有什么区别？这与语言学习者与大师诗人之间的区别相同。对语言的掌握是通过实践和进一步学习实现的。
- en: In the last chapter, I will show you the right direction if you want to go on
    to master Java yourself.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，如果你想要自己继续深入学习 Java，我会向你展示正确的方向。
- en: The compiler
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器
- en: The compiler is what turns our human-readable Java code into another piece of
    code that can be run in a virtual machine. This is called **compiling**. The Dalvik
    virtual machine will run this compiled code when our players tap on our app icon.
    Besides compiling Java code, the compiler will also check for mistakes. Although
    we might still have mistakes in our released app, many are discovered when our
    code is compiled.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是将我们人类可读的 Java 代码转换成可以在虚拟机上运行的另一段代码的工具。这被称为**编译**。当我们的用户点击我们的应用图标时，Dalvik
    虚拟机将运行这段编译后的代码。除了编译 Java 代码外，编译器还会检查错误。尽管我们可能仍然在我们的发布应用中存在错误，但许多错误是在代码编译时被发现的。
- en: Making code clear with comments
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注释使代码清晰
- en: As you become more advanced in writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide our code into separate chunks, very often across multiple files.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '随着你编写 Java 程序技能的提升，你用来创建程序的方法将会变得更长更复杂。此外，正如我们将在后面的章节中看到的，Java 是通过让我们将代码分成单独的部分，通常跨越多个文件，来设计用来管理复杂性的。 '
- en: '**Comments** are a part of the Java program that do not have any function in
    the program itself. The compiler ignores them. They serve to help the programmer
    to document, explain, and clarify their code to make it more understandable to
    themselves at a later date or to other programmers who might need to use or modify
    the code.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**是 Java 程序的一部分，在程序本身中没有任何功能。编译器会忽略它们。它们的作用是帮助程序员记录、解释和阐明他们的代码，以便在将来或对其他可能需要使用或修改代码的程序员来说更容易理解。'
- en: 'So, a good piece of code will be liberally sprinkled with lines like this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一段好的代码将会大量使用这样的行：
- en: '[PRE9]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. It is known as a single-line comment. So
    anything on that line is for humans only, whereas anything on the next line (unless
    it''s another comment) needs to be syntactically correct Java code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注释以两个正斜杠字符开始，`//`。注释在行尾结束。这被称为单行注释。所以那一行上的内容仅供人类阅读，而下一行上的内容（除非它是另一个注释）需要是语法正确的
    Java 代码：
- en: '[PRE10]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use multiple single-line comments:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个单行注释：
- en: '[PRE11]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Recall this code, which tells Android to load our menu UI:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要暂时禁用一行代码，单行注释也非常有用。我们可以在代码前加上 `//`，这样它就不会被包含在程序中。回想一下以下代码，它告诉Android加载我们的菜单UI：
- en: '[PRE12]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding situation, the menu will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
    There is another type of comment in Java—the multiline comment. This is useful
    for longer comments and also to add things such as copyright information at the
    top of a code file. Also like the single-line comment, it can be used to temporarily
    disable code, in this case usually multiple lines.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，菜单将不会被加载，当运行应用程序时，屏幕将是空的，因为整行代码被编译器忽略。Java中还有一种注释类型——多行注释。这对于较长的注释以及在代码文件顶部添加版权信息非常有用。同样，像单行注释一样，它也可以用来暂时禁用代码，在这种情况下通常是多行代码。
- en: 'Everything in between the leading `/*` signs and the ending `*/` signs is ignored
    by the compiler. Here are some examples:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在起始 `/*` 标签和结束 `*/` 标签之间的所有内容都会被编译器忽略。以下是一些示例：
- en: '[PRE13]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is no limit to the number of lines in a multiline comment. Which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly but you will often find liberally
    sprinkled comments within the code itself that add further explanation, insight
    or clarification. So it''s always a good idea to read all of the code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释的行数没有限制。哪种类型的注释最适合使用将取决于具体情况。在这本书中，我会始终明确解释每一行代码，但你经常会发现代码中散布着大量的注释，这些注释提供了进一步的解释、见解或澄清。因此，阅读所有代码总是一个好主意：
- en: '[PRE14]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All the best Java programmers liberally sprinkle their code with comments.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最好的Java程序员都会在他们的代码中大量添加注释。
- en: Storing data and using it with variables
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量存储数据和使用数据
- en: We can think of a variable as a labeled storage box. They are also like a programmer's
    window to the memory of the Android device, or whatever device we are programming.
    Variables can store data in memory (the storage box), ready to be recalled or
    altered when necessary by using the appropriate label.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量想象成一个带有标签的存储盒。它们也像是程序员通往Android设备（或我们正在编程的任何设备）内存的窗口。变量可以在内存（存储盒）中存储数据，以便在需要时通过适当的标签进行检索或修改。
- en: Computer memory has a highly complex system of addressing that we, fortunately,
    do not need to interact with in Java. Java variables allow us to make up convenient
    names for all the data that we want our program to work with; the JVM will handle
    all the technicalities that interact with the operating system, which in turn,
    probably through several layers of buck passing, will interact with the hardware.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存有一个非常复杂的寻址系统，幸运的是，我们不需要在Java中与之交互。Java变量允许我们为程序想要处理的所有数据创建方便的名称；JVM将处理所有与操作系统交互的技术细节，而操作系统反过来，可能通过几层委托，将与硬件交互。
- en: So we can think of our Android device's memory as a huge warehouse. When we
    assign names to our variables, they are stored in the warehouse, ready when we
    need them. When we use our variable's name, the device knows exactly what we are
    referring to. We can then tell it to do things such as "get box A and add it to
    box C, delete box B," and so on.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的Android设备内存想象成一个巨大的仓库。当我们为变量命名时，它们被存储在仓库中，以便在我们需要时使用。当我们使用变量的名称时，设备会确切地知道我们指的是什么。然后我们可以告诉它做一些事情，比如“获取盒子A并将其添加到盒子C，删除盒子B”，等等。
- en: In a game, we will likely have a variable named as something along the lines
    of `score`. It would be this `score` variable that we use to manage anything related
    to the user's score, such as adding to it, subtracting or perhaps just showing
    it to the player.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们可能会有一个名为 `score` 的变量。这个 `score` 变量将用于管理与用户分数相关的任何操作，例如增加、减少或者只是向玩家显示它。
- en: 'Some of the following situations that might arise:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现的一些以下情况：
- en: The player gets a question right, so add 10 to their existing `score`
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家回答正确问题，因此将10分加到他们现有的 `score` 上。
- en: The player views their stats screen, so print `score` on the screen
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家查看他们的统计数据界面，因此需要在屏幕上打印 `score`。
- en: The player gets the best score ever, so make `hiScore` the same as their current
    `score`
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家获得了最佳分数，因此将 `hiScore` 设置为与当前 `score` 相同。
- en: These are fairly arbitrary examples of names for variables and as long as you
    don't use any of the characters keywords that Java restricts, you can actually
    call your variables whatever you like. However, in practice, it is best to adopt
    a naming convention so that your variable names will be consistent. In this book,
    we will use a loose convention of variable names starting with a lowercase letter.
    When there is more than one word in the variable's name, the second word will
    begin with an uppercase letter. This is called "camel casing."
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是变量命名的一些相当随意的例子，只要你不使用Java限制的关键字字符，你实际上可以随意命名你的变量。然而，在实践中，最好采用一种命名约定，以便你的变量名保持一致。在这本书中，我们将使用一个松散的变量命名约定，即变量名以小写字母开头。当变量名中有多个单词时，第二个单词将以大写字母开头。这被称为“驼峰式命名法”。
- en: 'Here are some examples of camel casing:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些驼峰式命名的例子：
- en: '`score`'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`'
- en: '`hiScore`'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiScore`'
- en: '`playersPersonalBest`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playersPersonalBest`'
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些带有变量的真实Java代码之前，我们首先需要了解我们可以创建和使用哪些类型的变量。
- en: Types of variables
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: It is not hard to imagine that even a simple game will probably have quite a
    few variables. In the previous section, we introduced the `hiScore` variable as
    an example. What if the game has a high score table that remembers the names of
    the top 10 players? Then we might need variables for each player.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的游戏可能需要很多变量并不困难。在前一节中，我们以`hiScore`变量为例进行了介绍。如果游戏有一个记住前10名玩家名字的高分榜，那会怎样？那么我们可能需要为每个玩家设置变量。
- en: And what about the case when a game needs to know if a playable character is
    dead or alive, or perhaps has any lives/retries left? We might need code that
    tests for life and then ends the game with a nice blood spurt animation if the
    playable character is dead.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当一款游戏需要知道一个可玩角色是死是活，或者可能还有剩余的生命/重试次数时，情况会怎样呢？我们可能需要编写测试生命状态的代码，如果可玩角色死亡，则通过一个漂亮的血溅动画结束游戏。
- en: 'Another common requirement in a computer program, including games, is the right
    or wrong calculation: true or false.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中，包括游戏在内的另一个常见需求是正确或错误的计算：真或假。
- en: To cover these and many other types of information you might want to keep track
    of, Java has **types**. There are many types of variables and, as we will see
    in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP
    – Using Other People's Hard Work*, we can also invent our own types or use other
    people's types. But for now, we will look at the built-in Java types. To be fair,
    they cover just about every situation we are likely to run into for a while. Some
    examples are the best way to explain this type of stuff.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖这些以及其他你可能想要跟踪的信息类型，Java有**类型**。有许多种类的变量，正如我们将在[第6章](ch06.html "第6章。面向对象编程
    – 利用他人的辛勤工作")中看到的，*面向对象编程 – 利用他人的辛勤工作*，我们也可以发明自己的类型或使用他人的类型。但就目前而言，我们将查看内置的Java类型。为了公平起见，它们几乎涵盖了我们在一段时间内可能遇到的所有情况。一些例子是最好的解释方式。
- en: We have already discussed the hypothetical but highly likely `score` variable.
    The variable `score` is likely to be a number, so we have to convey this (that
    the score is a number) to the Java compiler by giving the score an appropriate
    type. The hypothetical but equally likely `playerName` will, of course, hold the
    characters that make up the player's name. Jumping ahead a couple of paragraphs,
    the type that holds a regular number is called `int`, and the type that holds
    name-like data is called `String`. And if we try and store a player name, perhaps
    "Ada Lovelace" in `score`, which is meant for numbers, we will certainly run into
    trouble.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了假设但高度可能的`score`变量。`score`变量很可能是数字，因此我们必须通过给分数一个适当的数据类型来向Java编译器传达这一点（即分数是数字）。假设但同样可能的`playerName`将当然包含构成玩家名字的字符。跳过几段之后，存储常规数字的类型称为`int`，而存储类似名字的数据的类型称为`String`。如果我们尝试在用于数字的`score`中存储玩家名字，比如“Ada
    Lovelace”，我们肯定会遇到麻烦。
- en: 'The compiler says no! Actually, the error would say this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器说不行！实际上，错误信息会这样显示：
- en: '![Types of variables](img/8859OS_03_05.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![变量类型](img/8859OS_03_05.jpg)'
- en: As we can see, Java was designed to make it impossible for such errors to make
    it to a running program. Did you also spot in the previous screenshot that I had
    forgotten the semicolon at the end of the line? With this compiler identifying
    our errors, what could possibly go wrong?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Java被设计成不可能让这样的错误进入运行程序。你也在之前的屏幕截图中发现我忘记在行尾加上分号了吗？有了这个编译器识别我们的错误，还能有什么可能出错呢？
- en: 'Here are the main types in Java. Later, we will see how to start using them:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Java中的主要数据类型。稍后我们将看到如何开始使用它们：
- en: '`int`: This type is used to store integers. It uses 32 pieces (**bits**) of
    memory and can therefore store values with a magnitude a little in excess of 2
    billion, including negative values.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这种类型用于存储整数。它使用32位（**位**）内存，因此可以存储超过20亿的值，包括负值。'
- en: '`long`: As the name hints at, this data type can be used when even larger numbers
    are required. A `long` data type uses 64 bits of memory and 2 to the power of
    63 is what we can store in this type. If you want to see what that looks like,
    try this: `9,223,372,036,854,775,807`. Perhaps surprisingly, there are uses for
    `long` variables but if a smaller variable will do, we should use it so that our
    program uses less memory.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：正如其名所示，这种数据类型可以在需要更大数字时使用。`long`数据类型使用64位内存，2的63次方是我们可以在这种类型中存储的。如果你想看看它是什么样子，试试这个：`9,223,372,036,854,775,807`。也许令人惊讶的是，`long`变量有用途，但如果较小的变量可以满足需求，我们应该使用它，这样我们的程序就会使用更少的内存。'
- en: Note
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering when you might use numbers of this magnitude. The obvious
    examples would be math or science applications that do complex calculations but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. The `long`
    data type could be useful to subtract a start time from an end time to determine
    an elapsed time. We will use `long` in [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会想知道何时会使用这种规模的数字。明显的例子是数学或科学应用，它们需要进行复杂的计算，但另一种用途可能是计时。当你计时某件事情花费了多长时间时，Java的`Date`类使用自1970年1月1日以来的毫秒数。`long`数据类型可以用来从结束时间减去开始时间，以确定经过的时间。我们将在[第5章](ch05.html
    "第5章。游戏和Java基础")，*游戏和Java基础*中使用`long`。
- en: '`float`: This is for floating-point numbers, that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole number portion, the range of numbers possible in a float
    is therefore decreased compared to non-floating-point numbers. So, unless our
    variable will definitely use the extra precision, float would not be our data
    type of choice.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这是用于浮点数，即小数点后有精度的数。由于一个数的分数部分和整数部分一样占用内存空间，因此与非浮点数相比，float类型可能存储的数值范围较小。所以，除非我们的变量确实需要额外的精度，否则float不会是我们的首选数据类型。'
- en: '`double`: When the precision in `float` is not enough we have `double`.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：当`float`的精度不足时，我们有`double`。'
- en: '`short`: When even an `int` data type is overkill, the super-skinny short fits
    into the tiniest of storage boxes, but we can only store around 64,000 values,
    from -32,768 to 32,767.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：当`int`数据类型也过于冗余时，超级瘦小的short类型可以放入最小的存储空间中，但我们只能存储大约64,000个值，从-32,768到32,767。'
- en: '`byte`: This is an even smaller storage box than a short type. There is plenty
    of room for these in memory but a byte can only store values from -128 to 127.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：这是一个比short类型更小的存储空间。在内存中有足够的空间，但一个byte只能存储从-128到127的值。'
- en: '`boolean`: We will be using plenty of Booleans throughout the book. A Boolean
    variable can be either true or false—nothing else. Perhaps Booleans answer questions
    such as:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：在这本书中我们将大量使用布尔值。布尔变量可以是true或false——没有其他情况。也许布尔值可以回答如下问题：'
- en: Is the player alive?
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家是否存活？
- en: Has a new high score been reached?
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否已经达到了新的高分？
- en: Are two examples for a Boolean variable enough?
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个例子是否足够说明布尔变量的用法？
- en: '`char`: This stores a single alphanumeric character. It''s not going to change
    anything on its own but it could be useful if we put lots of them together.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：这存储单个字母数字字符。它本身不会改变任何事情，但如果我们将很多这样的字符放在一起，可能会很有用。'
- en: Tip
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I have kept this discussion of data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, visit the Oracle Java tutorials
    site at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经将数据类型的讨论保持在实用的水平，这在本书的上下文中是有用的。如果你对数据类型值的存储方式以及为什么限制是这样的感兴趣，请访问Oracle Java教程网站[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)。请注意，你不需要比我们已讨论的更多信息来继续阅读本书。
- en: As we just learned, each type of data that we might want to store will require
    a specific amount of memory. So we must let the Java compiler know the type of
    the variable before we begin to use it.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚学到的，我们可能想要存储的每种数据类型都需要特定的内存量。因此，在我们开始使用变量之前，我们必须让Java编译器知道变量的类型。
- en: The preceding variables are known as the **primitive** types. They use predefined
    amounts of memory and so, using our storage analogy, fit into predefined sizes
    of the storage box.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的变量被称为**原始类型**。它们使用预定义的内存量，因此，使用我们的存储类比，可以适应预定义的存储盒大小。
- en: As the "primitive" label suggests, they are not as sophisticated as the reference
    types.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如“原始”标签所暗示的，它们不如引用类型复杂。
- en: Reference types
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用类型
- en: You might have noticed that we didn't cover the `String` variable type that
    we previously used to introduce the concept of variables.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有涵盖我们之前用来介绍变量概念的`String`变量类型。
- en: 'Strings are a special type of variable known as a reference type. They quite
    simply refer to a place in memory where the storage of the variable begins, but
    the reference type itself does not define a specific amount of memory. The reason
    for this is fairly straightforward: we don''t always know how much data will need
    to be stored until the program is actually run.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种特殊的变量类型，称为引用类型。它们非常简单，指的是变量存储开始的内存位置，但引用类型本身并不定义特定的内存量。原因相当直接：我们并不总是知道程序实际运行时需要存储多少数据。
- en: We can think of strings and other reference types as continually expanding and
    contracting storage boxes. So won't one of these `String` reference types bump
    into another variable eventually? If you think about the devices memory as a huge
    warehouse full of racks of labeled storage boxes, then you can think of the Dalvik
    virtual machine as a super-efficient forklift truck driver that puts the different
    types of storage boxes in the most appropriate place.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将字符串和其他引用类型想象成不断扩展和收缩的存储盒。那么，这些`String`引用类型最终不会撞到另一个变量吗？如果你把设备内存想象成一个装满了标签存储盒的巨大仓库，那么你可以把Dalvik虚拟机想象成一个超级高效的叉车司机，将不同类型的存储盒放在最合适的位置。
- en: And if it becomes necessary, the virtual machine will quickly move stuff around
    in a fraction of a second to avoid collisions. It will even incinerate unwanted
    storage boxes when appropriate. This happens at the same time as constantly unloading
    new storage boxes of all types and placing them in the best place, for that type
    of variable. Dalvik tends to keep reference variables in a part of the warehouse
    that is different from the part for the primitive variables, and we will learn
    more details about this in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，虚拟机将在几秒钟内快速移动东西以避免冲突。它甚至会在适当的时候销毁不需要的存储盒。这同时发生，不断卸载所有类型的新的存储盒并将它们放置在最佳位置，为该类型的变量。Dalvik倾向于将引用变量保存在与原始变量不同的仓库部分，我们将在第6章[OOP
    – 使用他人的辛勤工作](ch06.html "第6章。面向对象编程 – 使用他人的辛勤工作")中了解更多细节，*面向对象编程 – 使用他人的辛勤工作*。
- en: So strings can be used to store any keyboard character, like a `char` data type
    but of almost any length. Anything from a player's name to an entire book can
    be stored in a single string. We will be using strings regularly including in
    this chapter.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，字符串可以用来存储任何键盘字符，就像`char`数据类型一样，但长度几乎可以是任何长度。从玩家的名字到整本书都可以存储在一个单独的字符串中。我们将经常使用字符串，包括在本章中。
- en: There are a couple more reference types we will explore. Arrays are a way to
    store lots of variables of the same type, ready for quick and efficient access.
    We will look at arrays in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"),
    *Gaming and Java Essentials*.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索更多种类的引用类型。数组是一种存储大量相同类型变量的方式，便于快速高效地访问。我们将在[第5章](ch05.html "第5章. 游戏和Java基础")*游戏和Java基础*中查看数组。
- en: Think of an array as an aisle in our warehouse with all the variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as strings.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组想象成我们仓库中一个通道，所有特定类型的变量都按精确的顺序排列。数组是引用类型，因此Dalvik将这些变量存储在仓库的同一部分，就像字符串一样。
- en: The other reference type is the mysterious object or class that we will look
    at in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP –* *Using Other People's Hard Work*.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引用类型是我们将在[第6章](ch06.html "第6章. 面向对象编程 – 利用他人的辛勤工作")*面向对象编程 – 利用他人的辛勤工作*中探讨的神秘对象或类。
- en: So we know that each type of data that we might want to store will require an
    amount of memory. Hence, we must let the Java compiler know the type of the variable
    before we begin to use it.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道我们可能想要存储的每种数据类型都需要一定量的内存。因此，我们必须在开始使用它之前让Java编译器知道变量的类型。
- en: Declaration
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: That's enough of theory. Let's see how we would actually use our variables and
    types. Remember that each primitive type requires a specific amount of real device
    memory. This is one of the reasons that the compiler needs to know what type a
    variable will be of. So we must first **declare** a variable and its type before
    we attempt to do anything with it.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 理论就到这里。让我们看看我们实际上会如何使用我们的变量和类型。记住，每种原始类型都需要一定量的实际设备内存。这就是为什么编译器需要知道变量的类型。因此，在我们尝试对变量进行任何操作之前，我们必须首先**声明**变量及其类型。
- en: 'To declare a variable of type `int` with the name `score`, we would type:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个名为`score`的`int`类型变量，我们会输入：
- en: '[PRE15]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it! Simply state the type, in this case `int`, then leave a space, and
    type the name you want to use for this variable. Also note the semicolon on the
    end of the line as usual to show the compiler that we are done with this line
    and what follows, if anything, is not part of the declaration.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！只需声明类型，在这种情况下是`int`，然后留一个空格，然后输入你想为这个变量使用的名称。还要注意，通常在行尾的分号，以向编译器表明我们已经完成了这一行，并且如果有的话，接下来的内容不是声明的一部分。
- en: 'For almost all the other variable types, declaration would occur in the same
    way. Here are some examples. The variable names are arbitrary. This is like reserving
    a labeled storage box in the warehouse:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有的其他变量类型，声明方式都是相同的。以下是一些示例。变量名是任意的。这就像在仓库中预留一个带标签的存储箱：
- en: '[PRE16]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Initialization
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Here, for each type, we initialize a value to the variable. Think about placing
    a value inside the storage box, as shown in the following code:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于每种类型，我们给变量初始化一个值。想想在存储箱中放置一个值，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `char` variable uses single quotes (`'`) around the initialized
    value while the `String` uses double quotes (`"`).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`char`变量使用单引号(`'`)包围初始化值，而`String`使用双引号(`"`)。
- en: 'We can also combine the declaration and initialization steps. In the following
    snippet of code, we declare and initialize the same variables as we did previously,
    but in one step each:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将声明和初始化步骤结合起来。在下面的代码片段中，我们声明并初始化了之前相同的变量，但每个步骤都是一步：
- en: '[PRE18]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Whether we declare and initialize separately or together is probably dependent
    upon the specific situation. The important thing is that we must do both:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是单独声明和初始化还是一起进行，这很可能取决于具体情况。重要的是我们必须做两件事：
- en: '[PRE19]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code would cause the following result:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会导致以下结果：
- en: '[PRE20]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is a significant exception to this rule. Under certain circumstances variables
    can have **default values**. We will see this in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. But
    it is good practice to both declare and initialize variables.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的例外。在特定情况下，变量可以有**默认值**。我们将在[第6章](ch06.html "第6章. 面向对象编程 – 利用他人的辛勤工作")*面向对象编程
    – 利用他人的辛勤工作*中看到这一点。但良好的做法是同时声明和初始化变量。
- en: Changing variables with operators
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用运算符更改变量
- en: 'Of course, in almost any program, we are going to need to do something with
    these values. Here is a list of perhaps the most common Java operators that allow
    us to manipulate variables. You do not need to memorize them as we will look at
    every line of code when we use them for the first time:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在几乎任何程序中，我们都需要对这些值进行一些操作。以下是一个可能最常见的Java运算符列表，它允许我们操作变量。您不需要记住它们，因为当我们第一次使用它们时，我们会查看每一行代码：
- en: '**The assignment operator (=)**: This makes the variable to the left of the
    operator the same as the value to the right. For example, `hiScore = score;` or
    `score = 100;`.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值运算符 (=)**: 这使得运算符左侧的变量与右侧的值相同。例如，`hiScore = score;` 或 `score = 100;`。'
- en: '**The addition operator (+)**: This adds the values on either side of the operator.
    It is usually used in conjunction with the assignment operator, such as `score
    = aliensShot + wavesCleared;` or `score = score + 100;`. Notice that it is perfectly
    acceptable to use the same variable simultaneously on both sides of an operator.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法运算符 (+)**: 这将运算符两侧的值相加。它通常与赋值运算符一起使用，例如 `score = aliensShot + wavesCleared;`
    或 `score = score + 100;`。注意，在运算符两侧同时使用相同的变量是完全可接受的。'
- en: '**The subtraction operator (-)**: This subtracts the value on the right side
    of the operator from the value on the left. It is usually used in conjunction
    with the assignment operator, such as `lives = lives - 1;` or `balance = income
    - outgoings;`.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法运算符 (-)**: 这从运算符右侧的值减去运算符左侧的值。它通常与赋值运算符一起使用，例如 `lives = lives - 1;` 或 `balance
    = income - outgoings;`。'
- en: '**The division operator (/)**: This divides the number on the left by the number
    on the right. Again, it is usually used in conjunction with the assignment operator,
    as shown in `fairShare = numSweets / numChildren;` or `recycledValueOfBlock =
    originalValue / .9;`.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法运算符 (/)**: 这将左侧的数字除以右侧的数字。同样，它通常与赋值运算符一起使用，如 `fairShare = numSweets / numChildren;`
    或 `recycledValueOfBlock = originalValue / .9;`。'
- en: '**The multiplication operator (*)**: This multiplies variables and numbers,
    such as `answer = 10 * 10;` or `biggerAnswer = 10 * 10 * 10;`.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法运算符 (*)**: 这将变量和数字相乘，例如 `answer = 10 * 10;` 或 `biggerAnswer = 10 * 10 *
    10;`。'
- en: '**The increment operator (++)**: This is a really neat way to add `1` to the
    value of a variable. The `myVariable = myVariable + 1;` statement is the same
    as `myVariable++;`.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递增运算符 (++)**: 这是一种非常巧妙的方法，可以将 `1` 添加到变量的值。`myVariable = myVariable + 1;`
    语句与 `myVariable++;` 相同。'
- en: '**The decrement operator (--)**: You guessed it: a really neat way to subtract
    `1` from something. The `myVariable = myVariable -1;` statement is the same as
    `myVariable--;`.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递减运算符 (--)**: 你猜对了：一种从某物中减去 `1` 的非常巧妙的方法。`myVariable = myVariable -1;` 语句与
    `myVariable--;` 相同。'
- en: Note
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The formal names for these operators are slightly different from the names used
    here for explanation. For example, the division operator is actually one of the
    multiplicative operators. But the preceding names are far more useful for the
    purpose of learning Java and if you used the term "division operator", while conversing
    with someone from the Java community, they would know exactly what you mean.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符的正式名称与这里用于解释的名称略有不同。例如，除法运算符实际上是乘法运算符之一。但前面的名称对于学习Java来说更有用，如果您在与Java社区的人交谈时使用了“除法运算符”，他们会确切地知道您的意思。
- en: There are actually many more operators than these in Java. We will see a whole
    bunch later in this chapter when we learn about decisions in Java.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java中还有许多其他运算符。当我们学习Java中的决策时，我们将在本章后面看到一大堆运算符。
- en: Tip
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are curious about operators there is a complete list of them on the Java
    website at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators required to complete the projects in this book will be fully
    explained in this book. The link is provided for the curious among us.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对运算符感兴趣，可以在Java网站上找到它们的完整列表，网址为 [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)。本书中完成项目所需的所有运算符都将在此书中进行全面解释。此链接为好奇者提供。
- en: Expressing yourself in Java
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中表达自己
- en: Let's try using some declarations, assignments and operators. When we bundle
    these elements together into some meaningful syntax, we call it an expression.
    So let's write a quick app to try some out.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些声明、赋值和运算符。当我们将这些元素组合成有意义的语法时，我们称之为表达式。所以让我们快速编写一个应用程序来尝试一下。
- en: Here we will make a little side project so we can play with everything we have
    learned so far. We will need to create a new project, just as we did in the previous
    chapter but we will not need a UI this time.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将进行一个小型的辅助项目，以便我们可以玩转到目前为止所学的所有内容。我们需要创建一个新的项目，就像我们在上一章中所做的那样，但这次我们不需要UI。
- en: 'Instead, we will simply write some Java code and examine its effects by outputting
    the values of variables to the Android console, called **logcat**. We will see
    exactly how this works by building the simple project and examining the code and
    the console output:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将简单地编写一些Java代码，并通过将变量的值输出到Android控制台（称为**logcat**）来检查其效果。我们将通过构建简单的项目并检查代码和控制台输出来确切了解这是如何工作的：
- en: Tip
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The following is a quick reminder of how to create a new project.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建新项目的快速提醒。
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭当前打开的项目，请导航到**文件** | **关闭项目**。
- en: Click on **Start a** **new Android Studio project**.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始一个新的Android Studio项目**。
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com` or you could use your
    own company website name here instead.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现**创建新项目**配置窗口。填写**应用程序名称**字段和**公司域名**为`packtpub.com`，或者你也可以在这里使用你自己的公司网站名称。
- en: 'Now click on the **Next** button. On the next screen, make sure the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select fewer cutting-edge Android features
    will be available in our apps. A good balance is to select **API 8: Android 2.2
    (Froyo)**.'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击**下一步**按钮。在下一屏幕上，确保**手机和平板**复选框被勾选。现在我们必须选择我们想要为我们的应用构建的最早版本的Android。尝试在下拉选择器中玩转几个选项。你会发现，我们选择的版本越早，我们的应用可以支持的设备百分比就越大。然而，这里的权衡是，我们选择的版本越早，我们应用中可用的最新Android功能就越少。一个好的平衡点是选择**API
    8: Android 2.2 (Froyo)**。'
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**。现在选择**空白活动**，然后再次点击**下一步**。
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，只需将**活动名称**更改为`MainActivity`，然后点击**完成**。
- en: As we did in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements. However, this is not necessary
    for the example to work.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章. Android入门")中所述，为了保持代码清晰简单，你可以删除两个不需要的方法（`onCreateOptionsMenu`和`onOptionsItemSelected`）以及它们相关的`@override`和`@import`语句。然而，这对于示例的正常运行并不是必需的。
- en: Tip
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.html "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解创建新项目的说明和图片，请参阅[第2章](ch02.html "第2章. Android入门")，*Android入门*。
- en: As with all the examples and projects in this book, you can copy or review the
    code from the download bundle. You will find the code for this tutorial in the
    `Chapter3/ExpressionsInJava/MainActivity.java` file. Just create the project as
    described previously and paste the code from `MainActivity.java` file from the
    download bundle to the `MainActivity.java` file that was generated when you created
    the project in Android Studio. Just ensure that the package name is the same as
    the one you chose when the project was created. However, I strongly recommend
    going along with the tutorial so that we can learn how to do everything for ourselves.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的所有示例和项目一样，你可以从下载包中复制或查看代码。你可以在`Chapter3/ExpressionsInJava/MainActivity.java`文件中找到本教程的代码。只需按照之前描述的方式创建项目，并将下载包中的`MainActivity.java`文件中的代码粘贴到Android
    Studio创建项目时生成的`MainActivity.java`文件中。只需确保包名与创建项目时选择的相同。然而，我强烈建议跟随教程，这样我们可以学会自己完成所有事情。
- en: Note
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As this app uses the logcat console to show its output, you should run this
    app on the emulator only and not on a real Android device. The app will not harm
    a real device, but you just won't be able to see anything happening.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用使用logcat控制台来显示其输出，你应该只在模拟器上运行此应用，而不是在真实的Android设备上。此应用不会损害真实设备，但你将无法看到任何发生的事情。
- en: Create a new blank project called `Expressions In Java`.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Expressions In Java`的新空白项目。
- en: 'Now, in the `onCreate` method just after the line where we use the `setContentView`
    method, add this code to declare and initialize some variables:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`setContentView`方法之后的`onCreate`方法中，添加以下代码以声明和初始化一些变量：
- en: '[PRE21]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now add the following code. This code simply outputs the value of our variables
    in a form where we can closely examine them in a minute:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加以下代码。这段代码简单地以我们可以稍后仔细检查的形式输出变量的值：
- en: '[PRE22]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s change our variables using the addition operator and another new
    operator. See if you can work out the output values for variables `a`, `b`, and
    `c` before looking at the output and the code explanation:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用加法运算符和另一个新运算符来更改我们的变量。在查看输出和代码说明之前，看看你是否能计算出变量`a`、`b`和`c`的输出值：
- en: '[PRE23]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s output the values once more in the same way we did in step 3, but this
    time, the output should be different:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次以第3步中的相同方式输出值，但这次输出应该不同：
- en: '[PRE24]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the program on an emulator in the usual way. You can see the output by clicking
    on the **Android** tab from our "useful tabs" area below the Project Explorer.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式在模拟器上运行程序。你可以通过点击位于项目资源管理器下方的“有用的标签”区域中的**Android**标签来查看输出。
- en: 'Here is the output, with some of the unnecessary formatting stripped off:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出，其中一些不必要的格式已被删除：
- en: '[PRE25]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s discuss what happened. In step 2, we declared and initialized three
    variables:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论发生了什么。在第2步中，我们声明并初始化了三个变量：
- en: '`a`: This is an int that holds the value 10'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：这是一个存储值为10的整型。'
- en: '`b`: This is a string that holds the name of an eminent computer scientist.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：这是一个存储杰出计算机科学家名字的字符串。'
- en: '`c`: This is a Boolean that holds the value false'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：这是一个存储值为`false`的布尔值'
- en: 'So when we output the values in step 3, it should be no surprise that we get
    the following:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们输出第3步中的值时，我们得到以下结果应该不会让人感到惊讶：
- en: '[PRE26]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In step 4, all the fun stuff happens. We add 1 to the value of our int `a`
    using the increment operator like this: `a++;`. Remember that `a++` is the same
    as `a = a + 1`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，所有有趣的事情发生了。我们使用增量运算符`a++;`将我们的整型`a`的值增加1。记住，`a++`与`a = a + 1`相同。
- en: 'We then add 10 to `a`. Note we are adding 10 to `a` after having already added
    1\. So we get this output for a 10 + 1 + 10 operation:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将10加到`a`上。注意，我们在已经加1之后将10加到`a`上。因此，我们得到10 + 1 + 10操作的结果：
- en: '[PRE27]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now let's examine our string, `b`. We appear to be using the addition operator
    on our eminent scientist. What is happening is what you could probably guess.
    We are adding together two strings `"Alan Turing"` and `"was smarter than the
    average bear Booboo."` When you add two strings together it is called **concatenating**
    and the `+` symbol doubles as the concatenation operator.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的字符串`b`。我们似乎正在使用加法运算符在我们的杰出科学家上。发生的事情你可能已经猜到了。我们正在将两个字符串`"Alan Turing"`和`"was
    smarter than the average bear Booboo."`相加。当你将两个字符串相加时，这被称为**连接**，而`+`符号同时作为连接运算符。
- en: Finally, for our string, we appear to be adding `int a` to it. This is allowed
    and the value of `a` is concatenated to the end of `b`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的字符串，我们似乎正在将其与`int a`相加。这是允许的，`a`的值被连接到`b`的末尾。
- en: '[PRE28]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This does not work the other way round; you cannot add a string to an `int`.
    This makes sense as there is no logical answer.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这不适用于相反的情况；你不能将一个字符串添加到一个`int`上。这合乎逻辑，因为没有合理的答案。
- en: '`a = a + b`'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`a = a + b`'
- en: '![Expressing yourself in Java](img/8859OS_03_07.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中表达自己](img/8859OS_03_07.jpg)'
- en: 'Finally, let''s look at the code that changes our Boolean, `c`, from true to
    false: `c = (1+1=3);`. Here, we are assigning to `c` the value of the expression
    contained within the brackets. This would be straightforward, but why the double
    equals (`==`)? We have jumped ahead of ourselves a little. The double equals sign
    is another operator called the **comparison** operator.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看将我们的布尔值`c`从`true`变为`false`的代码：`c = (1+1=3);`。在这里，我们将括号内表达式的值赋给`c`。这本来是直截了当的，但为什么是双等号（`==`）？我们有点超前了。双等号是另一个称为**比较运算符**的运算符。
- en: So we are really asking, *does* 1+1 equal 3? Clearly the answer is false. You
    might ask, "why use `==` instead of `=`?" Simply to make it clear to the compiler
    when we mean to assign and when we mean to compare.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上是在问，1+1 是否等于 3？显然答案是错误的。你可能会问，“为什么使用 `==` 而不是 `=`？” 简单来说，是为了让编译器清楚地知道我们是在赋值还是比较。
- en: Tip
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inadvertently using `=` instead of `==` is a very common error.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 不小心使用 `=` 而不是 `==` 是一个非常常见的错误。
- en: The assignment operator (`=`) assigns the value on the right to the value on
    the left, while the comparison operator (`==`) compares the values on either side.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符 (`=`) 将右侧的值赋给左侧的值，而比较运算符 (`==`) 比较两侧的值。
- en: The compiler will warn us with an error when we do this but at first glance
    you might swear the compiler is wrong. We will learn more on this comparison operator
    and others later in the chapter and throughout the book.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，编译器会通过错误警告我们，但乍一看，你可能会发誓编译器是错的。我们将在本章的后面和整本书中学习更多关于比较运算符和其他运算符的内容。
- en: Now let's use everything we know and a bit more to make our math game project.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用我们所知道的一切以及更多知识来制作我们的数学游戏项目。
- en: Math game – asking a question
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学游戏 – 提出问题
- en: Now that we have all that knowledge under our belts, we can use it to improve
    our math game. First, we will create a new Android activity to be the actual game
    screen as opposed to the start menu screen. We will then use the UI designer to
    lay out a simple game screen so that we can use our Java skills with variables,
    types, declaration, initialization, operators, and expressions to make our math
    game generate a question for the player. We can then link the start menu and game
    screens together with a push button.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了所有这些知识，我们可以用它来改进我们的数学游戏。首先，我们将创建一个新的 Android 活动，作为实际的游戏屏幕，而不是开始菜单屏幕。然后我们将使用
    UI 设计器来布局一个简单的游戏屏幕，这样我们就可以使用我们的 Java 技能，包括变量、类型、声明、初始化、运算符和表达式，让我们的数学游戏为玩家生成一个问题。然后我们可以通过一个按钮将开始菜单和游戏屏幕连接起来。
- en: If you want to save typing and just review the finished project, you can use
    the code downloaded from the Packt Publishing website. If you have any trouble
    getting any of the code to work, you can review, compare, or copy and paste the
    code from the already completed code provided in the download bundle.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要节省打字时间并仅查看完成的项目，你可以使用从 Packt Publishing 网站下载的代码。如果你在使任何代码工作时有任何问题，你可以查看、比较或复制粘贴下载包中已完成的代码。
- en: 'The completed code is in the following files that correspond to the filenames
    we will be using in this tutorial:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码在以下文件中，这些文件对应于我们在本教程中将要使用的文件名：
- en: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
- en: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
- en: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
- en: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
- en: As usual, I recommend following this tutorial to see how we can create all of
    the code for ourselves.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我建议遵循这个教程，看看我们如何自己创建所有代码。
- en: Creating the new game activity
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的游戏活动
- en: We will first need to create a new Java file for the game activity code and
    a related layout file to hold the game activity UI.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个新的 Java 文件来存放游戏活动代码，以及一个相关的布局文件来存放游戏活动 UI。
- en: Run Android Studio and select your `Math Game Chapter 2` project that we built
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*. It might have been opened by default. Now we will create
    the new Android activity that will contain the actual game screen, which will
    run when the player taps the **Play** button on our main menu screen.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Android Studio 并选择我们已在 [第 2 章](ch02.html "第 2 章。Android 入门") 中构建的 `Math Game
    Chapter 2` 项目，*Android 入门*。它可能已经默认打开了。现在我们将创建一个新的 Android 活动，该活动将包含实际的游戏屏幕，当玩家在我们的主菜单屏幕上点击
    **Play** 按钮时，该屏幕将运行。
- en: To create a new activity, we now need another layout file and another Java file.
    Fortunately Android Studio will help us do this. To get started with creating
    all the files we need for a new activity, right-click on the `src` folder in the
    Project Explorer and then go to **New** | **Activity**. Now click on **Blank Activity**
    and then on **Next**.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的活动，我们现在需要另一个布局文件和另一个 Java 文件。幸运的是，Android Studio 会帮助我们完成这项工作。要开始创建新活动所需的所有文件，在项目资源管理器中右键单击
    `src` 文件夹，然后转到 **New** | **Activity**。现在点击 **Blank Activity**，然后点击 **Next**。
- en: We now need to tell Android Studio a little bit about our new activity by entering
    information in the above dialog box. Change the **Activity Name** field to `GameActivity`.
    Notice how the **Layout Name** field is automatically changed for us to `activity_game`
    and the **Title** field is automatically changed to `GameActivity`.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在上述对话框中输入一些信息来告诉Android Studio关于我们新的活动的一些信息。将**Activity Name**字段更改为`GameActivity`。注意**Layout
    Name**字段会自动更改为`activity_game`，而**Title**字段也会自动更改为`GameActivity`。
- en: Click on **Finish**. Android Studio has created two files for us and has also
    registered our new activity in a manifest file, so we don't need to concern ourselves
    with it.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Finish**。Android Studio已经为我们创建了两个文件，并且也在一个清单文件中注册了我们的新活动，所以我们不需要担心它。
- en: If you look at the tabs at the top of the editor window, you will see that `GameActivity.java`
    has been opened up ready for us to edit, as shown in the following screenshot:![Creating
    the new game activity](img/8859OS_03_02.jpg)
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看编辑器窗口顶部的标签页，你会看到`GameActivity.java`已经打开，准备好供我们编辑，如以下截图所示：![创建新的游戏活动](img/8859OS_03_02.jpg)
- en: Ensure that `GameActivity.java` is active in the editor window by clicking on
    the **GameActivity.java** tab shown previously.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击之前显示的**GameActivity.java**标签页，确保`GameActivity.java`在编辑器窗口中处于活动状态。
- en: Back in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, we talked about how Android overrides some methods for
    us by default, and that most of them were not necessary. Here again, we can see
    the code that is unnecessary. If we remove it, then it will make our working environment
    simpler and cleaner. You might also remember from [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*, that the process of deleting
    and amending sections of code, although not complex, is a fairly long process.
    To avoid this here, we will simply use the code from `MainActivity.java` as a
    template for `GameActivity.java`. We can then make some minor changes.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到[第2章](ch02.html "第2章。Android入门")，我们在“Android入门”中讨论了Android默认为我们覆盖了一些方法，并且大多数方法都是不必要的。在这里，我们再次可以看到不必要的代码。如果我们删除它，那么它将使我们的工作环境更简单、更干净。你可能还记得从[第2章](ch02.html
    "第2章。Android入门")，“Android入门”，删除和修改代码部分的过程，虽然不复杂，但相对较长。为了避免这种情况，我们将简单地使用`MainActivity.java`中的代码作为`GameActivity.java`的模板。然后我们可以做一些小的修改。
- en: Click on the **MainActivity.java** tab in the editor window. Highlight all of
    the code in the editor window using *Ctrl* + *A* on the keyboard.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中点击**MainActivity.java**标签页。使用键盘上的*Ctrl* + *A*组合键高亮显示编辑器窗口中的所有代码。
- en: Now copy all of the code in the editor window using the *Ctrl* + *C* on the
    keyboard.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在键盘上使用*Ctrl* + *C*组合键复制编辑器窗口中的所有代码。
- en: Now click on the **GameActivity.java** tab.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**GameActivity.java**标签页。
- en: Highlight all of the code in the editor window using *Ctrl* + *A* on the keyboard.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键盘上的*Ctrl* + *A*组合键在编辑器窗口中高亮显示所有代码。
- en: Now paste the copied code and overwrite the currently highlighted code using
    *Ctrl* + *V* on the keyboard.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将复制的代码粘贴到编辑器窗口中，并使用键盘上的*Ctrl* + *V*组合键覆盖当前高亮的代码。
- en: Notice that there is an error in our code denoted by the red underlining as
    shown in the following screenshot. This is because we pasted the code referring
    to `MainActivity` in our file that is called `GameActivity`.![Creating the new
    game activity](img/8859OS_03_03.jpg)
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到我们的代码中有一个错误，如以下截图所示，用红色下划线标记。这是因为我们在名为`GameActivity`的文件中粘贴了引用`MainActivity`的代码。![创建新的游戏活动](img/8859OS_03_03.jpg)
- en: Simply change the text **MainActivity** to **GameActivity** and the error will
    disappear. Take a moment to see if you can work out what other minor change is
    necessary, before I tell you.
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单地将文本**MainActivity**更改为**GameActivity**，错误就会消失。在我告诉你之前，花点时间看看你是否能找出其他必要的微小更改。
- en: Remember that `setContentView` loads our UI design. Well what we need to do
    is change `setContentView` to load the new design (that we will build next) instead
    of the home screen design. Change `setContentView(R.layout.activity_main);` to
    `setContentView(R.layout.activity_game);`.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住`setContentView`加载我们的UI设计。我们需要做的是将`setContentView`更改为加载新的设计（我们将在下一节构建），而不是主屏幕设计。将`setContentView(R.layout.activity_main);`更改为`setContentView(R.layout.activity_game);`。
- en: Save your work and we are ready to move on.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的工作，我们就可以继续了。
- en: Note the Project Explorer where Android Studio puts the two new files it created
    for us. I have highlighted two folders in the next screenshot. In future, I will
    simply refer to them as our `java` code folder or `layout` files folder.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 注意项目资源管理器，Android Studio会在这里放置为我们创建的两个新文件。在下一张截图中，我已经突出显示了两个文件夹。在未来的讨论中，我将简单地称它们为我们的`java`代码文件夹或`layout`文件文件夹。
- en: '![Creating the new game activity](img/8859OS_03_04.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![创建新的游戏活动](img/8859OS_03_04.jpg)'
- en: Note
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder why we didn't simply copy and paste the `MainActivity.java`
    file to begin with and saved going through the process of creating a new activity?
    The reason is that Android Studio does things behind the scenes. Firstly, it makes
    the layout template for us. It also registers the new activity for use through
    a file we will see later, called `AndroidManifest.xml`. This is necessary for
    the new activity to be able to work in the first place. All things considered,
    the way we did it is probably the quickest.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们一开始没有简单地复制粘贴`MainActivity.java`文件，而是跳过创建新活动的过程？原因在于Android Studio在幕后做了很多事情。首先，它为我们创建布局模板。它还通过一个我们稍后会看到的文件，即`AndroidManifest.xml`，注册了新的活动。这对于新活动能够正常工作至关重要。综合考虑，我们这样做可能是最快的。
- en: 'The code at this stage is exactly the same as the code for the home menu screen.
    We state the package name and import some useful classes provided by Android:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这阶段的代码与主菜单屏幕的代码完全相同。我们声明了包名并导入了Android提供的一些有用类：
- en: '[PRE29]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We create a new activity, this time called `GameActivity`:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的活动，这次称为`GameActivity`：
- en: '[PRE30]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we override the `onCreate` method and use the `setContentView` method
    to set our UI design as the contents of the player''s screen. Currently, however,
    this UI is empty:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重写`onCreate`方法并使用`setContentView`方法将我们的UI设计设置为玩家屏幕的内容。然而，目前这个UI是空的：
- en: '[PRE31]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can now think about the layout of our actual game screen.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以思考实际游戏屏幕的布局了。
- en: Laying out the game screen UI
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局游戏屏幕UI
- en: As we know, our math game will ask questions and offer the player some multiple
    choices to choose answers from. There are lots of extra features we could add,
    such as difficulty levels, high scores, and much more. But for now, let's just
    stick to asking a simple, predefined question and offering a choice of three predefined
    possible answers.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们的数学游戏将提出问题并给玩家提供一些多项选择题作为答案。我们可以添加很多额外功能，例如难度级别、高分等等。但就目前而言，让我们只专注于提出一个简单、预定义的问题并提供三个预定义的可能答案的选择。
- en: 'Keeping the UI design to the bare minimum suggests a layout. Our target UI
    will look somewhat like this:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 将UI设计保持到最简，这表明了一个布局。我们的目标UI将看起来大致如下：
- en: '![Laying out the game screen UI](img/8859OS_03_10.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![布局游戏屏幕UI](img/8859OS_03_10.jpg)'
- en: 'The layout is hopefully self-explanatory, but let''s ensure that we are really
    clear; when we come to building this layout in Android Studio, the section in
    the mock-up that displays **2 x 2** is the question and will be made up of three
    text views (both numbers, and the **=** sign is also a separate view). Finally,
    the three options for the answer are made up of **Button** layout elements. We
    used all of these UI elements in the previous chapter, but this time, as we are
    going to be controlling them using our Java code, there are a few extra things
    we need to do to them. So let''s go through it step by step:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 布局应该是自解释的，但让我们确保我们真正清楚；当我们开始在Android Studio中构建这个布局时，模拟图中显示**2 x 2**的部分是问题，将由三个文本视图（数字和**=**符号也是一个单独的视图）组成。最后，三个选项由**按钮**布局元素组成。我们在上一章中使用了所有这些UI元素，但这次，因为我们将通过Java代码来控制它们，所以我们需要对它们做一些额外的事情。所以让我们一步一步来：
- en: Open the file that will hold our game UI in the editor window. Do this by double-clicking
    on `activity_game.xml`. This is located in our UI `layout` folder, which can be
    found in the project explorer.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开将包含我们的游戏UI的文件。通过双击`activity_game.xml`来完成此操作。这个文件位于我们的UI `layout`文件夹中，可以在项目资源管理器中找到。
- en: Delete the **Hello World** TextView, as it is not required.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Hello World** TextView，因为它不是必需的。
- en: Find the **Large Text** element on the palette. It can be found under the **Widgets**
    section. Drag three elements onto the UI design area and arrange them near the
    top of the design as shown in the next screenshot. It does not have to be exact;
    just ensure that they are in a row and not overlapping, as shown in the following
    screenshot:![Laying out the game screen UI](img/8859OS_03_11.jpg)
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板中找到**大文本**元素。它可以在**小部件**部分找到。将三个元素拖动到UI设计区域，并将它们排列在如图所示的顶部附近。它不需要非常精确；只需确保它们成一行且不重叠，如图所示：![布置游戏屏幕UI](img/8859OS_03_11.jpg)
- en: Notice in the **Component Tree** window that each of the three TextViews has
    been assigned a name automatically by Android Studio. They are **textView** ,
    **textView2**, and **textView3**:![Laying out the game screen UI](img/8859OS_03_12.jpg)
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在**组件树**窗口中，Android Studio已经自动为三个TextView分配了名称。它们是**textView**、**textView2**和**textView3**：![布置游戏屏幕UI](img/8859OS_03_12.jpg)
- en: Android Studio refers to these element names as an **id**. This is an important
    concept that we will be making use of. So to confirm this, select any one of the
    textViews by clicking on its name (id), either in the component tree as shown
    in the preceding screenshot or directly on it in the UI designer shown previously.
    Now look at the **Properties** window and find the **id** property. You might
    need to scroll a little to do this:![Laying out the game screen UI](img/8859OS_03_15.jpg)
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android Studio将这些元素名称称为**id**。这是一个重要的概念，我们将利用它。为了确认这一点，通过点击其名称（id）选择任何一个textView，无论是在先前的截图所示的组件树中，还是在之前的UI设计器中直接点击它。现在查看**属性**窗口，找到**id**属性。你可能需要稍微滚动一下才能找到它：![布置游戏屏幕UI](img/8859OS_03_15.jpg)
- en: Notice that the value for the **id** property is **textView**. It is this `id`
    that we will use to interact with our UI from our Java code. So we want to change
    all the IDs of our TextViews to something useful and easy to remember.
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**id**属性的值为**textView**。正是这个`id`，我们将用它从Java代码中与UI进行交互。因此，我们希望将所有TextView的ID更改为有用且易于记忆的名称。
- en: If you look back at our design, you will see that the UI element with the **textView**
    id is going to hold the number for the first part of our math question. So change
    the id to `textPartA`. Notice the lowercase `t` in `text`, the uppercase `P` in
    `Part`, and the uppercase `A`. You can use any combination of cases and you can
    actually name the IDs anything you like. But just as with naming conventions with
    Java variables, sticking to conventions here will make things less error-prone
    as our program gets more complicated.
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你回顾我们的设计，你会看到具有**textView** ID的UI元素将用于存储数学问题的第一部分数字。因此，将ID更改为`textPartA`。注意`text`中的小写`t`，`Part`中的大写`P`，以及`A`的大写。你可以使用任何组合的大小写，实际上你可以将ID命名为任何你喜欢的名称。但就像Java变量命名约定一样，坚持这里的约定会使程序变得更加复杂时，减少错误的可能性。
- en: Now select **textView2** and change **id** to `textOperator`.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选中**textView2**，将**id**改为`textOperator`。
- en: Select the element currently with id **textView3** and change it to `textPartB`.
    This TextView will hold the later part of our question.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中当前ID为**textView3**的元素，并将其更改为`textPartB`。这个TextView将用于存储问题的后半部分。
- en: Now add another **Large Text** from the palette. Place it after the row of the
    three TextViews that we have just been editing.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从调色板中添加另一个**大文本**。将其放置在我们刚刚编辑的三行TextView之后。
- en: This **Large Text** will simply hold our equals to sign and there is no plan
    to ever change it. So we don't need to interact with it in our Java code. We don't
    even need to concern ourselves with changing the ID or knowing what it is. If
    this situation changed, we could always come back at a later time and edit its
    ID.
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段**大文本**仅仅用于存储等号，并且没有计划对其进行任何更改。因此，我们不需要在Java代码中与之交互。我们甚至不需要关心更改ID或了解它的具体内容。如果这种情况发生了变化，我们可以在稍后时间回来编辑它的ID。
- en: However, this new TextView currently displays **Large Text** and we want it
    to display an equals to sign. So in the **Properties** window, find the **text**
    property and enter the value **=**. We have changed the **text** property before
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, and you might also like to change the text property for
    `textPartA`, `textPartB`, and `textOperator`. This is not absolutely essential
    because we will soon see how we can change it via our Java code; however, if we
    change the **text** property to something more appropriate, then our UI designer
    will look more like it will when the game runs on a real device.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这个新的TextView当前显示的是**大号文本**，我们希望它显示等号。因此，在**属性**窗口中，找到**文本**属性，并输入值**=**。我们之前在[第2章](ch02.html
    "第2章。Android入门")中已经更改过**文本**属性，*Android入门*，你可能还希望更改`textPartA`、`textPartB`和`textOperator`的文本属性。这并不是绝对必要的，因为我们将很快看到如何通过Java代码来更改它；然而，如果我们将**文本**属性更改为更合适的内容，那么我们的UI设计将更接近游戏在真实设备上运行时的样子。
- en: So change the text property of **textPartA** to `2`, **textPartB** to `2`, and
    **textOperator** to `x`. Your UI design and Component tree should now look like
    this:![Laying out the game screen UI](img/8859OS_03_14.jpg)
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将**textPartA**的文本属性更改为`2`，**textPartB**更改为`2`，**textOperator**更改为`x`。你的UI设计和组件树现在应该看起来像这样：![布置游戏屏幕UI](img/8859OS_03_14.jpg)
- en: For the buttons to contain our multiple choice answers, drag three buttons in
    a row, below the **=** sign. Line them up neatly like our target design.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让按钮包含我们的多项选择题答案，将三个按钮排成一行，放在**=**符号下方。整齐地排列，就像我们的目标设计一样。
- en: Now, just as we did for the TextViews, find the **id** properties of each button,
    and from left to right, change the **id** properties to `buttonChoice1`, `buttonChoice2`,
    and `buttonChoice3`.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们对TextView所做的那样，找到每个按钮的**id**属性，并从左到右，将**id**属性更改为`buttonChoice1`、`buttonChoice2`和`buttonChoice3`。
- en: Why not enter some arbitrary numbers for the **text** property of each button
    so that the designer more accurately reflects what our game will look like, just
    as we did for our other TextViews? Again, this is not absolutely essential as
    our Java code will control the button appearance.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不为每个按钮的**文本**属性输入一些任意的数字，以便设计师更准确地反映我们的游戏外观，就像我们对其他TextView所做的那样？再次强调，这并不是绝对必要的，因为我们的Java代码将控制按钮的外观。
- en: We are now actually ready to move on. But you probably agree that the UI elements
    look a little lost. It would look better if the buttons and text were bigger.
    All we need to do is adjust the textSize property for each TextView and for each
    Button. Then, we just need to find the textSize property for each element and
    enter a number with the sp syntax. If you want your design to look just like our
    target design from earlier, enter `70sp` for each of the TextView textSize properties
    and `40sp` for each of the Buttons textSize properties. When you run the game
    on your real device, you might want to come back and adjust the sizes up or down
    a bit. But we have a bit more to do before we can actually try out our game.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在实际上已经准备好继续前进。但你可能也同意，UI元素看起来有点迷失。如果按钮和文本更大一些，看起来会更好。我们只需要调整每个TextView和每个按钮的textSize属性。然后，我们只需要找到每个元素的textSize属性，并输入一个带有sp语法的数字。如果你想你的设计看起来就像我们之前的目标设计，为每个TextView的textSize属性输入`70sp`，为每个按钮的textSize属性输入`40sp`。当你在你真实设备上运行游戏时，你可能想要回来调整大小上下一点。但在我们真正尝试我们的游戏之前，我们还有更多的事情要做。
- en: Save the project and then we can move on.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目后，我们就可以继续下一步了。
- en: As before, we have built our UI. This time, however, we have given all the important
    parts of our UI a unique, useful, and easy to identify ID. As we will see we are
    now able to communicate with our UI through our Java code.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们已经构建了我们的用户界面。然而，这次，我们给UI的所有重要部分都分配了一个独特、有用且易于识别的ID。正如我们将看到的，我们现在能够通过Java代码与我们的UI进行通信。
- en: Coding a question in Java
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中编写一个问题
- en: With our current knowledge of Java, we are not yet able to complete our math
    game but we can make a significant start. We will look at how we can ask the player
    a question and offer them some multiple choice answers (one correct and two incorrect).
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前对Java的了解，我们还没有能力完成我们的数学游戏，但我们可以迈出重要的一步。我们将探讨如何向玩家提问并提供一些多项选择题答案（一个正确答案和两个错误答案）。
- en: 'At this stage, we know enough of Java to declare and initialize some variables
    that will hold the parts of our question. For example, if we want to ask the times
    tables question *2 x 2*, we could have the following variable initializations
    to hold the values for each part of the question:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经有足够的Java知识来声明和初始化一些变量，这些变量将存储问题的各个部分。例如，如果我们想提出乘法表问题*2 x 2*，我们可以有以下的变量初始化来存储问题的每个部分的值：
- en: '[PRE32]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code declares and initializes two variables of the `int` type,
    each to the value of 2\. We use `int` because we will not be dealing with any
    decimal fractions. Remember that the variable names are arbitrary and were just
    chosen because they seemed appropriate. Clearly, any math game worth downloading
    is going to need to ask more varied and advanced questions than *2 x 2*, but it
    is a start.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明并初始化了两个整型变量，每个变量的值都为2。我们使用`int`类型，因为我们不会处理任何小数。记住，变量名是任意的，只是因为它们看起来合适。显然，任何值得下载的数学游戏都需要提出更多样化和高级的问题，而不仅仅是*2
    x 2*，但这是一个开始。
- en: 'Now we know that our math game will offer multiple choices as answers. So,
    we need a variable for the correct answer and two variables for two incorrect
    answers. Take a look at these combined declarations and initializations:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的数学游戏将提供多个答案选项。因此，我们需要一个变量来存储正确答案，以及两个变量来存储两个错误答案。看看以下合并的声明和初始化：
- en: '[PRE33]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the initialization of the variables for the wrong answers depends
    on the value of the correct answer, and the variables for the wrong answers are
    initialized after initializing the `correctAnswer` variable.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误答案变量的初始化依赖于正确答案的值，并且错误答案变量是在`correctAnswer`变量初始化之后初始化的。
- en: 'Now we need to put these values, held in our variables, into the appropriate
    elements on our UI. The question variables (`partA` and `partB`) need to be displayed
    in our UI elements, `textPartA` and `textPartB`, and the answer variables (`correctAnswer`,
    `wrongAnswer1`, and `wrongAnswer2`) need to be displayed in our UI elements with
    the following IDs: `buttonChoice1`, `buttonChoice2`, and `buttonChoice3`. We will
    see how we do this in the next step-by-step tutorial. We will also implement the
    variable declaration and initialization code that we discussed a moment ago:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些存储在变量中的值放入我们的UI上适当的位置。问题变量（`partA`和`partB`）需要在UI元素`textPartA`和`textPartB`中显示，而答案变量（`correctAnswer`、`wrongAnswer1`和`wrongAnswer2`）需要在具有以下ID的UI元素中显示：`buttonChoice1`、`buttonChoice2`和`buttonChoice3`。我们将在下一个逐步教程中看到如何做到这一点。我们还将实现之前讨论过的变量声明和初始化代码：
- en: First, open `GameActivity.java` in the editor window. Remember that you can
    do this by double-clicking on **GameActivity** in our `java` folder or clicking
    on its tab above the editor window if `GameActivity.java` is already open.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在编辑器窗口中打开`GameActivity.java`。记住，您可以通过在`java`文件夹中双击**GameActivity**或点击编辑器窗口上方的标签来实现这一点，如果`GameActivity.java`已经打开。
- en: 'All of our code will go into the `onCreate` method. It will go after the `setContentView(R.layout.activity_game);`
    line but before the closing curly brace `}` of the `onCreate` method. Perhaps,
    it''s a good idea to leave a blank line for clarity and a nice explanatory comment
    as shown in the following code. We can see the entire `onCreate` method as it
    stands after the latest amendments. The parts in bold are what you need to add.
    Feel free to add helpful comments like mine if you wish:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的代码都将放入`onCreate`方法中。它将放在`setContentView(R.layout.activity_game);`行之后，但在`onCreate`方法的闭合花括号`}`之前。也许，留一个空白行以增加清晰度，并添加一个像以下代码中那样的良好解释性注释是个好主意。我们可以看到经过最新修改后的整个`onCreate`方法。粗体部分是需要添加的内容。如果您愿意，可以添加像我一样的有帮助的注释：
- en: '[PRE34]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we need to add the values contained within the variables to the `TextView`
    and `Button` of our UI. But first, we need to get access to the UI elements we
    created. We do that by creating a variable of the appropriate class and linking
    it via the ID property of the appropriate UI element. We already know the class
    of our UI elements: `TextView` and `Button`. Here is the code that creates our
    special class variables for each of the necessary UI elements. Take a close look
    at the code, but don''t worry if you don''t understand all of it now. We will
    dissect the code in detail once everything is working. Enter the code immediately
    after the code entered in the previous step. You can leave a blank line for clarity
    if you wish. Just before you proceed, note that at two points while typing in
    this code, you will be prompted to import another class. Go ahead and do so on
    both occasions:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将变量中包含的值添加到我们的UI的`TextView`和`Button`中。但在做之前，我们需要获取我们创建的UI元素。我们通过创建适当类的一个变量，并通过适当UI元素的ID属性来链接它来实现这一点。我们已经知道我们的UI元素的类：`TextView`和`Button`。以下是创建我们每个必要UI元素的特殊类变量的代码。仔细查看代码，但如果你现在不完全理解也没有关系。一旦一切正常工作，我们将详细分析代码。在输入上一步代码之后立即输入代码。如果你愿意，可以留一个空白行以增加清晰度。在你继续之前，请注意，在编写此代码时，你将在两个地方被提示导入另一个类。请在这两个场合都进行导入：
- en: '[PRE35]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, if you read the multiline comment, you will see that
    I used the term **object**. When we create a variable type based on a class, we
    call it an object. Once we have an object of a class, we can do anything that
    that class was designed to do. This is very powerful and is explored thoroughly
    in [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP
    – Using Other People's Hard Work*.
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你阅读了多行注释，你会看到我使用了术语**对象**。当我们基于一个类创建一个变量类型时，我们称之为对象。一旦我们有一个类的对象，我们就可以做该类设计能做的任何事情。这是非常强大的，这在[第6章](ch06.html
    "第6章。面向对象编程 – 利用他人的辛勤工作") *面向对象编程 – 利用他人的辛勤工作*中得到了充分的探讨。
- en: 'Now we have five new objects linked to the elements of our UI that we need
    to manipulate. What precisely are we going to do with them? We need to display
    the values of our variables in the text of the UI elements. We can use the objects
    we just created combined with a method provided by the class, and use our variables
    as values for that text. As usual, we will dissect this code further at the end
    of this tutorial. Here is the code to enter directly after the code in the previous
    step. Try and work out what is going on before we look at it together:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有五个新的对象与我们需要操作的UI元素相关联。我们究竟打算如何使用它们呢？我们需要在UI元素的文本中显示变量的值。我们可以使用我们刚刚创建的对象以及由类提供的方法，并将我们的变量作为文本的值。像往常一样，我们将在本教程的末尾进一步分析这段代码。以下是紧接上一步代码之后的代码。在我们一起查看之前，试着弄清楚正在发生什么：
- en: '[PRE36]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save your work.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的工作。
- en: If you play with the assignment values for `partA` and `partB`, you can make
    them whatever you like and the game adjusts the answers accordingly. Obviously,
    we shouldn't need to reprogram our game each time we want a new question and we
    will solve that problem soon. All we need to do now is link the game section we
    have just made to the start screen menu. We will do that in the next tutorial.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调整`partA`和`partB`的赋值，你可以将它们设置为任何你喜欢的值，游戏会相应地调整答案。显然，我们不应该每次想要新的问题都需要重新编程我们的游戏，我们很快就会解决这个问题。我们现在需要做的是将我们刚刚创建的游戏部分链接到起始屏幕菜单。我们将在下一教程中这样做。
- en: Now let's explore the trickier and newer parts of our code in more detail.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更详细地探索我们代码中更复杂和较新的部分。
- en: 'In step 2, we declared and initialized the variables required so far:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明并初始化了迄今为止所需的变量：
- en: '[PRE37]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then in step 3, we got a reference to our UI design through our Java code.
    For the TextViews, it was done like this:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第3步中，我们通过Java代码获取了我们的UI设计参考。对于TextViews，操作如下：
- en: '[PRE38]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For each of the buttons, a reference to our UI design was obtained like this:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按钮，我们通过以下方式获取了我们的UI设计参考：
- en: '[PRE39]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In step 4, we did something new. We used a the `setText` method to show the
    values of our variables on our UI elements (`TextView` and `Button`) to the player.
    Let's break down one line completely to see how it works. Here is the code that
    shows the `correctAnswer` variable being displayed on `buttonObjectChoice1`.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们做了些新的事情。我们使用了`setText`方法来在我们的UI元素（`TextView`和`Button`）上向玩家显示变量的值。让我们逐行分析，看看它是如何工作的。以下是显示`correctAnswer`变量在`buttonObjectChoice1`上显示的代码。
- en: '[PRE40]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By typing `buttonObjectChoice1` and adding a period, as shown in the following
    line of code, we have access to all the preprogrammed methods of that object''s
    class type that are provided by Android:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在以下代码行中输入`buttonObjectChoice1`并添加一个点，我们可以访问Android提供的该对象类类型的所有预编程方法：
- en: '[PRE41]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The power of Button and the Android API**'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**按钮和Android API的力量**'
- en: There are actually lots of methods that we can perform on an object of the Button
    type. If you are feeling brave, try this to get a feeling of just how much functionality
    there is in Android.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有很多方法可以用于按钮类型的对象。如果你感到勇敢，尝试以下操作，以了解Android中功能性的丰富程度。
- en: 'Type the following code:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE42]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Be sure to type the period on the end. Android Studio will pop up a list of
    possible methods to use on this object. Scroll through the list and get a feel
    of the number and variety of options:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要在末尾输入句号。Android Studio会弹出一个列表，显示可以在此对象上使用的可能方法。滚动列表，感受一下选项的数量和多样性：
- en: '![Coding a question in Java](img/8859OS_03_09.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中编写一个问题](img/8859OS_03_09.jpg)'
- en: If a mere button can do all of this, think of the possibilities for our games
    once we have mastered all the classes contained in Android. A collection of classes
    designed to be used by others is collectively known as an **Application Programming
    Interface(API)**. Welcome to the Android API!
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个普通的按钮可以做到这一切，想想当我们掌握了Android中包含的所有类之后，我们的游戏会有多少可能性。设计供他人使用的类集合统称为**应用程序编程接口(API**)。欢迎来到Android
    API！
- en: 'In this case, we just want to set the button''s text. So, we use `setText`
    and concatenate the value stored in our `correctAnswer` variable to the end of
    an empty string, like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只想设置按钮的文本。因此，我们使用`setText`并将存储在我们`correctAnswer`变量中的值连接到空字符串的末尾，如下所示：
- en: '[PRE43]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We do this for each of the UI elements we require to show our variables.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为需要显示的每个UI元素都这样做。
- en: Tip
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Playing with autocomplete**'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用自动完成功能**'
- en: 'If you tried the previous tip, *The power of Button and the Android API*, and
    explored the methods available for objects of the Button type, you will already
    have some insight into autocomplete. Note that as you type, Android Studio is
    constantly making suggestions for what you might like to type next. If you pay
    attention to this, you can save a lot of time. Simply select the correct code
    completion statement that is suggested and press *Enter*. You can even see how
    much time you saved by selecting **Help** | **Productivity Guide** from the menu
    bar. Here you will see statistics for every aspect of code completion and more.
    Here are a few entries from mine:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试了之前的提示**按钮和Android API的力量**，并探索了按钮类型对象的可用方法，你将已经对自动完成有一些了解。请注意，当你输入时，Android
    Studio会不断为你可能想要输入的下一个内容提供建议。如果你注意这一点，可以节省很多时间。只需选择建议的正确代码完成语句并按*Enter*键。你甚至可以通过从菜单栏选择**帮助**
    | **生产力指南**来查看你节省了多少时间。在这里，你可以看到代码完成每个方面的统计数据以及更多内容。以下是我的一些条目：
- en: '![Coding a question in Java](img/8859OS_03_08.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中编写一个问题](img/8859OS_03_08.jpg)'
- en: As you can see, if you get used to using shortcuts early on, you can save a
    lot of time in the long run.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您早期就习惯了使用快捷键，从长远来看可以节省很多时间。
- en: Linking our game from the main menu
  id: totrans-696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的游戏链接到主菜单
- en: 'At the moment, if we run the app, we have no way for the player to actually
    arrive at our new game activity. We want the game activity to run when the player
    clicks on the **Play** button on the main `MainActivity` UI. Here is what we need
    to do to make that happen:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们运行应用程序，我们没有让玩家实际到达我们的新游戏活动的方法。我们希望当玩家点击主`MainActivity` UI上的**Play**按钮时，游戏活动能够运行。为了实现这一点，我们需要做以下事情：
- en: Open the file `activity_main.xml`, either by double-clicking on it in the Project
    Explorer or by clicking on its tab in the editor window.
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`activity_main.xml`，可以通过在项目资源管理器中双击它，或者在编辑器窗口中点击其标签来实现。
- en: Now, just like we did when building the game UI, assign an ID to the **Play**
    button. As a reminder, click on the **Play** button either on the UI design or
    in the component tree. Find the **id** property in the **Properties** window.
    Assign the `buttonPlay` value to it. We can now make this button do stuff by referring
    to it in our Java code.
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们在构建游戏UI时做的那样，为**Play**按钮分配一个ID。作为提醒，在UI设计或组件树中点击**Play**按钮。在**属性**窗口中找到**id**属性。将其分配给`buttonPlay`。现在我们可以通过在我们的Java代码中引用它来让这个按钮执行操作。
- en: Open the file `MainActivity.java`, either by double-clicking on it in the Project
    Explorer or clicking on its tab in the editor window.
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目资源管理器中双击或点击编辑器窗口中的标签来打开`MainActivity.java`文件。
- en: 'In our `onCreate` method, just after the line where we `setContentView`, add
    the following highlighted line of code:'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`onCreate`方法中，就在我们`setContentView`的行之后，添加以下突出显示的代码行：
- en: '[PRE44]'
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will dissect this code in detail once we have got this working. Basically
    we are making a connection to the **Play** button by creating a reference variable
    to a `Button` object. Notice that both words are highlighted in red indicating
    an error. Just as before, we need to import the Button class to make this code
    work. Use the *Alt* + *Enter* keyboard combination. Now click on **Import class**
    from the popped-up list of options. This will automatically add the required import
    directive at the top of our `MainActivity.java` file.
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们使这个代码工作，我们就会详细剖析它。基本上，我们通过创建一个指向`Button`对象的引用变量来与**播放**按钮建立连接。注意，这两个词都被用红色突出显示，表示有错误。就像之前一样，我们需要导入`Button`类来使代码工作。使用*Alt*
    + *Enter*键盘组合。现在点击弹出的选项列表中的**导入类**。这将在我们的`MainActivity.java`文件顶部自动添加所需的导入指令。
- en: 'Now for something new. We will give the button the ability to *listen* to the
    user clicking on it. Type this immediately after the last line of code we entered:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来点新的。我们将给按钮添加一个能力，使其能够*监听*用户对其的点击。在我们输入的最后一行代码之后立即输入以下内容：
- en: '[PRE45]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. This
    introduces another Java feature that will be more thoroughly explored in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People''s Hard Work"),*OOP – Using
    Other People''s Hard Work*. Setting that aside, we need to make a modification
    to our code now in order to allow the use of an interface that is a special code
    element that allows us to add a functionality, such as listening for button clicks.
    Edit the line as follows. When prompted to import another class, click on **OK**:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到`this`关键字被用红色突出显示，表示有错误。这引入了Java的另一个特性，我们将在[第6章](ch06.html "第6章。面向对象编程 –
    使用他人的辛勤工作"),*面向对象编程 – 使用他人的辛勤工作*中更详细地探讨。暂且不谈这个，我们现在需要修改我们的代码，以便使用一个特殊的代码元素，即接口，它允许我们添加功能，例如监听按钮点击。按照以下方式编辑这一行。当提示导入另一个类时，点击**确定**：
- en: '[PRE46]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: to
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: to
- en: '[PRE47]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we have the entire line underlined in red. This indicates an error but it's
    where we should be at this point. We mentioned that by adding `implements View.OnClickListener`,
    we have implemented an interface. We can think of this like a class that we can
    use but with extra rules. The rules of the `OnClickListener` interface state that
    we *must* implement/use one of its methods. Notice that until now, we have optionally
    overridden/used methods as and when they have suited us. If we wish to use the
    functionality this interface provides, namely listening for button presses, then
    we have to add/implement the `onClick` method.
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们整行都被红色下划线标出。这表示有错误，但这是我们在这个阶段应该所在的位置。我们提到，通过添加`implements View.OnClickListener`，我们已经实现了一个接口。我们可以将其视为一个我们可以使用的类，但带有额外的规则。`OnClickListener`接口的规则指出，我们必须实现/使用其方法之一。注意，到目前为止，我们已经根据需要选择性地覆盖/使用方法。如果我们希望使用这个接口提供的功能，即监听按钮按下，那么我们必须添加/实现`onClick`方法。
- en: 'This is how we do it. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty and it doesn''t do anything, but an empty method is enough to
    comply with the rules of the `OnClickListener` interface, and the red line indicating
    that our code has an error has gone. The syntax of these methods we have been
    using, as promised, will be explained in the next chapter when we start to write
    our own methods. Make sure that you type the following code, outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们这样做的方式。注意开括号`{`和闭括号`}`。这些表示方法的开始和结束。注意，这个方法是空的，它不做任何事情，但一个空的方法就足以符合`OnClickListener`接口的规则，并且表示我们的代码有错误的红色线条已经消失了。我们一直在使用的这些方法的语法，正如承诺的那样，将在我们开始编写自己的方法时在第6章中解释。确保你在`onCreate`方法的闭括号`}`之外、`MainActivity`类的闭括号`}`之内输入以下代码：
- en: '[PRE48]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that we have an empty line between `{` and `}` of the `onClick` method.
    We can now add code in here to make the button actually do something. Type the
    following highlighted code between `{` and `}` of `onClick`:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在`onClick`方法的`{`和`}`之间有一个空行。我们现在可以在这里添加代码，使按钮真正做些事情。在`onClick`的`{`和`}`之间输入以下突出显示的代码：
- en: '[PRE49]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: OK, so that code is a bit of a mouthful to comprehend all at once. See if you
    can guess what is happening. The clue is in the method named `startActivity` and
    the hopefully familiar term, `GameActivity`. Notice that we are assigning something
    to `i`. We will quickly get our app working and then diagnose the code in full.
    Its understanding will be complete when we explore how classes work in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，所以这段代码一次性理解起来有点困难。看看你是否能猜出发生了什么。线索在名为`startActivity`的方法和希望熟悉的术语`GameActivity`中。注意，我们在将某个东西分配给`i`。我们将快速使应用程序工作，然后全面诊断代码。当我们探索第6章[类的工作方式](ch06.html
    "第6章。面向对象编程 - 使用他人的辛勤工作")时，理解将完整。
- en: 'Notice that we have an error: all instances of the word `Intent` are red. We
    can solve this by importing the classes required to make `Intent` work. As before
    press *Alt* + *Enter*.'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们有一个错误：单词`Intent`的所有实例都是红色的。我们可以通过导入使`Intent`工作所需的类来解决此问题。像以前一样，按*Alt* +
    *Enter*。
- en: Run the game in the emulator or on your device.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或您的设备上运行游戏。
- en: 'Our app will now work. This is what the new game screen looks like after pressing
    **Play** on the menu screen:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在将正常工作。这是在菜单屏幕上按下**播放**后新游戏屏幕的外观：
- en: '![Linking our game from the main menu](img/8859OS_03_20.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![从主菜单链接我们的游戏](img/8859OS_03_20.jpg)'
- en: 'Almost every part of our code has changed a little and we have added a lot
    to it as well. Let''s go over the contents of `MainActivity.java` and look at
    it line by line. For context, here it is in full:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎我们代码的每一部分都有所改变，我们也添加了很多内容。让我们逐行查看`MainActivity.java`的内容。为了提供上下文，以下是它的完整内容：
- en: '[PRE50]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have seen much of this code before, but let''s just go over it a chunk at
    a time before moving on so that it is absolutely clear. The code works like this:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了很多这样的代码，但在继续之前，让我们逐块地浏览它，以确保它绝对清晰。代码的工作方式如下：
- en: '[PRE51]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You would probably remember that this first block of code defines what our package
    is called and makes available all the Android API stuff we need for Button, TextView,
    and Activity.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这个代码块定义了我们的包名，并提供了我们为按钮、文本视图和活动所需的全部Android API功能。
- en: 'From our `MainActivity.java` file, we have this:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`MainActivity.java`文件中，我们有以下内容：
- en: '[PRE52]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our `MainActivity` declaration with our new bit of code implements `View.OnClickListener`
    that gives us the ability to detect button clicks.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新代码声明的`MainActivity`实现了`View.OnClickListener`接口，这使我们能够检测按钮点击。
- en: 'Next in our code is this:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中接下来是：
- en: '[PRE53]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This previous bit of code hasn't changed since [Chapter 2](ch02.html "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*. It is at the start of
    our `onCreate` method where we first ask the hidden code of `onCreate` to do its
    stuff using `super.onCreate(savedInstanceState);`. Then we set our UI to the screen
    with `setContentView(R.layout.activity_main);`.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这段之前的代码自[第2章](ch02.html "第2章。Android入门")以来没有变化，即“Android入门”。它位于我们的`onCreate`方法的开头，我们首先使用`super.onCreate(savedInstanceState);`调用`onCreate`的隐藏代码来执行其功能。然后我们使用`setContentView(R.layout.activity_main);`将我们的UI设置到屏幕上。
- en: 'Next, we get a reference to our button with an ID of `buttonPlay`:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过ID为`buttonPlay`获取我们的按钮引用：
- en: '[PRE54]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, our `onClick` method uses the `Intent` class to send the player to
    our `GameActivity` class and the related UI when the user clicks on the **Play**
    button:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`onClick`方法使用`Intent`类在用户点击**播放**按钮时将玩家发送到我们的`GameActivity`类和相关UI：
- en: '[PRE55]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you run the app, you will notice that we can now click on the **Play** button
    and our math game will ask us a question. Of course, we can't answer it yet. Although
    we have very briefly looked at how to deal with button presses, we need to learn
    more of Java in order to intelligently react to them. We will also reveal how
    to write code to handle presses from several buttons. This will be necessary to
    receive input from our multiple-choice-centric `game_activity` UI.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行应用程序，您会注意到我们现在可以点击**播放**按钮，我们的数学游戏会向我们提问。当然，我们目前还不能回答它。尽管我们非常简要地了解了如何处理按钮点击，但我们需要学习更多的Java知识，以便智能地响应它们。我们还将揭示如何编写处理多个按钮点击的代码。这将是接收来自以多选题为中心的`game_activity`
    UI输入所必需的。
- en: Decisions in Java
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的决策
- en: We can now summon enough of Java prowess to ask a question but a real math game
    must obviously do much more than this. We need to capture the player's answer,
    and we are nearly there with that—we can detect button presses. From there, we
    need to be able to **decide** whether their answer is right or wrong. Then, based
    on this decision, we have to **choose** an appropriate course of action.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以召唤足够的 Java 能力来提问，但一个真正的数学游戏显然必须做更多的事情。我们需要捕捉玩家的答案，我们几乎做到了——我们可以检测按钮的按下。从那里，我们需要能够**决定**他们的答案是对是错。然后，基于这个决定，我们必须**选择**适当的行动方案。
- en: Let's leave the math game aside for now and look at how Java might help us by
    learning some more fundamentals and syntax of the Java language.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时把数学游戏放在一边，看看 Java 如何通过学习更多 Java 语言的基础知识和语法来帮助我们。
- en: More operators
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多运算符
- en: 'Let''s look at some more operators: we can already add (+), take away (-),
    multiply (*), divide (/), assign (=), increment (++), compare (==), and decrement
    (--) with operators. Let''s introduce some more super-useful operators, and then
    we will go straight to actually understanding how to use them in Java.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更多的运算符：我们已经有加法（+）、减法（-）、乘法（*）、除法（/）、赋值（=）、递增（++）、比较（==）和递减（--）等运算符了。现在让我们介绍一些更超级有用的运算符，然后我们将直接了解如何在
    Java 中实际使用它们。
- en: Tip
  id: totrans-741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't worry about memorizing every operator given here. Glance at them and their
    explanations and then move quickly on to the next section. There, we will put
    some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators plain from the start. The list will also be more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows it.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心记住这里给出的每一个运算符。快速浏览它们及其解释，然后迅速进入下一节。在那里，我们将使用一些运算符，随着我们看到一些它们能做什么的例子，它们将变得更加清晰。这里将它们列出来，只是为了从一开始就清楚地展示运算符的多样性和范围。列表也将更方便在随后的实现讨论中参考。
- en: '**==**: This is a comparison operator we saw this very briefly before. It tests
    for equality and is either true or false. An expression like `(10 == 9);`, for
    example, is false.'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**==**: 这是我们在之前非常简短地提到过的比较运算符。它用来测试相等性，结果要么为真要么为假。例如，表达式 `(10 == 9);` 是错误的。'
- en: '**!**: The logical NOT operator. The expression, `! (2+2==5)`.`)`, is true
    because 2+2 is NOT 5.'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**!**: 逻辑非运算符。表达式 `! (2+2==5)`.`)` 是正确的，因为 2+2 不等于 5。'
- en: '**!=**: This is another comparison operator, which tests if something is NOT
    equal. For example, the expression, `(10 != 9);)`, is true, that is, 10 is not
    equal to 9.'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**!=**: 这是另一个比较运算符，用来测试某个值是否不等于另一个值。例如，表达式 `(10 != 9);` 是正确的，也就是说 10 不等于 9。'
- en: '**>**: This is another comparison operator, which tests if something is greater
    than something else. The expression, `(10 > 9);)`, is true. There are a few more
    comparison operators as well.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>**: 这是另一个比较运算符，用来测试某个值是否大于另一个值。表达式 `(10 > 9);` 是正确的。还有一些其他的比较运算符。'
- en: '**<**: You guessed it. This tests whether the value to the left is less than
    the value to the right or not. The expression, `(10 < 9);`, is false.'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<**: 你猜对了。这个运算符用来测试左边的值是否小于右边的值。表达式 `(10 < 9);` 是错误的。'
- en: '**>=**: This operator tests whether one value is greater than or equal to the
    other, and if either is true, the result is true. For example, the expression,
    `(10 >= 9);`, is true. The expression, `(10 >= 10);`, is also true.'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>=**: 这个运算符用来测试一个值是否大于或等于另一个值，如果任一条件为真，结果为真。例如，表达式 `(10 >= 9);` 是正确的。表达式
    `(10 >= 10);` 也是正确的。'
- en: '**<=**: Like the preceding operator, this operator tests for two conditions
    but this time, less than and equal to. The expression, `(10 <= 9);`, is false.
    The expression, `(10 <= 10);`, is true.'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<=**: 和前面的运算符类似，这个运算符测试两个条件，但这次是小于或等于。表达式 `(10 <= 9);` 是错误的。表达式 `(10 <= 10);`
    是正确的。'
- en: '**&&**: This operator is known as logical AND. It tests two or more separate
    parts of an expression and all parts must be true in order for the result to be
    true. Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression, `((10 > 9) && (10 < 11));`, is true because
    both parts are true. The expression, `((10 > 9) && (10 < 9));`, is false because
    only one part of the expression is true and the other is false.'
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**&&**: 这个操作符被称为逻辑与。它测试表达式中的两个或多个独立部分，并且所有部分都必须为真，结果才为真。逻辑与通常与其他操作符结合使用，以构建更复杂的测试。表达式
    `((10 > 9) && (10 < 11));` 为真，因为两部分都是真的。表达式 `((10 > 9) && (10 < 9));` 为假，因为表达式中只有一部分为真，另一部分为假。'
- en: '**||**: This operator is called logical OR. It is just like logical AND except
    that only one of two or more parts of an expression need to be true for the expression
    to be true. Let''s look at the last example we used but replace the && sign with
    ||. The expression, `((10 > 9) || (10 < 9));`, is now true because one part of
    the expression is true.'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**||**: 这个操作符被称为逻辑或。它与逻辑与类似，只是表达式中的两个或多个部分中只需要一个为真，表达式就为真。让我们看看我们使用的最后一个例子，但将
    && 符号替换为 ||。表达式 `((10 > 9) || (10 < 9));` 现在为真，因为表达式的一部分为真。'
- en: All of these operators are virtually useless without a way of properly using
    them to make real decisions that affect real variables and code. Let's look at
    how to make decisions in Java.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作符在没有适当使用它们来做出影响真实变量和代码的实际决策的情况下几乎毫无用处。让我们看看如何在Java中做出决策。
- en: Decision 1 – If they come over the bridge, shoot them
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策1 – 如果他们过桥，就射击他们
- en: As we saw, operators serve hardly any purpose on their own but it was probably
    useful to see just a part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，操作符本身几乎没有用途，但看到我们可用的广泛而多样的范围的一部分可能是有用的。现在，当我们考虑使用最常用的操作符 `==` 时，我们可以开始看到操作符提供的强大而精细的控制。
- en: Let's make the previous examples less abstract using the Java `if` keyword and
    a few conditional operators with a fun story and some code.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个有趣的故事和一些代码，使用Java的 `if` 关键字和一些条件操作符来使前面的例子更具体。
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 上尉奄奄一息，知道他剩下的下属经验不足，他决定在他死后编写一个Java程序来传达他的最后命令。部队必须守住桥的一侧，等待增援。
- en: 'The first command the captain wants to make sure his troops understand is this:
    If they come over the bridge, shoot them.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 上尉想要确保他的部队理解的第一条命令是：如果他们过桥，就射击他们。
- en: So how do we simulate this situation in Java? We need a Boolean variable `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Java中模拟这种情况？我们需要一个布尔变量 `isComingOverBridge`。接下来的代码段假设 `isComingOverBridge`
    变量已经被声明并初始化。
- en: 'We can then use it like this:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：
- en: '[PRE56]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will run. If not, the program continues after the `if` block
    without running it.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `isComingOverBridge` 布尔值为真，则在大括号内的代码将执行。如果不是，程序将在 `if` 块之后继续执行，而不运行它。
- en: Decision 2 – Else, do this
  id: totrans-762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策2 – 否则，这样做
- en: The captain also wants to tell his troops what to do (stay put) if the enemy
    is not coming over the bridge.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 上尉还想要告诉他的部队（原地待命），如果敌人没有过桥。
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something and the `if` block does not evaluate to true, we can use `else`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们引入另一个Java关键字 `else`。当我们想要明确执行某些操作，而 `if` 块不评估为真时，我们可以使用 `else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we use `else`:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人没有过桥，告诉部队原地待命，我们使用 `else`：
- en: '[PRE57]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge and has more troops? His squad will be
    overrun. So, he came up with this code (we''ll use some variables as well this
    time):'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 上尉随后意识到问题并不像他最初想的那么简单。如果敌人过桥并且有更多的部队怎么办？他的小队将被包围。因此，他想出了以下代码（这次我们也会使用一些变量）：
- en: '[PRE58]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The Java code needed was obvious. Using the `wavingWhiteFlag`
    Boolean variable he wrote this test:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，船长的最后一个担忧是，如果敌人挥舞着白旗投降并立即被屠杀，那么他的手下最终会成为战争罪犯。所需的Java代码很明显。使用他写的`wavingWhiteFlag`布尔变量，他编写了这个测试：
- en: '[PRE59]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changing the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 但将这段代码放在哪里并不那么清楚。最后，船长选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试改为逻辑非，如下所示：
- en: '[PRE60]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create even deeper decisions.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以将`if`和`else`语句嵌套在一起，以创建更深层次的决策。
- en: We could go on making more and more complicated decisions but what we have seen
    is more than sufficient as an introduction. Take the time to reread this if anything
    is unclear. Who knows, there might even be a tricky logic question in the self-test
    at the end of the chapter. It is also important to point out that very often,
    there are two or more ways to arrive at the solution. The *right* way will usually
    be the way that solves the problem in the clearest and simplest manner.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续做出越来越复杂的决策，但我们所看到的已经足够作为入门。如果有任何不清楚的地方，请花时间重新阅读。谁知道呢，也许在章节末尾的自我测试中甚至有一个棘手的逻辑问题。重要的是要指出，通常情况下，到达解决方案的方法有两条或更多。*正确*的方法通常是以最清晰、最简单的方式解决问题的方法。
- en: Switching to make decisions
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`switch`进行决策
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了将Java运算符与`if`和`else`语句结合使用的广泛且几乎无限的组合可能性。但有时Java中的决策可以通过其他方式更好地做出。
- en: When we have to make a decision based on a clear list of possibilities that
    doesn't involve complex combinations, then **switch** is usually the way to go.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须根据一个清晰的、不涉及复杂组合的可能性列表做出决策时，通常使用**switch**是最佳选择。
- en: 'We start a `switch` decision like this:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样开始一个`switch`决策：
- en: '[PRE61]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the previous example, an argument could be an expression or a variable.
    Then within the curly braces, we can make decisions based on the argument with
    case and break elements:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，参数可以是一个表达式或一个变量。然后在大括号内，我们可以根据参数使用case和break元素来做出决策：
- en: '[PRE62]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can see that in the previous example, each case states a possible result
    and each break denotes the end of that case as well as the point at which no further
    case statements should be evaluated. The first break encountered takes us out
    of the switch block to proceed with the next line of code.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在上一个示例中，每个case都声明了一个可能的结果，每个break都表示该case的结束，以及不应再评估后续case语句的点。第一个遇到的break将我们带出switch块，继续执行下一行代码。
- en: 'We can also use **default** without a value to run some code if none of the
    case statements evaluate to true, like this:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用不带值的**default**来运行一些代码，如果没有任何case语句评估为true，如下所示：
- en: '[PRE63]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Supposing we are writing an old-fashioned text adventure game—the kind of game
    where the player types commands such as `"Go East"`, `"Go West"`, `"Take Sword"`,
    and so on. In this case, switch could handle that situation like this example
    code and we could use `default` to handle the case of the player typing a command
    that is not specifically handled:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个老式的文字冒险游戏——这类游戏中玩家输入命令，如`"Go East"`、`"Go West"`、`"Take Sword"`等。在这种情况下，switch可以像以下示例代码那样处理这种情况，并且我们可以使用`default`来处理玩家输入的未特别处理的命令的情况：
- en: '[PRE64]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the next section, we will use `switch` so that our `onClick` method can handle
    the different multiple-choice buttons of our math game.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`switch`来确保我们的`onClick`方法能够处理数学游戏中的不同多选题按钮。
- en: Tip
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Java has even more operators than we have covered here. We have looked at all
    the operators we are going to need in this book and probably the most used in
    general. If you want the complete lowdown on operators, take a look at the official
    Java documentation at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: Java有比我们这里涵盖的还要多的运算符。我们已经看到了这本书中将要需要的所有运算符，以及最常用的运算符。如果你想了解运算符的完整信息，请查看官方Java文档[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)。
- en: Math game – getting and checking the answer
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学游戏 – 获取和检查答案
- en: Here we will detect the right or wrong answer and provide a pop-up message to
    the player. Our Java is getting quite good now, so let's dive in and add these
    features. I will explain things as we go and then, as usual, dissect the code
    thoroughly at the end.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检测正确或错误的答案，并向玩家提供弹出消息。我们的 Java 代码现在相当不错了，所以让我们深入其中并添加这些功能。我会边走边解释，然后在结束时，像往常一样，彻底剖析代码。
- en: 'The already completed code is in the download bundle, in the following files
    that correspond to the filenames we will create/autogenerate in Android Studio
    in a moment:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 已经完成的代码在下载包中，在以下文件中，这些文件对应于我们将在 Android Studio 中创建/自动生成的文件名：
- en: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
- en: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
- en: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
- en: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
- en: As usual, I recommend following this tutorial step by step to see how we can
    create all of the code for ourselves.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我建议您一步一步地跟随这个教程，看看我们如何自己创建所有的代码。
- en: Open the `GameActivity.java` file visible in the editor window.
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器窗口中可见的 `GameActivity.java` 文件。
- en: 'Now we need to add the click detection functionality to our `GameActivity`,
    just as we did for our `MainActivity`. However, we will go a little further than
    the last time. So let''s do it step by step as if it is totally new. Once again,
    we will give the buttons the ability to *listen* to the user clicking on them.
    Type this immediately after the last line of code we entered in the `onCreate`
    method but before the closing `}`. This time of course, we need to add some code
    to listen to three buttons:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要给 `GameActivity` 添加点击检测功能，就像我们为 `MainActivity` 做的那样。然而，这次我们会做得更深入一些。所以让我们一步一步地做，就像它是全新的。再一次，我们将给按钮添加用户点击它们的能力。在输入
    `onCreate` 方法中的最后一行代码之后，但在关闭的 `}` 之前立即输入以下代码。这次当然，我们需要添加一些代码来监听三个按钮：
- en: '[PRE65]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. Again,
    we need to make a modification to our code in order to allow the use of an interface,
    the special code element that allows us to add functionalities such as listening
    to button clicks. Edit the line as follows. When prompted to import another class,
    click on **OK**. Consider this line of code:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到 `this` 关键字被红色突出显示，表示一个错误。再次，我们需要对我们的代码进行修改，以便使用接口，这是一个特殊的代码元素，它允许我们添加诸如监听按钮点击等功能。将这一行编辑如下。当提示导入另一个类时，点击
    **确定**。考虑以下代码行：
- en: '[PRE66]'
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Change it to the following line:'
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改成以下行：
- en: '[PRE67]'
  id: totrans-804
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we have the entire preceding line underlined in red. This indicates an error
    but it is where we should be at this point. We mentioned that by adding `implements
    View.OnClickListener`, we have implemented an interface. We can think of this
    like a class that we can use, but with extra rules. One of the rules of the `OnClickListener`
    interface is that we must implement one of its methods, as you might remember.
    Now we will add the `onClick` method.
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经用红色划下了整行。这表示有一个错误，但这也是我们目前应该所在的位置。我们提到，通过添加 `implements View.OnClickListener`，我们已经实现了一个接口。我们可以把它想象成一个我们可以使用的类，但带有额外的规则。`OnClickListener`
    接口的一个规则是我们必须实现其方法之一，正如你可能记得的那样。现在我们将添加 `onClick` 方法。
- en: 'Type the following code. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty; it doesn''t do anything but an empty method is enough to comply
    with the rules of the `OnClickListener` interface and the red line that indicated
    an error has gone. Make sure that you type the following code outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `GameActivity` class:'
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码。注意开括号 `{` 和闭括号 `}`，它们表示方法的开始和结束。注意，这个方法是空的；它不做任何事情，但一个空的方法就足以符合 `OnClickListener`
    接口的规则，以及表示错误的红色线条已经消失。确保你在 `onCreate` 方法的闭括号 `}` 之外，但 `GameActivity` 类的闭括号之内输入以下代码：
- en: '[PRE68]'
  id: totrans-807
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Notice that we have an empty line between the `{` and `}` braces of our `onClick`
    method. We can now put some code in here to make the buttons actually do something.
    Type the following in between `{` and `}` of `onClick`. This is where things get
    different from our code in `MainActivity`. We need to differentiate between the
    three possible buttons that could be pressed. We will do this with the `switch`
    statement that we discussed earlier. Look at the `case` criteria; they should
    look familiar. Here is the code that uses the switch statements:'
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在 `onClick` 方法的 `{` 和 `}` 大括号之间有一个空行。现在我们可以在其中放入一些代码，使按钮真正做些事情。在 `onClick`
    的 `{` 和 `}` 之间输入以下内容。这里与我们的 `MainActivity` 中的代码有所不同。我们需要区分可能被按下的三个按钮。我们将使用之前讨论过的
    `switch` 语句来完成这个任务。查看 `case` 条件；它们应该看起来很熟悉。以下是使用 `switch` 语句的代码：
- en: '[PRE69]'
  id: totrans-809
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Each `case` element handles a different button. For each button case, we need
    to get the value stored in the button that was just pressed and see if it matches
    our `correctAnswer` variable. If it does, we must tell the player they got it
    right, and if not, we must tell them they got it wrong. However, there is still
    one problem we have to solve. The `onClick` method is separate from the `onCreate`
    method and the Button objects. In fact, all the variables are declared in the
    `onCreate` method. If you try typing the code from step 9 now, you will get lots
    of errors. We need to make all the variables that we need in `onClick` available
    in `onClick`. To do this, we will move their declarations from above the `onCreate`
    method to just below the opening `{` of `GameActivity`. This means that these
    variables become variables of the `GameActivity` class and can be seen anywhere
    within `GameActivity`. Declare the following variables like this:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `case` 元素处理不同的按钮。对于每个按钮情况，我们需要获取刚刚按下的按钮中存储的值，并查看它是否与我们的 `correctAnswer` 变量匹配。如果是，我们必须告诉玩家他们答对了，如果不是，我们必须告诉他们答错了。然而，我们仍然有一个问题需要解决。`onClick`
    方法与 `onCreate` 方法以及按钮对象是分开的。实际上，所有变量都是在 `onCreate` 方法中声明的。如果你现在尝试输入步骤 9 中的代码，你会得到很多错误。我们需要在
    `onClick` 中使所有需要的变量都可用。为此，我们将它们的声明从 `onCreate` 方法上方移动到 `GameActivity` 的开头 `{`
    下方。这意味着这些变量成为 `GameActivity` 类的变量，可以在 `GameActivity` 的任何地方访问。以下是这样声明这些变量的方式：
- en: '[PRE70]'
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now change the initialization of these variables within `onCreate` as follows.
    The actual parts of code that need to be changed are highlighted. The rest is
    shown for context:'
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式更改 `onCreate` 方法中这些变量的初始化。需要更改的实际代码部分已突出显示。其余部分是为了说明上下文：
- en: '[PRE71]'
  id: totrans-813
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: and
  id: totrans-814
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE72]'
  id: totrans-815
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here is the top of our `onClick` method as well as the first `case` statement
    for our `onClick` method:'
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们的 `onClick` 方法顶部以及 `onClick` 方法的第一个 `case` 语句：
- en: '[PRE73]'
  id: totrans-817
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here are the rest of the `case` statements that do the same steps as the code
    in the previous step except handling the last two buttons. Enter the following
    code after the code entered in the previous step:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是其余的 `case` 语句，它们执行与上一步骤中代码相同的步骤，除了处理最后两个按钮。在上一步骤输入的代码之后输入以下代码：
- en: '[PRE74]'
  id: totrans-819
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Run the program, and then we will look at the code carefully, especially that
    odd-looking `Toast` thing. Here is what happens when we click on the leftmost
    button:![Math game – getting and checking the answer](img/8859OS_03_25.jpg)
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序后，我们将仔细查看代码，特别是那个看起来很奇怪的 `Toast` 东西。点击最左边的按钮时会发生以下情况：![数学游戏 – 获取并检查答案](img/8859OS_03_25.jpg)
- en: 'This is how we did it: In steps 1 through 6, we set up handling for our multi-choice
    buttons, including adding the ability to listen to clicks using the `onClick`
    method and a `switch` block to handle decisions depending on the button pressed.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们做到的：在步骤 1 到 6 中，我们设置了多选按钮的处理，包括使用 `onClick` 方法添加监听点击的能力，以及使用 `switch` 块来处理根据按下的按钮所做的决策。
- en: In steps 7 and 8, we had to alter our code to make our variables available in
    the `onClick` method. We did this by making them member variables of our `GameActivity`
    class.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 7 和 8 中，我们必须修改我们的代码，以便在 `onClick` 方法中使我们的变量可用。我们通过使它们成为 `GameActivity` 类的成员变量来实现这一点。
- en: Tip
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we make a variable a member of a class, we call it a **field**. We will
    discuss exactly when a variable should be a field and when it shouldn't in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个变量作为类的一个成员时，我们称之为 **字段**。我们将在 [第 6 章](ch06.html "第 6 章。面向对象编程 – 利用他人的辛勤工作")
    *面向对象编程 – 利用他人的辛勤工作* 中讨论变量何时应该是一个字段，何时不应该。
- en: In steps 9 and 10, we implemented the code that actually does the work in our
    switch statement in `onClick`. Let's take a line-by-line look at the code that
    runs when `button1` is pressed.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤9和10中，我们在`onClick`中的`switch`语句中实现了实际执行工作的代码。让我们逐行查看当按下`button1`时运行的代码。
- en: '[PRE75]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'First, the `case` statement is true when the button with an id of `buttonChoice1`
    is pressed. Then the next line of code to execute is this:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当按下具有`buttonChoice1` ID的按钮时，`case`语句为真。然后，接下来要执行的代码行是：
- en: '[PRE76]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding line gets the value on the button using two methods. First, `getText`
    gets the number as a string and then `Integer.parseInt` converts it to an integer.
    The value is stored in our `answerGiven` variable. The following code executes
    next:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用两种方法获取按钮上的值。首先，`getText`方法将数字作为字符串获取，然后`Integer.parseInt`将其转换为整数。该值存储在我们的`answerGiven`变量中。接下来的代码执行如下：
- en: '[PRE77]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `if` statement tests to see if the `answerGiven` variable is the same as
    `correctAnswer` using the `==` operator. If so, the `makeText` method of the `Toast`
    object is used to display a congratulatory message. If the values of the two variables
    are not the same, the message displayed is a bit more negative one.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句使用`==`运算符检查`answerGiven`变量是否与`correctAnswer`相同。如果是这样，就使用`Toast`对象的`makeText`方法来显示一条祝贺信息。如果两个变量的值不相同，显示的消息会稍微负面一些。'
- en: Note
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Toast` line of code is possibly the most evil thing we have seen thus
    far. It looks exceptionally complicated and it does need a greater knowledge of
    Java than we have at the moment to understand. All we need to know for now is
    that we can use the code as it is and just change the message, and it is a great
    tool to announce something to the player. By the end of [Chapter 6](ch06.html
    "Chapter 6. OOP – Using Other People''s Hard Work"), *OOP – Using Other People''s
    Hard Work*, the code for `Toast` will be clear. If you really want an explanation
    now, you can think of it like this: when we made button objects, we got to use
    all the button methods. But with Toast, we used the class directly to access its
    `makeText` method without creating an object first. We can do this process when
    the class and its methods are designed to allow it.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`代码行可能是我们迄今为止见过的最邪恶的东西。它看起来异常复杂，并且确实需要比我们目前所掌握的Java知识更深入的了解才能理解。现在我们只需要知道，我们可以直接使用这段代码，只需更改消息，它就是一个宣布给玩家消息的伟大工具。到[第6章](ch06.html
    "第6章。面向对象编程 – 使用他人的辛勤工作") *面向对象编程 – 使用他人的辛勤工作* 的结尾，`Toast`的代码将会清晰。如果你现在真的想要一个解释，你可以这样想：当我们创建按钮对象时，我们得到了使用所有按钮方法的机会。但是，对于Toast，我们直接使用类来访问其`makeText`方法，而不需要首先创建一个对象。我们可以在类及其方法设计为允许这样做的时候进行这个过程。'
- en: 'Finally, we break out of the whole `switch` statement as follows:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式跳出整个`switch`语句：
- en: '[PRE78]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now that we have improved the project as far as we can with what we learned
    in this chapter, why not test your understanding of everything you've learned
    so far?
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用本章学到的知识尽可能改进了项目，为什么不测试一下到目前为止你所学的所有知识？
- en: Self-test questions
  id: totrans-837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1) What does this code do?
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 这段代码做了什么？
- en: '[PRE79]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Q2) Which of these lines causes an error?
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 哪一行代码会导致错误？
- en: '[PRE80]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make the code look complicated. However, when looked at closely, they are not
    as tough as they seem. Usually, it is just a case of splitting the expressions
    into smaller pieces to work out what is going on. Here is an expression that is
    more convoluted than anything else you will ever see in this book. As a challenge,
    can you work out: what will `x` be?'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我们讨论了很多关于运算符的内容，以及如何将不同的运算符组合起来构建复杂的表达式。乍一看，表达式可能会让代码看起来很复杂。然而，仔细观察后，它们并没有看起来那么困难。通常，只需将表达式拆分成更小的部分，就可以弄清楚发生了什么。这里有一个比本书中任何其他表达式都更复杂的表达式。作为一个挑战，你能计算出：`x`将会是多少？
- en: '[PRE81]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Summary
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot in this chapter. We went from knowing nothing about Java syntax
    to learning about comments, variables, operators, and decision making.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多内容。我们从对Java语法一无所知，到学习注释、变量、运算符和决策。
- en: As with any language, mastery of Java can be achieved by simply practicing,
    learning, and increasing our vocabulary. At this point, the temptation might be
    to hold back until mastery of the current Java syntax has been achieved, but the
    best way is to move on to new syntax at the same time as revisiting what we have
    already begun to learn.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何语言一样，通过简单的练习、学习和增加我们的词汇量，我们可以掌握Java。在这个时候，我们可能会倾向于等到当前Java语法的掌握之后再继续前进，但最好的方法是同时在回顾我们已经开始学习的内容的同时，继续学习新的语法。
- en: In the next chapter, we will finally finish our math game by adding random questions
    of multiple difficulties as well as using more appropriate and random wrong answers
    for the multiple choice buttons.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加多种难度级别的随机问题以及为多选题按钮使用更合适和随机的错误答案，最终完成我们的数学游戏。
- en: To enable us to do this, we will first learn some more Java.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够做到这一点，我们首先将学习一些更多的Java。
- en: Chapter 4. Discovering Loops and Methods
  id: totrans-849
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：发现循环和方法
- en: In this chapter, we will learn how to repeatedly execute portions of our code
    in a controlled and precise way by looking at different types of loops in Java.
    These include `while` loops, `do-while` loops, and `for` loops. We will learn
    about the best occasions to use the different types of loops.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过查看Java中不同类型的循环（包括`while`循环、`do-while`循环和`for`循环）来学习如何以受控和精确的方式重复执行我们的代码的一部分。我们将了解在不同情况下使用不同类型循环的最佳时机。
- en: Then we will briefly cover the topic of random numbers. We will also see how
    the Java `Random` class can be used. This will obviously be of great help in enhancing
    our math game.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将简要介绍随机数的话题。我们还将看到如何使用Java的`Random`类。这显然对我们的数学游戏有很大的帮助。
- en: Next, we will look at **methods**. They allow us to compartmentalize our code
    into more manageable blocks. We will then see how to share data between methods
    and divide programming tasks to simplify problems.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究**方法**。它们允许我们将代码分成更易于管理的块。然后我们将看到如何在不同方法之间共享数据，以及如何将编程任务分解以简化问题。
- en: We will then use all that we have learned about loops, random numbers and methods
    on our math game project. For example, we will make the game change the question
    after each time we attempt the answer.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把关于循环、随机数和方法的所有知识应用到我们的数学游戏项目中。例如，我们将使游戏在每次尝试回答后更改问题。
- en: We will also add question difficulty levels and random questions within a range
    appropriate for a given difficulty level. We will show and update our score. The
    score goes up faster depending upon the difficulty level of the question answered
    (correctly). Eventually, even the best mathematicians among us should be beaten
    by the game. Nevertheless, most of us will hopefully get a bit further than what
    is shown in the next screenshot.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加问题难度级别和适合给定难度级别的随机问题。我们将展示并更新我们的分数。根据回答问题的难度级别（正确回答），分数上升得更快。最终，即使是我们中间最好的数学家也应该被游戏打败。然而，我们大多数人希望比下一张截图显示的更前进一点。
- en: 'If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero. This is what the game will look like when we are
    done:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家回答错误，难度将回到最简单级别，分数归零。这就是我们完成游戏后的样子：
- en: '![Discovering Loops and Methods](img/8859OS_04_01.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![发现循环和方法](img/8859OS_04_01.jpg)'
- en: 'In this chapter we will:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about looping in multiple types of loops
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习多种类型循环中的循环
- en: Learn how to generate random numbers in Java
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在Java中生成随机数
- en: Learn everything about Java methods, including how to write and call them
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Java方法的一切，包括如何编写和调用它们
- en: Significantly enhance our math game
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著提高我们的数学游戏
- en: Looping with loops
  id: totrans-862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环中的循环
- en: It would be completely reasonable to ask what loops have to do with programming,
    but they are exactly what the name implies. They are a way of performing the same
    part of the code more than once, or looping over the same part of code, but potentially
    for a different outcome each time.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 提问循环与编程有什么关系是完全合理的，但它们正是名字所暗示的。它们是一种执行代码相同部分多次或循环相同代码部分的方式，但每次可能得到不同的结果。
- en: This can simply mean doing the same thing until the code being looped over prompts
    the loop to end. It could prompt the loop after a predetermined number of times
    as specified by the loop code itself. It could also prompt the loop when a predetermined
    situation or **condition** is met. Or there could be a combination of more than
    one of these ways of prompting the loop to end. Along with `if`, `else`, and `switch`,
    loops are part of the Java **control flow statements**.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简单地意味着重复做同样的事情，直到被循环的代码提示循环结束。它可能在循环代码本身指定的预定次数后提示循环结束。它也可能在满足预定的某种情况或**条件**时提示循环结束。或者，可能有多种方式组合来提示循环结束。与
    `if`、`else` 和 `switch` 一样，循环是 Java **控制流语句**的一部分。
- en: We will look at all the major types of loop that Java offers us to control our
    code, and after we have looked at methods, we will use some of them to implement
    the enhancements to our math game. Let's proceed to our first type of loop.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 Java 提供给我们控制代码的所有主要循环类型，在我们查看方法之后，我们将使用其中一些来实现我们数学游戏的增强。让我们继续到我们第一种循环类型。
- en: While loops
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当循环
- en: 'A `while` loop has the simplest syntax. Recollect the `if` statements in [Chapter
    3](ch03.html "Chapter 3. Speaking Java – Your First Game"), *Speaking Java – Your
    First Game*. We can put virtually any combination of operators and variables in
    the conditional expression of the `if` statement. If the expression evaluated
    to `true`, then the code in the body of the `if` block is executed. Similarly,
    in the `while` loop, we put an expression that can evaluate to `true` or `false`,
    as shown in this code:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环具有最简单的语法。回忆一下 [第 3 章](ch03.html "第 3 章。说 Java – 你的第一个游戏") 中的 `if`
    语句，*说 Java – 你的第一个游戏*。我们可以在 `if` 语句的条件表达式中放置几乎任何组合的运算符和变量。如果表达式评估为 `true`，则执行
    `if` 块体内的代码。同样，在 `while` 循环中，我们放置一个可以评估为 `true` 或 `false` 的表达式，如以下代码所示：'
- en: '[PRE82]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What is happening here is that outside the `while` loop, an integer, `x`, is
    declared and initialized to `10`. Then the `while` loop begins. Its condition
    is `x > 0`, so it will continue looping through the code in its body until the
    condition evaluates to `false`. Hence, the code will execute 10 times.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是在 `while` 循环外部，声明了一个整数 `x` 并将其初始化为 `10`。然后开始 `while` 循环。其条件是 `x > 0`，因此它将一直循环执行其体内的代码，直到条件评估为
    `false`。因此，代码将执行 10 次。
- en: On the first pass, `x` is equal to `10`, then `9`, then `8`, and so on. But
    once `x` becomes equal to `0`, it is obviously no longer greater than `0`. So
    the program will exit the `while` loop and continue with the first line of code
    after the loop.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，`x` 等于 `10`，然后是 `9`，然后是 `8`，以此类推。但是一旦 `x` 等于 `0`，显然就不再大于 `0`。因此，程序将退出
    `while` 循环并继续执行循环之后的代码的第一行。
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this example of a `while` loop that never executes:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `if` 语句一样，`while` 循环可能一次也不会执行。看看这个永远不会执行的 `while` 循环的例子：
- en: '[PRE83]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Moreover, there is no limit to the complexity of the condition expression or
    the amount of code that can be written in the loop body:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，条件表达式的复杂性和循环体内可以编写的代码量都没有限制：
- en: '[PRE84]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding `while` loop would continue to execute until either `playerLive`s
    or `alienShips` becomes equal to or less than zero. As soon as one of these conditions
    occurs, the expression evaluates to `false` and the program continues to execute
    from the first line of code after the `while` loop.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `while` 循环将继续执行，直到 `playerLive`s 或 `alienShips` 等于或小于零。一旦这些条件中的任何一个发生，表达式评估为
    `false`，程序将继续从 `while` 循环后的第一行代码执行。
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to `false` somewhere in between,
    as the condition is not checked again until the code tries to start another pass:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦进入循环体，它总是会完成，即使表达式在中间某处评估为 `false`，因为条件不会再次检查，直到代码尝试开始另一轮循环：
- en: '[PRE85]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever (which is unsurprisingly called an **infinite loop**),
    like this:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的循环体将只执行一次。我们也可以设置一个会无限运行的 `while` 循环（这毫不奇怪地被称为**无限循环**），如下所示：
- en: '[PRE86]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Breaking out of a loop
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出循环
- en: 'We might use an infinite loop like the loop in the preceding example so that
    we can decide when to exit the loop from within its body. We would do this using
    the `break` keyword when we are ready to leave the loop body, as shown in the
    following code:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用一个无限循环，就像前面例子中的循环一样，这样我们就可以在循环体内决定何时退出循环。当我们准备好离开循环体时，我们会使用 `break` 关键字，如下面的代码所示：
- en: '[PRE87]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You might have been able to guess that we can combine any of the decision making
    tools like `if`, `else`, and `switch` within our `while` loops and the rest of
    the loops we will look at in a minute:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，我们可以在 `while` 循环以及我们稍后将看到的任何其他循环中结合任何决策工具，如 `if`、`else` 和 `switch`：
- en: '[PRE88]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops, but at some point, we want to get back to doing some real programming.
    So here is one last concept, combined with `while` loops.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续展示 `while` 循环的多样性，可能会占用更多页面，但我们想回到做一些真正的编程。所以这里有一个最后的概念，与 `while` 循环结合使用。
- en: The continue keyword
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`continue` 关键字'
- en: 'The `continue` keyword acts in a way similar to `break`—up to a point. The
    `continue` keyword will break out of the loop body but will also check the condition
    expression afterwards, so the loop *could* run again. The following example will
    show the use of `continue`:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 关键字的行为与 `break` 类似——但仅到此为止。`continue` 关键字会跳出循环体，但之后也会检查条件表达式，因此循环*可能*会再次运行。以下示例将展示
    `continue` 的用法：'
- en: '[PRE89]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Do-while loops
  id: totrans-889
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: 'A `do-while` loop is very much the same as a `while` loop with the exception
    that it evaluates its expression after the body. This means that a `do-while`
    loop will always execute at least once, as demonstrated in the following code:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环与 `while` 循环非常相似，区别在于它是在体之后评估其表达式的。这意味着 `do-while` 循环至少会执行一次，如下面的代码所示：'
- en: '[PRE90]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `break` and `continue` keywords can also be used in `do-while` loops.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 关键字也可以用在 `do-while` 循环中。'
- en: For loops
  id: totrans-894
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: 'A `for` loop has a slightly more complicated syntax than a `while` and `do-while`
    loop as it take three parts to initialize. Take a look at the following `for`
    loop first. Then we will break it apart:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的语法比 `while` 和 `do-while` 循环稍微复杂一些，因为它需要三个部分来初始化。首先看看下面的 `for` 循环。然后我们将将其分解：'
- en: '[PRE91]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The apparently obscure form of the `for` loop is clearer when put like this:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样表达时，`for` 循环的看似晦涩的形式就更加清晰了：
- en: '[PRE92]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To clarify further, we have the following in a `for` loop:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐明，我们可以在 `for` 循环中看到以下内容：
- en: '**Declaration and initialization**: We create a new `int` variable, `i`, and
    initialize it to 0.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明和初始化**：我们创建一个新的 `int` 变量 `i` 并将其初始化为 0。'
- en: '**Condition**: Just like the other loops, this refers to the condition that
    must be evaluated to true for the loop to continue.'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：就像其他循环一样，这指的是必须评估为真以使循环继续的条件。'
- en: '**Change after each pass through loop**: In the preceding example, `i++` means
    that 1 is added to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` on each pass, which is shown in the following code:'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环每次通过后的变化**：在前面的例子中，`i++` 表示在每次通过时将 1 添加到 `i` 中。我们也可以使用 `i--` 在每次通过时减少/递减
    `i`，如下面的代码所示：'
- en: '[PRE93]'
  id: totrans-903
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `break` and `continue` can also be used in `for` loops.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`break` 和 `continue` 也可以用在 `for` 循环中。
- en: The `for` loop essentially takes control of initialization, condition evaluation,
    and the control variable on itself. We will be using a `for` loop to enhance our
    math game right after we take a look at random numbers and methods.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环本质上将初始化、条件评估和控制变量的控制权掌握在自己手中。在我们查看随机数和方法之后，我们将立即使用 `for` 循环来增强我们的数学游戏。'
- en: Random numbers in Java
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 中的随机数
- en: Before we dive into methods, we will first take a look at how we can create
    random numbers because this is how we will generate our random questions.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究方法之前，我们首先看看我们如何可以创建随机数，因为这是我们生成随机问题的方法。
- en: 'All the hard work is done for us by the `Random` class. First we need to create
    an object of the `Random` type:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的艰苦工作都由 `Random` 类为我们完成。首先，我们需要创建一个 `Random` 类型的对象：
- en: '[PRE94]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    within a certain range:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用新对象的 `nextInt` 方法生成一定范围内的随机数：
- en: '[PRE95]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The range for the number that we enter starts from zero. So the preceding line
    of code will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的数字的范围从零开始。因此，前面的代码将生成一个介于 0 和 9 之间的随机数。如果我们想要一个介于 1 和 10 之间的随机数，我们只需这样做：
- en: '[PRE96]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Tip
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Often in these early chapters, we need to accept there is a bit of magic going
    on in objects like Random. In [Chapter 6](ch06.html "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*, we will be ripping
    open the black boxes and even making our own. We will be able to write our own
    classes and our own methods within those classes.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些早期章节中，我们通常需要接受在像Random这样的对象中发生了一些魔法。在[第6章](ch06.html "第6章。面向对象编程 – 使用他人的辛勤工作")“面向对象编程
    – 使用他人的辛勤工作”中，我们将打开黑盒子，甚至制作自己的。我们将能够编写自己的类，并在这些类中编写自己的方法。
- en: A good start is a look at regular vanilla methods, which we will do next.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的开始是查看常规的香草方法，我们将在下一节中这样做。
- en: Methods
  id: totrans-918
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: So what exactly are Java methods? A method is a collection of variables, expressions,
    and control flow statements. We have already been using lots of methods; we just
    haven't looked inside any yet.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Java方法究竟是什么呢？方法是一系列变量、表达式和控制流语句的集合。我们已经使用了很多方法；我们只是还没有深入查看过它们。
- en: Learning about Java methods will be the last topic for this chapter before we
    get practical and use what we have learned to enhance our math game.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际操作并使用所学知识来增强我们的数学游戏之前，了解Java方法将是本章的最后一个主题。
- en: The structure of a method
  id: totrans-921
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法结构
- en: 'The first part of a method that we write is called the **signature**. Here
    is a made-up example of a signature:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所写的每个方法的第一部分被称为**签名**。以下是一个虚构的签名示例：
- en: '[PRE97]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Add an opening and closing pair of curly braces with some code that the method
    performs, and we have a complete method, or a **definition**. Here is a made-up
    but syntactically correct method:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一对大括号，并在其中放置一些方法执行的操作代码，我们就有了完整的方法，或者称为**定义**。以下是一个虚构但语法正确的示例方法：
- en: '[PRE98]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We could then use our new method from another part of our code, like this:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后可以使用我们的新方法从代码的另一个部分，如下所示：
- en: '[PRE99]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: At the point where we call `setCoordinates`, our program's execution would branch
    to the code contained within that method, which would run until it reaches its
    end or is told to return. Then the code would continue running from the first
    line after the method call.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`setCoordinates`的点，程序的执行将分支到该方法内的代码，该代码将运行，直到它到达末尾或被指示返回。然后代码将从方法调用后的第一行继续运行。
- en: 'Here is another example of a method, complete with the code to make the method
    return to the code that called it:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个方法的示例，包括使方法返回到调用它的代码的代码：
- en: '[PRE100]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The call to use the preceding method could look like this:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面方法的调用可能看起来像这样：
- en: '[PRE101]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the preceding example helps us see a little more of the working of methods.
    First, we pass the values `2` and `4`. In the signature of the method, the value,
    `2`, is assigned to `int a` and the value, `4`, is assigned to `int b`.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要编写方法来将两个`int`变量相加，但前面的例子帮助我们更深入地了解了方法的工作原理。首先，我们传递了值`2`和`4`。在方法的签名中，值`2`被分配给`int
    a`，而值`4`被分配给`int b`。
- en: Within the method body, the `a` and `b` variables are added and used to initialize
    a new variable, which is the `int` answer. The `return answer` line does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value of `6`.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法体内部，变量`a`和`b`被添加并用于初始化一个新的变量，这个新变量是`int`类型的`answer`。`return answer`这一行正是这样做的。它将存储在`answer`中的值返回给调用代码，导致`myAnswer`被初始化为`6`的值。
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is that the Java method signature is quite flexible,
    allowing us to build exactly the methods we require.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面示例中的每个方法签名都有所不同。这是因为Java方法签名非常灵活，允许我们构建我们需要的精确方法。
- en: Exactly how the method signature defines how the method must be called and how
    a method must return a value, if it must, deserves further discussion. Let's give
    each part of that signature a name so that we can break it into chunks and learn
    about the parts separately.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名如何定义方法必须如何调用，以及方法必须返回值（如果必须的话），这值得进一步讨论。让我们给签名的每个部分起一个名字，这样我们就可以将其分解成块，并分别了解各个部分。
- en: Tip
  id: totrans-937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Here is a method signature with its parts labeled and ready for discussion.
    You can also take a look at the following table to further identify which part
    of the signature is which. This will make the rest of our discussion on methods
    straightforward.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有标签和准备讨论的方法签名。您还可以查看以下表格，以进一步确定签名的哪个部分是哪个。这将使我们对方法的讨论更加直接。
- en: '**Modifier** | **return type** | **name of the method** (**parameters**)'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**修饰符** | **返回类型** | **方法名称**（**参数**）'
- en: 'Here are a few examples that we have used so far so that you can clearly identify
    the part of the signature under discussion:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们迄今为止使用的例子，以便您可以清楚地识别正在讨论的签名部分：
- en: '| Part of signature | Examples |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| 签名部分 | 示例 |'
- en: '| --- | --- |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Modifier | `public`, `private`, and so on |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | `public`、`private`等等 |'
- en: '| Return type | `int`, `boolean`, `float`, and so on, or any Java type, expression,
    or object |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | `int`、`boolean`、`float`等等，或任何Java类型、表达式或对象 |'
- en: '| Name of the method | `shootLazers`, `setCoordinates`, `addAToB`, and so on
    |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | `shootLazers`、`setCoordinates`、`addAToB`等等 |'
- en: '| Parameters | (`int number`, `string type`), (`int x`, `int y`), (`int a`,
    `int b`), and so on |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | (`int number`，`string type`)，(`int x`，`int y`)，(`int a`，`int b`)等等 |'
- en: Modifier
  id: totrans-947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'In our previous examples, we only used a modifier twice, partly because the
    method doesn''t have to use the modifier. The modifier is a way of specifying
    which code can use your method. Some of the types of modifiers are `public` and
    `private`. Actually, regular variables can have modifiers too, such as these:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们只使用了修饰符两次，部分原因是该方法不必使用修饰符。修饰符是一种指定哪些代码可以使用您的方法的方式。一些修饰符的类型是`public`和`private`。实际上，常规变量也可以有修饰符，例如这些：
- en: '[PRE102]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Modifiers (for methods and variables) are an essential Java topic but they are
    best dealt with when we discuss the other vital Java topic we have skirted around
    a few times so far—objects and classes.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: （方法与变量的）修饰符是Java的一个基本主题，但最好在我们讨论其他重要的Java主题时处理，这些主题我们迄今为止已经绕过几次——对象和类。
- en: Note
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As previously promised, these mysterious objects will be revealed in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*. However, as we can see from our example methods and
    from the fact that all the examples we have written so far work just fine, modifiers
    are not necessary to facilitate our learning so far.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些神秘的对象将在[第6章](ch06.html "第6章。面向对象编程 - 使用他人的辛勤工作") *面向对象编程 - 使用他人的辛勤工作*
    中揭晓。然而，正如我们可以从我们的示例方法和从我们迄今为止编写的所有示例都运行得很好这一事实中看到的那样，修饰符到目前为止并不是促进我们学习所必需的。
- en: Return type
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型
- en: 'Next up is the `return` type. Like a modifier, a `return` type is also optional,
    although it is more immediately useful to us. So let''s look a bit closer. We
    have seen that our methods can get anything done. But what if we need the result
    from what they have done? The simplest example of a return type we have seen so
    far was this:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`return`类型。像修饰符一样，`return`类型也是可选的，尽管它对我们来说更有直接用处。所以让我们更仔细地看看。我们已经看到我们的方法可以完成任何事情。但如果我们需要他们所做事情的结果呢？我们迄今为止看到的简单`return`类型示例是这样的：
- en: '[PRE103]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this code, the `return` type in the signature is highlighted. So the `return`
    type is `int`. The `addAToB` method sends back (returns) to the code that called
    it a value that will fit in an `int` variable.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，签名中的`return`类型被突出显示。因此，`return`类型是`int`。`addAToB`方法将（返回）一个值给调用它的代码，这个值将适合一个`int`变量。
- en: 'The `return` type can be any Java type we have seen so far. The method, however,
    does not have to return a value at all. In this case, the signature must use the
    `void` keyword as the `return` type. When the `void` keyword is used, the method
    body must not attempt to return a value as this will cause a compiler error. It
    can, however, use the `return` keyword without a value. Here are some combinations
    of return type and uses of the `return` keyword that are valid:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`类型可以是迄今为止我们看到的任何Java类型。然而，方法不必返回任何值。在这种情况下，签名必须使用`void`关键字作为`return`类型。当使用`void`关键字时，方法体不得尝试返回一个值，因为这会导致编译器错误。然而，它可以使用不带值的`return`关键字。以下是一些有效的返回类型和`return`关键字使用的组合：'
- en: '[PRE104]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Another combination of `return` and `void` is as follows:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`和`void`的另一种组合如下：'
- en: '[PRE105]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The following code is yet another combination of `return` and `void`:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`return`和`void`的另一种组合：
- en: '[PRE106]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can call each of the preceding methods one by one, like this:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以逐个调用前面的每个方法，如下所示：
- en: '[PRE107]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code would execute all the code statements in each method one
    by one. If the method signature had parameters, the code that calls the method
    would look slightly different.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将逐个执行每个方法中的所有代码语句。如果方法签名有参数，调用方法的代码将略有不同。
- en: Name of a method
  id: totrans-967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法名称
- en: 'When we design our own methods, the method name is arbitrary, but there is
    a convention to use verbs that clearly explain what the method will do. Another
    convention is of the first letter of the first word in the name being lower case,
    and the first letter of each of the subsequent words being uppercase. This is
    called **camel case** because the shape the name can form has a hump in it:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计自己的方法时，方法名是任意的，但有一个约定是使用动词，清楚地说明方法将要做什么。另一个约定是名字中第一个单词的首字母小写，后续每个单词的首字母大写。这被称为
    **驼峰式命名法**，因为名字可以形成的形状有一个驼峰：
- en: '[PRE108]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This name is perfectly legitimate and will work. However, let''s take a look
    at a much clearer example that uses the conventions:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字是完全合法的，并且可以工作。然而，让我们看看一个使用约定更为清晰的例子：
- en: '[PRE109]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: These are much clearer method names.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是更清晰的方法名称。
- en: Now let's take a look at parameters.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看参数。
- en: Parameters
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: 'We know that a method can return a result to the calling code. What if we need
    to share some data values from the calling code with the method? Parameters allow
    us to share values with the method. We have already seen an example with parameters
    when looking at return types. We will look at the same example but a little more
    closely:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道一个方法可以向调用代码返回一个结果。如果我们需要从调用代码中共享一些数据值给方法怎么办？参数允许我们与方法共享值。当我们查看返回类型时，我们已经看到了一个带有参数的例子。我们将更仔细地查看相同的例子：
- en: '[PRE110]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The parameters in this code are highlighted. Notice that in the first line
    of the method body, we use `a + b` as if they are already declared and initialized.
    Well, that''s because they are. The parameters of the method signature is their
    declaration, and the code that calls the method initializes them:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的参数被突出显示。注意，在方法体的第一行，我们使用 `a + b` 仿佛它们已经被声明和初始化。嗯，那是因为它们已经被声明了。方法签名中的参数是它们的声明，调用方法的代码初始化它们：
- en: '[PRE111]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Also, as we have partly seen in previous examples, we don''t have to use `int`
    in our parameters. We can use any Java type, including types we design ourselves.
    We can mix and match types as well. We can also use as many parameters as necessary
    to solve our problem. An example of mixed Java types might help:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在之前的例子中部分看到的，我们不需要在我们的参数中使用 `int`。我们可以使用任何 Java 类型，包括我们自己设计的类型。我们还可以混合和匹配类型。我们可以使用必要的任何数量的参数来解决我们的问题。一个混合
    Java 类型的例子可能有助于理解：
- en: '[PRE112]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: It's now time to get serious about our body.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候认真对待我们的方法体了。
- en: Getting things done in the method body
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在方法体中完成事情
- en: 'The body is the part we have been avoiding so far with comments like this:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是我们迄今为止一直通过这样的注释来避免的部分：
- en: '[PRE113]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: But actually, we know exactly what to do here already. Any Java syntax we have
    learned so far will work in the body of a method. In fact, if we look back, all
    of the code we have written so far has been in a method, albeit somebody else's
    method. For example, we wrote code in the `onCreate` and `onClick` methods.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们已经知道在这里要做什么了。我们迄今为止学到的任何 Java 语法都可以在方法体中使用。事实上，如果我们回顾一下，我们迄今为止编写的所有代码都已经在方法中，尽管是别人的方法。例如，我们在
    `onCreate` 和 `onClick` 方法中编写了代码。
- en: The best thing we can do next is write some methods that actually do something
    in the body.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来能做的最好的事情就是编写一些在主体中实际做些事情的代码方法。
- en: Using methods
  id: totrans-987
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: We don't have to mess around with our math game project. We will quickly create
    a new blank project for each of the next two explorations into methods.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在我们的数学游戏项目中乱搞。我们将快速为接下来的两个方法探索创建一个新的空白项目。
- en: We also don't need to spend time making a UI. We will use the Android console
    to view the results and discuss the implications of our examples of methods. As
    we are using the Android console to view the results of our work with methods,
    we will need to run all of these examples on the Android emulator, not on a real
    device.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不需要花时间制作用户界面。我们将使用 Android 控制台来查看结果并讨论我们方法示例的影响。由于我们正在使用 Android 控制台来查看我们使用方法的工作结果，因此我们需要在
    Android 模拟器上而不是在真实设备上运行所有这些示例。
- en: Note
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to set up a real device to output to the console, but we have
    not covered that in this book. If you want to find out more about using your actual
    device for debugging, take a look at the article at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能设置一个真实设备以输出到控制台，但在这本书中我们没有涉及这一点。如果你想了解更多关于使用你的实际设备进行调试的信息，请查看[http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)上的文章。
- en: As usual, you can open the already typed code files in the usual way. The next
    two examples on methods can be found in the Packt Publishing code download in
    the `Chapter4` folder and the `AWorkingMethod` and `ExploringMethodOverloading`
    subfolders.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，你可以以通常的方式打开已经输入的代码文件。接下来的两个关于方法的示例可以在`Chapter4`文件夹和`AWorkingMethod`和`ExploringMethodOverloading`子文件夹中的Packt
    Publishing代码下载中找到。
- en: Tip
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The following is a quick reminder on how to create a new blank project.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建一个新空白项目的快速提醒。
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**文件** | **关闭项目**来关闭任何当前打开的项目。
- en: Click on **New Project...**.
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建项目...**。
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com`, or you could use your
    own company website's name here instead.
  id: totrans-997
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建新项目**配置窗口将出现。填写**应用程序名称**字段和**公司域名**为`packtpub.com`，或者你也可以在这里使用你自己的公司网站名称。'
- en: 'Now click on the **Next** button. On the next screen, ensure that the **Phone
    and tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer cutting-edge Android
    features we can have in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot.'
  id: totrans-998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击**下一步**按钮。在下一屏，确保**手机和平板**复选框中有勾选。现在我们必须选择我们想要为构建我们的应用程序的最早版本的Android。继续在下拉选择器中尝试一些选项。你会看到，我们选择的版本越早，我们的应用程序可以支持的设备百分比就越大。然而，这里的权衡是，我们选择的版本越早，我们可以在应用程序中拥有的最新Android功能就越少。一个好的平衡点是选择**API
    8: Android 2.2 (Froyo)**。现在就按照下一张截图所示进行操作。'
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  id: totrans-999
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**。现在选择**空白活动**并再次点击**下一步**。
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-1000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏，只需将**活动名称**改为`MainActivity`并点击**完成**。
- en: As we did in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements, but this is not necessary
    for the example to work.
  id: totrans-1001
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章。Android入门")中做的那样，为了使我们的代码清晰简单，你可以删除两个不需要的方法（`onCreateOptionsMenu`和`onOptionsItemSelected`）以及它们相关的`@override`和`@import`语句，但这对于示例工作不是必要的。
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.html "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建新项目的详细说明和图像，请参阅[第2章](ch02.html "第2章。Android入门")，*Android入门*。
- en: A working method
  id: totrans-1003
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个工作方法
- en: First, let's make ourselves a simple working method, complete with return types
    and a fully functioning body.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个简单的工作方法，包括返回类型和完全功能性的主体。
- en: 'This method will take three numbers as parameters and return a `true` or `false`
    value to the calling code depending upon whether one of the three numbers was
    randomly generated within the method or not:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将接受三个数字作为参数，并根据是否在方法中随机生成这三个数字之一，向调用代码返回`true`或`false`值：
- en: Create a new blank project called `A Working Method`.
  id: totrans-1006
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`A Working Method`的新空白项目。
- en: 'In this method, we will use the `Random` class we saw earlier and its `randInt`
    method as a part of the demonstration. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  id: totrans-1007
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将使用我们之前看到的`Random`类及其`randInt`方法作为演示的一部分。在`onCreate`的闭括号之后但在`MainActivity`的闭括号之前复制此方法的代码。当你被提示导入任何类时，只需点击**确定**：
- en: '[PRE114]'
  id: totrans-1008
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now we declare a Boolean variable called `found` and initialize it to `false`.
    We will change `found` to `true` if and when we guess the random number correctly.
    Next, we declare our random number and print some useful values to the console:'
  id: totrans-1009
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们声明一个名为`found`的布尔变量并将其初始化为`false`。如果我们正确猜出随机数，我们将`found`改为`true`。接下来，我们声明我们的随机数并向控制台打印一些有用的值：
- en: '[PRE115]'
  id: totrans-1010
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The last portion of code in our method tests to see whether there is a match
    for any of our passed-in parameters, prints some output, and then returns `true`
    or `false` using the `found` variable to the calling code in the `onCreate` method:'
  id: totrans-1011
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们方法中的最后一部分代码检查是否有任何传入的参数与我们的随机数匹配，打印一些输出，然后使用`found`变量将`true`或`false`返回给`onCreate`方法中的调用代码：
- en: '[PRE116]'
  id: totrans-1012
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the code and print some values to the Android console:'
  id: totrans-1013
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将此代码写在`onCreate`方法的括号关闭之前，以调用代码并打印一些值到Android控制台：
- en: '[PRE117]'
  id: totrans-1014
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Launch an emulator.
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个模拟器。
- en: Run the app on the emulator.
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。
- en: All our console messages have a tag called **info**. The console window will
    already have appeared underneath the editor window. We can filter its contents
    to only show our messages by typing `info` in the search box, as shown in the
    following screenshot:![A working method](img/8859OS_04_02.jpg)
  id: totrans-1017
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所有的控制台消息都有一个名为**info**的标签。控制台窗口已经在编辑器窗口下方出现。我们可以在搜索框中键入`info`，以仅显示我们的消息，如下面的屏幕截图所示：![一个工作方法](img/8859OS_04_02.jpg)
- en: In the preceding screenshot, you can see the search filter and the console output.
    We will now run through the code and explain the output.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到搜索过滤器和控制台输出。我们现在将运行代码并解释输出。
- en: 'For clarity, here is the precise console output, without the extraneous date,
    time, and package name added to the beginning of each line. Remember that we are
    dealing with a random number, so your output may vary:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，以下是精确的控制台输出，没有在每个行首添加额外的日期、时间和包名。记住，我们正在处理一个随机数，所以你的输出可能会有所不同：
- en: '[PRE118]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here is what is happening. In step 2, we started writing our first method.
    We called it `guessANumber`. It has three `int` parameters and will return a Boolean.
    Remember that these three `int` parameters become fully initialized variables.
    First of all, however, in our method, we simply output the values of the new variables
    passed in as parameters as well as a message confirming that the code in our method
    is currently being executed:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是正在发生的事情。在第二步中，我们开始编写我们的第一个方法。我们将其命名为`guessANumber`。它有三个`int`参数，并将返回一个布尔值。记住，这三个`int`参数成为完全初始化的变量。然而，首先，在我们的方法中，我们只是输出作为参数传递的新变量的值以及一条确认信息，表明我们方法中的代码目前正在执行：
- en: '[PRE119]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In step 3, we added more code to our method. We declared and initialized a
    Boolean variable called `found`, which we will use to return a value to the calling
    code and let the calling code know whether one of the parameters passed in was
    the same as the random number:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们在方法中添加了更多的代码。我们声明并初始化了一个名为`found`的布尔变量，我们将使用它将值返回给调用代码，并让调用代码知道传入的参数中是否有任何一个与随机数相同：
- en: '[PRE120]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next (still in step 3), we generated a random number in the same way as we
    did earlier in the chapter. We also used `Log` to output the random number so
    that we can examine what went on:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来（仍然在第三步中），我们以与本章前面相同的方式生成一个随机数。我们还使用`Log`输出随机数，以便我们可以检查发生了什么：
- en: '[PRE121]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In step 4, we used an `if` statement with the logical OR operator to detect
    whether any of the passed-in parameters matches the random number we just generated,
    as shown in the following code:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们使用逻辑或运算符的`if`语句检测传入的参数中是否有任何一个与刚刚生成的随机数匹配，如下面的代码所示：
- en: '[PRE122]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If the condition is true, that is, if any of `try1`, `try2`, or `try3` equals
    `randNum`, then the following code is run. Our `found` Boolean value is set to
    `true` and a message is printed:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，即`try1`、`try2`或`try3`中的任何一个等于`randNum`，则执行以下代码。我们的`found`布尔值被设置为`true`，并打印一条消息：
- en: '[PRE123]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If the condition is not true, the `else` statement is executed, a different
    message is printed, and the `found` variable is left the same as it was—`false`:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件不为真，则执行`else`语句，打印不同的消息，并将`found`变量保持与之前相同的状态——`false`：
- en: '[PRE124]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, in our method, we return the `found` variable, which will be either
    `true` or `false`, to the calling code:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的方法中，我们将`found`变量返回给调用代码，该变量将是`true`或`false`：
- en: '[PRE125]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now we look at step 5, which is the code in the `onCreate` method, which calls
    our `guessANumber` method in the first place. We start by simply printing a message
    saying that we are in `onCreate` at the moment:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看第五步，这是`onCreate`方法中的代码，它首先调用我们的`guessANumber`方法。我们首先简单地打印一条消息，说明我们现在在`onCreate`中：
- en: '[PRE126]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Then we make the call to `guessANumber` with the three parameters. In this
    case, we use 1, 2, and 3, but any `int` values would have worked. However, we
    wrap the call in an `if` statement. This means that the `return` value from the
    method will be used to evaluate the `if` statement. Simply put, if `true` is returned,
    the `if` statement will be executed and "**Found It**!" will be printed:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用三个参数调用`guessANumber`。在这种情况下，我们使用了1、2和3，但任何`int`值都可以工作。然而，我们将调用包裹在一个`if`语句中。这意味着方法返回的`return`值将被用来评估`if`语句。简单来说，如果返回`true`，则执行`if`语句，并打印出"**找到了**！"：
- en: '[PRE127]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'On the contrary, if `false` is returned, the `else` statement gets executed
    and "**Can''t find it**" is printed:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果返回`false`，则执行`else`语句，并打印出"**找不到**"：
- en: '[PRE128]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Remember that we are dealing with random numbers, so you might need to run
    it a few times before you see this output:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们正在处理随机数，所以你可能需要运行几次才能看到这个输出：
- en: '![A working method](img/8859OS_04_03.jpg)'
  id: totrans-1042
  prefs: []
  type: TYPE_IMG
  zh: '![一个工作方法](img/8859OS_04_03.jpg)'
- en: Of course, you should note that the guesses sent to the function as parameters
    are arbitrary. As long as all the numbers are between 0 and 5 and are not duplicated,
    they will together have a 50 percent chance of finding the random number.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该注意，发送给函数作为参数的猜测是任意的。只要所有数字都在0到5之间且不重复，它们共同将有50%的机会找到随机数。
- en: On a closing note, if you've to read only one tip in this whole book, it should
    be this one.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束语中，如果你只在这本书中读一条提示，那应该是这条。
- en: Tip
  id: totrans-1045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Printing variable values to the console is a great way to examine what is going
    on inside your game and to find bugs.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量值打印到控制台是检查你的游戏内部发生什么以及找到错误的好方法。
- en: Let's look at another example of methods.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看方法的另一个例子。
- en: Exploring method overloading
  id: totrans-1048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: As we are learning, methods are really diverse and deep as a topic, but hopefully,
    taking a step at a time, we will see they are not daunting in any way. We will
    be using what we have learned about methods when we enhance our math game. We
    will be exploring methods even more deeply in [Chapter 6](ch06.html "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. For
    now, however, it will serve us well to look at one more topic on methods. Let's
    create a new project to explore **method** **overloading**.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们学习，方法这个主题真的是多种多样且深奥，但希望一步一步来，我们会发现它们并不令人畏惧。当我们增强我们的数学游戏时，我们会使用我们学到的关于方法的知识。我们将在[第6章](ch06.html
    "第6章。面向对象编程 – 使用他人的辛勤工作")*面向对象编程 – 使用他人的辛勤工作*中更深入地探索方法。然而，现在，查看关于方法的一个更多主题将对我们大有裨益。让我们创建一个新的项目来探索**方法重载**。
- en: 'As we will now see, we can create more than one method with the same name,
    provided the parameters are different. The code in this project is vastly simpler
    than that of the last project. It is how this code works that might appear slightly
    curious until we analyze it later:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在将看到的，如果我们提供的参数不同，我们可以创建多个具有相同名称的方法。这个项目中的代码比上一个项目简单得多。直到我们稍后分析，这个代码是如何工作的可能会显得有些奇怪：
- en: Create a new blank project called `Exploring Method Overloading`.
  id: totrans-1051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exploring Method Overloading`的新空白项目。
- en: 'In the first method, we will simply call it `printStuff` and pass an `int`
    variable via a parameter to be printed. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  id: totrans-1052
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们将简单地称其为`printStuff`，并通过参数传递一个要打印的`int`变量。在`onCreate`的括号关闭后但在`MainActivity`的括号关闭前复制这个方法的代码。当你被提示导入任何类时，只需点击**确定**：
- en: '[PRE129]'
  id: totrans-1053
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We will also call the second method `printStuff` but pass a `string` variable
    to be printed. Copy the code for this method after the closing bracket of `onCreate`
    but before the closing bracket of `MainActivity`. Again, when you are prompted
    to import any classes, simply click on **OK**:'
  id: totrans-1054
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将调用第二个方法`printStuff`，但传递一个要打印的`string`变量。在`onCreate`的括号关闭后但在`MainActivity`的括号关闭前复制这个方法的代码。再次，当你被提示导入任何类时，只需点击**确定**：
- en: '[PRE130]'
  id: totrans-1055
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Yet again, we will call this third method `printStuff` but pass a `string`
    variable and an `int` variable to be printed. As before, copy the code for this
    method after the closing bracket of `onCreate` but before the closing bracket
    of `MainActivity`:'
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将调用这个第三个方法`printStuff`，但传递一个要打印的`string`变量和一个`int`变量。和之前一样，在`onCreate`的括号关闭后但在`MainActivity`的括号关闭前复制这个方法的代码：
- en: '[PRE131]'
  id: totrans-1057
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the methods and print some values to the Android console:'
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将此代码写在`onCreate`方法的闭合括号之前，以调用方法并将一些值打印到Android控制台：
- en: '[PRE132]'
  id: totrans-1059
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Launch an emulator.
  id: totrans-1060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器。
- en: Run the app on the emulator.
  id: totrans-1061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。
- en: 'Here is the console output:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是控制台输出：
- en: '[PRE133]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: As you can see, Java has treated three methods with the same name as totally
    different methods. This, as we have just demonstrated, can be really useful. It
    is called **method overloading**.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Java将具有相同名称但参数不同的三个方法视为完全不同的方法。正如我们刚才所展示的，这可以非常实用。这被称为**方法重载**。
- en: Tip
  id: totrans-1065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Method overloading and overriding confusion**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法重载和重写的混淆**'
- en: 'Overloading and overriding are defined as follows:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 重载和重写如下定义：
- en: Overloading occurs when we have more than one method with the same name but
    different parameters
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们有一个以上同名但参数不同的方法时，会发生重载。
- en: Overriding occurs when we essentially replace a method with the same name and
    the same parameter list
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们用具有相同名称和参数列表的方法替换一个方法时，会发生重写。
- en: We know enough about overloading and overriding to complete this book, but if
    you are brave and your mind is wandering, you can override an overloaded method.
    However, that is something for another time.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对重载和重写有了足够的了解，可以完成这本书，但如果您勇敢且好奇心强，您可以重写一个重载的方法。但这将是另一篇文章的内容。
- en: 'This is how the preceding code works. In each of the three steps (2, 3, and
    4), we create a method called `printStuff`, but each `printStuff` method has different
    parameters, so each is a different method that can be called individually:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码的工作原理。在每个三个步骤（2、3和4）中，我们创建了一个名为`printStuff`的方法，但每个`printStuff`方法都有不同的参数，因此每个都是可以单独调用的不同方法：
- en: '[PRE134]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The body of each of the methods is simple. It just prints the passed-in parameters
    and confirms which version of the method is being called currently.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法体的内容都很简单。它只是打印传入的参数并确认当前正在调用哪个版本的方法。
- en: 'The next important part of our code is when we make it plain which method we
    want to call, using the appropriate parameters. In step 5, we call each of them
    in turn, using the appropriate parameters so that Java knows the exact method
    required:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的下一个重要部分是我们使用适当的参数明确指出要调用哪个方法。在第5步中，我们依次使用适当的参数调用它们，以便Java知道确切需要的方法：
- en: '[PRE135]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now we know more than enough about methods, loops, and random numbers to make
    some improvements to our math game.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对方法、循环和随机数有了足够的了解，可以对我们数学游戏进行一些改进。
- en: Enhancing our math game
  id: totrans-1077
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的数学游戏
- en: We are going to add some features to our math game using what we have just learned
    about methods and loops.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们刚刚学到的关于方法和循环的知识，为我们的数学游戏添加一些功能。
- en: As usual, the code is available for copying in the `Chapter4` folder of the
    code download. The project is in the `MathGameChapter4` subfolder and encompasses
    all the remaining phases of improvement covered in this chapter, including enhancing
    the UI, amending our game activity, `setQuestion`, `updateScoreAndLevel`, `isCorrect`,
    and calling our new methods.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，代码可在代码下载的`Chapter4`文件夹中复制。项目位于`MathGameChapter4`子文件夹中，包括本章中涵盖的所有剩余改进阶段，包括增强UI、修改我们的游戏活动、`setQuestion`、`updateScoreAndLevel`、`isCorrect`和调用我们的新方法。
- en: We will make the game change the question after each time we attempt the answer.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每次尝试回答问题后更改游戏的问题。
- en: We will also add difficulty levels to questions and random questions but within
    a range appropriate for that difficulty level.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为问题添加难度级别和随机问题，但都在适合该难度级别的范围内。
- en: We will show and update our score. The score goes up faster depending on the
    difficulty level of the question answered correctly.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将显示和更新分数。正确回答问题的难度级别越高，分数上升得越快。
- en: If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家回答问题错误，难度将回到最简单级别，分数归零。
- en: Enhancing the UI
  id: totrans-1084
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强UI
- en: Let's get on with modifying our math game UI to incorporate our new game features.
    We will be adding a TextView to display the score and another TextView to display
    the level.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修改我们的数学游戏UI，以融入我们新的游戏功能。我们将添加一个TextView来显示分数，并添加另一个TextView来显示等级。
- en: Open the `activity_game.xml` file in the editor window. We will add a new TextView
    to the very bottom of our UI for our score.
  id: totrans-1086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`activity_game.xml`文件。我们将在UI的底部添加一个新的TextView来显示分数。
- en: Drag a **Large Text** element from **Palette** and place it to the left, below
    our three answer buttons.
  id: totrans-1087
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**调色板**中拖动一个**大文本**元素，并将其放置在我们的三个答案按钮的左侧下方。
- en: Now we need to change the **id** property so that we can access our new TextView
    from our Java code. Ensure that the new TextView is selected by clicking on it.
    Now, in the **Properties** window, change the **id** property to `textScore`.
  id: totrans-1088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更改**id**属性，以便我们可以从Java代码中访问我们的新TextView。确保通过单击它来选择新的TextView。现在，在**属性**窗口中，将**id**属性更改为`textScore`。
- en: For the sake of clarity (although this step serves no use in programming), change
    the **text** property to `Score:999`.
  id: totrans-1089
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见（尽管这一步在编程中没有任何作用），将**text**属性更改为`Score:999`。
- en: Now put another **Large Text** element to the right of the one we just configured
    and change the **id** property to `textLevel`. The lower part of our UI should
    now look like this:![Enhancing the UI](img/8859OS_04_10.jpg)
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将另一个**大文本**元素放置在我们刚刚配置的元素的右侧，并将**id**属性更改为`textLevel`。我们的UI的下半部分现在应该看起来像这样：![增强UI](img/8859OS_04_10.jpg)
- en: Once again, for the sake of clarity (although this step serves no use in programming),
    change the **text** property to `Level:4`.
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次为了清晰起见（尽管这一步在编程中没有任何作用），将**text**属性更改为`Level:4`。
- en: Save the project.
  id: totrans-1092
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目。
- en: We have just added two new TextView elements and assigned them both an ID that
    we can refer to in our Java code.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了两个新的TextView元素，并给它们都分配了一个ID，我们可以在Java代码中引用它。
- en: Tip
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You have probably realized by now that the precise layout and size of our UI
    elements are unimportant as far as getting the game to work is concerned. This
    gives us a lot of flexibility in designing layouts for different screen sizes.
    As long as each layout for each screen size contains the same element types with
    the same IDs, the same Java code will work for different layouts. If you want
    to know more about designing for multiple screen sizes, take a look at [http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经意识到，就使游戏运行而言，我们UI元素的精确布局和大小并不重要。这为我们设计不同屏幕尺寸的布局提供了很大的灵活性。只要每个屏幕尺寸的布局都包含相同类型的元素和相同的ID，相同的Java代码就可以用于不同的布局。如果你想了解更多关于为多个屏幕尺寸设计的信息，请查看[http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html)。
- en: Now that we have our enhanced UI and an understanding of how the Java `Random`
    class works, we can add the Java code to implement our new features.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了增强的UI，并且理解了Java `Random`类的工作方式，我们可以添加Java代码来实现我们的新功能。
- en: The new Java code
  id: totrans-1097
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的Java代码
- en: As previously explained, the project code is available in the `Chapter4` folder
    of the downloadable code. The project is called `MathGameChapter4` and encompasses
    all the improvements covered in this chapter.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，项目代码位于可下载代码的`Chapter4`文件夹中。项目名为`MathGameChapter4`，涵盖了本章中涵盖的所有改进。
- en: In this phase, we will be adding lots of new code, moving some existing code,
    and modifying some existing code too. As so much is changing, we are going to
    approach the code from the very beginning. The new code will be explained completely,
    the code that has moved will be pointed out with a reason, and the code that has
    stayed the same and in the same place will have the least explanation.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将添加大量的新代码，移动一些现有代码，并修改一些现有代码。由于变化如此之多，我们将从头开始处理代码。新代码将完全解释，移动的代码将给出原因，而保持不变且位置相同的代码将解释得最少。
- en: We will first make some modifications and deletions to our existing code. We
    will then look at designing and implementing each of our new methods to improve
    our code and add our new features.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对我们的现有代码进行一些修改和删除。然后我们将查看设计和实现我们每个新方法，以改进我们的代码并添加我们的新功能。
- en: Amending GameActivity
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改GameActivity
- en: 'First, let''s perform the necessary amendments and deletions to our current
    code:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对我们的当前代码进行必要的修改和删除：
- en: Open the `GameActivity.java` file in the editor window.
  id: totrans-1103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`GameActivity.java`文件。
- en: 'We now need to consider the scope of the objects that represent our UI elements.
    Both `textObjectPartA` and `textObjectPartB` need to be accessible from the methods
    we will be creating soon. So let''s move their declarations, as we did with the
    multi-choice buttons in the previous chapter, out of the `onCreate` method so
    that they are accessible everywhere in our `GameActivity` class. The following
    code shows all our declarations so far. They are present immediately after the
    start of the `GameActivity` class. The recently added (or moved) declarations
    are highlighted. Notice that we have also added declarations for our two new TextViews
    and for the score and level displays. In addition, there are two new `int` variables
    that we can manipulate for our score and to keep track of our level. They are
    `currentScore` and `currentLevel`:'
  id: totrans-1104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要考虑代表我们 UI 元素的对象的作用域。`textObjectPartA` 和 `textObjectPartB` 都需要从我们将要创建的方法中可访问。所以，让我们像上一章中处理多选按钮一样，将它们的声明从
    `onCreate` 方法中移出，以便它们在 `GameActivity` 类的任何地方都可以访问。以下代码显示了迄今为止的所有声明。它们位于 `GameActivity`
    类开始之后。最近添加（或移动）的声明被突出显示。请注意，我们还添加了两个新 TextView 的声明以及得分和等级显示的声明。此外，还有两个新的 `int`
    变量，我们可以操作它们来记录我们的得分和等级。它们是 `currentScore` 和 `currentLevel`：
- en: '[PRE136]'
  id: totrans-1105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'All of the code that assigns text to our Buttons or TextViews objects, and
    the code that initializes the parts of our question and assigns the values for
    our wrong answers, are now going to change and move, so we need to delete it all.
    Everything shown in the following code is to be deleted:'
  id: totrans-1106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有分配文本给我们的按钮或 TextView 对象的代码，以及初始化问题部分并分配错误答案值的代码，现在都将改变并移动，因此我们需要删除所有这些。以下代码中显示的所有内容都将被删除：
- en: '[PRE137]'
  id: totrans-1107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The following code snippet needs to be deleted too:'
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段也需要删除：
- en: '[PRE138]'
  id: totrans-1109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'For clarity and context, here is the entire `onCreate` method as it currently
    stands. There is nothing new here, but you can see your code, which links our
    Button and TextView objects that we declared in step 2\. Again, this code includes
    our two new TextViews, which are highlighted, but everything else, which is described
    in steps 3 and 4, is deleted. As before, there is a piece of code that makes our
    game listen to button clicks:'
  id: totrans-1110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰和上下文，这里展示了当前整个 `onCreate` 方法的内容。这里没有新的内容，但你可以看到你的代码，它连接了我们步骤2中声明的按钮和 TextView
    对象。再次强调，这段代码包括我们新添加的两个 TextView，它们被突出显示，但步骤3和4中描述的其他所有内容都被删除了。和之前一样，有一段代码使我们的游戏能够监听按钮点击：
- en: '[PRE139]'
  id: totrans-1111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now we will delete some more code that we don''t need because we are going
    to make it more efficient by compartmentalizing it into our new methods and adding
    our new features at the same time. So in our `onClick` method, in each case of
    our `switch` statement, we want to delete the `if` and the `else` statements.
    We will be completely rewriting these, but we will leave in place the code that
    initializes our `answerGiven` variable. Our `onClick` method will now look like
    this:'
  id: totrans-1112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将删除一些我们不需要的代码，因为我们将通过将其分块到我们新的方法中并添加我们的新功能来使其更高效。所以，在我们的 `onClick` 方法中，在
    `switch` 语句的每个情况下，我们想要删除 `if` 和 `else` 语句。我们将完全重写这些，但我们将保留初始化我们的 `answerGiven`
    变量的代码。我们的 `onClick` 方法现在将看起来像这样：
- en: '[PRE140]'
  id: totrans-1113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Save your project.
  id: totrans-1114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目。
- en: Wow! That was a lot of code, but as we saw along the way, there were no new
    concepts. In step 2, we simply moved the initialization of our Button and TextView
    objects to a place where they will now be visible from anywhere within our class.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这有很多代码，但正如我们在过程中所看到的，没有新的概念。在步骤2中，我们只是将按钮和 TextView 对象的初始化移动到了一个它们现在可以从我们类中的任何地方可见的地方。
- en: In steps 3 and 4, we did a fair bit of deletion because we will no longer be
    making the question or populating the multi-choice buttons in `onCreate`, as this
    is not flexible enough. We will soon see how we improve on this.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3和4中，我们进行了大量的删除，因为我们不再在 `onCreate` 中创建问题或填充多选按钮，因为这不够灵活。我们很快就会看到如何改进这一点。
- en: In step 6, we deleted the code that tested whether the answer was correct or
    incorrect. However, as we saw, we still initialized the `answerGiven` variable
    in the same way—in the appropriate case of our `switch` statement in the `onClick`
    method.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6中，我们删除了测试答案是否正确的代码。然而，正如我们所看到的，我们仍然以相同的方式初始化了 `answerGiven` 变量——在 `onClick`
    方法中的 `switch` 语句的适当情况下。
- en: Great! Now we are ready to consider and design some new methods to compartmentalize
    our code, avoid repetitions in it, and add our extra features. Consider the following
    methods that we will soon implement.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们准备考虑和设计一些新的方法来划分我们的代码，避免其中的重复，并添加我们的额外功能。考虑以下我们将很快实现的方法。
- en: The methods
  id: totrans-1119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'We will now walk through writing some methods. As we will see, the methods
    will compartmentalize our code and prevent the implementation of our new features
    from causing the code to become too long and sprawling:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步编写一些方法。正如我们将看到的，这些方法将划分我们的代码，并防止我们的新功能的实现使代码变得过长和杂乱：
- en: We will write a `setQuestion` method to prepare a question of appropriate difficulty.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写一个`setQuestion`方法来准备一个难度适当的题目。
- en: We will write an `updateScoreAndLevel` method that will do just that. We will
    also write an `isCorrect` method that one of our other methods will use to evaluate
    the correctness of the answer.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写一个`updateScoreAndLevel`方法来完成这项工作。我们还将编写一个`isCorrect`方法，我们的其他方法将使用它来评估答案的正确性。
- en: Then we will strategically place the code that calls our new methods.
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将有策略地放置调用我们新方法的代码。
- en: We will do each of these tasks one at a time and explain the code along the
    way, as leaving the explanation to the end will make referring to individual steps
    cumbersome.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个完成这些任务，并在过程中解释代码，因为将解释留到最后会使引用单个步骤变得繁琐。
- en: 'We will use many of the features of Java that we learned in this chapter and
    the previous chapter. These include the following:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在本章和上一章中学到的许多Java特性。这些包括以下内容：
- en: Methods
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: A `for` loop
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`for`循环
- en: The switch control structure
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`控制结构'
- en: So let's get started with our first method.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从我们的第一个方法开始。
- en: The setQuestion method
  id: totrans-1130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`setQuestion`方法'
- en: We determined that we needed a method to prepare a question for us; `setQuestion`
    seems like a decent name for such a method. Every time our player gives an answer
    by tapping one of the three multi-choice buttons, a new question will need to
    be prepared.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定我们需要一个为我们准备问题的方法；`setQuestion`似乎是一个不错的名字。每次我们的玩家通过点击三个多选按钮之一给出答案时，都需要准备一个新的问题。
- en: This method will need to generate values for our `partA` and `partB` variables
    as well as show them in our TextViews referenced by the `textObjectPartA` and
    `textObjectPartB` objects. In addition, the method will need to assign the new
    correct answer to our `correctAnswer` variable, which will then be used to calculate
    some suitable incorrect answers. Finally, the method will show both the correct
    and incorrect answers on our multi-choice buttons.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要为我们的`partA`和`partB`变量生成值，并在由`textObjectPartA`和`textObjectPartB`对象引用的TextViews中显示它们。此外，该方法还需要将新的正确答案分配给我们的`correctAnswer`变量，然后该变量将被用来计算一些合适的错误答案。最后，该方法将在我们的多选按钮上显示正确和错误答案。
- en: 'Furthermore, our `setQuestion` method will need to take into account the level
    held in `currentLevel` to determine the range or difficulty of the question it
    will ask. Let''s go through the code. If you want to type this code as we go,
    then just make sure you place it after the closing bracket of `onClick` but before
    the closing bracket of our `GameActivity` class:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`setQuestion`方法需要考虑`currentLevel`中持有的级别，以确定它将提出的问题的范围或难度。让我们看一下代码。如果您想在我们进行时输入此代码，请确保将其放置在`onClick`的闭括号之后，但在我们的`GameActivity`类的闭括号之前：
- en: 'First of all, we have the method signature and the opening curly brace before
    the body of our method:'
  id: totrans-1134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有方法签名和位于方法体之前的方法开大括号：
- en: '[PRE141]'
  id: totrans-1135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This tells us that the return type is `void`, so `setQuestion` will not return
    a value to the code that calls it. Also, there are no parameters here, so it does
    not need any value passed for it to work. Let''s see what it does. Now we enter
    the code to generate the two parts of the question:'
  id: totrans-1136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉我们返回类型是`void`，所以`setQuestion`不会向调用它的代码返回任何值。此外，这里没有参数，所以它不需要任何值传递给它才能工作。让我们看看它做了什么。现在我们进入代码以生成问题的两部分：
- en: '[PRE142]'
  id: totrans-1137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the previous step, we declared a new `int` variable, `numberRange`, and
    initialized it by multiplying the player''s `currentLevel` value by `3`. Then
    we got a new `Random` object called `randInt` and used it to generate new values
    based on `numberRange`. We did this to the `partA` and `partB` variables. As the
    value of `currentLevel` increases, so potentially does the difficulty of the question.
    Now, just as we have written in the past, we write this:'
  id: totrans-1138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们声明了一个新的`int`变量`numberRange`，并通过将玩家的`currentLevel`值乘以`3`来初始化它。然后我们得到了一个新的`Random`对象，称为`randInt`，并使用它根据`numberRange`生成新的值。我们对`partA`和`partB`变量都做了这样的事情。随着`currentLevel`值的增加，问题的难度也可能增加。现在，就像我们过去所写的那样，我们写下这个：
- en: '[PRE143]'
  id: totrans-1139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We assigned the answer of our new multiplication question to `correctAnswer`.
    Then we declared and assigned two incorrect answers to the new `int` variables,
    `wrongAnswer1` and `wrongAnswer2`. We also used the `setText` method of our TextView
    objects to display the question to the player. Notice that we have not yet displayed
    the correct and incorrect answers. Here it is. Try to work out what is happening
    here:'
  id: totrans-1140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将新乘法问题的答案分配给`correctAnswer`。然后我们声明并分配了两个错误的答案给新的`int`变量，`wrongAnswer1`和`wrongAnswer2`。我们还使用了TextView对象的`setText`方法来向玩家显示问题。请注意，我们还没有显示正确和错误的答案。下面是它们：尝试分析这里发生了什么：
- en: '[PRE144]'
  id: totrans-1141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In the preceding code, we used our `Rando`m object, `randInt`, to generate
    a number between 0 and 2, and assigned the value to a new `int` variable called
    `buttonLayou`t. We then used `buttonLayou`t to switch between all its possible
    values: 0, 1, or 2\. Each `case` statement sets the correct and incorrect answers
    to the multi-choice buttons in a slightly different order, so the player can''t
    just keep tapping the same button over and over to achieve a massive score. Notice
    the extra closing bracket after the closing bracket of the switch. This is the
    end of our `setQuestion` method.'
  id: totrans-1142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了我们的`Rando`m对象`randInt`来生成一个介于0和2之间的数字，并将其分配给一个新的`int`变量，称为`buttonLayou`t。然后我们使用`buttonLayou`t在所有可能的值之间切换：0、1或2。每个`case`语句将正确和错误的答案以稍微不同的顺序设置到多选按钮中，这样玩家就不能只是不断地连续点击同一个按钮以获得高分。注意在关闭括号后面的额外关闭括号。这是我们的`setQuestion`方法的结束。
- en: We explained the code fairly thoroughly as we went through it but it might be
    worthwhile to just take a closer look at some parts again.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解释代码时相当详细，但再次仔细看看一些部分可能是有益的。
- en: 'In step 1, we saw our method signature with a `void` return type and no parameters.
    In step 2, we generated some random numbers that will be within a certain range.
    This range isn''t as obvious as it might seem at first. First, we assigned, declared,
    and initialized `numberRange` like this:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们看到了我们的方法签名，它有一个`void`返回类型且没有参数。在步骤2中，我们生成了一些随机数，这些数将位于某个范围内。这个范围可能不像一开始看起来那么明显。首先，我们像这样分配、声明和初始化`numberRange`：
- en: '[PRE145]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'So if the player is at the first question, then `currentLevel` will hold the
    value `1` and `numberRange` will be initialized as `3`. Then we made a new `Random`
    object as previously discussed and entered this line of code:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果玩家处于第一个问题，那么`currentLevel`将持有值`1`，而`numberRange`将被初始化为`3`。然后我们像之前讨论的那样创建了一个新的`Random`对象，并输入了这一行代码：
- en: '[PRE146]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'What occurs here is that the `nextInt` method of the `Random` object, `randInt`,
    will return a value of either 0, 1, or 2 because we have given it a seed of 3\.
    We don''t want any zeros in our game because they result in very easy multiplication,
    so we enter this:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，`Random`对象的`nextInt`方法，即`randInt`，将返回0、1或2的值，因为我们给它提供了一个3的种子。我们不希望我们的游戏中出现任何零，因为它们会导致非常简单的乘法，所以我们进入这个：
- en: '[PRE147]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This operator, which you probably remember from [Chapter 3](ch03.html "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*, when we discussed
    operators, adds 1 to `partA`. We then do exactly the same to our `partB` variable,
    which means that assuming that the player is still on level 1, they will have
    a question that will be one of the following:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符，你可能还记得从[第3章](ch03.html "第3章。Speaking Java – 你的第一个游戏")，*Speaking Java –
    你的第一个游戏*，当我们讨论操作符时，会将`partA`增加1。然后我们对`partB`变量做完全相同的事情，这意味着如果玩家仍然在第一级，他们将有一个以下的问题：
- en: 1 x 1, 1 x 2, 1 x 3, 2 x 1, 2 x 2, 2 x 3, 3 x 1, 3 x 2, or 3 x 3
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 1，1 x 2，1 x 3，2 x 1，2 x 2，2 x 3，3 x 1，3 x 2，或 3 x 3
- en: As the level increases, the potential range of the question increases significantly.
    So at level 2, the options are that either part of the question could be from
    1 to 6; for level 3, from 1 to 9; and so on. It is still possible to get an easy
    question on a higher level but it becomes less likely as the levels advance. Finally
    in this step, we display the question to the player using the `setText` method.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 随着难度的提升，问题的潜在范围显著增加。因此，在2级时，问题选项可以是1到6的部分；对于3级，则是1到9；以此类推。在更高难度级别上仍然有可能得到一个简单的问题，但随着难度的增加，这种情况变得越来越不可能。最后在这个步骤中，我们使用`setText`方法将问题显示给玩家。
- en: In step 3, we have seen before but this time we varied it slightly. We calculate
    and assign a value for `correctAnswer`, and declare and assign values to `wrongAnswer1`
    and `wrongAnswer2`, which will hold the wrong answer choices for our buttons.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们之前已经看到过，但这次我们稍作修改。我们计算并分配一个值给`correctAnswer`，并声明和分配`wrongAnswer1`和`wrongAnswer2`的值，它们将持有按钮的错误答案选项。
- en: Part 3 varies very slightly from what we did in `onCreate` in the previous chapter
    because we subtract and add 2 to `wrongAnswer1` and `wrongAnswer2`, respectively.
    This makes guessing the answer to multiplication questions a little harder because
    you can't eliminate answers based on whether they are odd or even.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 第3部分与上一章中`onCreate`所做的内容略有不同，因为我们分别从`wrongAnswer1`和`wrongAnswer2`中减去和加上2。这使得猜测乘法问题的答案变得更难，因为你不能根据答案的奇偶性来排除答案。
- en: Step 4 simply randomizes which buttons the correct and incorrect answers will
    be placed on. We don't need to keep track of this because when the time comes
    to compare the value on the button pressed with the correct answer, we can simply
    use our Java code to discover it as we did in [Chapter 3](ch03.html "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步简单地随机化正确和错误答案将被放置的按钮。我们不需要跟踪这一点，因为当需要比较按下的按钮上的值与正确答案时，我们可以简单地使用我们的Java代码来发现它，就像我们在[第3章](ch03.html
    "第3章。Speaking Java – 你的第一个游戏")中做的那样，*Speaking Java – 你的第一个游戏*。
- en: The updateScoreAndLevel method
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`updateScoreAndLevel`方法'
- en: The name of this method speaks for itself. Because the keeping of the score
    is not simple and because we want higher levels to yield higher scores, we will
    compartmentalize the code to keep our program readable. If we then want to make
    modifications to the scoring system, they can all take place in there.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的名字本身就说明了它的作用。因为保持分数并不简单，而且我们希望更高难度级别产生更高的分数，所以我们将代码分块以保持程序的可读性。如果我们想要修改评分系统，所有这些修改都可以在这里进行。
- en: Let's write the code.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码。
- en: 'This code can go anywhere within the opening and closing braces of `GameActivity
    {}`, but it is good practice to place them in the approximate order they will
    be used. So why not start adding your code after the closing brace of `setQuestion`
    but obviously before the closing brace of `GameActivity`? Here is the method signature
    with the opening brace:'
  id: totrans-1159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码可以放在`GameActivity {}`的任何开闭花括号内，但按照它们将被使用的顺序放置是良好的实践。所以为什么不从`setQuestion`的闭花括号之后开始添加你的代码，但显然在`GameActivity`的闭花括号之前呢？以下是带有开花括号的方法签名：
- en: '[PRE148]'
  id: totrans-1160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'This tells us that our method does not return a value but that it does receive
    an `int`, which it will require to do its stuff. The name of the parameter is
    a big clue to what we will be passing. We will see that in action in the body
    in a minute, but if passing the player''s answer to this method instead of the
    `isCorrect` method is a bit confusing, we will see things become clearer in the
    next chunk of code. Here is the next part of the code to add:'
  id: totrans-1161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的方法不返回任何值，但它确实接收一个`int`类型的参数，它将需要这个参数来完成其功能。参数的名称为我们提供了将要传递内容的很大线索。我们将在下一分钟看到它的实际应用，但如果将玩家的答案传递给这个方法而不是`isCorrect`方法有些令人困惑，我们将在下一部分代码中看到事情变得更加清晰。以下是需要添加的代码的下一部分：
- en: '[PRE149]'
  id: totrans-1162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'There is a lot happening here, so we will dissect it more once we have the
    method completed. Basically, it calls the `isCorrect` method (which we will write
    soon) and if the response is `true`, adds to the player''s score in a `for` loop.
    After that, the method adds 1 to `currentLevel`. Here comes the `else` part of
    the code in case the response from `isCorrect` is `false`:'
  id: totrans-1163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以我们将在方法完成后再对其进行更详细的剖析。基本上，它调用`isCorrect`方法（我们很快就会编写），如果响应是`true`，则通过`for`循环给玩家的分数加1。之后，该方法将`currentLevel`增加1。以下是代码中的`else`部分，以防`isCorrect`的响应是`false`：
- en: '[PRE150]'
  id: totrans-1164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'If the response is `false`, that is, if the player got the answer wrong, the
    `currentScore` variable is set to `0` and the level back to `1`. Finally for this
    method, we type the following:'
  id: totrans-1165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应是`false`，即如果玩家答错了，`currentScore`变量将被设置为`0`，并将等级回退到`1`。最后，对于这个方法，我们输入以下内容：
- en: '[PRE151]'
  id: totrans-1166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: In the previous step, we updated the actual TextViews that the player sees with
    the newly determined score and level. The method then ended and the control of
    the program returned to the code that called `updateScoreAndLevel` to begin with.
    Save your project.
  id: totrans-1167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们更新了玩家看到的实际TextViews，以显示新确定的分数和等级。然后方法结束，程序的控制在最初调用`updateScoreAndLevel`的代码处返回。保存你的项目。
- en: We explained most of the code as we went but it might be good to quickly review
    it and dig a bit deeper into certain parts, especially the call to `isCorrect`
    in that odd-looking `if` statement.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讲解代码的过程中解释了大部分内容，但快速回顾一下并深入探讨某些部分可能是个好主意，特别是那个看起来奇怪的`if`语句中的`isCorrect`调用。
- en: 'In step 1, we began with the method signature. Then in step 2, we began with
    the aforementioned curious `if`:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们从方法签名开始。然后在第二步中，我们从上述那个奇怪的`if`语句开始：
- en: '[PRE152]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We have seen this type of statement before in the *A working method* example
    in the *Methods* section of this chapter. What is happening here is that the call
    to `isCorrect` is replacing the statement to be evaluated, or rather it *is* the
    statement to be evaluated. So `isCorrect` is called with the `answerGiven` variable.
    The `answerGiven` variable, as you might remember, was passed to `updateScoreAndLevel`.
    This time, it is passed to the `isCorrect` method, which will do some work with
    it and perhaps a few other things. Then it will return to the `if` statement a
    value of `true` or `false`. The value will be true if the question is answered
    correctly and false if not.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的“方法”部分的“*A working method*”示例中已经见过这种类型的语句。这里发生的情况是，`isCorrect`的调用正在替换要评估的语句，或者说它*就是*要评估的语句。所以`isCorrect`被调用时，带有`answerGiven`变量。你可能记得，`answerGiven`变量被传递给了`updateScoreAndLevel`。这次，它被传递给了`isCorrect`方法，该方法将对其进行一些操作，也许还有其他一些事情。然后它将返回一个`true`或`false`的值给`if`语句。如果问题被正确回答，该值将为`true`；如果没有，则为`false`。
- en: 'Assuming the `if` statement evaluates to true, the program runs this bit of
    code (also from step 2):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`if`语句评估为真，程序将运行以下这段代码（也是第二步的内容）：
- en: '[PRE153]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The code enters a `for` loop where the starting variable `i` is initialized
    to 1 like this: `int i = 1;`. Furthermore, the loop is instructed to continue
    as long as `i` is less than or equal to our `currentLevel` variable. Then within
    the `for` loop, we add `i` to the current score. As an example, let''s assume
    that the player has just got a question correct and we enter the `for` loop with
    `currentLevel` at 1\. The player''s score is still at 0 because this is their
    first correct answer.'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码进入一个`for`循环，其中起始变量`i`被初始化为1，如下所示：`int i = 1;`。此外，循环被指令在`i`小于或等于我们的`currentLevel`变量时继续。然后在`for`循环内，我们将`i`加到当前分数上。例如，假设玩家刚刚答对了一个问题，并且我们带着`currentLevel`为1进入`for`循环。玩家的分数仍然是0，因为这是他们的第一个正确答案。
- en: 'At pass 1, we get the following:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，我们得到以下结果：
- en: '`i = 1`, so it is equal to `currentLevel`, which is also 1\. So we enter the
    `for` loop'
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，因此它等于`currentLevel`，也就是1。所以我们进入了`for`循环'
- en: '`i = 1`, so `currentScore` equals 0'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，所以`currentScore`等于0'
- en: We add `i`, which is `1`, to `currentScore`
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`i`，即`1`，加到`currentScore`
- en: Our `currentScore` variable is now equal to `1`
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`currentScore`变量现在等于`1`
- en: 'At pass 2, the following steps take place:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历中，发生以下步骤：
- en: '`i` is incremented to 2, so it is now greater than `currentLevel`, which is
    1'
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`增加到2，所以它现在大于`currentLevel`，即1'
- en: The `for` loop condition evaluates to `false` and we continue with the code
    after the `for` loop
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环的条件评估为`false`，我们继续执行`for`循环之后的代码'
- en: '`currentLevel` is increased by 1 to 2'
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentLevel`增加1到2'
- en: Now let's look at that `for` loop again assuming that the player gets the next
    question correct as well, and we are back in `updateScoreAndLevel`. This time,
    `isCorrect` has evaluated true and we enter the `for` loop but with a slightly
    different situation than the last time.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看看那个`for`循环，假设玩家也答对了下一个问题，并且我们回到了`updateScoreAndLevel`。这次，`isCorrect`评估为真，我们进入了`for`循环，但情况与上次略有不同。
- en: 'At pass 1, the following steps take place:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遍历中，发生以下步骤：
- en: '`i = 1`, so `i` is less than `currentLevel` is 2 and we enter the `for` loop'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，所以`i`小于`currentLevel`，即2，我们进入了`for`循环'
- en: '`i = 1`, `currentScore` `= 1`'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，`currentScore` `= 1`'
- en: We add `i`, which is equal to 1, to `currentScore`
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `i`（等于 1）添加到 `currentScore`
- en: Our `currentScore` variable is now equal to 2
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `currentScore` 变量现在等于 2
- en: 'At pass 2, we have the following steps happening:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 次遍历时，发生以下步骤：
- en: '`i` is incremented to 2 and it is now equal to `currentLevel`, which is also
    2'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 增加到 2，现在等于 `currentLevel`，也就是 2'
- en: '`i = 2`, `currentScore = 2`'
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 2`，`currentScore = 2`'
- en: We add `i`, which is now equal to 2, to `currentScore`
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `i`（现在等于 2）添加到 `currentScore`
- en: Our `currentScore` variable is now equal to 4
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `currentScore` 变量现在等于 4
- en: 'At pass 3, the following steps take place:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 次遍历时，以下步骤发生：
- en: '`i` is incremented to 3 and it is now greater than `currentLevel`, which is
    2.'
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 增加到 3，现在大于 `currentLevel`，即 2。'
- en: The `for` loop condition evaluates to false and we continue with the code after
    the `for` loop.
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的条件评估为 `false`，我们继续执行 `for` 循环之后的代码。'
- en: The value of `currentLevel` is increased by 1 to 3\. So the next time, we will
    have an extra pass through our `for` loop.
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentLevel` 的值增加 1 到 3。所以下次，我们将有额外的 `for` 循环遍历。'
- en: 'What is happening is that with each level, the player is being rewarded with
    another pass through the `for` loop, and each pass through the `for` loop adds
    a greater value to their score. To summarize what happens in the `for` loop, here
    is a brief table of values showing how the player''s score is increased based
    on the `currentLevel` variable:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，随着每个等级的提升，玩家将获得另一个遍历 `for` 循环的机会，每次遍历 `for` 循环都会给他们的分数增加更大的值。为了总结 `for`
    循环中发生的事情，以下是一个简短的值表，显示了玩家的分数是如何根据 `currentLevel` 变量增加的：
- en: '| currentLevel | Added to currentScore | currentScore after for loop |'
  id: totrans-1200
  prefs: []
  type: TYPE_TB
  zh: '| currentLevel | 添加到当前分数 | 循环后的当前分数 |'
- en: '| --- | --- | --- |'
  id: totrans-1201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 1 | 1 |'
  id: totrans-1202
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '| 2 | 3 (1 + 2) | 4 |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 (1 + 2) | 4 |'
- en: '| 3 | 6 (1 + 2 + 3) | 10 |'
  id: totrans-1204
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 6 (1 + 2 + 3) | 10 |'
- en: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
- en: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
- en: Note
  id: totrans-1207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, we could have kept it really simple and not used a `for` loop. We
    could just use `currentScore = currentScore + level` perhaps, but that doesn't
    offer an ever increasing reward in the same way as our current solution does and
    we wouldn't have been able to practice our `for` loops either.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本来可以保持它非常简单，不使用 `for` 循环。我们可能只是使用 `currentScore = currentScore + level`，但这样并不能像我们当前解决方案那样提供不断增长的奖励，而且我们也无法练习我们的
    `for` 循环。
- en: If `if(isCorrect(answerGiven))` evaluates to `false`, it simply resets the score
    to 0 and the level to 1 in step 3\. Step 4 then updates our TextViews for the
    score and the level using the variables we have just discussed.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `if(isCorrect(answerGiven))` 评估为 `false`，它将简单地在第 3 步将分数重置为 0，并将等级重置为 1。然后第
    4 步使用我们刚刚讨论的变量更新我们的 TextViews 分数和等级。
- en: Now we have just one more method to write. Of course, this is the `isCorrect`
    method, which we just called.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要编写一个方法。当然，这是 `isCorrect` 方法，我们刚刚调用过。
- en: The isCorrect method
  id: totrans-1211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`isCorrect` 方法'
- en: 'This method is nice and simple because we have seen all of the relevant code
    before. It is just the method signature and the return value that we need to look
    at carefully:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很好也很简单，因为我们之前已经看到了所有相关的代码。我们只需要仔细查看方法签名和返回值：
- en: 'Enter the code just after the closing brace of the `updateScoreAndLevel` method
    but before the closing brace of the `GameActivity` class. Type the method signature
    like this:'
  id: totrans-1213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `updateScoreAndLevel` 方法的闭合括号之后和 `GameActivity` 类的闭合括号之前输入代码。输入方法签名如下：
- en: '[PRE154]'
  id: totrans-1214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here we can see that the method must return a Boolean value, `true` or `false`.
    If it doesn''t, then the program won''t compile. This guarantees that when we
    use this method as the evaluation expression in the `updateScoreAndLevel` method,
    we will definitely get a result. It can be true or false. The signature also shows
    us the `answerGiven` variable passed in, ready for us to use. Type this code,
    which will determine that result:'
  id: totrans-1215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们可以看到，该方法必须返回一个布尔值，`true` 或 `false`。如果不这样做，程序将无法编译。这保证了当我们使用此方法作为 `updateScoreAndLevel`
    方法的评估表达式时，我们肯定会得到一个结果。它可以是 `true` 或 `false`。签名还显示了我们传入的 `answerGiven` 变量，准备好供我们使用。输入以下代码，这将确定该结果：
- en: '[PRE155]'
  id: totrans-1216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'We have seen almost all of the preceding code before. The exception is that
    we declare a Boolean variable, `correctTrueOrFalse`, which we assign to `true`
    if the player answers correctly and to `false` if not. We know whether the player
    is correct or not because we compare `answerGiven` to `correctAnswer` in the `if`
    statement. Notice that we have also triggered the appropriate Android pop-up toast
    message as we did before. Finally, we do this:'
  id: totrans-1217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前几乎看到了所有的代码。例外的是，我们声明了一个布尔变量`correctTrueOrFalse`，如果玩家回答正确，我们将其赋值为`true`，如果不正确，则赋值为`false`。我们知道玩家是否正确，因为我们比较了`answerGiven`和`correctAnswer`在`if`语句中。注意，我们像之前一样触发了适当的Android弹出提示消息。最后，我们这样做：
- en: '[PRE156]'
  id: totrans-1218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: We just returned whatever value is contained within `correctTrueOrFalse`. So
    the critical `if` statement in `updateScoreAndLevel`, which we discussed in detail,
    will know what to do next.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是返回了`correctTrueOrFalse`中包含的任何值。所以，在`updateScoreAndLevel`中，我们详细讨论的关键的`if`语句将知道接下来要做什么。
- en: To make sure we understand what is happening in `isCorrect`, let's go through
    the sequence of events in our code. In step 1 we have the method signature. We
    see that we will return a `true` or `false` value and receive `int`.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们理解`isCorrect`中发生的事情，让我们回顾一下我们代码中的事件序列。在步骤1中，我们有方法签名。我们看到我们将返回一个`true`或`false`值，并接收`int`。
- en: In step 2, we declare a Boolean variable called `correctTrueOrFalse` to hold
    the value we will soon return. Then we test for a right or wrong answer with `if(answerGiven
    == correctAnswer)`. If the two compared values match, a congratulatory message
    pops up and we assign `true` to our Boolean variable. Of course, if the `if` statement
    is `false`, we offer commiserations to the player and assign `false` to our important
    Boolean.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们声明了一个名为`correctTrueOrFalse`的布尔变量来保存我们将要返回的值。然后我们用`if(answerGiven ==
    correctAnswer)`测试正确或错误的答案。如果比较的两个值匹配，就会弹出恭喜的消息，并将`true`赋值给我们的布尔变量。当然，如果`if`语句是`false`，我们向玩家表示同情，并将`false`赋值给我们的重要布尔变量。
- en: Finally in step 3, we send back `true` or `false` so that the `updateScoreAndLevel`
    method can proceed with its work.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在步骤3中，我们发送回`true`或`false`，以便`updateScoreAndLevel`方法可以继续其工作。
- en: We have now implemented all our methods. It's time to put them to work.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了所有的方法。现在是时候将它们投入使用。
- en: Calling our new methods
  id: totrans-1224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用我们的新方法
- en: 'Of course, our shiny new methods won''t do anything until we call them. So
    here is the plan to call these methods:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们这些闪亮的新方法在未被调用之前不会做任何事情。所以，这里是调用这些方法的计划：
- en: 'When the game starts, we want to set a new question for the player. Therefore,
    as the last line of code in our `onCreate` method, we can call our `setQuestion`
    method like this:'
  id: totrans-1226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏开始时，我们希望为玩家设置一个新的问题。因此，作为`onCreate`方法中的最后一行代码，我们可以这样调用我们的`setQuestion`方法：
- en: '[PRE157]'
  id: totrans-1227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Then we turn our attention to the `onClick` method, which already detects which
    button has been pressed and loads the player''s answer into our `answerGiven`
    variable. So at the end of the `onClick` method, after the closing brace of the
    `switch` statement, we just call this function:'
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将注意力转向`onClick`方法，它已经检测到哪个按钮被按下，并将玩家的答案加载到我们的`answerGiven`变量中。所以，在`onClick`方法的末尾，在`switch`语句的闭合括号之后，我们只需调用这个函数：
- en: '[PRE158]'
  id: totrans-1229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This sends our player''s attempted answer to `updateScoreAndLevel`, which evaluates
    the answer using `isCorrect`, adds points, and increments the score if the answer
    is correct or resets the score and level if not. All that we need now is another
    question. Add this line. It will ask another question:'
  id: totrans-1230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将玩家的尝试答案发送到`updateScoreAndLevel`，它使用`isCorrect`评估答案，如果答案正确则加分并增加分数，如果不正确则重置分数和等级。我们现在需要的只是另一个问题。添加这一行。它将询问另一个问题：
- en: '[PRE159]'
  id: totrans-1231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'So now what happens is that the player starts our math game by clicking on
    its icon on their Android device. Our `GameActivity` class declares a few variables
    that we need access to throughout:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在发生的情况是，玩家通过点击他们Android设备上的图标来开始我们的数学游戏。我们的`GameActivity`类声明了一些我们需要在整个过程中访问的变量：
- en: '[PRE160]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Then `onCreate` initializes some variables and gets our buttons ready to receive
    clicks from the player before asking the first question by calling `setQuestion`.
    The game then waits for the player to attempt an answer. When the player attempts
    an answer, it is dealt with by `onClick`, `updateScoreAndLevel`, and `isCorrect`.
    Then the program control comes back to `onClick` again, `setQuestion` is called
    again, and we wait for the player's answer once more.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `onCreate` 方法初始化一些变量，并使我们的按钮准备好接收玩家的点击，在调用 `setQuestion` 方法提出第一个问题之前。游戏随后等待玩家尝试回答。当玩家尝试回答时，它会被
    `onClick`、`updateScoreAndLevel` 和 `isCorrect` 处理。然后程序控制回到 `onClick`，再次调用 `setQuestion`，我们再次等待玩家的回答。
- en: Finishing touches
  id: totrans-1235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成细节
- en: Our math game is coming along nicely. Unfortunately, we have to move on soon.
    The project has served its purpose to demonstrate some fundamentals of Java programming
    as well as some key Android features. Now we need to start introducing some more
    game-related topics.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏数学游戏进展顺利。不幸的是，我们很快就要继续前进。该项目已经完成了它的目的，展示了Java编程的一些基本原理以及一些关键的Android功能。现在我们需要开始介绍一些更多与游戏相关的话题。
- en: Before we go on, there are two really easy things to make our game a bit more
    cool and complete. In case you are wondering about the High Scores button, we
    will see how that can be implemented when we look at our next game project in
    [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming and Java
    Essentials*. You will then have enough information to easily come back and implement
    high scores on your own.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有两件非常简单的事情可以使我们的游戏更加酷和完整。如果你对高分按钮感到好奇，我们将在查看下一个游戏项目[第5章](ch05.html "第5章。游戏和Java基础")时了解如何实现，即
    *游戏和Java基础*。那时，你将拥有足够的信息轻松地回来并自己实现高分。
- en: The other feature that would really round off our game and make it more playable
    is an overall or per question time limit. Perhaps even increasing the score based
    on how quickly the correct answer is given will help. We need some new Java tricks
    up our sleeves before we can do that, but we will see how we can measure and respond
    to time in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming
    and Java Essentials*, when we talk about threads.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个真正使我们的游戏更加完整并使其更具可玩性的功能是整体或每题的时间限制。也许甚至根据给出正确答案的速度来增加分数也会有所帮助。在我们能够做到这一点之前，我们需要一些新的Java技巧，但我们将看到如何在[第5章](ch05.html
    "第5章。游戏和Java基础")，*游戏和Java基础*中，当我们谈到线程时，如何测量和响应时间。
- en: 'Now we will quickly learn two improvements:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速学习两个改进：
- en: Locking the screen orientation
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定屏幕方向
- en: Changing the home screen image
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改主屏幕图像
- en: Going full screen and locking orientation
  id: totrans-1242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全屏显示和锁定方向
- en: You might have noticed that if you rotate your device while the app is running,
    not only does your game UI get distorted but the game progress is also lost. What
    goes wrong is that when the device is rotated, the `onPause` and `onStop` methods
    are called. Then the app is restarted. We could handle this by overriding the
    `onPause` method and saving our data. We will do this later. For now we don't
    want the screen to rotate anyway, so if we stop it we solve two problems in one.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，如果你在应用运行时旋转设备，不仅你的游戏用户界面会扭曲，游戏进度也会丢失。出问题的是，当设备旋转时，会调用 `onPause` 和 `onStop`
    方法。然后应用被重新启动。我们可以通过重写 `onPause` 方法并保存我们的数据来处理这个问题。我们将在稍后做这个。现在我们无论如何都不想屏幕旋转，所以如果我们停止它，我们就能一劳永逸地解决两个问题。
- en: 'While adding code to this file, Android Studio may try to "help" by adding
    extra formatting. If you get red error indicators, you can compare your `AndroidManifest.xml`
    file with the one in the code download in the `Chapter4/MathGameChapter4` folder.
    Alternatively, you can simply replace the contents of your file with the contents
    of the file in the download. The step-by-step changes are detailed in this guide
    just to highlight what is changing:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在向此文件添加代码时，Android Studio 可能会试图“帮助”通过添加额外的格式。如果你得到红色的错误指示器，你可以将你的 `AndroidManifest.xml`
    文件与 `Chapter4/MathGameChapter4` 文件夹中的代码下载中的文件进行比较。或者，你可以简单地用下载的文件内容替换你文件的内容。逐步更改在此指南中详细说明，只是为了突出显示正在更改的内容：
- en: This is the first step in locking the app to portrait. Open the `AndroidManifest.xml`
    file. It is located directly below the `res` folder in the Project Explorer. Find
    the first opening `<activity` in the code.
  id: totrans-1245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是锁定应用为纵向的第一步。打开 `AndroidManifest.xml` 文件。它在项目资源管理器中的 `res` 文件夹下方直接位置。找到代码中的第一个
    `<activity>` 开标签。
- en: 'Enter a new line as follows:'
  id: totrans-1246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式输入新行：
- en: '[PRE161]'
  id: totrans-1247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Repeat step 2 after the second instance of `<activity`. We have now locked both
    the menu and game screens in portrait mode.
  id: totrans-1248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个`<activity>`实例之后重复步骤2。现在我们已经锁定菜单和游戏屏幕为横幅模式。
- en: 'To make the game full screen, in the same file, find the following text and
    add the line in bold after it but before the closing `>` sign:'
  id: totrans-1249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使游戏全屏，在同一文件中，找到以下文本，并在其后面但关闭`>`符号之前添加一行粗体：
- en: '[PRE162]'
  id: totrans-1250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Make the same change to the `GameActivity` activity like this. Again, here
    is the code in context in order to avoid mistakes with these `>` signs:'
  id: totrans-1251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的更改应用到`GameActivity`活动上，如下所示。再次，这里是在上下文中提供的代码，以避免这些`>`符号的错误：
- en: '[PRE163]'
  id: totrans-1252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Save the project.
  id: totrans-1253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目。
- en: Now, when you rotate the device during gameplay, the portrait orientation will
    be fixed.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在游戏过程中旋转设备时，横幅方向将被固定。
- en: Adding a custom image (instead of the Android icon)
  id: totrans-1255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义图片（而不是Android图标）
- en: 'We probably don''t want to have the Android image on our finished game home
    screen, so here is the procedure to change it. This quick guide relies on you
    having an image you would like to use:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不想在我们的完成游戏主屏幕上显示Android图片，所以这里是更改它的步骤。这个快速指南依赖于你有一个想要使用的图片：
- en: First, we need to add the required image to the layout folder. Copy your image
    file by clicking on it in **Windows Explorer** and using *Ctrl* + *C*.
  id: totrans-1257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将所需的图片添加到布局文件夹中。通过在**Windows资源管理器**中点击图片并使用*Ctrl* + *C*来复制你的图片文件。
- en: Now find the `drawable-mdpi` folder in the Android Studio Project Explorer.
    Click on the folder.
  id: totrans-1258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在Android Studio项目资源管理器中找到`drawable-mdpi`文件夹。点击该文件夹。
- en: Paste the image to the folder using *Ctrl* + *V*.
  id: totrans-1259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *V*将图片粘贴到文件夹中。
- en: Now the image is a part of our project. We simply need to choose it in the same
    way as we chose the image of the Android robot previously. Open `activity_main.xml`
    in the editor window and click on **ImageView** (currently an Android robot).
  id: totrans-1260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在图片已成为我们项目的一部分。我们只需像之前选择Android机器人的图片一样选择它。在编辑窗口中打开`activity_main.xml`，并点击**ImageView**（目前是Android机器人）。
- en: In the **Properties** window, find the **src** property. Click on it and then
    on **...**.
  id: totrans-1261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中，找到**src**属性。点击它，然后点击**...**。
- en: Search for your image and select it.
  id: totrans-1262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索你的图片并选择它。
- en: Save your project.
  id: totrans-1263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目。
- en: You now have the image of your choice on the home screen.
  id: totrans-1264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在已经在主屏幕上选择了你喜欢的图片。
- en: Self-test questions
  id: totrans-1265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: 'Q1) Guess what is wrong with this method:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 猜猜这个方法有什么问题：
- en: '[PRE164]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Q2) What will `x` be equal to at the end of this code snippet?
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在这段代码的末尾`x`将等于多少？
- en: '[PRE165]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Summary
  id: totrans-1270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We came a really long way in this chapter. You got a serious handle on Java
    loops and took your first, fairly deep look into Java methods and how to use them.
    You learned how to generate random numbers and significantly enhanced your math
    game using all of the knowledge you gained.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们走了很长的路。你掌握了Java循环，并首次深入了解了Java方法和如何使用它们。你学习了如何生成随机数，并利用你获得的所有知识显著增强了你的数学游戏。
- en: As the chapters proceed, the games will get more and more real-game-like. In
    the next chapter, we will make a game to test the player's memory. It will have
    sound, animation and will actually save the player's high scores too.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的推进，游戏将变得越来越像真实游戏。在下一章中，我们将制作一个测试玩家记忆力的游戏。它将包含声音、动画，并且实际上还会保存玩家的高分。
- en: Congratulations on your progress so far but let's keep going.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你到目前为止取得的进步，但让我们继续前进。
- en: Chapter 5. Gaming and Java Essentials
  id: totrans-1274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。游戏和Java基础
- en: In this chapter, we will cover a diverse and interesting range of topics. We
    will learn about Java arrays, which allow us to manipulate a potentially huge
    amount of data in an organized and efficient manner.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖一系列多样且有趣的主题。我们将学习Java数组，它允许我们以有组织和高效的方式操纵大量数据。
- en: Then, we will look at the role threads can play in games, in order to do more
    than one thing apparently simultaneously.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨线程在游戏中的作用，以便同时执行多项操作。
- en: If you thought that our math game was a bit on the quiet side, then we will
    look at adding sound effects to our games as well as introducing a cool open source
    app to generate authentic sound effects.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为我们的数学游戏有点安静，那么我们还将考虑为我们的游戏添加音效，以及介绍一个酷的开源应用程序来生成逼真的音效。
- en: The last new thing we will learn will be persistence. This is what happens when
    the player quits our game or even turns off their Android device. What happens
    to the score then? How will we load the right level the next time they play?
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习的最后一项新内容将是持久性。这是当玩家退出我们的游戏，甚至关闭他们的Android设备时发生的事情。那么分数会怎样？我们如何加载他们下次玩时的正确级别？
- en: Once we have done all this, we will use all the new techniques and knowledge
    along with what we already know to create a neat memory game.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有这些，我们将使用所有新的技术和知识，以及我们已有的知识来创建一个有趣的游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Java arrays—an array of variables
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java数组——变量数组
- en: Timing with threads
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程同步
- en: Creating and using beeps 'n' buzzes—Android sound
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用蜂鸣声和嗡嗡声——Android声音
- en: A look at life after destruction—persistence
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏后的生活展望——持久性
- en: Building the memory game
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建记忆游戏
- en: Java arrays – an array of variables
  id: totrans-1286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java数组 - 变量数组
- en: 'You might be wondering what happens when we have a game with lots of variables
    to keep track of. How about a table of high scores with the top 100 scores? We
    could declare and initialize 100 separate variables like this:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道当我们有一个需要跟踪大量变量的游戏时会发生什么。比如有一个包含前100名分数的高分表？我们可以像这样声明和初始化100个单独的变量：
- en: '[PRE166]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Straightaway, this can seem unwieldy, and what about the case when someone
    gets a new top score and we have to shift the scores in every variable down one
    place? A nightmare begins:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，这可能会显得难以控制，那么当有人获得新的最高分而我们不得不将每个变量的分数向下移动一个位置时怎么办？噩梦开始了：
- en: '[PRE167]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: There must be a better way to update the scores. When we have a large set of
    variables, what we need is a Java **array**. An array is a reference variable
    that holds up to a fixed maximum number of elements. Each element is a variable
    with a consistent type.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 更新分数肯定有更好的方法。当我们有一大批变量时，我们需要的是一个Java **数组**。数组是一个可以存储最多固定数量元素的引用变量。每个元素都是一个具有一致类型的变量。
- en: 'The following line of code declares an array that can hold `int` type variables,
    even a high score table perhaps:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行声明了一个可以存储`int`类型变量的数组，甚至可能是高分表：
- en: '[PRE168]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'We can also declare arrays of other types, like this:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以声明其他类型的数组，如下所示：
- en: '[PRE169]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it is used, like this:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些数组在使用之前都需要分配一个固定的最大存储空间，如下所示：
- en: '[PRE170]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The preceding line of code allocates up to a maximum of 100 integer-sized storage
    spaces. Think of a long aisle of 100 consecutive storage spaces in our variable
    warehouse. The spaces would probably be labeled `intArray[0]`, `intArray[1]`,
    `intArray[2]`, and so on, with each space holding a single `int` value. Perhaps
    the slightly surprising thing here is that the storage spaces start off at 0,
    not 1\. Therefore, in an array of size 100, the storage spaces would run from
    0 to 99.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行分配了最多100个整数大小的存储空间。想象一下在我们的变量仓库中有一排100个连续的存储空间。这些空间可能会被标记为`intArray[0]`、`intArray[1]`、`intArray[2]`等等，每个空间都存储一个`int`值。这里令人略感惊讶的事情是，存储空间从0开始，而不是从1开始。因此，在大小为100的数组中，存储空间将从0到99。
- en: 'We can actually initialize some of these storage spaces like this:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以像这样初始化一些存储空间：
- en: '[PRE171]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Note that we can only put the declared type into an array and the type that
    an array holds can never change:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能将声明的类型放入数组中，并且数组所持有的类型永远不会改变：
- en: '[PRE172]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'So when we have an array of `int` types, what are each of the `int` variables
    called? The array notation syntax replaces the name. We can do anything with a
    variable in an array that we could do with a regular variable with a name:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们有一个`int`类型的数组时，每个`int`变量叫什么呢？数组表示法语法替换了名称。我们可以对数组中的变量做任何我们可以在具有名称的常规变量上做的事情：
- en: '[PRE173]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Here is another example of array variables being used like normal variables:'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个数组变量像常规变量一样使用的例子：
- en: '[PRE174]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We can also assign a value from an array to a regular variable of the same
    type, like this:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数组中的值赋给相同类型的常规变量，如下所示：
- en: '[PRE175]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable,
    so any changes made to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is not connected to the array.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，`myNamedInt`是一个独立且不同的原始变量，所以对其所做的任何更改都不会影响存储在`intArray`引用中的值。它在仓库中有自己的空间，并且与数组不相连。
- en: Arrays are objects
  id: totrans-1310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是对象
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So each of `someArray[0]`, `someArray[1]`,
    and so on is the aisle number followed by the position number in the aisle.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说数组是引用变量。将数组变量想象成指向一组给定类型变量的地址。也许，使用仓库类比，`someArray`是一个通道号。所以`someArray[0]`、`someArray[1]`等等是通道号后面跟着通道中的位置号。
- en: 'Arrays are also objects. This means that they have methods and properties that
    we can use:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也是对象。这意味着它们有我们可以使用的方法和属性：
- en: '[PRE176]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: In the previous line of code, we assigned the length of `someArray` to the `int`
    variable called `lengthOfSomeArray`.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们将`someArray`的长度赋值给名为`lengthOfSomeArray`的`int`变量。
- en: 'We can even declare an array of arrays. This is an array that, in each of its
    elements, stores another array, like this:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以声明一个数组的数组。这是一个数组，在其每个元素中存储另一个数组，如下所示：
- en: '[PRE177]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array-crazy just yet. Just remember that an array holds up to a
    predetermined number of variables of any predetermined type and their values are
    accessed using this syntax:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，我们可以为每个国家存储一个城市列表。现在我们不要变得过于热衷于数组。只需记住，一个数组可以存储预定的数量和类型的变量，它们的值可以通过以下语法访问：
- en: '[PRE178]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Let's actually use some arrays to try and get an understanding of how to use
    them in real code and what we might use them for.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际使用一些数组来尝试理解如何在实际代码中使用它们以及我们可能用它们做什么。
- en: A simple example of an array
  id: totrans-1320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的一个简单示例
- en: 'Let''s write a really simple working example of an array by performing the
    following steps. You can get the complete code for this example in the downloadable
    code bundle. It''s at `Chapter5/SimpleArrayExample/MainActivity.java`:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤编写一个真正简单的数组工作示例。你可以在这个示例的完整代码在可下载的代码包中找到。它在`Chapter5/SimpleArrayExample/MainActivity.java`：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-1322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章。Android入门")中做的那样，*Android入门*。同时，通过删除不必要的部分来清理代码，但这不是必需的。
- en: 'First, we declare our array, allocate five spaces, and initialize some values
    to each of the elements:'
  id: totrans-1323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的数组，分配五个空间，并将一些值初始化到每个元素中：
- en: '[PRE179]'
  id: totrans-1324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'We output each of the values to the **logcat** console. Notice that when we
    add the array elements together, we are doing so over multiple lines. This is
    fine because we have omitted a semicolon until the last operation, so the Java
    compiler treats the lines as one statement:'
  id: totrans-1325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个值输出到**logcat**控制台。注意，当我们添加数组元素时，我们是在多行上进行的。这是可以的，因为我们直到最后一个操作之前省略了分号，所以Java编译器将这些行视为一个语句：
- en: '[PRE180]'
  id: totrans-1326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Run the example on an emulator.
  id: totrans-1327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。
- en: 'Remember that nothing will happen on the emulator display because the entire
    output will be sent to our **logcat** console window in Android Studio. Here is
    the output of the preceding code:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在模拟器显示上不会发生任何事情，因为整个输出都将发送到Android Studio中的我们的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE181]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: In step 2, we declared an array called `ourArray` to hold `int` variables, and
    allocated space for up to five variables of that type.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明了一个名为`ourArray`的数组来存储`int`变量，并为该类型分配了最多五个变量的空间。
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的数组中的五个空间分别赋值。记住，第一个空间是`ourArray[0]`，最后一个空间是`ourArray[4]`。
- en: In step 3, we simply printed the value in each array location to the console.
    From the output, we can see that they hold the value we initialized in the previous
    step. Then we added each of the elements in `ourArray` and initialized their value
    to the `answer` variable. We then printed `answer` to the console and saw that
    all the values where added together, just as if they were plain old `int` types
    stored in a slightly different manner, which is exactly what they are.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们简单地打印出每个数组位置的值到控制台。从输出中，我们可以看到它们持有我们在上一步中初始化的值。然后我们将`ourArray`中的每个元素相加，并将它们的值初始化到`answer`变量中。然后我们将`answer`打印到控制台，并看到所有的值都被加在一起，就像它们是以稍微不同的方式存储的普通旧`int`类型一样，这正是它们的本质。
- en: Getting dynamic with arrays
  id: totrans-1333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的动态使用
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit in an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在所有这些数组内容开始讨论时讨论的那样，如果我们需要单独声明和初始化数组的每个元素，那么数组与常规变量相比并没有太大的好处。让我们看看动态声明和初始化数组的示例。
- en: Dynamic array example
  id: totrans-1335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态数组示例
- en: 'Let''s make a really simple dynamic array by performing the following steps.
    You can find the working project for this example in the download bundle. It is
    at `Chapter5/DynamicArrayExample/MainActivity.java`:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个非常简单的动态数组。你可以在这个示例的工作项目中找到它，在下载包中，位于`Chapter5/DynamicArrayExample/MainActivity.java`：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"),*Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-1337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章. 开始使用Android")中做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这不是必需的。
- en: 'Type the following between the opening and closing curly braces of `onCreate`.
    See if you can work out what the output will be before we discuss it and analyze
    the code:'
  id: totrans-1338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`的括号内输入以下内容。在我们讨论和分析代码之前，看看你能否预测输出结果：
- en: '[PRE182]'
  id: totrans-1339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Run the example on an emulator. Remember that nothing will happen on the emulator
    display because the entire output will be sent to our **logcat** console window
    in Android Studio. Here is the output of the preceding code:'
  id: totrans-1340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。记住，在模拟器显示上不会发生任何操作，因为所有的输出都将发送到Android Studio中的我们的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE183]'
  id: totrans-1341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'I have removed 994 iterations of the loop for brevity:'
  id: totrans-1342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简洁起见，我删除了循环的994次迭代：
- en: '[PRE184]'
  id: totrans-1343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'All the action happened in step 2\. We declared and allocated an array called
    `ourArray` to hold up to 1,000 `int` values. This time, however, we did the two
    steps in one line of code:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都在第2步完成。我们声明并分配了一个名为`ourArray`的数组来存储最多1,000个`int`类型的值。然而，这次我们在一行代码中完成了这两个步骤：
- en: '[PRE185]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用了一个设置为循环1,000次的`for`循环：
- en: '[PRE186]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'We initialized the spaces in the array from 0 to 999 with the value of `i`
    multiplied by `5`, as follows:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化数组中的空间从0到999，其值为`i`乘以`5`，如下所示：
- en: '[PRE187]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'To demonstrate the value of `i` and the value held in each position of the
    array, we output the value of `i` followed by the value held in the corresponding
    position in the array as follows:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`i`的值和数组中每个位置所持有的值，我们按照以下方式输出`i`的值和数组中相应位置的值：
- en: '[PRE188]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: All of this happened 1,000 times, producing the output we saw.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作重复了1,000次，产生了我们看到的输出。
- en: Entering the nth dimension with arrays
  id: totrans-1353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组进入第n维
- en: We very briefly mentioned that an array can even hold other arrays at each of
    its positions. Now, if an array holds lots of arrays that hold lots of some other
    type, how do we access the values in the contained arrays? And why would we ever
    need this anyway? Take a look at the next example of where multidimensional arrays
    can be useful.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常简短地提到了数组甚至可以在每个位置存储其他数组。现在，如果一个数组包含很多存储很多其他类型的数组，我们如何访问包含数组中的值？我们为什么需要这样做呢？看看多维数组可以有用的下一个示例。
- en: An example of a multidimensional array
  id: totrans-1355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组的示例
- en: 'Let''s create a really simple multidimensional array by performing the following
    steps. You can find the working project for this example in the download bundle.
    It is at `Chapter5/MultidimensionalArrayExample/MainActivity.java`:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个非常简单的多维数组。你可以在这个示例的工作项目中找到它，在下载包中，位于`Chapter5/MultidimensionalArrayExample/MainActivity.java`：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary methods, but this isn't essential.
  id: totrans-1357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章. 开始使用Android")中做的那样，*开始使用Android*。同时，通过删除不必要的代码来清理代码，但这不是必需的。
- en: 'After the call to `setContentView`, declare and initialize a two-dimensional
    array, like this:'
  id: totrans-1358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setContentView`之后，声明并初始化一个二维数组，如下所示：
- en: '[PRE189]'
  id: totrans-1359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Now we output the contents of the array using a `for` loop and a `Random` class
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer:'
  id: totrans-1360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`for`循环和一个`Random`类对象输出数组的内容。注意我们如何确保虽然问题是随机的，但我们总能选择正确的答案：
- en: '[PRE190]'
  id: totrans-1361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Run the example on an emulator. Once again, nothing will happen on the emulator
    display because the output will be sent to our **logcat** console window in Android
    Studio. Here is the output of the previous code:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。再次强调，在模拟器显示上不会发生任何事情，因为输出将被发送到Android Studio中的**logcat**控制台窗口。以下是上一段代码的输出：
- en: '[PRE191]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: What just happened? Let's go through this chunk by chunk so that we know exactly
    what is going on.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？让我们逐块分析，以便我们确切地知道发生了什么。
- en: 'We make a new object of the `Random` type, called `randInt`, ready to generate
    random numbers later in the program:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`Random`类型对象，命名为`randInt`，以便在程序后面生成随机数：
- en: '[PRE192]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We declare a simple `int` variable to hold a question number:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个简单的`int`变量来存储问题编号：
- en: '[PRE193]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Then we declare `countriesAndCities`, our array of arrays. The outer array
    holds arrays:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明`countriesAndCities`，我们的数组数组。外层数组包含数组：
- en: '[PRE194]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Now we allocate space within our arrays. The first outer array will be able
    to hold five arrays and each of the inner arrays will be able to hold two strings:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们的数组分配空间。第一个外层数组将能够容纳五个数组，每个内层数组将能够容纳两个字符串：
- en: '[PRE195]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Next, we initialize our arrays to hold countries and their corresponding capital
    cities. Notice that with each pair of initializations, the outer array number
    stays the same, indicating that each country/capital pair is within one inner
    array (a string array). Of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化我们的数组来存储国家和它们相应的首都城市。注意，随着每次初始化配对，外层数组的数字保持不变，这表明每个国家/首都对都在一个内层数组（字符串数组）中。当然，这些内层数组中的每一个都存储在外层数组的一个元素中（它包含数组）：
- en: '[PRE196]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are held at position `1`:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使即将到来的`for`循环更清晰，我们声明并初始化`int`变量来表示来自我们数组的国家和首都。如果你回顾一下数组初始化，所有的国家都存储在内层数组的`0`位置，所有相应的首都城市都存储在`1`位置：
- en: '[PRE197]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Now we create a `for` loop that will run three times. Note that this number
    does not mean we access the first three elements of our array. It is rather the
    number of times we go through the loop. We could make it loop one time or a thousand
    times, but the example would still work:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个将运行三次的`for`循环。请注意，这个数字并不意味着我们访问数组的第一个三个元素。它实际上是我们通过循环的次数。我们可以让它循环一次或一千次，但示例仍然会工作：
- en: '[PRE198]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Next, we actually determine which question to ask, or more specifically, which
    element of our outer array. Remember that `randInt.nextInt(5)` returns a number
    between 0 and 4\. This is just what we need as we have an outer array with five
    elements, from 0 to 4:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实际上确定要问哪个问题，或者更具体地说，确定我们外层数组中的哪个元素。记住`randInt.nextInt(5)`返回一个介于0到4之间的数字。这正是我们所需要的，因为我们有一个包含五个元素的外层数组，从0到4：
- en: '[PRE199]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过输出内层数组中持有的字符串来提出一个问题，而内层数组又是由上一行通过随机生成的数字选择的外层数组持有的：
- en: '[PRE200]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist and what they can
    do, so you can revisit them if necessary.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录，我们将在本书的其余部分不使用任何多维数组。所以如果关于这些数组内部的数组还有一点模糊不清，那就没关系了。你知道它们存在以及它们能做什么，所以如果需要可以回过头来复习它们。
- en: Array-out-of-bounds exceptions
  id: totrans-1384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组越界异常
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Whenever we try this, we get an error. Sometimes,
    the compiler will catch it to prevent the error from going into a working game,
    like this:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个不存在的数组元素时，会发生数组越界异常。每次我们尝试这样做时，我们都会得到一个错误。有时，编译器会捕获它，以防止错误进入一个正在运行的游戏，就像这样：
- en: '[PRE201]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Guess what happens if we write something like this:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜如果我们写点这样的东西会发生什么：
- en: '[PRE202]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The only way we can avoid this problem is to know the rule. The rule is that
    arrays start at zero and go up to the number obtained by subtracting one from
    the allocated number. We can also use clear, readable code where it is easy to
    evaluate what we have done and spot the problems.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免这种问题的唯一方法就是了解规则。规则是数组从零开始，到分配数减一为止。我们还可以使用清晰、易读的代码，这样我们就可以轻松评估我们所做的工作，并找出问题。
- en: Timing with threads
  id: totrans-1390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的定时
- en: So what is a thread? You can think of threads in Java programming just like
    threads in a story. In one thread of a story, we have the primary character battling
    the enemy on the front line, and in another thread, the soldier's family are getting
    by, day to day. Of course, a story doesn't have to have just two threads. We could
    introduce a third thread. Perhaps the story also tells of the politicians and
    military commanders making decisions. These decisions subtly, or not so subtly,
    affect what happens in the other threads.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是线程呢？你可以把Java编程中的线程想象成故事中的线程。在一个故事的一个线程中，我们有主要角色在前线与敌人战斗，而在另一个线程中，士兵的家庭在日常生活中过着日子。当然，一个故事不一定只有两个线程。我们可以引入第三个线程。也许故事还讲述了政治家和军事指挥官在做决策。这些决策微妙地或不太微妙地影响着其他线程发生的事情。
- en: 'Threads in programming are just like this. We create parts/threads in our program
    and they control different aspects for us. We introduce threads to represent these
    different aspects because of the following reasons:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的线程就像这样。我们在程序中创建部分/线程，它们为我们控制不同的方面。我们引入线程来表示这些不同的方面，原因如下：
- en: They make sense from an organizational point of view
  id: totrans-1393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组织角度来看是有意义的
- en: They are a proven way of structuring a program that works
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是构建程序的一种经过验证的方法
- en: The nature of the system we are working on forces us to use them
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在工作的系统的性质迫使我们使用它们
- en: In Android, we use threads for all of these reasons simultaneously. It makes
    sense, it works, and we have to use it because of the design of the system.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们出于所有这些原因同时使用线程。这是有意义的，它有效，我们必须使用它，因为系统的设计。
- en: In gaming, think about a thread that receives the player's button taps for "left",
    "right", and "shoot", a thread that represents the alien thinking where to move
    next, and yet another thread that draws all the graphics on the screen.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，想想看有一个线程接收玩家的“左”，“右”和“射击”按钮点击，一个线程代表外星人思考下一步该移动到哪里，还有一个线程在屏幕上绘制所有图形。
- en: Programs with multiple threads can have problems. Like the threads of a story,
    if proper synchronization does not occur, then things go wrong. What if our soldier
    went into battle before the battle or even the war existed? Weird!
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多线程的程序可能会出现问题。就像故事中的线程一样，如果未能进行适当的同步，那么事情就会出错。如果我们的士兵在战斗或甚至战争存在之前就进入了战场呢？太奇怪了！
- en: What if we have a variable, `int x`, that represents a key piece of data that
    say three threads of our program use? What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness**, caused by multiple threads racing to completion,
    oblivious of each other—because they are just dumb code after all.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个变量，`int x`，它代表程序中三个线程使用的关键数据。如果一个线程稍微领先于自己，使得数据对其他两个线程“错误”怎么办？这个问题是**正确性**问题，由多个线程竞速完成，彼此之间毫无察觉——因为毕竟它们只是愚蠢的代码。
- en: The problem of correctness can be solved by close oversight of the threads and
    **locking**. Locking means temporarily preventing execution in one thread to ensure
    that things are working in a synchronized manner. It's like freezing the soldier
    from boarding a ship to war until the ship has actually docked and the plank has
    been lowered, avoiding an embarrassing splash.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性问题可以通过对线程的密切监督和**锁定**来解决。锁定意味着暂时阻止一个线程的执行，以确保事情以同步的方式进行。这就像冻结士兵上船参战，直到船真正靠岸，跳板降下，避免尴尬的溅水。
- en: The other problem with programs with multiple threads is the problem of **deadlock**,
    where one or more threads become locked, waiting for the right moment to access
    `x`, but that moment never comes and the entire program eventually grinds to a
    halt.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多线程的程序的其他问题是**死锁**问题，其中一个或多个线程被锁定，等待合适的时机访问`x`，但那个时刻永远不会到来，整个程序最终会停止运行。
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock). Now consider all that we have
    just been discussing and mix it in with the Android Activity lifecycle. It's possible
    that you start to feel a little nauseous with the complexity.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，第一个问题（正确性）的解决方案是导致第二个问题（死锁）的原因。现在考虑我们刚刚讨论的所有内容，并将其与Android Activity生命周期结合起来。你可能会因为复杂性而感到有些恶心。
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override its methods to interact with the Android lifecycle, we can
    also use other classes to create and manage our threads. Just as with `Activity`,
    we only need to know how to use them, not how they work.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，问题已经为我们解决了。正如我们使用`Activity`类并重写其方法来与Android生命周期交互一样，我们也可以使用其他类来创建和管理我们的线程。正如`Activity`一样，我们只需要知道如何使用它们，而不需要知道它们是如何工作的。
- en: 'So why tell me all this stuff about threads when I didn''t need to know, you
    would rightly ask. It''s simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We will have no sweat writing our Java
    code to create and work within our threads if we can do the following:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你问我所有这些关于线程的事情，而你实际上并不需要知道时，你可能会正确地问道。这仅仅是因为我们将要编写的代码看起来不同，并且以不熟悉的方式结构化。如果我们能够做到以下这些，我们就不需要流汗来编写我们的Java代码以创建和在我们的线程中工作：
- en: Accept that the new concepts we will introduce are what we need to work with
    in order to create an Android-specific solution to the problems related to working
    with threads
  id: totrans-1405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受我们将要引入的新概念是我们为了创建与线程相关的问题的Android特定解决方案所必需的
- en: Understand the general concept of a thread, which is mostly the same as a story
    thread that happens almost simultaneously
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程的一般概念，这通常与几乎同时发生的故事线程相同
- en: Learn the few rules of using some of the Android thread classes
  id: totrans-1407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用一些Android线程类的几个规则
- en: Notice that I said classes, plural, in the third bullet. Different thread classes
    work best in different situations. You could write a whole book on just threads
    in Android. We will use two thread classes in this book. In this chapter, we will
    use `Handler`. In [Chapter 7](ch07.html "Chapter 7. Retro Squash Game"), *Retro
    Squash Game*, and [Chapter 8](ch08.html "Chapter 8. The Snake Game"), *The Snake
    Game*, we will use the `Runnable` class. All we need to remember is that we will
    be writing parts of our program that run at almost the same time as each other.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在第三点中说的是类，复数。不同的线程类在不同的情境下工作得最好。你甚至可以写一本书专门讨论Android中的线程。在这本书中，我们将使用两个线程类。在本章中，我们将使用`Handler`。在[第7章](ch07.html
    "第7章. Retro Squash Game")，*Retro Squash Game*和[第8章](ch08.html "第8章. 蛇游戏")，*蛇游戏*中，我们将使用`Runnable`类。我们只需要记住的是，我们将编写几乎同时运行的程序的部分。
- en: Tip
  id: totrans-1409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What do I mean by "almost"? What is actually happening is that the CPU switches
    between threads in turn. However, this happens so fast that we will not be able
    to perceive anything but simultaneity.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“几乎”是什么意思？实际上发生的情况是CPU会依次在各个线程之间切换。然而，这个过程发生得如此之快，以至于我们无法感知到任何东西，只能感觉到同时性。
- en: A simple thread timer example with the Handler class
  id: totrans-1411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Handler类的一个简单的线程计时器示例
- en: After this example, we can heave a sigh of relief when we realize that threads
    are not as complicated as first feared. When using threads in a real game, we
    will have to add a bit of extra code alongside the code in this simple example,
    but it's not much, and we will talk about it when we get to it.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例之后，当我们意识到线程并不像最初担心的那样复杂时，我们可以松一口气。在真实游戏中使用线程时，我们将在简单示例的代码旁边添加一些额外的代码，但这并不多，我们将在适当的时候讨论它。
- en: As usual, you can simply use the complete code from the download bundle. This
    project is located in `Chapter5`/`SimpleThreadTimer/MainActivity.java`.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你可以简单地使用下载包中的完整代码。该项目位于`Chapter5`/`SimpleThreadTimer/MainActivity.java`。
- en: 'As the name suggests, we will be creating a timer—quite a useful feature in
    a lot of games:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，我们将创建一个计时器——这在许多游戏中都是一个非常有用的功能：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-1415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章. 开始使用Android")中做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这不是必需的。
- en: 'Immediately after the class declaration, enter the three highlighted lines:'
  id: totrans-1416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明之后立即输入三条突出显示的行：
- en: '[PRE203]'
  id: totrans-1417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Enter this code inside the `onCreate` method. It will create a thread with
    something else going on in the `if(gameOn)` block:'
  id: totrans-1418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中输入此代码。它将在`if(gameOn)`块中创建一个线程，并有一些其他操作：
- en: '[PRE204]'
  id: totrans-1419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Run the app. Quit with the home or back button on the emulator. Notice that
    it is still printing to the console. We will deal with this anomaly when we implement
    our memory game.
  id: totrans-1420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。在模拟器上使用主页或返回按钮退出。请注意，它仍在控制台打印。当我们实现我们的记忆游戏时，我们将处理这个异常。
- en: 'When you run the example on an emulator, remember that nothing will happen
    on the emulator display because all of the output will be sent to our **logcat**
    console window in Android Studio. Here is the output of the previous code:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上运行示例时，请记住模拟器显示上不会发生任何事情，因为所有的输出都将发送到Android Studio中的**logcat**控制台窗口。以下是之前代码的输出：
- en: '[PRE205]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: So what just happened? After 1-second intervals, the number of seconds elapsed
    was printed to the console. Let's learn how this happened.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，刚才发生了什么？在1秒间隔后，已过去的时间数被打印到控制台。让我们学习这是如何发生的。
- en: 'First, we declare a new object, called `myHandler`, of the `Handler` type.
    We then declare a Boolean variable called `gameOn`. We will use this to keep track
    of when our game is running. Finally, the last line of this block of code declares
    a variable of the `long` type. You might remember the `long` type from [Chapter
    3](ch03.html "Chapter 3. Speaking Java – Your First Game"), *Speaking Java – Your
    First Game*. We can use `long` variables to store very large whole numbers, and
    this is what we do here with `startTime`:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了一个新的对象，名为`myHandler`，其类型为`Handler`。然后我们声明了一个名为`gameOn`的布尔变量。我们将使用它来跟踪游戏何时运行。最后，这段代码块的最后一行声明了一个`long`类型的变量。你可能还记得从[第3章](ch03.html
    "第3章。讲Java - 你的第一个游戏") *讲Java - 你的第一个游戏* 中学到的`long`类型。我们可以使用`long`变量来存储非常大的整数，这就是我们在`startTime`中做的事情：
- en: '[PRE206]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Next, we initialized `startTime` using `currentTimeMillis`, a method of the
    `System` class. This method holds the number of milliseconds since January 1,
    1970\. We will see how we use this value in the next line of code.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`currentTimeMillis`方法初始化`startTime`，这是`System`类的一个方法。该方法包含自1970年1月1日以来的毫秒数。我们将在下一行代码中看到我们如何使用这个值。
- en: '[PRE207]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Next is the important code. Everything up to `if(gameOn)` marks the code to
    define our thread. Certainly, the code is a bit of a mouthful, but it is not as
    bad as it looks at first glance. Also, remember that we only need to use the threads;
    we don't need to understand every aspect of how they do their work.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是重要的代码。直到`if(gameOn)`的所有代码标记了定义我们线程的代码。当然，代码有点长，但并不像第一眼看上去那么糟糕。此外，记住我们只需要使用线程；我们不需要理解它们如何工作的每一个方面。
- en: Let's dissect the preceding code to demystify it a bit. The `myHandler = new
    Handler()` line simply initializes our `myHandler` object. What is different from
    what we have seen before is that we go on to customize the object immediately
    afterwards. We override the `handleMessage` method (which is where we put our
    code that runs in the thread) and then we call `super.handleMessage`, which calls
    the default version of `handleMessage` before it runs our custom code. This is
    much like we do for the `onCreate` method every time we call `super.onCreate`.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析前面的代码，以消除一些神秘感。`myHandler = new Handler()`这一行只是初始化我们的`myHandler`对象。与之前看到的不同之处在于，我们紧接着立即定制该对象。我们重写了`handleMessage`方法（这是我们放置在线程中运行的代码的地方），然后调用`super.handleMessage`，在运行我们的自定义代码之前调用默认版本的`handleMessage`。这与每次调用`super.onCreate`时我们为`onCreate`方法所做的是一样的。
- en: 'Then we have the `if(gameOn)` block. Everything in that `if` block is the code
    that we want to run in the thread. The `if(gameOn)` block simply gives us a way
    to control whether we want to run our code at all. For example, we might want
    the thread up and running but only sometimes run our code. The `if` statement
    gives us the power to easily choose. Take a look at the code now. We will analyze
    what is happening in the `if` block later:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`if(gameOn)`块。该`if`块中的所有代码都是我们想要在线程中运行的代码。`if(gameOn)`块只是给我们提供了一个控制是否运行我们代码的方法。例如，我们可能想让线程运行，但只在某些时候运行我们的代码。这个`if`语句给了我们轻松选择的能力。现在看看代码。我们将在稍后分析`if`块中发生的事情：
- en: '[PRE208]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Inside the `if` block, we declare and initialize another `long` variable called
    `seconds`, and do a little bit of math with it:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部，我们声明并初始化另一个名为`seconds`的`long`变量，并对其进行一些数学运算：
- en: '[PRE209]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'First, we get the current number of milliseconds since January 1, 1970, and
    then subtract `startTime` from it. This gives us the number of milliseconds since
    we first initialized `startTime`. Then we divide the answer by 1000 and get a
    value in seconds. We print this value to the console with the following line:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取自1970年1月1日以来的当前毫秒数，然后从中减去`startTime`。这给出了自我们首次初始化`startTime`以来的毫秒数。然后我们将答案除以1000，得到秒的值。我们使用以下行将此值打印到控制台：
- en: '[PRE210]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Next, just after our `if` block, we have this line:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，就在我们的`if`块之后，我们有这一行：
- en: '[PRE211]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: The previous line tells the Android system that we want to run the code in the
    `handleMessage` method once every 1000 milliseconds (once a second).
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 上行代码告诉Android系统，我们希望在每1000毫秒（每秒）运行一次`handleMessage`方法中的代码。
- en: 'Back in `onCreate`, after the closing curly braces of the `handleMessage` method
    and the `Handler` class, we finally set `gameOn` to `true` so that it is possible
    to run the code in the `if` block:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中，在`handleMessage`方法和`Handler`类的闭合花括号之后，我们最终将`gameOn`设置为`true`，这样就可以在`if`块中运行代码：
- en: '[PRE212]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Then, this last line of the code starts the flow of messages between our thread
    and the Android system:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码的最后一行开始在我们线程和Android系统之间传递消息的流程：
- en: '[PRE213]'
  id: totrans-1442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: It is worth pointing out that the code inside the `if` block can be as minimal
    or as extensive as we need. When we implement our memory game, we will see much
    more code in our `if` block.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`if`块内的代码可以是我们需要的最少或最多。当我们实现我们的记忆游戏时，我们将在`if`块中看到更多的代码。
- en: All we really need to know is that the somewhat elaborate setup we have just
    seen allows us to run the contents of the `if` block in a new thread. That's it!
    Perhaps apart from brushing over that `System` class a bit quickly.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要了解的是，我们刚才看到的相对复杂的设置允许我们在新线程中运行`if`块的内容。就是这样！也许除了快速浏览一下`System`类之外。
- en: Note
  id: totrans-1445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `System` class has many uses. In this case, we use it to get the number
    of milliseconds since January 1, 1970\. This is a common system used to measure
    time in a computer. It is known as Unix time, and the first millisecond of January
    1, 1970, is known as the Unix Epoch. We will bump into this concept a few more
    times throughout the book.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`类有很多用途。在这种情况下，我们使用它来获取自1970年1月1日以来的毫秒数。这是一种在计算机中测量时间的通用系统。它被称为Unix时间，1970年1月1日的第一毫秒被称为Unix纪元。我们将在整本书中多次遇到这个概念。'
- en: Enough on threads, let's make some noise!
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的讨论就到这里，让我们制造一些噪音吧！
- en: Beeps n buzzes – Android sound
  id: totrans-1448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喇叭声和蜂鸣声 - Android声音
- en: This section will be divided into two parts—creating and using sound FX. So
    let's get on with it.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将分为两部分——创建和使用声音效果。所以，让我们开始吧。
- en: Creating sound FX
  id: totrans-1450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建声音效果
- en: Years ago, whenever I made a game, I would spend many hours trawling websites
    offering royalty-free sound FX. Although there are many good ones out there, the
    really great ones are always costly, and no matter how much you pay, they are
    never exactly what you want. Then a friend pointed out a simple open source app
    called Bfxr, and I have never wasted another moment looking for sound effects
    since. We can make our own.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，每当我制作一个游戏，我就会花很多小时在提供免费声音效果的网站上搜索。虽然那里有很多好的，但真正出色的总是很昂贵，无论你付多少钱，它们永远不是你想要的。然后一个朋友指出一个简单的开源应用程序Bfxr，从那以后我再也没有浪费时间寻找声音效果了。我们可以自己制作。
- en: Here is a very fast guide to making your own sound effects using Bfxr. Grab
    a free copy of Bfxr from [www.bfxr.net](http://www.bfxr.net).
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用Bfxr制作您自己的声音效果的快速指南。从[www.bfxr.net](http://www.bfxr.net)获取Bfxr的免费副本。
- en: 'Follow the simple instructions on the website to set it up. Try out a few of
    these examples to make cool sound effects:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的简单说明进行设置。尝试一些这些示例来制作酷炫的声音效果：
- en: Tip
  id: totrans-1454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is a seriously condensed tutorial. You can do much more with Bfxr. To learn
    more, read the tips on the website at the previous URL.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简化的教程。您可以使用Bfxr做更多的事情。要了解更多，请阅读之前URL网站上提供的提示。
- en: Run `bfxr.exe`:![Creating sound FX](img/8859OS_05_10.jpg)
  id: totrans-1456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`bfxr.exe`：![创建声音效果](img/8859OS_05_10.jpg)
- en: Try out all the preset types, which generate a random sound of that type. When
    you have a sound that is close to what you want, move to the next step:![Creating
    sound FX](img/8859OS_05_11.jpg)
  id: totrans-1457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试所有预设类型，它们会生成该类型的随机声音。当您得到一个接近您想要的声音时，进入下一步：![创建声音效果](img/8859OS_05_11.jpg)
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Creating sound FX](img/8859OS_05_12.jpg)
  id: totrans-1458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块来微调您新声音的音高、时长和其他方面：![创建声音效果](img/8859OS_05_12.jpg)
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see, we can save in formats other than `.wav`.![Creating
    sound FX](img/8859OS_05_13.jpg)
  id: totrans-1459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**导出Wav**按钮保存你的声音。尽管这个按钮的名字是Wav，但正如我们将看到的，我们可以保存成除了`.wav`以外的其他格式。![创建声音效果](img/8859OS_05_13.jpg)
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file, use the `.ogg` extension on the end of whatever you decide to call it.
  id: totrans-1460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android喜欢使用OGG格式的声音，所以当被要求命名文件时，在文件名后面使用`.ogg`扩展名。
- en: Repeat steps 2 to 5 as often as required.
  id: totrans-1461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有需要，重复步骤2到5。
- en: Tip
  id: totrans-1462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every project in this book that requires sound samples comes with the sound
    samples provided, but as we have seen, it is much more fun to make our own samples.
    All you need to do is to save them with the same filename as the provided samples.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中每个需要声音样本的项目都附带提供的声音样本，但正如我们所看到的，制作自己的样本更有趣。你只需要将它们保存为与提供的样本相同的文件名。
- en: Playing sounds in Android
  id: totrans-1464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android中播放声音
- en: 'To complete this brief example, you will need three sound effects saved in
    the `.ogg` format. So if you don''t have them to hand, go back to the *Creating
    sound FX* section to make some. Alternatively, you can use the sounds provided
    in the `Chapter5/ PlayingSounds/assets` folder of the code bundle. As usual, you
    can view or use the already completed code at `Chapter5/PlayingSounds/java/MainActivity.java`
    and `Chapter5/PlayingSounds/layout/activity_main.xml`. Now perform the following
    steps:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个简短的示例，你需要三个保存为`.ogg`格式的声音效果。所以如果你没有，请回到*创建声音效果*部分制作一些。或者，你可以使用代码包中`Chapter5/PlayingSounds/assets`文件夹提供的声音。像往常一样，你可以在`Chapter5/PlayingSounds/java/MainActivity.java`和`Chapter5/PlayingSounds/layout/activity_main.xml`中查看或使用已经完成好的代码。现在执行以下步骤：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, although this isn't essential.
  id: totrans-1466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章。Android入门")中做的那样，*Android入门*。同时，通过删除不必要的部分来清理代码，尽管这不是必需的。
- en: Create three sound files and save them as `sample1.ogg`, `sample2.ogg`, and
    `sample3.ogg`.
  id: totrans-1467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个声音文件，并将它们保存为`sample1.ogg`、`sample2.ogg`和`sample3.ogg`。
- en: In the `main` folder in the Project Explorer window, we need to add a folder
    called `assets`. So in the Project Explorer window, right-click on the **main**
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-1468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口的`main`文件夹中，我们需要添加一个名为`assets`的文件夹。所以在项目资源管理器窗口中，右键点击**main**文件夹，导航到**新建**
    | **目录**。在**新建目录**对话框中输入`assets`。
- en: Now copy and paste the three sound files to the newly created `assets` folder.
    Alternatively, select the three files, right-click on them, and click on **Copy**.
    Then click on the **assets** folder in the Android Studio Project Explorer. Now
    right-click on the **assets** folder and click on **Paste**.
  id: totrans-1469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将三个声音文件复制并粘贴到新创建的`assets`文件夹中。或者，选择这三个文件，右键点击它们，然后点击**复制**。然后点击Android Studio项目资源管理器中的**assets**文件夹。现在右键点击**assets**文件夹并点击**粘贴**。
- en: Open `activity_main.xml` in the editor window and drag three button widgets
    onto your UI. It doesn't matter where they are or how they are aligned. When you
    look at the **id** property in the **Properties** window for any of our three
    new buttons, you will notice that they have automatically been assigned **id**
    properties. They are `button`, `button2`, and `button3`. As we will see, this
    is just what we need.
  id: totrans-1470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`activity_main.xml`，并将三个按钮小部件拖拽到你的UI上。它们的位置和排列方式无关紧要。当你查看任何我们三个新按钮的**id**属性在**属性**窗口中时，你会注意到它们已经被自动分配了**id**属性。它们是`button`、`button2`和`button3`。正如我们将看到的，这正是我们所需要的。
- en: 'Let''s enable our activity to listen to the buttons being clicked by implementing
    `onClickListener` as we have done in all our other examples with buttons. Open
    **MainActivity.java** in the editor window. Replace the `public class MainActivity
    extends Activity {` line with the following line of code:'
  id: totrans-1471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们的活动能够监听按钮的点击，就像我们在所有其他按钮示例中做的那样实现`onClickListener`。在编辑窗口中打开**MainActivity.java**。将`public
    class MainActivity extends Activity {`这一行替换为以下代码：
- en: '[PRE214]'
  id: totrans-1472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: As before, we get an unsightly red underline on our new line of code. The last
    time this happened, we typed in the empty body of the `onClick` method that we
    must implement and all was well. This time, because we already know what is going
    on here, we will learn a shortcut. Hover your mouse cursor over the error and
    right-click on it. Now click on **Generate...** and then select **Implement methods...**.
    In the **Select** **Methods To Implement** dialog box, **onClick(View):void**
    will already be selected:![Playing sounds in Android](img/8859OS_05_03.jpg)
  id: totrans-1473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们在新的一行代码上得到了一个难看的红色下划线。上次发生这种情况时，我们输入了必须实现的`onClick`方法的空体，一切顺利。这次，因为我们已经知道这里的情况，我们将学习一个快捷方式。将鼠标光标悬停在错误上，然后右键单击。现在点击**生成...**然后选择**实现方法...**。在**选择**
    **要实现的方法**对话框中，**onClick(View):void**已经选中：![在Android中播放声音](img/8859OS_05_03.jpg)
- en: Select this option by clicking on **OK**. Now scroll to the bottom of your code
    and see that Android Studio has very kindly implemented the `onClick` method for
    you and the error is also gone.
  id: totrans-1474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**确定**选择此选项。现在滚动到代码的底部，你会看到Android Studio已经非常友好地为你实现了`onClick`方法，错误也已经消失了。
- en: 'Type this code after the `MainActivity` declaration to declare some variables
    for our sound effects:'
  id: totrans-1475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后输入此代码以声明一些用于声音效果的变量：
- en: '[PRE215]'
  id: totrans-1476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Type this code in the `onCreate` method to load our sounds into memory:'
  id: totrans-1477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中输入此代码以将我们的声音加载到内存中：
- en: '[PRE216]'
  id: totrans-1478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Now add the code to grab a reference to the buttons in our UI and listen to
    clicks on them:'
  id: totrans-1479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加代码以获取我们UI中按钮的引用并监听它们的点击：
- en: '[PRE217]'
  id: totrans-1480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Finally, type this code in the `onClick` method that we autogenerated:'
  id: totrans-1481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在自动生成的`onClick`方法中输入此代码：
- en: '[PRE218]'
  id: totrans-1482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Run the example on an emulator or on a real Android device. Notice that by clicking
    on a button, you can play any of your three sound samples at will. Of course,
    sounds can be played at almost any time, not just on button presses. Perhaps they
    can be played from a thread as well. We will see more sound samples when we implement
    the memory game later in the chapter.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或真实Android设备上运行示例。注意，通过点击按钮，你可以随意播放你的三个声音样本。当然，声音可以在几乎任何时间播放，而不仅仅是按钮按下时。也许它们可以从线程中播放。当我们在本章后面实现记忆游戏时，我们将看到更多的声音样本。
- en: This is how the code works. We started off by setting up a new project in the
    usual way. In steps 2 to 5, however, we created some sounds with Bfxr, created
    an `assets` folder, and placed the files within it. This is the folder where Android
    expects to find sound files. So when we write the code in the next steps that
    refers to the sound files, the Android system will be able to find them.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理。我们首先以通常的方式设置了一个新项目。然而，在第2步到第5步中，我们使用Bfxr创建了一些声音，创建了一个`assets`文件夹，并将文件放入其中。这是Android期望找到声音文件的文件夹。因此，当我们编写下一步骤中引用声音文件的代码时，Android系统将能够找到它们。
- en: In steps 6 to 8, we enabled our activity to listen to button clicks as we have
    done several times before. Only this time, we got Android Studio to autogenerate
    the `onClick` method.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步到第8步中，我们使我们的活动能够监听按钮点击，就像我们之前多次做的那样。但这次，我们让Android Studio自动生成`onClick`方法。
- en: 'Then we saw this code:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了这段代码：
- en: '[PRE219]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'First, we create an object of the `SoundPool` type, called `soundPool`. This
    object will be the key to making noises with our Android device. Next, we have
    this code:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`soundPool`的`SoundPool`类型的对象。这个对象将是我们在Android设备上制造噪音的关键。接下来，我们有以下代码：
- en: '[PRE220]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The preceding code is very simple; we declared three `int` variables. However,
    they serve a slightly deeper purpose than a regular `int` variable. As we will
    see in the next block of code we analyze, they will be used to hold a reference
    to a sound file that is loaded into memory. In other words, the Android system
    will assign a number to each variable that will refer to a place in memory where
    our sound file will reside.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常简单；我们声明了三个`int`变量。然而，它们比普通的`int`变量有更深层次的目的。正如我们将在下一块代码分析中看到的那样，它们将被用来保存一个引用到已加载到内存中的声音文件。换句话说，Android系统将为每个变量分配一个数字，该数字将引用我们的声音文件在内存中的位置。
- en: We can think of this as a location in our variable warehouse. So we know the
    name of the `int` variable, and contained within it is what Android needs to find
    our sound. Here is how we load our sounds into memory and use the references we've
    just been discussing.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其视为我们变量仓库中的一个位置。因此，我们知道`int`变量的名称，并且其中包含Android需要找到我们的声音的内容。以下是我们将声音加载到内存中并使用我们刚刚讨论的引用的方法。
- en: 'Let''s break the code in step 10 into a few parts. Take a close look and then
    we will examine what is going on:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把第10步中的代码拆分成几个部分。仔细看看，然后我们将检查正在发生的事情：
- en: '[PRE221]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Here, we initialize our `soundPool` object and request up to 10 simultaneous
    streams of sound. We should be able to really mash the app buttons and get a sound
    every time. `AudioManager.STREAM_MUSIC` describes the type of stream. This is
    typical for applications of this type. Finally, the `0` argument indicates we
    would like default quality sound.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化我们的 `soundPool` 对象，并请求最多10个同时播放的声音流。我们应该能够在每次按下应用按钮时都能得到声音。`AudioManager.STREAM_MUSIC`
    描述了流的类型。这对于此类应用来说是典型的。最后，`0` 参数表示我们希望默认音质的声音。
- en: Now we see something new. Notice that the next chunk of code is wrapped into
    two blocks, `try` and `catch`. This means that if the code in the `try` block
    fails, we want the code in the `catch` block to run. As you can see, there is
    nothing but a comment in the `catch` block.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一些新的东西。注意，接下来的代码块被包裹在两个块中，`try` 和 `catch`。这意味着如果 `try` 块中的代码失败，我们希望 `catch`
    块中的代码运行。正如你所看到的，`catch` 块中除了注释之外没有其他内容。
- en: We must do this because of the way the `SoundPool` class is designed. If you
    try to write the code without the `try` and `catch` blocks, it won't work. This
    is typical of Java classes involved in reading from files. It is a fail-safe process
    to check whether the file is readable or even whether it exists. You could put
    a line of code to output to the console that an error has occurred.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做，因为 `SoundPool` 类的设计方式。如果你尝试在不使用 `try` 和 `catch` 块的情况下编写代码，它将不会工作。这是典型的涉及从文件读取的
    Java 类。这是一个检查文件是否可读甚至是否存在的安全过程。你可以在控制台输出一行代码来显示错误已发生。
- en: Tip
  id: totrans-1497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to experiment with `try/catch`, then put a line of code to output
    a message in the `catch` block and remove one of the sound files from the assets
    folder. When you run the app, the loading will fail and the code in the `catch`
    block will be triggered.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试使用 `try/catch`，那么在 `catch` 块中添加一行代码以输出一条消息，并从资源文件夹中删除一个声音文件。当你运行应用时，加载将失败，并且
    `catch` 块中的代码将被触发。
- en: 'We will throw caution to the wind because we are quite sure that the files
    will be there and will work . Let''s examine what is inside the `try` block. Take
    a close look at the following code and then we will dissect it:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不顾一切，因为我们相当确信文件会存在并且可以工作。让我们检查 `try` 块中的内容。仔细看看以下代码，然后我们将对其进行剖析：
- en: '[PRE222]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'First, we create an object called `assetManager` of the `AssetManager` type
    and an `AssetFileDescriptor` object called `descriptor`. We then use these two
    objects combined to load our first sound sample like this:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为 `assetManager` 的 `AssetManager` 类型的对象和一个名为 `descriptor` 的 `AssetFileDescriptor`
    对象。然后我们使用这两个对象组合来加载我们的第一个声音样本，如下所示：
- en: '[PRE223]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: We now have a sound sample loaded in memory and its location saved in our `int`
    variable called `sample1`. The first sound file, `sample1.ogg`, is now ready to
    use. We perform the same procedure for `sample2` and `sample3` and we are ready
    to make some noise!
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将一个声音样本加载到内存中，并将其位置保存在我们名为 `sample1` 的 `int` 变量中。第一个声音文件 `sample1.ogg`
    现在可以使用了。我们对 `sample2` 和 `sample3` 执行相同的程序，我们就准备好制造一些噪音了！
- en: 'In step 11, we set up our buttons, which we have seen several times before.
    In step 12, we have our switch block ready to perform a different action depending
    upon which button is pressed. You can probably see that the single action each
    button takes is the playing of a sound. For example, **Button1** does this:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步中，我们设置了我们的按钮，这是我们之前见过几次的。在第12步中，我们有了准备执行不同操作的开关块。你可能已经注意到，每个按钮执行的单个操作是播放声音。例如，**Button1**
    执行如下：
- en: '[PRE224]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: This line of code plays the sound that is loaded in memory at the location referred
    to by `int sample1`.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码播放内存中由 `int sample1` 指示位置加载的声音。
- en: Note
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The arguments of the method from left to right define the following: the sample
    to play, left volume, right volume, priority over other playing sounds, loop or
    not, rate of playback. You can have some fun with these if you like. Try setting
    the loop argument to `3` and the rate argument to perhaps `1.5`.'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数从左到右定义如下：要播放的样本，左声道音量，右声道音量，相对于其他播放声音的优先级，循环与否，播放速率。如果你喜欢，可以玩玩这些参数。尝试将循环参数设置为
    `3`，将速率参数设置为 `1.5`。
- en: We handle each button in the same way. Now let's learn something serious.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式处理每个按钮。现在让我们学习一些严肃的内容。
- en: Life after destruction – persistence
  id: totrans-1510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏后的生活——持久性
- en: Okay, this is not as heavy as it sounds, but it is an important topic when making
    games. You have probably noticed that the slightest thing can reset our math game,
    such as an incoming phone call, a battery that ran flat, or even tilting the device
    to a different orientation.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这听起来可能很复杂，但在制作游戏时，这是一个重要的主题。你可能已经注意到，最轻微的事情都可能重置我们的数学游戏，比如 incoming phone
    call，电量耗尽，或者甚至将设备倾斜到不同的方向。
- en: When these events occur, we might like our game to remember the exact state
    it was in so that when the player comes back, it is in exactly the same place
    as they left off. If you were using a word-processing app, you would definitely
    expect this type of behavior.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些事件发生时，我们可能希望我们的游戏记住它当时的确切状态，这样当玩家回来时，它就在他们离开的地方。如果你使用的是文字处理应用程序，你肯定会期望这种行为。
- en: We are not going to go to that extent with our game, but as a bare minimum,
    shouldn't we at least remember the high score? This gives the player something
    to aim for, and most importantly, a reason to come back to our game.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏不会达到那种程度，但作为最低限度，我们至少应该记住最高分。这给玩家一个目标，最重要的是，一个回到我们游戏的原因。
- en: An example of persistence
  id: totrans-1514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性的一个例子
- en: Android and Java have many different ways to achieve persistence of data, from
    reading and writing to files to setting up and using whole databases through our
    code. However, the neatest, simplest, and most suitable way for the examples in
    this book is by using the `SharedPreferences` class.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: Android和Java有许多不同的方法来实现数据的持久性，从读取和写入文件到通过我们的代码设置和使用整个数据库。然而，对于本书中的示例来说，最整洁、最简单、最合适的方法是使用`SharedPreferences`类。
- en: In this example, we will use the `SharedPreferences` class to save data. Actually,
    we will be reading and writing to files, but the class hides all of the complexity
    from us and allows us to focus on the game.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`SharedPreferences`类来保存数据。实际上，我们将读取和写入文件，但这个类隐藏了所有的复杂性，使我们能够专注于游戏。
- en: 'We will see a somewhat abstract example of persistence so that we are familiar
    with the code before we use something similar to save the high score in our memory
    game. The complete code for this example can be found in the code bundle at `Chapter5/Persistence/java/MainActivity.java`
    and `Chapter5/Persistence/layout/activity_main.xml`:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个相对抽象的持久性例子，这样在我们使用类似的方法在记忆游戏中保存最高分之前，我们就能熟悉代码。这个例子的完整代码可以在代码包`Chapter5/Persistence/java/MainActivity.java`和`Chapter5/Persistence/layout/activity_main.xml`中找到：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-1518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.html "第2章. Android入门")中做的那样，*Android入门*。同时，通过删除不必要的部分来清理代码，但这不是必需的。
- en: Open `activity_main.xml` in the editor window and click and drag one button
    from the palette to the design. The default ID of the button that is assigned
    is perfect for our uses, so no further work is required on the UI.
  id: totrans-1519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`activity_main.xml`，从调色板中拖动一个按钮到设计区域。按钮分配的默认ID非常适合我们的用途，因此不需要在UI上进行进一步的工作。
- en: Open `MainActivity.java` in the editor window. Implement `View.OnClickListener`
    and autogenerate the required `onClick` method, just as we did in steps 6 and
    7 of the *Playing sound in Android* example previously.
  id: totrans-1520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`MainActivity.java`。实现`View.OnClickListener`并自动生成所需的`onClick`方法，就像我们在之前的*在Android中播放声音*示例的第6步和第7步中所做的那样。
- en: 'Type the following code just after the `MainActivity` declaration. This declares
    our two objects that will do all the complex stuff behind the scenes: a bunch
    of strings that will be useful and a button:'
  id: totrans-1521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后输入以下代码。这声明了我们将在幕后执行所有复杂操作的两个对象：一些有用的字符串和一个按钮：
- en: '[PRE225]'
  id: totrans-1522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Add the next block of code to the `onCreate` method after the call to `setContentView`.
    We initialize our objects and set up our button. We will look closely at this
    code once the example is done:'
  id: totrans-1523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setContentView`之后，将下一块代码添加到`onCreate`方法中。我们初始化我们的对象并设置我们的按钮。示例完成后，我们将仔细查看这段代码：
- en: '[PRE226]'
  id: totrans-1524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Now the action takes place in our `onClick` method. Add this code, which generates
    a random number and adds it to the end of `currentString`. Then it saves the string
    and sets the value of the string to the button as well:'
  id: totrans-1525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在动作发生在我们的`onClick`方法中。添加以下代码，它生成一个随机数并将其添加到`currentString`的末尾。然后它保存字符串并将字符串的值设置为按钮：
- en: '[PRE227]'
  id: totrans-1526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Run the example on an emulator or a device. Notice that each time you press
    the button, a random number is appended to the text of the button. Now quit the
    app, or even shut down the device if you like. When you restart the app, our cool
    `SharedPreferences` class simply loads the last saved string.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行示例。注意，每次你按按钮时，都会将一个随机数附加到按钮的文本上。现在退出应用程序，或者如果你喜欢，甚至关闭设备。当你重新启动应用程序时，我们酷炫的`SharedPreferences`类简单地加载最后保存的字符串。
- en: 'Here is how the code works. There is nothing we haven''t seen several times
    before until step 4:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作方式。直到第4步，我们之前没有看到过任何我们没有看到过的东西：
- en: '[PRE228]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Here, we declare two types of `SharedPreferences` objects called `prefs` and
    `editor`. We will see exactly how we use them in a minute.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两种名为`prefs`和`editor`的`SharedPreferences`对象。我们将在一分钟内看到我们如何使用它们。
- en: 'Next, we declare the `dataName` and `stringName` strings. We do this because
    to use the facilities of `SharedPreferences`, we need to refer to our collection
    of data, as well as any individual pieces of data within it, using a consistent
    name. By initializing `dataName` and `stringName`, we can use them as a name for
    our data store as well as a specific item within that data store, respectively.
    The sad face in `defaultString` gets used any time the `SharedPreferences` object
    needs a default because either nothing has been previously saved or the loading
    process fails for some reason. The `currentString` variable will hold the value
    of the string we will be saving and loading as well as displaying to the user
    of our app. Our buttonis `button1`:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了`dataName`和`stringName`字符串。我们这样做是因为要使用`SharedPreferences`的设施，我们需要使用一致的名字来引用我们的数据集合，以及其中任何单个数据项。通过初始化`dataName`和`stringName`，我们可以分别将它们用作数据存储的名称以及数据存储中的特定项。`defaultString`中的悲伤面孔在`SharedPreferences`对象需要默认值时被使用，因为要么之前没有保存任何内容，要么由于某种原因加载过程失败。`currentString`变量将保存我们将要保存和加载的字符串，以及显示给我们的应用程序用户。我们的按钮是`button1`：
- en: '[PRE229]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'In step 5, the real action starts with this code:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，真正的动作从以下代码开始：
- en: '[PRE230]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The previous code does stuff that would take a lot more code if we didn't have
    the useful `SharedPreferences` class. The first two lines initialize the objects
    and the third loads the value from our data store item, whose name is contained
    in `stringName`, to our `currentString` variable. The first time this happens,
    it uses the `defaultString` value because nothing is stored there yet, but once
    there is a value stored, this single line of code that will load up our saved
    string.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码做了如果没有有用的`SharedPreferences`类将需要更多代码的事情。前两行初始化对象，第三行从我们的数据存储项（其名称包含在`stringName`中）加载值到`currentString`变量。第一次这样做时，它使用`defaultString`值，因为那里还没有存储任何内容，但一旦有值被存储，这一行代码将加载我们保存的字符串。
- en: 'At the end of step 5, we set up our button as we have done many times before.
    Moving on to step 6 in the `onClick` method, there is no `switch` block because
    there is only one button. So if a click is detected, it must be our button. Here
    are the first three lines from `onClick`:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步结束时，我们设置了我们的按钮，就像我们之前多次做的那样。接下来进行第6步，在`onClick`方法中，因为没有多个按钮，所以没有`switch`块。所以如果检测到点击，那一定是我们的按钮。以下是`onClick`的前三条代码：
- en: '[PRE231]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'We generate a random number and append it to the `currentString` variable.
    Next, still in `onClick`, we do this:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个随机数并将其附加到`currentString`变量。接下来，仍然在`onClick`中，我们这样做：
- en: '[PRE232]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: This is like the opposite of the code that loaded our string in `onCreate`.
    The first of the previous two lines identifies the place in the data store to
    write the value to (`stringName`) and the value to be written there (`currentString`).
    The next line, `editor.commit();`, simply says, "go ahead and do it."
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在`onCreate`中加载我们的字符串的代码的反面。前两行中的第一行标识了数据存储中写入值的位置（`stringName`）和要写入那里的值（`currentString`）。下一行`editor.commit();`只是说，“去做吧。”
- en: 'The following line displays `currentString` as text on our button so that we
    can see what is going on:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将`currentString`作为文本显示在我们的按钮上，这样我们就可以看到发生了什么：
- en: '[PRE233]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Tip
  id: totrans-1543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more on persistence, take a look at the second question of the *Self-test
    questions* section at the end of this chapter.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于坚持的信息，请查看本章末尾的*自测问题*部分的第二个问题。
- en: The memory game
  id: totrans-1545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆游戏
- en: The code in the memory game shouldn't challenge us too much because we have
    done the background research on threads, arrays, sound, and persistence. There
    will be some new-looking code and we will examine it in detail when it crops up.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆游戏中的代码不应该给我们带来太多挑战，因为我们已经对线程、数组、声音和持久性进行了背景研究。将会有一些看起来新的代码，当它出现时，我们将详细检查它。
- en: 'Here is a screenshot of our finished game:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的完成游戏的截图：
- en: '![The memory game](img/8859OS_05_15.jpg)'
  id: totrans-1548
  prefs: []
  type: TYPE_IMG
  zh: '![记忆游戏](img/8859OS_05_15.jpg)'
- en: 'This is the home screen. It shows the high score, which persists between play
    sessions and when the device is shut down. It also shows a **Play** button, which
    will take the player to the main game screen. Take a look at the following screenshot:'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主页。它显示了高分，该分数在游戏会话之间以及当设备关闭时保持不变。它还显示了一个**播放**按钮，该按钮将玩家带到主游戏屏幕。看看下面的截图：
- en: '![The memory game](img/8859OS_05_16.jpg)'
  id: totrans-1550
  prefs: []
  type: TYPE_IMG
  zh: '![记忆游戏](img/8859OS_05_16.jpg)'
- en: The game screen itself will play a sequence of sounds and numbers. The corresponding
    button will *wobble* in time with the corresponding sound. Then the player will
    be able to interact with the buttons and attempt to copy the sequence. For every
    part of the sequence that the player gets right, they will be awarded points.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕本身将播放一系列声音和数字。相应的按钮将与相应的声音同步*摇摆*。然后玩家将能够与按钮交互并尝试复制序列。对于玩家正确复制序列的每一部分，他们都会获得积分。
- en: If the sequence is copied in its entirety, then a new and longer sequence will
    be played and again the player will attempt to repeat the sequence. This continues
    until the player gets a part of a sequence wrong.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个序列被复制，则将播放一个新的更长的序列，并且玩家将再次尝试重复该序列。这将继续，直到玩家在序列的一部分出错。
- en: As the score increases, it is displayed in the relevant TextView, and when a
    sequence is copied correctly, the level is increased and displayed below the score.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分数的增加，它将在相关的TextView中显示，并且当序列正确复制时，级别将提高并在分数下方显示。
- en: The player can start a new game by pressing the **Replay** button. If a high
    score is achieved, it will be saved to a file and displayed on the home screen.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过按下**重播**按钮开始新游戏。如果达到高分，它将被保存到文件中并在主页上显示。
- en: 'The implementation of the game is divided into five phases. The end of a phase
    would be a good place to take a break. Here are the different phases of the game:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的实现分为五个阶段。阶段结束时是一个很好的休息时机。以下是游戏的各个阶段：
- en: '**Phase 1**: This implements the UI and some basics.'
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段**：这实现了UI和一些基础知识。'
- en: '**Phase 2**: This prepares our variables and presents the pattern (to be copied)
    to the player.'
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段**：这为我们准备了变量，并向玩家展示要复制的图案。'
- en: '**Phase 3**: In this phase, we will handle the player''s response when they
    try to copy the pattern.'
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段**：在这个阶段，我们将处理玩家尝试复制图案时的响应。'
- en: '**Phase 4**: Here, we will use what we just learned about persistence to maintain
    the player''s high score when they quit the game or turn off their device.'
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四阶段**：在这里，我们将使用我们刚刚学到的持久性知识来保持玩家在退出游戏或关闭设备时的高分。'
- en: '**Phase 5**: At the end of phase 4, we will have a fully working memory game.
    However, to add to our repertoire of Android skills, after we have discussed Android
    UI animations near the end of this chapter, we will complete this phase, which
    will enhance our memory game.'
  id: totrans-1560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五阶段**：在第四阶段结束时，我们将拥有一个完全工作的记忆游戏。然而，为了增加我们的Android技能库，在讨论完本章末尾的Android UI动画后，我们将完成这个阶段，这将增强我们的记忆游戏。'
- en: All the files containing the complete code and the sound files after all five
    stages can be found in the download bundle in the `Chapter5/MemoryGame` folder.
    In this project, however, there is a lot to be learned from going through each
    of the stages.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包含完整代码和声音文件的文件，在所有五个阶段之后，都可以在`Chapter5/MemoryGame`文件夹中的下载捆绑包中找到。然而，在这个项目中，通过每个阶段的学习有很多东西可以学到。
- en: Phase 1 – the UI and the basics
  id: totrans-1562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一阶段 – UI和基础知识
- en: 'Here, we will lay out a home menu screen UI and a UI for the game itself. We
    will also configure some IDs for some of the UI elements so that we can control
    them in our Java code later:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将布局一个主页菜单屏幕UI和游戏本身的UI。我们还将为一些UI元素配置一些ID，以便我们可以在Java代码中稍后控制它们：
- en: Create a new application called `Memory Game` and clean up the code if you wish.
  id: totrans-1564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Memory Game`的新应用程序，如果你愿意，可以清理代码。
- en: Now we create a new activity and call it `GameActivity`. So right-click on the
    `java` folder in Project Explorer, navigate to **New** | **Activity**, then click
    on **Next**, name the activity as `GameActivity`, and click on **Finish**. For
    clarity, clean up this activity in the same way as we cleaned up all our others.
  id: totrans-1565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个新的活动，并将其命名为`GameActivity`。因此，在项目资源管理器中的`java`文件夹上右键单击，导航到**新建** | **活动**，然后单击**下一步**，将活动命名为`GameActivity`，然后单击**完成**。为了清晰起见，以我们清理所有其他活动相同的方式清理此活动。
- en: Make the game fullscreen and lock the orientation as we did in the *Going fullscreen
    and locking orientation* tutorial at the end of [Chapter 4](ch04.html "Chapter 4. Discovering
    Loops and Methods"), *Discovering Loops and Methods*.
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏设置为全屏并锁定方向，就像我们在[第4章](ch04.html "第4章. 发现循环和方法")末尾的*全屏和锁定方向*教程中所做的那样，*发现循环和方法*。
- en: Open the `activity_main.xml` file from the `res/layout` folder.
  id: totrans-1567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`res/layout`文件夹中打开`activity_main.xml`文件。
- en: 'Let''s quickly create our home screen UI by performing the following steps:'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建我们的主屏幕UI，按照以下步骤操作：
- en: Open `activity_main.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-1569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`activity_main.xml`并删除**Hello World**`TextView`。
- en: 'Click and drag the following: **Large Text** to the top center (to create our
    title text), **Image** just below that, another **LargeText** below that (for
    our high score), and a **Button** (for our player to click to play). Your UI should
    look a bit like what is shown in the following screenshot:![Phase 1 – the UI and
    the basics](img/8859OS_05_04.jpg)'
  id: totrans-1570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击并拖动以下内容：**大文本**到顶部中央（以创建我们的标题文本），**图像**在下面，另一个**大文本**在下面（用于我们的高分），以及一个**按钮**（玩家点击以开始游戏）。您的UI应该看起来有点像以下截图所示：![阶段1
    – UI和基础知识](img/8859OS_05_04.jpg)
- en: Adjust the **text** properties of the two TextViews and the Button element to
    make it plain what each will be used for. As usual, you can replace the Android
    icon in the **ImageView** with any image you choose (as we did in [Chapter 4](ch04.html
    "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and Methods*,
    in the *Adding a custom image* tutorial).
  id: totrans-1571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整两个`TextView`和按钮元素的**文本**属性，使其明确表示每个将用于什么。像往常一样，您可以用您选择的任何图像替换**ImageView**中的Android图标（就像我们在[第4章](ch04.html
    "第4章. 发现循环和方法")的*添加自定义图像*教程中所做的那样）。
- en: Tweak the sizes of the elements in the usual way to suit the emulator or device
    you will be running the game on.
  id: totrans-1572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式调整元素的大小，以适应您将在其上运行游戏的模拟器或设备。
- en: Let's make the ID for our **Hi Score** TextView more relevant to its purpose.
    Left-click to select the **Hi Score** TextView, find its **id** property in the
    **Properties** window, and change it to `textHiScore`. The IDs of the image and
    the title are not required, and the existing ID of the play button is `button`,
    which seems appropriate already. So there is nothing else to change here.
  id: totrans-1573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使我们的**高分**`TextView`的ID与其用途更相关。左键单击选择**高分**`TextView`，在**属性**窗口中找到其**id**属性，并将其更改为`textHiScore`。图像和标题的ID不是必需的，播放按钮的现有ID为`button`，这似乎已经足够合适。所以这里没有其他需要更改的地方。
- en: 'Let''s wire up the **Play** button to create a link between the home and the
    game screens, as follows:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接**播放**按钮，创建主屏幕和游戏屏幕之间的链接，如下所示：
- en: Open `MainActivity.java` in the editor.
  id: totrans-1575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`MainActivity.java`。
- en: 'Add `implements View.onClickListener` to the end of the `MainActivity` declaration
    so that it now looks like this:'
  id: totrans-1576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明末尾添加`implements View.onClickListener`，使其现在看起来像这样：
- en: '[PRE234]'
  id: totrans-1577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method we must implement.
  id: totrans-1578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将鼠标悬停在您刚刚输入的行上，右键单击它。现在单击**生成**，然后单击**实现方法...**，然后单击**确定**，让Android Studio自动生成我们必须实现的`onClick`方法。
- en: 'At the end of our `onCreate` method, before the closing curly brace, enter
    the following code to get a reference to our **Play** button and listen to clicks:'
  id: totrans-1579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法末尾，在闭合花括号之前，输入以下代码以获取对**播放**按钮的引用并监听点击：
- en: '[PRE235]'
  id: totrans-1580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Scroll down to our `onClick` method and enter the following code in its body
    to have the **Play** button take the player to our `GameActivity`, which we will
    design soon:'
  id: totrans-1581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到我们的`onClick`方法，并在其主体中输入以下代码，以便**播放**按钮将玩家带到我们即将设计的`GameActivity`：
- en: '[PRE236]'
  id: totrans-1582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'At this point, the app will run and the player can click on the **Play** button
    to take them to our game screen. So let''s quickly create our game screen UI:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序将运行，玩家可以点击**播放**按钮，将其带到我们的游戏屏幕。所以让我们快速创建我们的游戏屏幕UI：
- en: Open `activity_game.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-1584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`activity_game.xml`并删除**Hello World** TextView。
- en: Drag three **Large Text** elements one below the other and center them horizontally.
    Below them, add four buttons stacked one on top of the other, and finally, add
    another button below that but offset it to the right-hand side so that it looks
    like what is shown in the next screenshot. I have also adjusted the text properties
    for the UI elements to make it clear what each will be used for, but this is optional
    because our Java code will do all of the work for us. You can also tweak the sizes
    of the elements in the usual way to suit the emulator or device you will be running
    the game on.![Phase 1 – the UI and the basics](img/8859OS_05_05.jpg)
  id: totrans-1585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个**大文本**元素一个接一个地拖动并水平居中。在它们下面，添加四个按钮，一个叠在另一个上面，最后，在下面添加另一个按钮，但将其向右偏移，使其看起来像下一张截图所示。我还调整了UI元素的文本属性，以便清楚地知道每个元素将用于什么，但这不是必需的，因为我们的Java代码将为我们完成所有工作。您也可以像往常一样调整元素的大小，以适应您将在其上运行游戏的模拟器或设备。![阶段1
    – UI和基础](img/8859OS_05_05.jpg)
- en: 'Now let''s assign some useful IDs to our UI elements so that we can do some
    Java magic with them in the next tutorial. Here is a table that matches the UI
    elements shown in the last screenshot with the **id** property value that you
    need to assign. Assign the following **id** property values to the corresponding
    UI elements:'
  id: totrans-1586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的UI元素分配一些有用的ID，这样我们就可以在下一教程中使用它们进行一些Java魔法。以下是一个表格，将上一张截图所示的UI元素与您需要分配的**id**属性值相匹配。将以下**id**属性值分配给相应的UI元素：
- en: '| Purpose | Default id property | New id to assign |'
  id: totrans-1587
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 目的 | 默认id属性 | 新分配的id |'
- en: '| --- | --- | --- |'
  id: totrans-1588
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Score indicator | textView | textScore |'
  id: totrans-1589
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 分数指示器 | textView | textScore |'
- en: '| Difficulty indicator | textView2 | textDifficulty |'
  id: totrans-1590
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 难度指示器 | textView2 | textDifficulty |'
- en: '| Watch/go indicator | textView3 | textWatchGo |'
  id: totrans-1591
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 观察/出发指示器 | textView3 | textWatchGo |'
- en: '| Button 1 | button | Leave at default |'
  id: totrans-1592
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 按钮1 | button | 保持默认 |'
- en: '| Button 2 | button2 | Leave at default |'
  id: totrans-1593
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 按钮2 | button2 | 保持默认 |'
- en: '| Button 3 | button3 | Leave at default |'
  id: totrans-1594
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 按钮3 | button3 | 保持默认 |'
- en: '| Button 4 | button4 | Leave at default |'
  id: totrans-1595
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 按钮4 | button4 | 保持默认 |'
- en: '| Replay button | button5 | buttonReplay |'
  id: totrans-1596
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 重放按钮 | button5 | buttonReplay |'
- en: Now that we have our game menu and actual game UI ready to go, we can start
    to make it work.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了游戏菜单和实际的游戏UI，我们可以开始让它工作。
- en: Phase 2 – preparing our variables and presenting the pattern
  id: totrans-1598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段2 – 准备变量和展示模式
- en: 'Here, we will set up a whole load of variables and objects for us to use, both
    in this phase and in the later phases. We will also implement the parts of the
    code that present a pattern to the player. We will add code that enables the player
    to respond in a later phase:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将设置大量变量和对象供我们使用，包括这个阶段和后续阶段。我们还将实现向玩家展示模式的代码部分。我们将在后续阶段添加允许玩家做出反应的代码：
- en: Open `GameActivity.java` in the editor window.
  id: totrans-1600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`GameActivity.java`。
- en: I made the sounds by finding a pleasing one then slowly increasing the **Frequency**
    slider for each subsequent sample. You can use my sound from the `assets` folder
    in the `MemoryGame` project or create your own sound using Bfxr.
  id: totrans-1601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我通过找到一个令人愉悦的声音，然后逐渐增加每个后续样本的**频率**滑块来制作声音。您可以使用`MemoryGame`项目中的`assets`文件夹中的我的声音，或者使用Bfxr创建自己的声音。
- en: In the `main` folder in the project explorer window, we need to add a folder
    called `assets`. So in the project explorer window, right-click on the `main`
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-1602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口的`main`文件夹中，我们需要添加一个名为`assets`的文件夹。因此，在项目资源管理器窗口中，右键单击`main`文件夹，导航到**新建**
    | **目录**。在**新建目录**对话框中键入`assets`。
- en: 'Now copy and paste the four sound files to the newly created `assets` folder.
    You can do so like this: select the files, right-click on them, and then click
    on **Copy**. Then click on the `assets` folder in the Android Studio project explorer.
    Now right-click on the `assets` folder and click on **Paste**.'
  id: totrans-1603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将四个声音文件复制并粘贴到新创建的`assets`文件夹中。您可以这样做：选择文件，右键单击它们，然后单击**复制**。然后单击Android Studio项目资源管理器中的`assets`文件夹。现在右键单击`assets`文件夹并单击**粘贴**。
- en: 'Let''s prepare `GameActivity` to listen to button clicks just as we did for
    `MainActivity`, as follows:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备`GameActivity`以监听按钮点击，就像我们对`MainActivity`所做的那样，如下所示：
- en: 'Add `implementsView.onClickListener` to the end of the `GameActivity` declaration
    so that it now looks like this:'
  id: totrans-1605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameActivity`声明末尾添加`implementsView.onClickListener`，使其看起来如下所示：
- en: '[PRE237]'
  id: totrans-1606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method that we will use shortly.
  id: totrans-1607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在您刚刚输入的行上，然后右键单击它。现在点击 **生成**，然后点击 **实现方法...**，最后点击 **确定** 以让 Android
    Studio 自动生成我们很快将使用的 `onClick` 方法。
- en: 'Let''s declare some objects that we need to reference our UI and our `int`
    references for the sound effects we will load soon. Write the code just after
    the declaration for `GameActivity`. By putting them here, they will be available
    to all parts of our code in `GameActivity.java`. Here is the code in context:'
  id: totrans-1608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一些我们需要引用我们的 UI 和即将加载的音效的 `int` 引用的对象。在 `GameActivity` 的声明之后写入代码。通过将它们放在这里，它们将在
    `GameActivity.java` 的所有代码部分中可用。以下是代码的上下文：
- en: '[PRE238]'
  id: totrans-1609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Now, after the last line of code from the previous step, enter the following
    code snippet, which will declare and initialize some variables for use in our
    thread. Notice that at the end, we also declare `myHandler`, which will be our
    thread, and `gameOn` to control whether our code within the thread is executed:'
  id: totrans-1610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在上一步的最后一条代码之后，输入以下代码片段，它将声明并初始化一些用于我们线程的变量。注意，在最后，我们还声明了 `myHandler`，它将成为我们的线程，以及
    `gameOn` 以控制线程内的代码是否执行：
- en: '[PRE239]'
  id: totrans-1611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Just after our call to `setContentView` in the `onCreate` method, we make our
    sound effects ready to be played:'
  id: totrans-1612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中调用 `setContentView` 之后，我们使我们的音效准备好播放：
- en: '[PRE240]'
  id: totrans-1613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Just after the code in the last step and still within the `onCreate` method,
    we initialize our objects and set click listeners for the buttons:'
  id: totrans-1614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码之后，并且仍然在 `onCreate` 方法中，我们初始化我们的对象并为按钮设置点击监听器：
- en: '[PRE241]'
  id: totrans-1615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Now, after the last line of the code from the previous step, enter the code
    that will create our thread. We will add the details in the next step within the
    `if(playSequence)` block. Notice that the thread is run every nine-tenths of a
    second (900 milliseconds). Notice that we start the thread but do not set `playSequence`
    to `true`. So it will not do anything yet:'
  id: totrans-1616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在上一步的最后一条代码之后，输入创建我们线程的代码。我们将在下一步的 `if(playSequence)` 块中添加详细信息。注意，线程每九十分之一秒（900毫秒）运行一次。注意，我们启动了线程，但没有将
    `playSequence` 设置为 `true`。所以它现在不会做任何事情：
- en: '[PRE242]'
  id: totrans-1617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Before we look at the code that will run in our thread, we need a way to generate
    a random sequence appropriate for the difficulty level. This situation sounds
    like a candidate for a method. Enter this method just before the closing curly
    brace of the `GameActivity` class:'
  id: totrans-1618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看将在我们的线程中运行的代码之前，我们需要一种方法来生成适合难度级别的随机序列。这种情况看起来是一个方法的候选者。在 `GameActivity`
    类的闭合花括号之前输入此方法：
- en: '[PRE243]'
  id: totrans-1619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'We also need a method to prepare and start our thread. Type the following method
    after the closing curly brace of `createSequence`:'
  id: totrans-1620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个方法来准备和启动我们的线程。在 `createSequence` 的闭合花括号之后输入以下方法：
- en: Tip
  id: totrans-1621
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Actually, the order of implementation of the methods is unimportant. However,
    following along in order will mean our code will look the same. Even if you are
    referring to the downloaded code, the order will be the same.
  id: totrans-1622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，方法的实现顺序并不重要。然而，按照顺序进行将意味着我们的代码看起来是一样的。即使您正在参考下载的代码，顺序也将是相同的。
- en: '[PRE244]'
  id: totrans-1623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Just before we look at the details of the thread code, we need a method to
    tidy up our variables after the sequence has been played. Enter this method after
    the closing curly brace of `playASequence`:'
  id: totrans-1624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看线程代码的细节之前，我们需要一个方法在序列播放后整理我们的变量。在 `playASequence` 的闭合花括号之后输入此方法：
- en: '[PRE245]'
  id: totrans-1625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Finally, we will implement our thread. There is some new code in this part,
    which we will go through in detail after we finish this phase of the project.
    Enter this code between the opening and closing curly braces of the `if(playSequence){
    }` block:'
  id: totrans-1626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现我们的线程。这部分有一些新的代码，我们将在完成项目这一阶段后详细说明。在 `if(playSequence){ }` 块的开闭花括号之间输入此代码：
- en: '[PRE246]'
  id: totrans-1627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Tip
  id: totrans-1628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Just before the closing curly brace of `onCreate`, we could initiate a sequence
    by calling our `playASequence` method, like this:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate` 的闭合花括号之前，我们可以通过调用我们的 `playASequence` 方法来启动一个序列，如下所示：
- en: '[PRE247]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: We could then run our app, click on **Play** on the home screen, and watch as
    a sequence of four random buttons and their matching sounds begins, with the sounds
    being played. In the next phase, we will wire up the **Replay** button so that
    the player can start the sequence when they are ready.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行我们的应用，点击主屏幕上的 **播放**，并观察一系列四个随机按钮及其匹配的音效开始播放。在下一阶段，我们将连接 **重放** 按钮以便玩家在他们准备好时启动序列。
- en: Phew! That was a long one. Actually, there is not much new there, but we did
    cram in just about everything we ever learned about Java and Android into one
    place, and we used it in new ways too. So we will look at it step by step and
    give extra focus to the parts that might seem tricky.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这真是一段长话。实际上，其中并没有太多新内容，但我们几乎把关于Java和Android的所有知识都塞进了一个地方，并且我们还以新的方式使用了它们。因此，我们将一步一步地查看它，并额外关注可能看起来有些棘手的部分。
- en: Let's look at each new piece of code in turn.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每一块新的代码。
- en: From steps 1 to 7, we initialized our variables, set up our buttons, and loaded
    our sounds as we have done before. We also put in the outline of the code for
    our thread.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤1到7，我们初始化了我们的变量，设置了我们的按钮，并加载了我们的声音，就像我们之前做的那样。我们还为我们的线程放入了代码的大纲。
- en: 'In step 8, we implemented the `createSequence` method. We used a `Random` object
    to generate a sequence of random numbers between 1 and 4\. We did this in a `for`
    loop, which loops until a sequence the length of `difficultyLevel` has been created.
    The sequence is stored in an array called `sequenceToCopy`, which we can later
    use to compare to the player''s response:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们实现了`createSequence`方法。我们使用一个`Random`对象生成介于1和4之间的随机数序列。我们使用一个`for`循环来做这件事，直到创建了一个长度为`difficultyLevel`的序列。这个序列存储在一个名为`sequenceToCopy`的数组中，我们可以稍后使用它来比较玩家的回答：
- en: '[PRE248]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'In step 9, we implemented `playASequence`. First, we call `createSequence`
    to load our `sequenceToCopy` array. Then we set `isResponding` to `false` because
    we don''t want the player to bash buttons while the sequence is still playing.
    We set `elementToPlay` to `0` as this is the first element of our array. We also
    set `playerResponses` to `0`, ready to count the player''s responses. Next, we
    set some text on the UI to `"WATCH!"` to make it clear to the player that the
    sequence is playing. Finally, we set `playSequence` to `true`, which allows the
    code in our thread to run once every 900 milliseconds. Here is the code we have
    just analyzed:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们实现了`playASequence`方法。首先，我们调用`createSequence`来加载我们的`sequenceToCopy`数组。然后我们将`isResponding`设置为`false`，因为我们不希望玩家在序列仍在播放时乱按按钮。我们将`elementToPlay`设置为`0`，因为这是我们数组的第一个元素。我们还把`playerResponses`设置为`0`，以便准备好计数玩家的回答。接下来，我们在UI上设置一些文本为`"WATCH!"`，以便让玩家清楚地知道序列正在播放。最后，我们将`playSequence`设置为`true`，这允许我们的线程代码每900毫秒运行一次。以下是刚刚分析的代码：
- en: '[PRE249]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'In step 10, we handle `sequenceFinished`. We set `playSequence` to `false`,
    which prevents the code in our thread from running. We set all the buttons back
    to visible because, as we will see in the thread code, we set them to invisible
    to emphasize which button comes next in the sequence. We set our UI text to **GO!**
    to make it clear. It is time for the player to try and copy the sequence. For
    the code in the `checkElement` method to run, we set `isResponding` to `true`.
    We will look at the code in the `checkElement` method in the next phase:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10步中，我们处理`sequenceFinished`。我们将`playSequence`设置为`false`，这阻止了我们的线程中的代码运行。我们将所有按钮都设置回可见状态，因为，正如我们将在线程代码中看到的，我们将它们设置为不可见，以强调序列中下一个按钮。我们将我们的UI文本设置为**GO!**，以使其清晰。现在是玩家尝试复制序列的时候了。为了使`checkElement`方法中的代码运行，我们将`isResponding`设置为`true`。我们将在下一阶段查看`checkElement`方法中的代码：
- en: '[PRE250]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'In step 11, we implement our thread. It''s quite long but not too complicated.
    First, we set all the buttons to visible as this is quicker than checking which
    one of them is currently invisible and setting just that one:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步中，我们实现了我们的线程。它相当长，但并不复杂。首先，我们将所有按钮都设置为可见，因为这比检查哪个按钮当前不可见并只设置那个按钮要快：
- en: '[PRE251]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Then we switch based on what number is next in our sequence, hide the appropriate
    button, and play the appropriate sound. Here is the first case in the `switch`
    block for reference. The other case elements perform the same function but on
    a different button and with a different sound:'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据序列中下一个数字是什么来切换，隐藏相应的按钮，并播放相应的声音。以下是`switch`块中的第一个情况，供参考。其他情况元素执行相同的功能，但针对不同的按钮和不同的声音：
- en: '[PRE252]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Now we increment `elementToPlay`, ready to play the next part of the sequence
    when the thread runs again in approximately 900 milliseconds:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们增加`elementToPlay`，以便在线程大约900毫秒后再次运行时播放序列的下一部分：
- en: '[PRE253]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Next, we check whether we have played the last part of the sequence. If we
    have, we call our `sequenceFinished` method to set things up for the player to
    attempt their answer:'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否已经播放了序列的最后一部分。如果我们已经播放了，我们就调用`sequenceFinished`方法来为玩家尝试回答设置好一切：
- en: '[PRE254]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Finally, we tell the thread when we would like to run our code again:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉线程我们希望再次运行我们的代码：
- en: '[PRE255]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: When you ran a sequence (see the previous tip), did you notice an imperfection/bug
    with our game operation? This has to do with the way the last element of the sequence
    is animated. It is because our `sequenceFinished` method makes all the buttons
    visible so soon after the button has just been made invisible that looks like
    the button is never made invisible at all. We will solve the problem of the button
    that doesn't stay invisible long enough when we learn about UI animation in phase
    5.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个序列（参见之前的提示）时，你是否注意到我们的游戏操作有一个不完美/错误？这与序列的最后一个元素的动画方式有关。这是因为我们的 `sequenceFinished`
    方法在按钮刚刚变得不可见之后立即使所有按钮可见，所以看起来按钮根本就没有变得不可见。当我们学习到第5阶段的UI动画时，我们将解决按钮不够长时间保持不可见的问题。
- en: Now let's handle the player's response.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理玩家的反应。
- en: Phase 3 – the player's response
  id: totrans-1653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三阶段 – 玩家的反应
- en: We now have an app that plays a random sequence of button flashes and matching
    sounds. It also stores that sequence in an array. So what we have to do now is
    enable the player to attempt to replicate the sequence and score points if successful.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个应用程序，它会播放一系列随机的按钮闪烁和匹配的声音。它还会将这个序列存储在数组中。所以我们现在要做的就是让播放器尝试复制这个序列，如果成功则得分。
- en: We can do all of this in two phases. First, we need to handle the button presses,
    which can pass all the hard work to a method that will do everything else.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分两个阶段完成所有这些。首先，我们需要处理按钮点击，这可以把所有的工作都传递给一个方法，它会做所有其他的事情。
- en: 'Let''s write the code and look at it as we go. Afterwards, we will closely
    examine the less obvious parts:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在编写代码的同时查看它。之后，我们将仔细检查不那么明显的地方：
- en: 'Here is how we handle the button presses. We have the empty body of the `switch`
    statement with an extra `if` statement that checks whether there is a sequence
    currently being played. If there is a sequence, then no input is accepted. We
    will start to fill the code in the empty body in the next step:'
  id: totrans-1657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是处理按钮点击的方式。我们有一个空的 `switch` 语句体，其中有一个额外的 `if` 语句检查是否正在播放序列。如果有序列，则不接受任何输入。我们将在下一步开始填充空体中的代码：
- en: '[PRE256]'
  id: totrans-1658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Now, here is the code that handles `button1`. Notice that it just plays the
    sound related to `button1` and then calls the `checkElement` method, passing a
    value of 1\. This is all we have to do for the buttons 1 through 4: play a sound
    and then tell our new method (`checkElement`) which numbered button was pressed,
    and `checkElement` will do the rest:'
  id: totrans-1659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这是处理 `button1` 的代码。注意，它只是播放与 `button1` 相关的声音，然后调用 `checkElement` 方法，传递一个值为1。对于按钮1到4，我们只需要做这些：播放声音，然后告诉我们的新方法（`checkElement`）哪个编号的按钮被按下，`checkElement`
    将完成其余的工作：
- en: '[PRE257]'
  id: totrans-1660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Here is the near-identical code for buttons 2 through 4\. Notice that the value
    passed to `checkElement` and the sound sample that is played are the only differences
    from the previous step. Enter this code directly after the code in the previous
    step:'
  id: totrans-1661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是按钮2到4的几乎相同的代码。注意，传递给 `checkElement` 的值和播放的声音样本是唯一与上一步不同的地方。在上一步骤的代码之后直接输入以下代码：
- en: '[PRE258]'
  id: totrans-1662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Here is the last part of the code in our `onClick` method. This handles the
    **Restart** button. The code just resets the score and the difficulty level and
    then calls our `playASequence` method, which does the rest of the work of starting
    the game again. Enter this code directly after the code in the previous step:'
  id: totrans-1663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们在 `onClick` 方法中的代码的最后部分。这部分处理的是**重置**按钮。代码只是重置得分和难度级别，然后调用我们的 `playASequence`
    方法，它负责重新开始游戏的其余工作。在上一步骤的代码之后直接输入以下代码：
- en: '[PRE259]'
  id: totrans-1664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Finally, here is our do-everything method. This is quite a long method compared
    to most of our previous methods, but it helps to see its entire structure. We
    will break this down line by line in a minute. Enter the following code, after
    which you will actually be able to play the game and get a score:'
  id: totrans-1665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是我们的全能方法。与之前的方法相比，这个方法相当长，但有助于看到它的整个结构。我们将在稍后逐行分解它。在输入以下代码后，你实际上将能够玩游戏并获得分数：
- en: '[PRE260]'
  id: totrans-1666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: We covered the methods fairly comprehensively as we went through the tutorial.
    The one elephant in the room, however, is the apparent sprawl of code in the `checkElement`
    method. So let's go through all of the code in step 6, line by line.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在教程过程中相当全面地介绍了这些方法。然而，房间里的大象，即 `checkElement` 方法中代码的明显扩展。所以让我们一步一步地过一遍第6步中的所有代码。
- en: 'First, we have the method signature. Notice that it does not return a value
    but it receives an `int` value. Remember that it is the `onClick` method that
    calls this method and it passes a `1`, `2`, `3`, or `4`, depending upon which
    button was clicked:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有方法签名。注意，它不返回任何值，但它接收一个`int`类型的值。记住，是`onClick`方法调用这个方法，并传递一个`1`、`2`、`3`或`4`，这取决于哪个按钮被点击：
- en: '[PRE261]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Next, we wrap the rest of this code into an `if` statement. Here is the `if`
    statement. We enter the block when the `isResponding` Boolean is `true`, and `isResponding`
    is set to `true` when the `sequenceFinnished` method completes, which is just
    what we need so that the player can''t mash the buttons until it is time to do
    so and our game is ready to listen:'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将剩余的代码封装到一个`if`语句中。这里是`if`语句。当`isResponding`布尔值为`true`时，我们进入这个代码块，而`isResponding`在`sequenceFinnished`方法完成后被设置为`true`，这正是我们所需要的，以便玩家不能在时间到来之前连续按按钮，并且我们的游戏已经准备好监听：
- en: '[PRE262]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Here is what happens inside the `if` block. We increment the number of the
    player''s responses received in the `playerResponses` variable:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`if`代码块内部发生的事情。我们在`playerResponses`变量中增加玩家收到的响应次数：
- en: '[PRE263]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Now we check whether the number passed to the `checkElement` method and stored
    in `thisElement` matches the appropriate part of the sequence the player is trying
    to copy. If it matches, we increase `playerScore` by an amount relative to the
    number of correctly matched parts of the sequence so far. Then we set the score
    on the screen. Notice that if the response does not match, there is an `else`
    block to go with this `if` block that we will explain soon:'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查传递给`checkElement`方法并存储在`thisElement`中的数字是否与玩家试图复制的序列的适当部分匹配。如果匹配，我们将`playerScore`增加一个与到目前为止正确匹配的序列部分数量相关的金额。然后我们在屏幕上设置分数。注意，如果响应不匹配，有一个`else`代码块与这个`if`代码块相对应，我们将在下面解释：
- en: '[PRE264]'
  id: totrans-1675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Next, we have another `if` block. Note that this `if` block is nested inside
    the `if` block we just described. So it will only be tested and potentially run
    if the player''s response was correct. This `if` statement checks whether it is
    the last part of the sequence, like this:'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还有一个`if`代码块。注意，这个`if`代码块嵌套在我们刚刚描述的`if`代码块内部。因此，它只有在玩家的响应正确时才会被测试和可能执行。这个`if`语句检查是否是序列的最后一部分，如下所示：
- en: '[PRE265]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'If it is the last part of the sequence, it executes the following lines:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是序列的最后一部分，它将执行以下行：
- en: '[PRE266]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'What is happening inside the nested `if` statement, which checks whether the
    whole sequence has been correctly copied, is the following: It sets `isResponding`
    to `false`, so the player gets no response from the buttons. It then raises the
    difficulty level by 1 so that the sequence is a bit tougher next time. Finally,
    it calls the `playSequence` method to play another sequence and the whole process
    starts again.'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的`if`语句内部发生的事情，该语句检查整个序列是否被正确复制，如下所示：它将`isResponding`设置为`false`，因此玩家从按钮那里得不到任何响应。然后它将难度级别提高1，以便下次序列更难。最后，它调用`playSequence`方法来播放另一个序列，整个过程再次开始。
- en: 'Here is the `else` block, which runs if the player gets part of the sequence
    wrong:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`else`代码块，如果玩家在序列的一部分出错时运行：
- en: '[PRE267]'
  id: totrans-1682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Here, we set some text on the screen and set `isResponding` to `false`.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在屏幕上设置一些文本，并将`isResponding`设置为`false`。
- en: Now let's use what we learned about the `SharedPreferences` class to preserve
    the high scores.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用关于`SharedPreferences`类的知识来保存高分。
- en: Phase 4 – preserving the high score
  id: totrans-1685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四阶段 – 保存高分
- en: 'This phase is nice and short. We will use what we learned earlier in the chapter
    to save the player''s score if it is a new high score, and then display the best
    score in the **hi-score** TextView in our `MainActivity`:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段既简洁又愉快。我们将使用本章早期学到的知识，如果玩家得分是新的高分，就保存玩家的分数，然后在`MainActivity`中的**hi-score**
    TextView上显示最佳分数：
- en: Open `MainActivity.java` in the editor window.
  id: totrans-1687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`MainActivity.java`。
- en: 'Then we declare our objects used to read from a file just after the class declaration,
    like this:'
  id: totrans-1688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在类声明之后立即声明用于从文件中读取的对象，如下所示：
- en: '[PRE268]'
  id: totrans-1689
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Now, just after our call to `setContentView` in the `onCreate` method, we initialize
    our objects, read from our file, and set the result to our `hiScore` variable.
    We then display it to the player:'
  id: totrans-1690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就在`onCreate`方法中调用`setContentView`之后，我们初始化我们的对象，从我们的文件中读取，并将结果设置到`hiScore`变量中。然后我们向玩家显示它：
- en: '[PRE269]'
  id: totrans-1691
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Next, we need to go back to the `GameActivity.java` file.
  id: totrans-1692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要回到`GameActivity.java`文件。
- en: 'We declare our objects to edit our file, this time like this:'
  id: totrans-1693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明我们的对象来编辑文件，这次是这样的：
- en: '[PRE270]'
  id: totrans-1694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Just after the call to `setContentView` in the `onCreate` method, we instantiate
    our objects and assign a value to `hiScore`:'
  id: totrans-1695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中调用`setContentView`之后，我们实例化我们的对象并将一个值赋给`hiScore`：
- en: '[PRE271]'
  id: totrans-1696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'The only thing that is different to what we have already learned is that we
    need to consider where we put the code to test for a high score and where to write
    to our file if appropriate. Consider this: eventually, every player must fail.
    Furthermore, the point at which they fail is the point when their score is at
    its highest, yet before it is reset when they try again. Place the following code
    in the `else` block, which handles a wrong answer from the player. The highlighted
    code is the new code; the rest is there to help you with the context:'
  id: totrans-1697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们之前学到的唯一不同之处在于，我们需要考虑将代码放在哪里来测试高分，以及如果合适的话，在哪里写入我们的文件。考虑以下情况：最终，每个玩家都必须失败。此外，他们失败的时刻是他们分数最高的时刻，但在他们再次尝试时分数被重置之前。将以下代码放在处理玩家错误答案的`else`块中，高亮显示的代码是新的代码；其余的代码是为了帮助你理解上下文：
- en: '[PRE272]'
  id: totrans-1698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Play the game and get a high score. Now quit the app or even restart the phone.
    When you come back to the app, your high score is still there.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并得到高分。现在退出应用或甚至重新启动手机。当你回到应用时，你的高分仍然在那里。
- en: The code we added in this phase is nearly the same as the code we wrote in our
    previous example of persistence, the only difference being that we wrote to the
    data store when a new high score was achieved instead of when a button was pressed.
    In addition, we used the `editor.putInt` method because we were saving an integer
    instead of `editor.putString` when we were saving a string.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段我们添加的代码几乎与我们在之前的持久化示例中写的代码相同，唯一的区别在于我们是在达到新的高分时写入数据存储，而不是在按钮被按下时。此外，我们使用了`editor.putInt`方法，因为我们保存的是整数而不是使用`editor.putString`保存字符串。
- en: Animating our game
  id: totrans-1701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化我们的游戏
- en: Before we go ahead, let's just think about animation. What is it exactly? The
    word probably conjures up images of moving cartoon characters and in-game characters
    of a video game.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们先思考一下动画。它究竟是什么？这个词可能让人联想到移动的卡通角色和视频游戏中的游戏角色。
- en: We need to animate our buttons (make them move) to make it clear when they are
    part of the sequence. We saw that simply making one disappear and then reappear
    was inadequate.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要动画化我们的按钮（使它们移动），以便清楚地表明它们是序列的一部分。我们看到了仅仅让一个按钮消失然后再次出现是不够的。
- en: The thought of controlling the movement of UI elements might make us imagine
    complex `for` loops and per-pixel calculations.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 想象控制UI元素的运动可能会让我们联想到复杂的`for`循环和像素级计算。
- en: Fortunately, Android provides us with the `Animation` class, which allows us
    to animate UI objects without any such per-pixel awkwardness. Here is how it works.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android为我们提供了`Animation`类，它允许我们无需任何这样的像素级尴尬来动画化UI对象。以下是它是如何工作的。
- en: Note
  id: totrans-1706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, to fully control the shape and size of in-game objects, we must eventually
    learn to manipulate individual pixels and lines. We will do so from [Chapter 7](ch07.html
    "Chapter 7. Retro Squash Game"), *Retro Squash Game*, onwards, when we make a
    retro pong-style squash game.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要完全控制游戏中的形状和大小，我们最终必须学会操纵单个像素和线条。我们将从[第7章](ch07.html "第7章。复古 squash 游戏")，*复古
    squash 游戏*开始这样做，当我们制作复古乒乓球风格的 squash 游戏时。
- en: UI animation in Android
  id: totrans-1708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android中的UI动画
- en: 'Animations in the Android UI can be divided into three phases:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: Android UI中的动画可以分为三个阶段：
- en: Describing the animation in a file using a special syntax we will see shortly
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们很快就会看到的特殊语法在文件中描述动画
- en: Referencing that animation by creating an object of it in our Java code
  id: totrans-1711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Java代码中通过创建其对象来引用该动画
- en: Applying the animation to a UI element when the animation is required to run
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要运行动画时，将动画应用于UI元素
- en: Let's take a look at some code that describes an animation. We will soon be
    reusing this same code in our memory game. The purpose of showing it is not so
    much that we understand each and every line of it. After all, learning Java should
    be enough of an accomplishment without mastering this too. Moreover, the purpose
    is to demonstrate that whatever animation you can describe can then be used in
    our games using the same Java.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些描述动画的代码。我们很快就会在记忆游戏中重用这段代码。展示它的目的并不仅仅是让我们理解它的每一行。毕竟，学习Java本身就足够是一项成就，无需掌握这一点。此外，目的在于展示无论你描述了什么样的动画，都可以使用相同的Java在我们的游戏中使用。
- en: 'We can quickly search the Web to find the code to perform the following:'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速在网上搜索以找到执行以下操作的代码：
- en: Fading in and out
  id: totrans-1715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡入淡出
- en: Sliding
  id: totrans-1716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动
- en: Rotating
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转
- en: Expanding or shrinking
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展或缩小
- en: Morphing color
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状变色
- en: 'Here is some code that causes a wobble effect. We will use it on a button,
    but you can also use it on any UI element or even the whole screen:'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码可以产生晃动效果。我们将将其用于按钮，但你也可以将其用于任何 UI 元素，甚至整个屏幕：
- en: '[PRE273]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: The first line simply states that this is a file written in XML format. The
    next states that we will be performing a rotation. Then we state that the duration
    will be 100 milliseconds, the rotation will be from -5 degrees, the pivot will
    be on the *x* and *y* axes by 50 percent, repeat eight times, and reverse to positive
    5 degrees.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行简单地声明这是一个以 XML 格式编写的文件。下一行声明我们将执行一个旋转。然后我们声明持续时间将为 100 毫秒，旋转将从 -5 度开始，旋转中心在
    *x* 和 *y* 轴上各占 50%，重复八次，然后反向到正 5 度。
- en: This is quite a mouthful, but the point is that it is easy to grab a template
    that works and then customize it to fit our situation. We could save the preceding
    code with a filename like `wobble.xml`.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些复杂，但关键是它很容易抓取一个有效的模板，然后根据我们的情况对其进行定制。我们可以将前面的代码保存为名为 `wobble.xml` 的文件。
- en: 'Then we could simply reference it as follows:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地按照以下方式引用它：
- en: '[PRE274]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'Now we can play the animation like this on our chosen UI object, in this case
    our `button1` object:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们选择的 UI 对象上播放动画，在这种情况下是我们的 `button1` 对象：
- en: '[PRE275]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Phase 5 – animating the UI
  id: totrans-1728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五阶段 – 动画 UI
- en: 'Let''s add an animation that causes a button to wobble when a button sound
    is played. At the same time, we can remove the code that makes the button invisible
    and the code that makes it reappear. That wasn''t the best way to do it, but it
    served a purpose while developing the game:'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个动画，当播放按钮声音时，按钮会晃动。同时，我们可以移除使按钮不可见和使其重新出现的代码。这并不是最好的方法，但在开发游戏时它起到了作用：
- en: We need to add a new folder to our project, called `anim`. So right-click on
    the `res` folder in the Project Explorer window. Navigate to **New** | **Android
    resource directory** and click on **OK** to create the new `anim` folder.
  id: totrans-1730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们项目中添加一个新的文件夹，命名为 `anim`。因此，在项目资源管理器窗口中，在 `res` 文件夹上右键单击。导航到 **新建** |
    **Android 资源目录**，然后单击 **确定** 创建新的 `anim` 文件夹。
- en: Now right-click on the `anim` folder and navigate to **New** | **Animation resource
    file**. Enter `wobble` in the **File name** field and click on **OK**. We now
    have a new file called **wobble.xml** open in the editor window.
  id: totrans-1731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `anim` 文件夹上右键单击，并导航到 **新建** | **动画资源文件**。在 **文件名** 字段中输入 `wobble`，然后单击
    **确定**。现在我们在编辑器窗口中打开了一个名为 **wobble.xml** 的新文件。
- en: 'Replace all but the first line of `wobble.xml` with this code:'
  id: totrans-1732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `wobble.xml` 的第一行之外的所有行替换为以下代码：
- en: '[PRE276]'
  id: totrans-1733
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Now switch to `GameActivity.java`.
  id: totrans-1734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `GameActivity.java`。
- en: 'Add the following code just after the declaration of our `GameActivity` class:'
  id: totrans-1735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `GameActivity` 类声明之后添加以下代码：
- en: '[PRE277]'
  id: totrans-1736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Just after the call to `setContentView` in our `onCreate` method, add this
    piece of code:'
  id: totrans-1737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `onCreate` 方法中调用 `setContentView` 之后，添加以下代码：
- en: '[PRE278]'
  id: totrans-1738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Now, near the start of our thread code, find the calls to make our buttons
    reappear. Comment them out like this:'
  id: totrans-1739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的线程代码开头附近，找到使按钮重新出现的调用。像这样将其注释掉：
- en: '[PRE279]'
  id: totrans-1740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Next, directly after our code in the previous step, within each of the four
    `case` statements, we need to comment out the lines that call `setVisibility`
    and replace them with our wobble animation. The following code is slightly abbreviated
    but shows exactly where to comment and where to add the new lines:'
  id: totrans-1741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，直接在我们上一步的代码之后，在每个 `case` 语句中，我们需要注释掉调用 `setVisibility` 的行，并用我们的晃动动画替换它们。以下代码略有缩写，但显示了注释和添加新行的确切位置：
- en: '[PRE280]'
  id: totrans-1742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Finally, in our `sequenceFinished` method, we can comment out all the `setVisibility`
    calls, just as we did in our thread, like this:'
  id: totrans-1743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的 `sequenceFinished` 方法中，我们可以像在线程中那样注释掉所有的 `setVisibility` 调用，如下所示：
- en: '[PRE281]'
  id: totrans-1744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: That was not too tough. We added the wobble animation to the `anim` folder,
    declared an animation object, and initialized it. Then we used it whenever it
    was required on the appropriate button.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太难。我们在 `anim` 文件夹中添加了晃动动画，声明了一个动画对象，并初始化了它。然后，在需要时在适当的按钮上使用它。
- en: There are obviously loads of improvements we could make to this game, especially
    to its appearance. I'm sure you can think of more. And certainly, if this was
    to be your app, you were trying to make it big on the Play Store. That is exactly
    what you should do.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以对这个游戏进行大量的改进，特别是外观方面。我相信你能想到更多。当然，如果这是你的应用，你正在尝试在 Play Store 上取得成功。这正是你应该做的。
- en: Constantly improve all aspects and strive to be the best in your genre. If you
    feel the urge, then why not improve upon it?
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 不断改进所有方面，努力成为你所在领域的最佳。如果你有这样的冲动，为什么不尝试改进呢？
- en: Here are a few self-test questions that look at ways we could do more with some
    of the examples from this chapter.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些自我测试问题，考察了我们如何利用本章的一些示例做更多的事情。
- en: Self-test questions
  id: totrans-1749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1) Suppose that we want to have a quiz where the question could be to name
    the president as well as capital city. How can we do this with multidimensional
    arrays?
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 假设我们想要有一个测验，问题可能是命名总统以及首都。我们如何使用多维数组来完成这个任务？
- en: Q2) In our *Persistence example* section, we saved a continually updating string
    to a file so that it persisted after the app had been shut down and restarted.
    This is like asking the user to click on a Save button. Summoning all your knowledge
    of [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it in the button click but just when the user quits the app?
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在我们的 *持久化示例* 部分，我们将一个持续更新的字符串保存到文件中，以便在应用程序关闭并重新启动后持久化。这就像要求用户点击一个“保存”按钮。回顾一下[第2章](ch02.html
    "第2章. 开始使用Android")，*开始使用Android*，你能想到一种方法来保存字符串，而无需在按钮点击时保存，而是在用户退出应用程序时保存吗？
- en: Q3) Other than increasing the difficulty level, how could we increase the challenge
    of our memory game for our players?
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 除了提高难度级别，我们如何增加我们记忆游戏的挑战性，以吸引我们的玩家？
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer and try and work out how
    we could quickly improve the visual appearance of our UI.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 使用平淡无奇的Android UI和单调的灰色按钮并不令人兴奋。看看视觉设计器中的UI元素，并尝试找出我们如何快速改善UI的视觉外观。
- en: Summary
  id: totrans-1754
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That was a bit of a hefty chapter, but we learned lots of new techniques such
    as storing and manipulating with arrays, creating and using sound effects, and
    saving important data such as a high score, in our game. We also took a very brief
    look at the powerful but simple-to-use `Animation` class.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个相当厚重的章节，但我们学到了很多新技术，例如使用数组进行存储和操作、创建和使用音效，以及在我们的游戏中保存重要数据，如高分。我们还简要地了解了一下功能强大且易于使用的`Animation`类。
- en: In the next chapter, we will be taking a more theoretical approach, but we will
    have plenty of working samples too. We will finally be opening the black box of
    Java classes so that we can gain an understanding of what is going on when we
    declare and use objects of a class.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采取更理论的方法，但也会有大量的实际示例。我们最终将打开Java类的黑盒子，以便我们能够理解当我们声明和使用类的对象时发生了什么。
- en: Chapter 6. OOP – Using Other People's Hard Work
  id: totrans-1757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. OOP – 利用他人的辛勤工作
- en: OOP stands for **object-oriented programming**. In this chapter, you don't need
    to even try and remember everything. Why do I say this? Surely, that's what learning
    is. The more important thing is to grasp the concepts and begin to understand
    the *why* of OOP rather than memorize rules, syntax, and jargon.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: OOP代表**面向对象编程**。在本章中，你甚至不需要尝试记住所有内容。我为什么这么说？当然，那才是学习的本质。更重要的是，要掌握概念，并开始理解OOP的*为什么*，而不是记住规则、语法和术语。
- en: The more important thing is to actually start to use some of the concepts, even
    though you might have to keep referring back and your code might not properly
    adhere to every OOP principal that we discuss. Neither does the code in this book.
    The code in this chapter is here to help you explore and grasp the concepts of
    OOP.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，实际上开始使用一些概念，即使你可能需要不断回顾，你的代码可能也无法完全遵循我们讨论的每个面向对象编程（OOP）原则。本书中的代码也是如此。本章中的代码旨在帮助你探索和掌握OOP的概念。
- en: If you try to memorize this chapter, you will have to make a lot of room in
    your brain, and you will probably forget something really important in its place
    such as going to work or thanking the author for telling you not to try and memorize
    this stuff.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图记住这一章，你需要在你的大脑中腾出很多空间，你可能会忘记一些非常重要的事情，比如去上班或感谢作者告诉你不要试图记住这些内容。
- en: A good goal will be to try and almost get it. Then we will start to recognize
    examples of OOP in action so that our understanding becomes more rounded. You
    can then often refer back to this chapter for a refresher.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的目标将是尽量接近成功。然后我们将开始识别OOP的实际应用示例，以便我们的理解更加全面。然后你可以经常回顾这一章以进行复习。
- en: So what is all this OOP stuff we will learn about? Actually, we have already
    learned loads about OOP. Until now, we have been using classes such as `Button`,
    `Random`, and `Activity`, overriding methods of classes (mainly `onCreate`) and
    using an **interface** as well; remember implementing `onClickListener` a few
    times in the first five chapters?
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们将学习哪些关于面向对象编程（OOP）的东西呢？实际上，我们已经在面向对象编程（OOP）方面学到了很多。到目前为止，我们已经使用了`Button`、`Random`和`Activity`等类，覆盖了类的方法（主要是`onCreate`）以及使用了一个**接口**；记得在前五章中多次实现`onClickListener`吗？
- en: This chapter just helps to make sense of OOP and expands our understanding,
    and finally, we will make our own classes.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是帮助我们理解面向对象编程（OOP），并扩展我们的理解，最后，我们将自己创建类。
- en: Then we will be in a good position in the next two chapters to make two cool
    retro arcade games using lots of other people's hard work. This chapter will be
    mainly theory, but with a few practical console examples using LogCat so that
    we can see OOP in action.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在接下来的两个章节中，我们将能够利用许多人的辛勤工作来制作两个酷炫的复古街机游戏。本章将主要介绍理论，但会包含一些使用LogCat的实用控制台示例，以便我们可以看到面向对象编程（OOP）的实际应用。
- en: 'In this chapter, we will do the following:'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Look at what OOP is.
  id: totrans-1766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看面向对象编程（OOP）是什么。
- en: Write our first class.
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个类。
- en: Look at what encapsulation is and how we achieve it as well as look more deeply
    at variables and the different types. We will also take a short break to throw
    out the garbage.
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看封装是什么，以及我们如何实现它，以及更深入地了解变量和不同类型。我们还将短暂休息一下，以清除垃圾。
- en: Learn about inheritance and how we can extend and even improve upon a class
    before we use it.
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用之前，了解继承以及我们如何扩展甚至改进一个类。
- en: Take a look at polymorphism, which is a way of being more than one thing at
    a time and is really useful in programming.
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看多态性，这是一种一次成为多件事物的方式，在编程中非常有用。
- en: What is OOP?
  id: totrans-1771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是面向对象编程（OOP）？
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种编程方式，它涉及将我们的需求分解成比整体更易于管理的块。
- en: Each chunk is self-contained yet potentially reusable by other programs while
    working together as a whole with the other chunks.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都是自包含的，同时可能被其他程序重用，同时与其他块一起作为一个整体工作。
- en: These chunks are what we have been referring to as objects. When we plan an
    object, we do so with a class. A class can be thought of as the blueprint of an
    object.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块就是我们所说的对象。当我们规划一个对象时，我们是用一个类来规划的。一个类可以被看作是对象的蓝图。
- en: 'We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can''t live in it, but you can build a house
    from it, which means you build an instance of it. However, OOP is more than this.
    It is also a methodology that defines best practices such as the following:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个类的对象。这被称为类的**实例**。想想房子的蓝图。你不能住在里面，但你可以从它那里建造一栋房子，这意味着你建造了它的一个实例。然而，面向对象编程（OOP）不仅仅是这个。它也是一种定义最佳实践的方法论，例如以下内容：
- en: '**Encapsulation**: This means keeping the internal workings of your code safe
    from interference from the programs that use it, and allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still accessed in the same way.'
  id: totrans-1776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：这意味着保护你的代码的内部工作不被使用它的程序干扰，并且只允许你选择的变量和方法被访问。这意味着只要暴露的部分仍然以相同的方式访问，你的代码就可以始终更新、扩展或改进，而不会影响使用它的程序。'
- en: '**Inheritance**: Just like it sounds, inheritance means we can harness all
    the features and benefits of other people''s hard work, including encapsulation
    and polymorphism, while refining their code specifically for our situation. Actually,
    we have done this already every time we used the `extends` keyword.'
  id: totrans-1777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：正如其名，继承意味着我们可以利用其他人的所有努力，包括封装和多态性，同时针对我们的特定情况进行代码优化。实际上，我们每次使用`extends`关键字时都已经这样做过了。'
- en: '**Polymorphism**: This allows us to write code that is less dependent on the
    types we are trying to manipulate, making our code clearer and more efficient.
    Some examples later in the chapter will make this clear.'
  id: totrans-1778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：这允许我们编写不那么依赖于我们试图操作的类型的代码，使我们的代码更清晰、更高效。本章后面的几个例子将使这一点变得清晰。'
- en: Tip
  id: totrans-1779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we talk about using other people's hard work, we are not talking about
    a magical way to abuse copyright and get away with it. Some code is plain and
    simple, someone else's property. What we are taking about is the vast array of
    free-to-use code, particularly in the context of this book, in the Java and Android
    APIs. If you want some code that does a certain thing, it has probably been done
    before. We just have to find it, then use it or modify it.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论利用他人的辛勤工作时，我们并不是在谈论一种滥用版权并逍遥法外的神奇方法。有些代码简单明了，属于他人的财产。我们所说的是大量可供免费使用的代码，尤其是在本书的Java和Android
    API的背景下。如果你需要一些完成特定任务的代码，它可能已经被编写过了。我们只需要找到它，然后使用或修改它。
- en: Java was designed from the start with all of this in mind, so we are fairly
    significantly constrained to using OOP. However, this is a good thing because
    we learn how to use the best practices.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: Java从一开始就是为了考虑所有这些而设计的，所以我们相当程度上被限制在面向对象编程的使用上。然而，这却是好事，因为它让我们学会了如何使用最佳实践。
- en: Why do it like this?
  id: totrans-1782
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这样做？
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained nature means less, or perhaps zero, consequences for
    other parts of the program. This is the encapsulation part.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写得当，所有这些面向对象编程都允许你在添加新功能时不必过多担心它们与现有功能的交互。当你确实需要更改一个类时，其自包含的特性意味着对程序其他部分的影响更小，或者可能是零。这就是封装的部分。
- en: You can use other people's code without knowing or perhaps even caring how it
    works. Think about the Android lifecycle, buttons, threads, and so on. The `Button`
    class is quite complicated, with nearly 50 methods—do we really want to write
    all that just for a button?
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用他人的代码，而无需了解甚至可能不关心它是如何工作的。想想Android的生命周期、按钮、线程等等。`Button`类相当复杂，有近50个方法——我们真的想只为一个按钮编写所有这些代码吗？
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat. You can create multiple similar yet different versions of a class without
    starting the class from scratch using inheritance, and you can still use the methods
    intended for the original type of object with your new object because of polymorphism.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）让你在处理高度复杂的情况时也能轻松应对。你可以通过继承来创建多个类似但不同的类版本，而无需从头开始编写类，同时由于多态性，你仍然可以使用为原始对象类型设计的那些方法来使用你的新对象。
- en: Makes sense, really! Let's write some classes and then make some objects out
    of them.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很有道理！让我们编写一些类，然后从它们中创建一些对象。
- en: Our first class and first object
  id: totrans-1787
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个类和第一个对象
- en: So what exactly is a class? A class is a bunch of code that can contain methods,
    variables, loops, and all other types of Java syntax. A class is part of a package
    and most packages will normally have multiple classes. Usually, but not always,
    each new class will be defined in its own `.java` code file with the same name
    as the class.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 那么到底什么是类呢？类是一组可以包含方法、变量、循环以及所有其他类型Java语法的代码。类是包的一部分，大多数包通常会有多个类。通常但并非总是，每个新的类都会定义在其自己的`.java`代码文件中，文件名与类名相同。
- en: Once we have written a class, we can use it to make as many objects from it
    as we need. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class;
    it is an object made from the class.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了一个类，我们就可以用它来创建所需数量的对象。记住，类是蓝图，我们根据蓝图来创建对象。房子不是蓝图，对象也不是类；它是从类中创建的对象。
- en: 'Here is the code for a class. We call it a class implementation:'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个类的代码。我们称之为类实现：
- en: '[PRE282]'
  id: totrans-1791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The preceding snippet of code is a class implementation for a class called `Soldier`.
    There are two variables, an `int` variable called `health` and a `string` variable
    called `soldierType`.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个名为`Soldier`的类的实现。有两个变量，一个名为`health`的`int`类型变量和一个名为`soldierType`的`string`类型变量。
- en: There is also a method called `shootEnemy`. The method has no parameters and
    a `void return` type, but class methods can be of any shape or size that we discussed
    in [Chapter 5](ch05.html "Chapter 5. Gaming and Java Essentials"), *Gaming and
    Java Essentials*.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`shootEnemy`的方法。该方法没有参数，返回类型为`void`，但类方法可以是我们在[第5章](ch05.html "第5章。游戏和Java基础")“游戏和Java基础”中讨论的任何形状或大小。
- en: When we declare variables in a class, they are known as **fields**. When the
    class is instantiated into a real object, the fields become variables of the object
    itself, so we call them **instance** variables. Whichever fancy name they are
    referred to by, they are just variables of the class. However, the difference
    between fields and variables declared in methods (called the **local** variables)
    becomes more important as we progress. We will look at all types of variables
    again in the *Variables revisited* section.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类中声明变量时，它们被称为**字段**。当类实例化为一个真实对象时，字段变成了对象本身的变量，因此我们称它们为**实例变量**。无论它们被称为什么花哨的名字，它们只是类的变量。然而，随着我们的深入，字段和方法中声明的变量（称为**局部变量**）之间的区别变得越来越重要。我们将在
    *变量回顾* 部分再次查看所有类型的变量。
- en: 'Remember, this is just a class, not an object. It is a blueprint for a soldier,
    not an actual `soldier` object. This is how we make an object of the `Soldier`
    type from our `Soldier` class:'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这只是一个类，不是一个对象。这是一个士兵的蓝图，而不是实际的 `soldier` 对象。这就是我们从 `Soldier` 类中创建 `Soldier`
    类型对象的方式：
- en: '[PRE283]'
  id: totrans-1796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'In the first part of the code, `Soldier mySoldier` declares a new reference
    type variable of type `Soldier`, called `mySoldier`, and in the last part of the
    code, `new Soldier()` creates an actual `Soldier` object. Of course, the assignment
    operator, `=`, in the middle of the two parts assigns the result of the second
    part to that of the first. Just like regular variables, we could also have performed
    the preceding steps like this:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一部分，`Soldier mySoldier` 声明了一个新的引用类型变量 `mySoldier`，类型为 `Soldier`，在代码的最后部分，`new
    Soldier()` 创建了一个实际的 `Soldier` 对象。当然，两个部分中间的赋值操作符 `=` 将第二部分的结果赋给第一部分。就像常规变量一样，我们也可以像这样执行前面的步骤：
- en: '[PRE284]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'This is how we would assign and use the variables:'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何分配和使用变量的方式：
- en: '[PRE285]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'In the preceding code snippet, the dot operator, `.`, is used to access the
    variables of the class, and this is how we would call the method. Again, we use
    the object name and not the class name, followed by the dot operator:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，点操作符 `.` 用于访问类的变量，这就是我们调用方法的方式。再次强调，我们使用对象名称而不是类名称，然后跟随着点操作符：
- en: '[PRE286]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Tip
  id: totrans-1803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a rough guide, a class's methods are what it can *do* and its instance variables
    are what it *knows* about itself.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 作为粗略的指南，一个类的方法是它能做什么，它的实例变量是它对自己了解的内容。
- en: 'We can also go ahead by making another `Soldier` object and accessing its methods
    and variables:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过创建另一个 `Soldier` 对象并访问其方法和变量来继续：
- en: '[PRE287]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: It is important to realize that `mySoldier2` is a totally separate object with
    totally separate instance variables.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到 `mySoldier2` 是一个完全独立的对象，具有完全独立的实例变量。
- en: Also notice that everything is done on the object itself. We must create objects
    of classes in order to make them useful.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有操作都是在对象本身上进行的。我们必须创建类的对象，以便使它们变得有用。
- en: Note
  id: totrans-1809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As always, there are exceptions to this rule, but they are in the minority,
    and we will look at the exceptions later in the chapter. In fact, we have already
    seen an exception way back in [Chapter 3](ch03.html "Chapter 3. Speaking Java
    – Your First Game"), *Speaking Java – Your First Game*. Think of `Toast`.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有例外，但它们是少数，我们将在本章后面讨论这些例外。事实上，我们早在 [第3章](ch03.html "第3章. 讲解Java – 你的第一个游戏")，*讲解Java
    – 你的第一个游戏* 中就已经看到了一个例外。想想 `Toast`。
- en: Let's explore basic classes a little more deeply.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探索基本类。
- en: Basic classes
  id: totrans-1812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类
- en: What happens when we want an army of `Soldier` objects? We will instantiate
    multiple objects. We will also demonstrate the use of the dot operator on variables
    and methods, and show that different objects have different instance variables.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要一支 `Soldier` 对象的军队时，我们将实例化多个对象。我们还将演示在变量和方法上使用点操作符，并展示不同的对象有不同的实例变量。
- en: 'You can get the working project for this example in the code download. It is
    in the `chapter6` folder and is called simply `BasicClasses`. Or read on to create
    your own working example:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码下载中找到这个示例的工作项目。它在 `chapter6` 文件夹中，简单地命名为 `BasicClasses`。或者继续阅读以创建你自己的工作示例：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Clean
    up the code by deleting the unnecessary parts, but this isn't essential. Call
    the application `BasicClasses`.
  id: totrans-1815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在 [第2章](ch02.html "第2章. 开始使用Android")，*开始使用Android* 中所做的那样。通过删除不必要的部分来清理代码，但这不是必需的。将应用程序命名为
    `BasicClasses`。
- en: Now we create a new class called `Soldier`. Right-click on the `com.packtpub.basicclasses`
    folder in the Project Explorer window. Click on **New**, then on **Java Class**.
    In the **Name** field, type `Soldier` and click on **OK**. The new class is created
    for us, with a code template ready to put our implementation within, just like
    what is shown in the following screenshot:![Basic classes](img/8859OS_06_01.jpg)
  id: totrans-1816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个新的类，名为`Soldier`。在项目资源管理器窗口中，右键单击`com.packtpub.basicclasses`文件夹。点击**新建**，然后点击**Java类**。在**名称**字段中输入`Soldier`，然后点击**确定**。新类会为我们创建，并带有代码模板，我们可以将其实现放入其中，就像以下截图所示：![基本类](img/8859OS_06_01.jpg)
- en: 'Notice that Android Studio has put the class in the same package as the rest
    of our app. Now we can write its implementation. Write the following class implementation
    code within the opening and closing curly braces of the `Soldier` class:'
  id: totrans-1817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Android Studio已经将类放在了与我们的应用其余部分相同的包中。现在我们可以编写它的实现了。在`Soldier`类的开头和结尾大括号内编写以下类实现代码：
- en: '[PRE288]'
  id: totrans-1818
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Now that we have a class, a blueprint for our future objects of the `Soldier`
    type, we can start to build our army. In the editor window, click on the tab of
    **MainActivity.java**. We will write this code, as so often, within the `onCreate`
    method just after the call to `setContentView`:'
  id: totrans-1819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了类，这是我们的未来`Soldier`类型对象的蓝图，我们可以开始构建我们的军队。在编辑器窗口中，点击**MainActivity.java**标签页。我们将像往常一样，在调用`setContentView`方法之后，在`onCreate`方法中编写此代码：
- en: '[PRE289]'
  id: totrans-1820
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Tip
  id: totrans-1821
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is a really good time to start taking advantage of the autocomplete feature
    in Android Studio. Notice that after you have declared and created a new object,
    all you have to do is begin typing the object's name and all the autocomplete
    options will present themselves.
  id: totrans-1822
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这正是开始利用Android Studio中的自动完成功能的好时机。注意，在你声明并创建了一个新对象之后，你只需开始输入对象的名称，所有自动完成选项就会显示出来。
- en: 'Now that we have our extremely varied and somewhat unlikely army, we can use
    it and also verify the identity of each object. Type the following code below
    the code in the previous step:'
  id: totrans-1823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了极其多样且有些不太可能的军队，我们可以使用它并验证每个对象的身份。在上一步骤的代码下方输入以下代码：
- en: '[PRE290]'
  id: totrans-1824
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Now we can run our app on an emulator. Remember, all the output will be in the
    **LogCat** console window.
  id: totrans-1825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在模拟器上运行我们的应用。记住，所有输出都将显示在**LogCat**控制台窗口中。
- en: This is how the preceding pieces of code work. In step 2, Android Studio created
    a template for our new `Soldier` class. In step 3, we implemented our class in
    quite the same way that we have before—two variables, an `int` and a `string`,
    called `health` and `soldierType`, respectively.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码片段的工作原理。在第2步中，Android Studio为我们新的`Soldier`类创建了一个模板。在第3步中，我们以与之前相同的方式实现了我们的类——两个变量，一个`int`和一个`string`，分别称为`health`和`soldierType`。
- en: 'We also have a method in our class called `shootEnemy`. Let''s look at it again
    and examine what is going on:'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类中还有一个名为`shootEnemy`的方法。让我们再次查看它并检查正在发生的事情：
- en: '[PRE291]'
  id: totrans-1828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: In the body of the method, we print the `soldierType` string to the console
    first, and then the arbitrary `" is shooting"` string. What's neat here is that
    the `soldierType` string will be different depending on which object we call the
    `shootEnemy` method on.
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法体中，我们首先将`soldierType`字符串打印到控制台，然后是任意的`" is shooting"`字符串。这里很酷的是，`soldierType`字符串将根据我们调用`shootEnemy`方法的哪个对象而不同。
- en: In step 4, we declared, created, and assigned three new objects of type `Soldier`.
    They where `rambo`, `vassily`, and `wellington`. In step 5, we initialized each
    with a different value for `health` as well as `soldierType`.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们声明、创建并分配了三个新的`Soldier`类型对象。它们是`rambo`、`vassily`和`wellington`。在第5步中，我们为每个对象的`health`以及`soldierType`分配了不同的值。
- en: 'Here is the output:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE292]'
  id: totrans-1832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Notice that each time we access the `health` variable of each `Soldier` object,
    it is printed to the value we assigned it, demonstrating that although the three
    objects are of the same type, they are completely separate individual objects.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次我们访问每个`Soldier`对象的`health`变量时，它都会打印出我们分配的值，这证明了尽管三个对象属于同一类型，但它们是完全独立的个体对象。
- en: Perhaps more interesting are the three calls to `shootEnemy`. One call by each
    of our `Soldier` objects' `shootEnemy` method is made, and we print the `soldierType`
    variable to the console. The method has the appropriate value for each individual
    object, further demonstrating that we have three distinct objects, albeit created
    from the same `Soldier` class.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更有趣的是对 `shootEnemy` 的三次调用。我们的每个 `Soldier` 对象的 `shootEnemy` 方法都进行了一次调用，并且我们将
    `soldierType` 变量打印到控制台。该方法对每个单独的对象都有适当的值，进一步证明了我们有三个不同的对象，尽管它们都是从同一个 `Soldier`
    类创建的。
- en: More things we can do with our first class
  id: totrans-1835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以用我们的第一个类做更多的事情
- en: 'We can treat a class much like other variables. Assuming we have already implemented
    our `Soldier` class, we can make an array of `Soldier` objects like this:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类视为其他变量一样。假设我们已经实现了我们的 `Soldier` 类，我们可以创建一个 `Soldier` 对象的数组，如下所示：
- en: '[PRE293]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Then we can use an object from an array using the same style of array notation
    as we did for regular variables, like this:'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用与常规变量相同的数组表示法来使用数组中的对象，如下所示：
- en: '[PRE294]'
  id: totrans-1839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'We can also use a class as an argument in a method call. Here is a hypothetical
    call to a `healSoldier` method:'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个类用作方法调用中的参数。以下是对 `healSoldier` 方法的假设调用：
- en: '[PRE295]'
  id: totrans-1841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Tip
  id: totrans-1842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, the preceding example might raise questions like should the `healSoldier`
    method be a method of a class?
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的例子可能会引发一些问题，比如 `healSoldier` 方法是否应该是类的一个方法？
- en: '[PRE296]'
  id: totrans-1844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: It could be or not (as shown in the previous example). It would depend upon
    what is the best solution for the situation. We will look at more OOP, and then
    the best solution for lots of similar conundrums should present themselves more
    easily.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是或不是（如前例所示）。这取决于对情况的最好解决方案。我们将查看更多的面向对象编程，然后对于许多类似的难题，最好的解决方案应该更容易出现。
- en: 'As you might have come to expect by now, we can use an object as the return
    value of a method. Here is what the hypothetical `healSoldier` method might look
    like:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所期望的那样，我们可以将对象用作方法调用的返回值。以下是对假设的 `healSoldier` 方法的可能实现：
- en: '[PRE297]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: All of this information will likely raise a few questions. OOP is like that,
    so to try and consolidate all this class stuff with what we already know, let's
    take another look at variables and encapsulation.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息可能会引发一些疑问。面向对象编程（OOP）就是这样，所以为了尝试将所有这些类的东西与我们已经知道的东西结合起来，让我们再看看变量和封装。
- en: Encapsulation
  id: totrans-1849
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention, although we did discuss the wider goals of all this OOP stuff. Now
    we will take things further and begin to see how we actually manage to achieve
    encapsulation with OOP.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们真正看到的是一种代码组织惯例，尽管我们讨论了所有这些面向对象编程的更广泛目标。现在我们将更进一步，看看我们实际上是如何通过面向对象编程实现封装的。
- en: Tip
  id: totrans-1851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Definition of encapsulation**'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装的定义**'
- en: As we have learned encapsulation means keeping the internal workings of your
    code safe from interference from the programs that use it, allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still made available in the same way. It also allows the code
    that uses your encapsulated code to be much simpler and easier to maintain because
    much of the complexity of the task is encapsulated in your code.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，封装意味着保护你的代码的内部工作免受使用它的程序的干扰，只允许你选择的变量和方法被访问。这意味着只要暴露的部分仍然以相同的方式提供，你的代码就可以始终更新、扩展或改进，而不会影响使用它的程序。这也使得使用你的封装代码的程序更加简单和易于维护，因为任务的大部分复杂性都封装在你的代码中。
- en: But didn't I say that we don't have to know what is going on inside? So you
    might question what we have seen so far. If we are constantly setting the instance
    variables like this `rambo.health = 100;`, isn't it possible that eventually things
    could start to go wrong, perhaps like the following line of code?
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 但我没有说过我们不需要了解内部发生的事情吗？所以你可能会对我们迄今为止所看到的内容提出质疑。如果我们不断地设置实例变量，就像这样 `rambo.health
    = 100;`，那么最终事情可能会开始出错，也许就像以下这一行代码？
- en: '[PRE298]'
  id: totrans-1855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Encapsulation protects your class from being used in a way that it wasn''t
    meant to be. By strictly controlling the way that your code is used, it can only
    ever do what you want it to do, with values you can control. It can''t be forced
    into errors or crashes. Also, you are then free to make changes to the way your
    code works internally, without breaking any programs that are using an older version
    of the code or the rest of your program:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 封装保护你的类不被以它不应该被使用的方式使用。通过严格控制代码的使用方式，它只能做你想要它做的事情，使用你可以控制的价值。它不能被强制进入错误或崩溃。此外，你还可以自由地更改代码内部的工作方式，而不会破坏使用较旧版本代码或程序其他部分的任何程序：
- en: '[PRE299]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: We can encapsulate our classes to avoid this, and here is how.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过封装我们的类来避免这种情况，下面是如何做的。
- en: Controlling the use of classes with access modifiers
  id: totrans-1859
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制类的使用
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an **access modifier** before the `class`
    keyword, like this:'
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计者控制着任何使用他们类的程序可以看到和操作的内容。我们可以在 `class` 关键字之前添加一个 **访问修饰符**，如下所示：
- en: '[PRE300]'
  id: totrans-1861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'There are two class access modifiers. Let''s briefly look at each in turn:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类访问修饰符。让我们依次简要地看看每个：
- en: '`public`: This is straightforward. A class declared as `public` can be seen
    by all other classes.'
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：这是直截了当的。声明为 `public` 的类可以被所有其他类看到。'
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package, and inaccessible
    to all others.'
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当没有指定访问修饰符时，类具有默认访问。这将使其公开，但仅限于同一包中的类，对所有其他类不可访问。'
- en: Now we can make a start with this encapsulation thing. However, even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始处理这个封装问题。然而，即使一眼看去，所描述的访问修饰符也不是非常细粒度。我们似乎被限制在完全锁定包外的一切或完全自由使用。
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package that fulfills a set of tasks. Then all the complex inner workings
    of the package, the stuff that shouldn't be messed with by anybody but our package,
    should have default access (only accessible to classes within the package). We
    can then provide a careful selection of public classes that can be used by others
    (or other distinct parts of our program).
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里的好处很容易被利用。想法是设计一个包，它完成一系列任务。然后，包的复杂内部工作，那些不应该被除我们包之外的人乱动的东西，应该有默认访问（仅限于包内的类）。然后我们可以提供一组精心挑选的公开类，供其他人（或我们程序的另一个独立部分）使用。
- en: Tip
  id: totrans-1867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the size and complexity of the games in this book, multiple packages are
    almost certainly overkill.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书中游戏的规模和复杂性，多个包几乎肯定是不必要的。
- en: Class access in a nutshell
  id: totrans-1869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问概述
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含默认或默认和公开的类。
- en: In addition to class-level privacy controls, Java gives us very fine-grained
    controls, but to use these controls, we have to look at variables in more detail.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类级别的隐私控制之外，Java 给我们提供了非常细粒度的控制，但为了使用这些控制，我们必须更详细地查看变量。
- en: Controlling the use of variables with access modifiers
  id: totrans-1872
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制变量的使用
- en: 'To build on class visibility controls, we have variable access modifiers. Here
    is a variable with the private access modifier being declared:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建基于类可见性控制的基础上，我们有了可变访问修饰符。下面是一个声明为私有访问修饰符的变量示例：
- en: '[PRE301]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们关于变量访问修饰符的所有讨论也适用于对象变量。例如，这里是我们 `Soldier` 类的一个实例被声明、创建和分配的情况。正如你所看到的，这种情况下的访问指定是公开的：
- en: '[PRE302]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class `a` is not visible to class `b`, say because class `a` has
    default access and class `b` is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class `a`; class `b` still can't
    see it.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 在将修饰符应用于变量之前，你必须首先考虑类的可见性。如果类 `a` 对类 `b` 不可见，比如说因为类 `a` 有默认访问，而类 `b` 在另一个包中，那么在类
    `a` 的变量上使用什么访问修饰符都没有关系；类 `b` 仍然看不到它。
- en: Thus, it makes sense to show a class to another class when necessary, but you
    should only expose the variables that are needed—not everything.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在必要时向另一个类展示一个类是有意义的，但你应该只暴露所需的变量——而不是所有东西。
- en: We have a bit more to cover on access modifiers, and then we will look at a
    few examples to help clarify things. For now, here is an explanation of the different
    variable access modifiers. They are more numerous and fine-grained than the class
    access modifiers. Most of the explanations are straightforward, and the ones that
    might raise questions will become clearer when we look at an example.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有关于访问修饰符的更多内容要介绍，然后我们将通过一些示例来帮助澄清这些内容。目前，这里是对不同变量访问修饰符的解释。它们比类访问修饰符更多且更细致。大部分解释都很直接，那些可能引起疑问的将在我们查看示例时变得清晰。
- en: 'The depth and complexity of access modification is not so much in the range
    of modifiers, but by using them in smart ways, we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰的深度和复杂性并不在于修饰符的范围，而在于我们以智能的方式使用它们，我们可以将它们组合起来以实现封装的值得追求的目标。以下是变量访问修饰符：
- en: '`public`: You guessed it! Any class or method from any package can see this
    variable. Use `public` only when you are sure that this is what you want.'
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：正如你所猜到的！任何包中的任何类或方法都可以看到这个变量。只有当你确定这是你想要的时才使用`public`。'
- en: '`protected`: This is the next least restrictive modifier after `public`. `protected`
    Variables set as protected can be seen by any class and any method as long as
    they are in the same package.'
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：这是`public`之后最不限制的修饰符。设置为`protected`的变量可以由同一包中的任何类和任何方法看到。'
- en: '`default`: This doesn''t sound as restrictive as `protected`, but it is more
    so. A variable has default access when no access is specified. The fact that `default`
    is restrictive perhaps implies that we should be thinking on the side of hiding
    our variables rather than exposing them. At this point, we need to introduce a
    new concept. Do you remember that we briefly discussed inheritance, and how we
    can quickly take on the attributes of a class and yet refine it using the `extends`
    keyword? Just for the record, default access variables are not visible to subclasses.
    This means that when we extend a class like we did with `Activity`, we cannot
    see its default variables. We will look at inheritance in more detail later in
    the chapter.'
  id: totrans-1883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：这听起来不像`protected`那样限制性，但实际上更限制。当一个变量没有指定访问权限时，它具有默认访问权限。`default`是限制性的事实可能意味着我们应该考虑隐藏变量而不是暴露它们。在此阶段，我们需要引入一个新概念。你还记得我们简要讨论了继承，以及我们如何可以通过使用`extends`关键字快速获得类的属性并对其进行改进吗？仅记录在案，具有默认访问权限的变量对子类不可见。这意味着当我们像使用`Activity`那样扩展一个类时，我们无法看到它的默认变量。我们将在本章的后面更详细地探讨继承。'
- en: '`private`: These variables can only be seen within the class they are declared.
    Like default access, they cannot be seen by subclasses (inherited classes).'
  id: totrans-1884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：这些变量只能在声明它们的类内部看到。像默认访问一样，它们不能被子类（继承类）看到。'
- en: Variable access in a nutshell
  id: totrans-1885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问概述
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes. Within these classes, variables will
    have carefully chosen and most likely varied access modifiers.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能包含一个或多个包，每个包只包含默认或默认和公共类。在这些类内部，变量将会有精心选择的、很可能是不同的访问修饰符。
- en: There's one more twist in all this access modification stuff before we get practical
    with it.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际应用访问修饰符之前，还有一些关于访问修饰的细节需要了解。
- en: Methods have access modifiers too
  id: totrans-1888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也有访问修饰符
- en: It makes sense that methods are the things that our classes can do. We will
    want to control what users of our class can and can't do. The general idea here
    is that some methods will do things internally only and are therefore not needed
    by users of the class, and some methods will be fundamental to how users use your
    class.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是我们类可以执行的事情，我们希望控制类用户可以做什么和不可以做什么。这里的一般想法是，一些方法只会在内部执行，因此不需要类用户，而一些方法对于用户如何使用你的类是基本的。
- en: The access modifiers for methods are the same as those for the class variables.
    This makes things easy to remember but suggests again that successful encapsulation
    is a matter of design rather than any specific set of rules.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的访问修饰符与类变量的访问修饰符相同。这使得事情容易记住，但再次表明，成功的封装是一个设计问题，而不是任何特定的规则集。
- en: 'As an example, the method in the following code snippet, provided in a public
    class, can be used by any other class:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段中的方法，在一个公共类中提供，可以被任何其他类使用：
- en: '[PRE303]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'However, the following method can only be used internally by the class that
    created it:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下方法只能由创建它的类内部使用：
- en: '[PRE304]'
  id: totrans-1894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'The next method has default visibility with no access specified. It can be
    used only by other classes in the same package. If we extend the class containing
    this default access method, the class will not have access to this method:'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法具有默认可见性，没有指定访问权限。它只能由同一包中的其他类使用。如果我们扩展包含此默认访问方法类的类，该类将无法访问此方法：
- en: '[PRE305]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Here is a last example before we move on. It contains a `protected` method,
    only visible to the package, but usable by our classes that extend it:'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这里有一个最后的例子。它包含一个`protected`方法，仅对包可见，但可以被扩展它的我们的类使用：
- en: '[PRE306]'
  id: totrans-1898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Method access in a nutshell
  id: totrans-1899
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问概述
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need, and preferably nothing more. Thereby, we achieve our encapsulation goals
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 应选择方法访问以最好地执行我们已讨论的原则。它应向类的用户提供他们需要的访问权限，而且最好是不要更多。因此，我们实现了封装目标，如保护代码的内部工作免受使用它的程序干扰，这是我们已讨论的所有原因。
- en: Accessing private variables with the getter and setter methods
  id: totrans-1901
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用获取器和设置器方法访问私有变量
- en: So if it is best practice to hide our variables away as private, how do we allow
    access to them without spoiling our encapsulation? What if an object of the `Hospital`
    class wanted access to the `health` member variable from an object of type `Soldier`
    so that it could increase it? The `health` variable should be private, right?
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们认为将变量隐藏为私有是最好的实践，那么我们如何在不破坏封装的情况下允许访问它们呢？如果`Hospital`类的对象想要从`Soldier`类型的对象中访问`health`成员变量以增加它怎么办？`health`变量应该是私有的，对吧？
- en: In order to be able to make as many member variables as possible private and
    yet allow some kind of limited access to some of them, we use **getters** and
    **setters**. Getters and setters are methods that just get and set variable values.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够尽可能多地使成员变量私有，同时允许对其中一些变量进行某种有限的访问，我们使用**获取器**和**设置器**。获取器和设置器是仅获取和设置变量值的方法。
- en: This is not some special or new Java thing we have to learn. It is just a convention
    for the use of what we already know. Let's take a look at getters and setters
    using the example of our `Soldier` and `Hospital` classes.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们必须学习的特殊或新Java特性。这只是对我们已知内容使用的一种约定。让我们通过我们的`Soldier`和`Hospital`类的例子来看看获取器和设置器。
- en: 'In this example, each of our two classes are created in their own file but
    the same package. First of all, here is our hypothetical `Hospital` class:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的两个类都是在其自己的文件中创建的，但属于同一个包。首先，这是我们的假设`Hospital`类：
- en: '[PRE307]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter, so this method will
    work on whichever `Soldier` object is passed in: `vassily`, `wellington`, `rambo`,
    or whoever.'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`Hospital`类只有一个方法，`healSoldier`。它接收一个`Soldier`对象的引用作为参数，因此此方法将适用于传递的任何`Soldier`对象：`vassily`、`wellington`、`rambo`或任何人。
- en: It also has a `health` variable. It uses this variable to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's `health` is private,
    so the public getter method is used instead.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个`health`变量。它使用这个变量来暂时保存并增加士兵的健康值。在同一行中，它将`health`变量初始化为`Soldier`对象的当前健康值。`Soldier`对象的`health`是私有的，所以使用公共获取器方法来代替。
- en: Then `health` is increased by 10 and the `setHealth` setter method loads the
    new `health` value back to the `Soldier` object.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`health`增加10，`setHealth`设置器方法将新的`health`值加载回`Soldier`对象。
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it does so within the bounds of the getter and setter methods. The getter
    and setter methods can be written to control and check for potentially erroneous
    or harmful values.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，尽管`Hospital`对象可以改变`Soldier`对象的健康值，但它是在获取器和设置器方法的范围内进行的。获取器和设置器方法可以编写来控制和检查可能错误或有害的值。
- en: 'Next comes our hypothetical `Soldier` class, with the simplest implementation
    possible of it''s getter and setter methods:'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的假设`Soldier`类，它具有最简单的getter和setter方法的实现：
- en: '[PRE308]'
  id: totrans-1912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method, which unsurprisingly returns the value held in the private
    `health` variable of the `int` type. As this method is public, anyone with access
    to the `Soldier` class can use it.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`health`的实例变量，它是私有的。私有意味着它只能通过`Soldier`类的方法来更改。然后我们有一个公共的`getHealth`方法，不出所料，它返回私有的`health`变量的值，该变量是`int`类型。由于这个方法是公共的，任何有权访问`Soldier`类的人都可以使用它。
- en: Next, the `setHealth` method is implemented. Again it is public, but this time,
    it takes `int` as a parameter and assigns whatever value is passed to the private
    `health` variable. In a more life-like example, we would write some more code
    here to ensure that the value passed is within the bounds we expect.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现`setHealth`方法。它仍然是公共的，但这次它接受`int`类型的参数，并将传入的任何值分配给私有的`health`变量。在一个更逼真的例子中，我们会在这里写更多的代码来确保传入的值在我们预期的范围内。
- en: 'Now we will declare, create, and assign to make an object of each of our two
    new classes and see how our getters and setters work:'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明、创建和分配，为我们的两个新类中的每一个创建一个对象，并看看我们的获取器和设置器是如何工作的：
- en: '[PRE309]'
  id: totrans-1916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can also call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which can use the public getters and setters to manipulate the private `health`
    variable.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，我们可以在我们的`Soldier`类型对象上直接调用公共的`setHealth`和`getHealth`方法。不仅如此，我们还可以调用`Hospital`对象的`healSoldier`方法，传入`Soldier`对象的引用，该引用可以使用公共的获取器和设置器来操作私有的`health`变量。
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，私有的`health`变量简单易访问，但完全在`Soldier`类的设计者控制之下。
- en: If you want to play around with this example, there is a working app in the
    code bundle in the `Chapter6` folder, called `Getters And Setters`. I have added
    a few lines of code to print to the console. We deliberately covered this the
    way we did to keep the key parts of the code as clear as possible. We will soon
    build some real working examples that explore class, variable, and method access.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对这个例子进行实验，代码包中的`Chapter6`文件夹里有一个可工作的应用程序，名为`Getters And Setters`。我在这里添加了几行代码来打印到控制台。我们故意这样处理，以使代码的关键部分尽可能清晰。我们很快将构建一些真正的示例，探索类、变量和方法访问。
- en: Note
  id: totrans-1920
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. Just thought you might
    like to know.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器有时被称为它们更正确的名字，**访问器**和**修改器**。我们将坚持使用获取器和设置器。只是想让你知道。
- en: 'Yet again, our example and the explanation are probably raising more questions.
    That''s good! Previously, I said that:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们的例子和解释可能又提出了更多问题。这是好事！之前，我说过：
- en: There are two access modifiers for a class, default and public
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类有两个访问修饰符，默认和公共
- en: Objects of classes are a type of reference variable
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的对象是一种引用变量
- en: Variables (including objects) have even more access possibilities
  id: totrans-1925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（包括对象）有更多的访问可能性
- en: We need to look more closely at reference and primitive variables as well as
    local and instance variables. We will do so in a moment in the *Variables revisited*
    section. In that section, we will consolidate our information further to get a
    tighter grip on this OOP stuff. First let's remind ourselves of a bit about encapsulation.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更仔细地观察引用和原始变量，以及局部和实例变量。我们将在“变量回顾”部分这样做。在那个部分，我们将进一步整合我们的信息，以更紧密地掌握面向对象的内容。首先，让我们提醒自己关于封装的一些内容。
- en: Using encapsulation features (such as access control) is like signing a really
    important deal about how to use and access a class, its methods, and its variables.
    The contract is not just an agreement about the present but an implied guarantee
    for the future. We will see that as we proceed through this chapter, there are
    more ways that we refine and strengthen this contract.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封装特性（如访问控制）就像签订一份非常重要的协议，关于如何使用和访问一个类、其方法和其变量。这个协议不仅是对现在的协议，也是对未来的一种隐含保证。随着我们继续本章的学习，我们将看到更多的方式来完善和加强这个协议。
- en: Note
  id: totrans-1928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is perfectly possible to rewrite every example in this book without thinking
    or caring about encapsulation. In fact, the projects in this book outside of this
    chapter are quite lax about encapsulation.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 完全有可能在不考虑或关心封装的情况下重写本书中的每个示例。事实上，本书中除本章外的项目对封装相当宽松。
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as the games in this book, except when the topic you are learning is encapsulation
    itself.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要的地方使用封装，或者当然，如果你是由雇主支付来使用它的话。通常，在小型学习项目中，如本书中的游戏，封装可能过度，除非你正在学习封装本身。
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在学习Java面向对象编程（OOP）时，假设你有一天会想要编写更复杂的应用程序，无论是在Android上还是在其他使用OOP的平台。
- en: Setting up our objects with constructors
  id: totrans-1932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数设置我们的对象
- en: 'With all of these private variables and their getters and setters, does it
    mean that we need a getter and a setter for every private variable? What about
    a class with lots of variables that need initializing at the start? Think about
    this:'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有这些私有变量及其获取器和设置器相比，这意味着我们需要为每个私有变量都提供一个获取器和设置器吗？对于需要在一开始就初始化大量变量的类，又会怎样？考虑以下情况：
- en: '[PRE310]'
  id: totrans-1934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: We could go on like this. Some of these variables might need getters and setters,
    but what if we just want to set things up when the object is first created to
    make the object function correctly? Do we need two methods (a getter and a setter)
    for each?
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这样下去。这些变量中的一些可能需要获取器和设置器，但如果我们只想在对象首次创建时设置一些东西，以便对象能够正确地运行，那会怎样？我们是否需要对每个变量都需要两个方法（一个获取器和设置器）？
- en: 'For this, we have a special method called a constructor. Here, we create an
    object of type `Soldier` and assign it to an object called `mySoldier`:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们有一个特殊的方法，称为构造函数。在这里，我们创建了一个`Soldier`类型的对象，并将其分配给一个名为`mySoldier`的对象：
- en: '[PRE311]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'There''s nothing new here, but look at the last part of that line of code:'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的内容，但看看那行代码的最后部分：
- en: '[PRE312]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: This looks suspiciously like a method.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常像是一个方法。
- en: We have called a special method called a constructor that has been supplied
    automatically for us by the compiler.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了一个特殊的方法，称为构造函数，它是由编译器自动为我们提供的。
- en: 'However (and this is getting to the point now), like a method, we can override
    it, which means we can do really useful things to set up our new object *before*
    it is used and any of its methods are placed on the stack:'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 然而（现在我们正在接近重点），就像方法一样，我们可以重写它，这意味着我们可以在对象被使用之前以及任何方法被放置在栈上之前做一些非常有用的事情来设置我们的新对象：
- en: '[PRE313]'
  id: totrans-1943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: This is a constructor. It has a lot of syntactical similarities to a method.
    It can only be run with the use of the `new` keyword. It is created for us automatically
    by the compiler unless we create our own like in the previous code.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构造函数。它有很多与方法的语法相似之处。它只能通过使用`new`关键字来运行。除非我们像在之前的代码中那样创建自己的，否则它是由编译器自动为我们创建的。
- en: 'Constructors have the following properties:'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有以下属性：
- en: They have no return type
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有返回类型
- en: They have the same name as the class
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的名称与类名相同
- en: They can have parameters
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有参数
- en: They can be overloaded
  id: totrans-1949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被重载
- en: We will play with constructors in the next demo.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个演示中，我们将玩转构造函数。
- en: Variables revisited
  id: totrans-1951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量回顾
- en: You probably remember, back in the math game project, that we kept changing
    where we declared our variables. First, we declared some in `onCreate`, then we
    moved them to just below the class declaration, and then we were making them member
    or instance variables.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在数学游戏项目中，我们一直在改变声明变量的位置。一开始，我们在`onCreate`中声明了一些变量，然后又把它们移到了类声明下方，然后我们正在把它们变成成员或实例变量。
- en: Because we didn't specify the access, they were of default access and visible
    to the whole class, and as everything took place in the one class, we could access
    them everywhere. For example, we could update our TextView type objects from `onClick`,
    but why couldn't we do that when they were declared in `onCreate`? Further explanation
    about when and how we can access different variables is probably going to be useful.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有指定访问权限，它们是默认访问权限，对整个类可见，并且由于所有操作都在一个类中完成，我们可以从任何地方访问它们。例如，我们可以从`onClick`更新我们的TextView类型对象，但为什么在它们在`onCreate`中声明时不能这样做？关于何时以及如何访问不同变量的进一步解释可能是有用的。
- en: The stack and the heap
  id: totrans-1954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈和堆
- en: The VM inside every Android device takes care of memory allocation to our games.
    In addition, it stores different types of variables in different places.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备内部的虚拟机负责为我们游戏分配内存。此外，它将不同类型的变量存储在不同的地方。
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the `stack`. We can stick to our warehouse analogy when talking
    about the stack—almost. We already know how we can manipulate the stack.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法中声明和初始化的变量存储在称为“栈”的内存区域。当我们谈论栈时，可以坚持我们的仓库类比——几乎如此。我们已经知道如何操作栈。
- en: Let's talk about the heap and what is stored there. All reference type objects,
    which include objects (of classes) and arrays, are stored in the heap. Think of
    the heap as a separate area of the same warehouse. The heap has lots of floor
    space for odd-shaped objects, racks for smaller objects, lots of long rows with
    smaller sized cube-shaped holes for arrays, and so on. This is where our objects
    are stored. The problem is that we have no direct access to the heap.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈堆以及那里存储了什么。所有引用类型对象，包括对象（类的）和数组，都存储在堆上。把堆想象成同一个仓库的另一个独立区域。堆有大量的地板空间用于形状奇特的物体，货架用于较小的物体，有很多长行带有较小尺寸的立方体孔用于数组，等等。这就是我们对象存储的地方。问题是我们没有直接访问堆的能力。
- en: Let's look again at what exactly a reference variable is. It is a variable that
    we refer to and use via a reference. A reference can be loosely (but usefully)
    defined as an address or location. The reference (address or location) of the
    object is on the stack. When we use the dot operator, we are asking Dalvik to
    perform a task at a specific location as stored in the reference.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看引用变量究竟是什么。它是一个我们通过引用来引用和使用的变量。引用可以松散地（但很有用）定义为地址或位置。对象的引用（地址或位置）在栈上。当我们使用点操作符时，我们是在要求Dalvik在存储在引用中的特定位置执行任务。
- en: Note
  id: totrans-1959
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reference variables are just that—a reference. They are a way to access and
    manipulate the object (variables or methods), but they are not the actual variable.
    An analogy might be that primitives are right there (on the stack) but references
    are an address, and we say what to do at the address. In this analogy, all addresses
    are on the heap.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量正是如此——一个引用。它们是访问和操作对象（变量或方法）的方式，但它们并不是实际的变量。一个类比可能是原始数据类型就在那里（在栈上），但引用是一个地址，我们告诉在地址上做什么。在这个类比中，所有地址都在堆上。
- en: Why would we ever want a system like this? Just give me my objects on the stack
    already!
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要有一个这样的系统呢？直接给我栈上的对象不就行了！
- en: A quick break to throw out the trash
  id: totrans-1962
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速休息一下，扔掉垃圾
- en: Remember way back in the first chapter when I said Java was easier to learn
    than some languages because it helps us manage the memory? Well, this whole stack
    and heap thing does that for us.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在第一章开头我说Java比一些语言更容易学习，因为它帮助我们管理内存吗？嗯，这个整个栈和堆的事情就是这样为我们做的。
- en: As we know, the VM keeps track of all our objects for us and stores them in
    the heap—a special area of our warehouse. Periodically, the VM will scan the stack,
    or the regular racks of our warehouse, and match references to objects. If it
    finds any objects without a matching reference, it destroys them. In Java terminology,
    it performs garbage collection. Think of a very discriminating refuse vehicle
    driving through the middle of our heap, scanning objects to match to references.
    No reference? You're garbage now! After all, if an object has no reference variable,
    we can't possibly do anything with it anyway. This system of garbage collection
    helps our games run more efficiently by freeing unused memory.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，虚拟机为我们跟踪所有对象并将它们存储在堆上——我们仓库的一个特殊区域。定期，虚拟机将扫描栈，或者我们仓库的常规货架，并将引用与对象匹配。如果它发现任何没有匹配引用的对象，它就会销毁它们。在Java术语中，它执行垃圾回收。想象一下一个非常挑剔的垃圾车在我们的堆中间行驶，扫描对象以匹配引用。没有引用？你现在就是垃圾了！毕竟，如果一个对象没有引用变量，我们无论如何也不可能对它做任何事情。这种垃圾回收系统通过释放未使用的内存帮助我们的游戏更有效地运行。
- en: So variables declared in a method are local, on the stack, and only visible
    within the method they were declared. A member variable is on the heap and can
    be referenced from any place where there is a reference to it, provided the access
    specification allows the referencing.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在方法中声明的变量是局部的，位于栈上，并且只能在声明它们的那个方法中可见。成员变量位于堆上，并且可以从任何有引用到它的地方引用，前提是访问权限允许引用。
- en: Now we can take a closer look at the variable scope—what can be seen from where.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更仔细地看看变量作用域——从哪里可以看到什么。
- en: There are more twists and turns to be learned with regard to variables. In the
    next demo, we will explore all we have learned so far in this chapter and some
    new ideas too.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量，还有更多需要学习的内容。在下一个演示中，我们将探索本章所学到的所有内容，以及一些新的想法。
- en: 'We will look at the following topics:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Static variables that are consistent (the same) across every instance of a class
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的每个实例中保持一致的静态变量
- en: Static methods of a class where you can use the methods of a class without an
    object of that class type
  id: totrans-1970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的静态方法，其中你可以使用该类的方法而不需要该类类型的对象
- en: We will demonstrate the scope of class and local variables, and where they can
    and can't be seen by different parts of the program
  id: totrans-1971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将演示类和局部变量的作用域，以及它们可以在程序的不同部分中看到或看不到的地方
- en: We will look at the `this` keyword, which allows us to write code that refers
    to variables that belong to a specific instance of a class, but without keeping
    track of which instance we are currently using
  id: totrans-1972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨`this`关键字，它允许我们编写引用特定类实例变量的代码，而无需跟踪当前使用的是哪个实例
- en: The following is the demo.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示。
- en: Access, scope, this, static, and constructors demo
  id: totrans-1974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问、作用域、this、静态和构造函数演示
- en: 'We have looked at the intricate way by which access to variables and their
    scope is controlled, and it would probably serve us well to look at an example
    of them in action. These will not be very practical real-world examples of variable
    use, but more of a demonstration to help understand access modifiers for classes,
    methods, and variables, alongside the different types of variables such as reference
    (or primitive) and local (or instance). Then we will cover the new concepts of
    static and final variables and the `this` keyword. The completed project is in
    the `Chapter6` folder of the code download. It is called `AccessScopeThisAndStatic`.
    We will now perform the following steps to implement it:'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了控制变量访问和作用域的复杂方式，看看它们的实际应用示例可能对我们大有裨益。这些示例可能不是非常实用的现实世界中的变量使用案例，但更多的是为了帮助理解类、方法和变量的访问修饰符，以及不同类型的变量，如引用（或原始）和局部（或实例）。然后我们将介绍静态和最终变量的新概念以及`this`关键字。完成的项目位于代码下载的`Chapter6`文件夹中。它被称为`AccessScopeThisAndStatic`。现在我们将执行以下步骤来实现它：
- en: Create a new blank activity project and call it `AccessScopeThisAndStatic`.
  id: totrans-1976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空白活动项目，并将其命名为`AccessScopeThisAndStatic`。
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the Project Explorer and navigating to **New** | **Class**. Name the new class
    `AlienShip`.
  id: totrans-1977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目资源管理器中右键单击现有的`MainActivity`类并导航到**新建** | **类**来创建一个新的类。将新类命名为`AlienShip`。
- en: 'Now we declare our new class and some member variables. Note that `numShips`
    is private and static. We will soon see how this variable is the same across all
    instances of the class. The `shieldStrength` variable is `private` and `shipName`
    is `public`:'
  id: totrans-1978
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们声明我们的新类和一些成员变量。请注意，`numShips`是私有的和静态的。我们很快就会看到这个变量在类的所有实例中都是相同的。`shieldStrength`变量是私有的，而`shipName`是公共的：
- en: '[PRE314]'
  id: totrans-1979
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class, as per the rules. In it, we increment
    the private static `numShips` variable. Remember that this will happen each time
    we create a new object of the `AlienShip` type. The constructor also sets a value
    for the `shieldStrength` private variable using the private `setShieldStrength`
    method:'
  id: totrans-1980
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是构造函数。我们可以看到构造函数是公共的，没有返回类型，并且名称与类名相同，符合规则。在其中，我们增加私有静态`numShips`变量。记住，每次我们创建一个新的`AlienShip`类型的对象时，这都会发生。构造函数还使用私有的`setShieldStrength`方法为`shieldStrength`私有变量设置一个值：
- en: '[PRE315]'
  id: totrans-1981
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Here is the public static getter method that classes outside `AlienShip` can
    use to find out how many `AlienShip` objects are there. We will also see the unusual
    way in which we use static methods:'
  id: totrans-1982
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是公开静态获取器方法，外部`AlienShip`类可以使用它来找出有多少`AlienShip`对象。我们还将看到我们使用静态方法的非同寻常的方式：
- en: '[PRE316]'
  id: totrans-1983
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'The following code shows our private `setShieldStrength` method. We could have
    just set `shieldStrength` directly from within the class, but this code shows
    how we can distinguish between the `shieldStrength` local variable/parameter and
    the `shieldStrength` member variable using the `this` keyword:'
  id: totrans-1984
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了我们的私有`setShieldStrength`方法。我们本可以直接在类内部设置`shieldStrength`，但这段代码展示了如何使用`this`关键字区分`shieldStrength`局部变量/参数和`shieldStrength`成员变量：
- en: '[PRE317]'
  id: totrans-1985
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'This next method is the getter, so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  id: totrans-1986
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个方法是获取器，因此其他类可以读取但不能更改每个`AlienShip`对象的护盾强度：
- en: '[PRE318]'
  id: totrans-1987
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then checks whether that particular
    object''s `shieldStrength` is zero. If it is zero, it calls the `destroyShip`
    method, which we look at next:'
  id: totrans-1988
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个公共方法，每次`AlienShip`对象被击中时都可以调用。它只是打印到控制台，然后检查特定对象的`shieldStrength`是否为零。如果是零，它将调用我们接下来要看的`destroyShip`方法：
- en: '[PRE319]'
  id: totrans-1989
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Finally, we will look at the `destroyShip` method for our `AlienShip` class.
    We print a message that indicates which ship has been destroyed, based on its
    `shipName`, as well as increment the `numShips` static variable so that we can
    keep track of the number of objects of the `AlienShip` type we have:'
  id: totrans-1990
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将查看`AlienShip`类的`destroyShip`方法。我们打印一条消息，指示根据其`shipName`已销毁的船只，以及增加`numShips`静态变量，以便我们可以跟踪我们拥有的`AlienShip`类型对象的数量：
- en: '[PRE320]'
  id: totrans-1991
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All of the code goes in the `onCreate` method after
    the call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  id: totrans-1992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们切换到我们的`MainActivity`类，并编写一些使用我们新的`AlienShip`类的代码。所有的代码都在调用`setContentView`之后放入`onCreate`方法中。首先，我们创建了两个新的`AlienShip`对象，分别命名为`girlShip`和`boyShip`：
- en: '[PRE321]'
  id: totrans-1993
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Look how we get the value in `numShips`. We use the `getNumShips` method as
    we might expect. However, look closely at the syntax. We are using the class name
    and not an object. We can also access static variables with methods that are not
    static. We did it this way to see a static method in action:'
  id: totrans-1994
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看我们是如何获取`numShips`的值的。我们使用`getNumShips`方法，正如我们预期的那样。然而，仔细看看语法。我们使用的是类名，而不是对象。我们还可以使用非静态方法访问静态变量。我们这样做是为了看到静态方法的作用：
- en: '[PRE322]'
  id: totrans-1995
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'Now we assign names to our public `shipName` string variables:'
  id: totrans-1996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为我们的公共`shipName`字符串变量命名：
- en: '[PRE323]'
  id: totrans-1997
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'If we attempt to assign a value directly to a private variable, it won''t work.
    Therefore, we use the public `getShieldStrength` getter method to print the value
    of `shieldStrength`, which was assigned to the constructor:'
  id: totrans-1998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试直接给私有变量赋值，这是不会工作的。因此，我们使用公共的`getShieldStrength`获取器方法来打印`shieldStrength`的值，该值被分配给构造函数：
- en: '[PRE324]'
  id: totrans-1999
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the shield strength of our two objects:'
  id: totrans-2000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们通过玩弄`hitDetected`方法并偶尔检查两个对象的护盾强度来炸毁一些东西：
- en: '[PRE325]'
  id: totrans-2001
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to check whether our static variable `numShips` was changed by the `destroyShip`
    method:'
  id: totrans-2002
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们认为我们已经销毁了一艘船时，我们再次使用我们的静态`getNumShips`方法来检查我们的静态变量`numShips`是否被`destroyShip`方法改变：
- en: '[PRE326]'
  id: totrans-2003
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE326]'
- en: Run the demo and look at the console output.
  id: totrans-2004
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行演示并查看控制台输出。
- en: 'Here is the output of the preceding blocks of code:'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码块输出的结果：
- en: '[PRE327]'
  id: totrans-2006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name using the `this` keyword. We can also use the `this`
    keyword to write code that refers to the current object being acted upon.
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了我们可以使用`this`关键字区分同名局部变量和成员变量。我们还可以使用`this`关键字来编写引用当前正在操作的对象的代码。
- en: We saw that a static variable, in this case `numShips`, is consistent across
    all instances. Moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we created.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，静态变量（在这个例子中是`numShips`）在所有实例中是一致的。此外，通过在构造函数中增加并在我们的`destroyShip`方法中减少它，我们可以跟踪我们创建的`AlienShip`对象的数量。
- en: We also saw that we can use static methods by writing the class name with the
    dot operator instead of an object.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，我们可以通过使用点操作符来写类名而不是对象来使用静态方法。
- en: Finally, we demonstrated how we could hide and expose certain methods and variables
    using an access specifier.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了如何使用访问修饰符来隐藏和暴露某些方法和变量。
- en: Let's take a look at a quick review of the stack and the heap before we move
    on to something new.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续学习新内容之前，让我们快速回顾一下栈和堆。
- en: A quick summary on stack and heap
  id: totrans-2012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于栈和堆的简要总结
- en: 'Let''s look at what we learned about the stack and the heap:'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于栈和堆的知识：
- en: You don't delete objects but the VM sends the garbage collector when it thinks
    it is appropriate. This is usually done when there is no active reference to the
    object.
  id: totrans-2014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要删除对象，但虚拟机在认为合适时会发送垃圾回收器。这通常发生在没有活动引用指向对象时。
- en: Local variables and methods are on the stack, and local variables are local
    to the specific method within which they were declared.
  id: totrans-2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量和方法位于栈上，而局部变量仅限于它们声明的特定方法内。
- en: Instance or class variables are on the heap (with their objects) but the reference
    to the object (address) is a local variable on the stack.
  id: totrans-2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例或类变量位于堆上（及其对象），但指向对象的引用（地址）是栈上的局部变量。
- en: We control what goes inside the stack. We can use the objects on the heap but
    only by referencing them.
  id: totrans-2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们控制栈内的内容。我们可以使用堆上的对象，但只能通过引用它们。
- en: The heap is maintained by the garbage collector.
  id: totrans-2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆由垃圾回收器维护。
- en: An object is garbage collected when there is no longer a valid reference to
    it. Therefore, when a reference variable, local or instance, is removed from the
    stack, then its related object becomes viable for garbage collection, and when
    the virtual machine decides the time is right (usually very promptly), it will
    free the RAM memory to avoid running out.
  id: totrans-2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再有有效的引用指向一个对象时，该对象就会被垃圾回收。因此，当一个引用变量（无论是局部还是实例）从栈中移除时，与其相关的对象就变得适合进行垃圾回收，而当虚拟机决定时机合适（通常非常迅速）时，它将释放RAM内存以避免耗尽。
- en: If we try to reference an object that doesn't exist, we will get a **null pointer
    exception** and the game will crash.
  id: totrans-2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试引用一个不存在的对象，我们将得到一个**空指针异常**，游戏将崩溃。
- en: Inheritance
  id: totrans-2021
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of an API such as that of Android, but this whole OOP
    thing goes even further than that.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过从Android等API的类中实例化/创建对象来利用他人的辛勤工作，但这个面向对象（OOP）的概念甚至比这还要深入。
- en: What if there is a class that has loads of useful functionality in it but not
    quite what we want? We can inherit from the class and then further refine or add
    to how it works and what it does.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类中包含大量有用的功能，但并不完全符合我们的需求呢？我们可以从这个类继承，然后进一步改进或添加其工作方式和功能。
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single game and demo we looked at. When we use the `extends`
    keyword, we are inheriting, for example, in this line of code:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地听到，我们实际上已经这样做了。事实上，我们已经在我们查看的每一个游戏和演示中都这样做了。当我们使用`extends`关键字时，我们正在继承，例如，在这行代码中：
- en: '[PRE328]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: Here, we are inheriting the `Activity` class along with all its functionality,
    or more specifically, all of the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在继承`Activity`类及其所有功能，或者更具体地说，是类设计者希望我们能够访问的所有功能。以下是我们可以对扩展的类执行的一些操作。
- en: 'We can override a method and still rely in part on the overridden method in
    the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `Activity` class, but we also called the default implementation
    provided by the class designers when we did this:'
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写一个方法，同时仍然部分依赖于我们从其继承的类中的重写方法。例如，每次我们扩展`Activity`类时，我们都重写了`onCreate`方法，但当我们这样做时，我们也调用了类设计者提供的默认实现：
- en: '[PRE329]'
  id: totrans-2028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: In the next chapter, we will also be overriding some more methods of the `Activity`
    class. Specifically, we'll override the methods that handle the lifecycle.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将重写`Activity`类的更多方法。具体来说，我们将重写处理生命周期的那些方法。
- en: If we or the designer of a class wants to force us to inherit before we use
    their class, they can declare a class as **abstract**. Then we cannot make an
    object from it. Therefore, we must extend it first and make an object from the
    subclass. We will do this in our inheritance example and discuss it further when
    we look at polymorphism.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们或类的设计者想要在我们使用他们的类之前强制我们继承，他们可以将类声明为**抽象的**。然后我们不能从它创建对象。因此，我们必须首先扩展它，并从子类创建对象。我们将在我们的继承示例中这样做，并在我们研究多态时进一步讨论。
- en: We can also declare a method abstract, and that method must be overridden in
    any class that extends the class with the abstract method. We will do this as
    well in our inheritance example.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以声明一个方法为抽象的，并且这个方法必须在扩展具有抽象方法的类的任何类中重写。我们将在我们的继承示例中也这样做。
- en: In our game projects, we will not be designing any classes that we will be extending.
    We have no need of that in the context of learning about building simple games.
    However, we will be extending classes designed by others in every future game.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏项目中，我们不会设计任何将要扩展的类。在了解构建简单游戏的环境中，我们没有这个需求。然而，在未来的每个游戏中，我们都会扩展其他人为设计的类。
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend. With this in mind, let's make some simple classes
    and see how we can extend them, just to play around with the syntax as a first
    step, and also to be able to say we have done it. When we look at the last major
    topic of this chapter, polymorphism, we will also dig a little deeper into inheritance.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论继承，是为了理解我们周围正在发生的事情，并且作为最终能够设计出有用类，我们或他人可以扩展的第一步。考虑到这一点，让我们创建一些简单的类，看看我们如何扩展它们，仅作为一个初步的语法练习，并且能够说我们已经做到了。当我们看到本章的最后一个主要主题多态时，我们也会对继承进行更深入的探讨。
- en: An example of inheritance
  id: totrans-2034
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的一个例子
- en: 'We have looked at the way we can create hierarchies of classes to model the
    system that fits our game or software project, so let''s try out some simple code
    that uses inheritance. The completed project is in the `Chapter6` folder of the
    code download. It is called `InheritanceExample`. We will now perform the following
    steps:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建类层次结构来模拟适合我们的游戏或软件项目的系统，现在让我们尝试一些使用继承的简单代码。完成的项目位于代码下载的`Chapter6`文件夹中。它被称为`InheritanceExample`。我们现在将执行以下步骤：
- en: Create three new classes in the usual way. Call one `AlienShip`, another `Fighter`,
    and the last one `Bomber`.
  id: totrans-2036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式创建三个新类。将其中一个命名为`AlienShip`，另一个命名为`Fighter`，最后一个命名为`Bomber`。
- en: 'Here is the code for the `AlienShip` class. It is very similar to our previous
    `AlienShip` class demo. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength. The constructor also
    outputs a message to the console so that we can see when it is being used. The
    `AlienShip` class also has a new method, `fireWeapon`, that is declared `abstract`.
    This guarantees that any class that subclasses `AlienShip` must implement their
    own version of `fireWeapon`. Notice that the class has the `abstract` keyword
    as part of its declaration. We have to do this because one of its methods also
    uses the keyword `abstract`. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism:'
  id: totrans-2037
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`AlienShip`类的代码。它与我们的上一个`AlienShip`类演示非常相似。不同之处在于，构造函数现在接受一个`int`参数，它使用这个参数来设置护盾强度。构造函数还会向控制台输出一条消息，以便我们能够看到它何时被使用。`AlienShip`类还有一个新的方法`fireWeapon`，它被声明为`abstract`。这保证了任何子类`AlienShip`都必须实现自己的`fireWeapon`版本。注意，类声明中包含`abstract`关键字。我们必须这样做，因为它的一个方法也使用了`abstract`关键字。我们将在讨论这个演示和抽象类时解释`abstract`方法，当我们谈到多态时，我们也会更深入地讨论抽象类：
- en: '[PRE330]'
  id: totrans-2038
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the superclass with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print the location so that we can see when the `Bomber` constructor
    is being executed. We also implement a `Bomber` class-specific version of the
    abstract `fireWeapon` method because we must do so:'
  id: totrans-2039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现`Bomber`类。注意调用`super(100)`。这会调用超类构造函数，并传入`shieldStrength`的值。我们可以在构造函数中做进一步的特定`Bomber`初始化，但现阶段，我们只是打印位置信息，以便我们能够看到`Bomber`构造函数何时被调用。我们还实现了一个`Bomber`类特定的抽象`fireWeapon`方法版本，因为我们必须这样做：
- en: '[PRE331]'
  id: totrans-2040
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the superclass with the value of `shieldStrength`.
    We could do further `Fighter` class-specific initialization in this constructor,
    but for now, we just print the location so that we can see when the `Fighter`
    constructor is being executed. We also implement a `Fighter` specific version
    of the abstract `fireWeapon` method because we must do so:'
  id: totrans-2041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现`Fighter`类。注意调用`super(400)`。这会调用超类构造函数，并传入`shieldStrength`的值。我们可以在构造函数中做进一步的`Fighter`类特定初始化，但现阶段，我们只是打印位置信息，以便我们能够看到`Fighter`构造函数何时被调用。我们还实现了一个`Fighter`特定的抽象`fireWeapon`方法版本，因为我们必须这样做：
- en: '[PRE332]'
  id: totrans-2042
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Here is our code in the `onCreate` method of `MainActivity`. As usual, we enter
    this code after the call to `setContentView`. This is the code that uses our three
    new classes. It looks quite ordinary, but there''s nothing new; it is the output
    that is interesting:'
  id: totrans-2043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是我们代码在`MainActivity`的`onCreate`方法中的样子。像往常一样，我们在调用`setContentView`之后输入这段代码。这段代码使用了我们的三个新类。它看起来相当普通，但没有什么新东西；有趣的是输出：
- en: '[PRE333]'
  id: totrans-2044
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Here is the output of the preceding snippets of code:'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面代码片段的输出：
- en: '[PRE334]'
  id: totrans-2046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: We can see how the constructor of the subclass can call the constructor of the
    superclass. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到子类的构造函数是如何调用超类的构造函数的。我们也可以清楚地看到`fireWeapon`方法的单独实现工作得完全符合预期。
- en: As if OOP where not useful enough already! We can now model real-world objects
    and design them to interact with each other. We have also seen how we can make
    OOP even more useful by subclassing/extending/inheriting from other classes. The
    terminology we might like to learn here is that the class that is extended from
    is the **superclass** and the class that inherits from the superclass is the **subclass**.
    We can also call them parent and child classes.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像面向对象编程本身还不够有用一样！我们现在可以模拟现实世界的对象，并设计它们相互交互。我们还看到了如何通过子类化/扩展/从其他类继承来使面向对象编程更加有用。我们可能想学习在这里的术语是，从其扩展的类是**超类**，从超类继承的类是**子类**。我们也可以称它们为父类和子类。
- en: Tip
  id: totrans-2049
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'As usual, we might find ourselves asking this question about inheritance: Why?
    We can write common code once, in the parent class, and we can update that common
    code. All the classes that inherit from it are also updated. Furthermore, a subclass
    only inherits public instance variables and methods. When designed properly, this
    further enhances the goals of encapsulation.'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们可能会对继承提出这样的问题：为什么？我们可以在父类中一次性编写通用的代码，并且可以更新这些通用代码。所有从它继承的类也会得到更新。此外，子类只继承公共实例变量和方法。当设计得当，这进一步增强了封装的目标。
- en: Polymorphism
  id: totrans-2051
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism roughly means different forms. But what does it mean to us?
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 多态大致意味着不同的形式。但它对我们意味着什么呢？
- en: In the simplest words possible, any subclass can be used as a part of the code
    that uses the superclass.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 用最简单的话来说，任何子类都可以作为使用超类的代码的一部分。
- en: For example, if we have an array of animals, we could put any object that is
    of a type that is a subclass of `Animal` in the `Animal` array, perhaps cats and
    dogs.
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个动物数组，我们可以将任何类型为`Animal`子类的对象放入`Animal`数组中，比如猫和狗。
- en: 'This means that we can write code that is simpler and easier to understand
    and modify:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写更简单、更容易理解和修改的代码：
- en: '[PRE335]'
  id: totrans-2056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'We can also write code for the superclass and rely on the fact that no matter
    how many times it is subclassed, within certain parameters, the code will still
    work. Let''s continue our previous example:'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为超类编写代码，并依赖于这样一个事实：无论它被子类化多少次，在一定的参数范围内，代码仍然可以工作。让我们继续之前的例子：
- en: '[PRE336]'
  id: totrans-2058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'You can also write methods with polymorphic return types and arguments:'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写具有多态返回类型和参数的方法：
- en: '[PRE337]'
  id: totrans-2060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: So you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你甚至可以编写今天的代码，并在一周、一个月或一年后创建另一个子类，而完全相同的方法和数据结构仍然可以工作。
- en: Further, we can enforce on our subclasses a set of rules as to what they can
    and cannot do, and also how they should do it. Thus, good design in one stage
    can influence our subclasses at other stages.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以对子类施加一套规则，规定它们可以做什么，不可以做什么，以及应该如何做。因此，一个阶段的好设计可以影响其他阶段的子类。
- en: If you do suddenly find yourself with a flappy-bird-sized phenomenon, and you
    have a lot of OOP in your code, right from the start, it will be much easier to
    bring in hired help to move the project forward and still maintain control of
    the project.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你突然发现自己遇到了一个像《愤怒的小鸟》那么大的现象，并且你的代码中有很多面向对象编程，那么从一开始，引入外部帮助来推进项目并仍然保持对项目的控制将会容易得多。
- en: What if you have an idea for a game with lots of features but you want to get
    a simple version of the game out as soon as possible? Smart, object-oriented design
    would certainly be the solution. It could enable you to write the working bare
    bones of a game and then gradually extend it.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个有很多功能的游戏的想法，但你希望尽快推出一个简单的游戏版本，那么智能的面向对象设计当然会是解决方案。它可以使你编写游戏的工作框架，然后逐渐扩展它。
- en: 'Moving on, let''s look at another OOP concept: abstract classes. We can now
    get to the bottom of what was going on with that `AlienShip` code:'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个面向对象编程（OOP）的概念：抽象类。我们现在可以深入探究那个 `AlienShip` 代码中发生的事情：
- en: '[PRE338]'
  id: totrans-2066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Abstract classes
  id: totrans-2067
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class is a class that cannot be instantiated, or cannot be made
    into an object. We mentioned that `AlienShip` was abstract in the previous example.
    So is it a blueprint that will never be used then? But that's like paying an architect
    to design your home and then never building it! I kind of got the idea of an abstract
    method but this is just silly!
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是一个不能被实例化，或者不能被制作成对象的类。我们在前面的例子中提到 `AlienShip` 是一个抽象类。那么它是不是一个永远不会被使用的蓝图呢？但那就像请建筑师设计你的房子然后永远不建造它一样！我对抽象方法的概念有点理解，但这真的很荒谬！
- en: 'It might seem like this at first. We make a class abstract by declaring it
    with the `abstract` keyword, like this:'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这看起来可能如此。我们通过使用 `abstract` 关键字声明一个抽象类，如下所示：
- en: '[PRE339]'
  id: totrans-2070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: But why?
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么呢？
- en: Sometimes, we want a class that can be used as a polymorphic type but we need
    to ensure that it can never be used as an object. For example, `Animal` doesn't
    really make sense on its own.
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望有一个可以作为多态类型的类，但同时确保它永远不能被用作对象。例如，`Animal` 类本身并没有什么意义。
- en: We don't talk about animals; we talk about types of animals. We don't say, "Ooh,
    look at that lovely, fluffy, white animal", or "Yesterday, we went to the pet
    shop and got an animal and an animal bed." It's just too abstract.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不谈论动物；我们谈论动物的类型。我们不说，“哇，看那只可爱、蓬松、白色的动物”，或者“昨天我们去宠物店买了一只动物和一张动物床。”这太抽象了。
- en: So an abstract class is like a template to be used by any class that extends
    it (inherits from it).
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 所以抽象类就像是一个模板，可以被任何扩展它的类（继承它的类）使用。
- en: We might want a `Worker` class and extend to make classes such as `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    class do? Why would we ever want to instantiate one?
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一个 `Worker` 类，并扩展它来创建如 `Miner`、`Steelworker`、`OfficeWorker` 和当然还有 `Programmer`
    这样的类。但一个普通的 `Worker` 类到底做什么呢？我们为什么想要实例化一个？
- en: The answer is that we wouldn't want to instantiate it, but we might want to
    use it as a polymorphic type so that we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of workers.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们可能不想实例化它，但我们可能希望将其用作多态类型，这样我们就可以在方法之间传递多个工作子类，并拥有可以存储所有类型工人的数据结构。
- en: We call this type of class an abstract class, and when a class has even one
    abstract method, like `AlienShip` did, it must be declared abstract itself. As
    we saw, all abstract methods must be overridden by any class that extends the
    abstract class. This means that the abstract class can provide some of the common
    functionality that would be available in all its subclasses. For example, the
    `Worker` class might have the `height`, `weight`, and `age` member variables.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型的类为抽象类，当一个类有一个甚至一个抽象方法，如 `AlienShip` 所做的那样，它本身也必须被声明为抽象。正如我们所见，所有抽象方法都必须由扩展抽象类的任何类重写。这意味着抽象类可以提供一些在所有子类中都可能存在的公共功能。例如，`Worker`
    类可能有 `height`、`weight` 和 `age` 成员变量。
- en: It might have the `getPayCheck` method, which is the same in all the subclasses,
    and the `doWork` method, which is abstract and must be overridden because all
    the different types of worker do work very differently.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能有一个 `getPayCheck` 方法，这个方法在所有子类中都是相同的，还有一个抽象的 `doWork` 方法，这个方法必须被重写，因为所有不同类型的工人做的工作非常不同。
- en: This leads us neatly on to another area of polymorphism that deserves an honorable
    mention because we have been using it in every game so far.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 这很自然地引出了多态性的另一个领域，它值得特别提一下，因为我们到目前为止在每一款游戏中都使用了它。
- en: Interfaces
  id: totrans-2080
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is like a class. Phew! Nothing complicated here then. However,
    it's like a class that is always abstract and with only abstract methods.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像一个类。呼！这里没有什么复杂的。然而，它就像一个总是抽象的类，并且只包含抽象方法。
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract too. Okay, so you can just about wrap your head round an abstract class
    because it can at least pass on some functionality in its methods that are not
    abstract and serve as a polymorphic type.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将接口想象为一个完全抽象的类，其中所有的方法也都是抽象的。好吧，所以你几乎可以理解抽象类，因为它至少可以在其非抽象方法中传递一些功能，并作为多态类型。
- en: But seriously, this interface seems a bit pointless. Bear with me.
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 但说真的，这个接口似乎有点没有意义。请耐心听我说。
- en: 'To define an interface, we type the following code:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个接口，我们输入以下代码：
- en: '[PRE340]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的方法没有主体，因为它们是抽象的，但它们仍然可以有返回类型和参数，或者没有。
- en: 'To use an interface, we use the `implements` keyword after the class declaration.
    Yes, we already did this for `onClickListener` a few times:'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用接口，我们在类声明之后使用`implements`关键字。是的，我们已经为`onClickListener`做过几次了：
- en: '[PRE341]'
  id: totrans-2088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. As long as it implements an
    interface, the whole thing can be passed along as if it is that thing, which it
    is. We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用多态性，处理来自完全不同继承层次结构中的多个不同对象。只要它实现了接口，整个对象就可以像那个对象一样传递，它就是那个对象。我们甚至可以让一个类同时实现多个不同的接口。只需在每个接口之间添加逗号，并在`implements`关键字之后列出它们。但请确保实现所有必要的函数。
- en: Let's go back to the `onClickListener` interface. Any thing might like to know
    when it is being clicked on; a Button, a TextView, and so on. We don't want different
    `onClick` methods for every type.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`onClickListener`接口。任何东西都可能想知道它何时被点击；一个按钮、一个文本视图等等。我们不想为每种类型都有不同的`onClick`方法。
- en: Tip
  id: totrans-2091
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using Android, for games or for more regular GUI-based apps (a bit like
    ours so far), 9 times out of 10, you will be implementing interfaces rather than
    writing your own. However, knowing what is happening is quite important, not so
    much from a point of view of technical awareness, as we have just seen that the
    interface specifies a contract and the compiler enforces it, but more as a matter
    of sanity in knowing what is actually happening when you use the `implements`
    keyword and write a method (or methods) with a name that you didn't choose.
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Android时，无论是用于游戏还是用于更常见的基于GUI的应用（有点像我们到目前为止的应用），十有八九，你将实现接口而不是编写自己的。然而，了解正在发生的事情非常重要，这不仅是因为技术意识的角度，正如我们刚才看到的，接口指定了一个合同，编译器强制执行它，而且更多的是因为当你使用`implements`关键字并编写一个（或多个）你未选择名称的方法时，了解实际发生的事情。
- en: More about OOP and classes
  id: totrans-2093
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于面向对象编程（OOP）和类的内容
- en: It is possible to write a whole book on OOP, and many authors have already done
    so, but the best way to learn OOP is probably to practice it; practice it *before*
    we have learned all of the theory. Anyway, before we get on with some more practical
    examples, here is one more slightly theoretical OOP example that will leave us
    scratching our heads later if not mentioned.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写一本关于面向对象编程（OOP）的整本书，许多作者已经这样做了，但学习面向对象编程的最佳方式可能是实践；在我们学习所有理论之前先实践。无论如何，在我们继续一些更实际的例子之前，这里有一个稍微理论性的面向对象编程例子，如果不提出来，我们稍后可能会感到困惑。
- en: Inner classes
  id: totrans-2095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部类
- en: When we looked at our basic classes demo app, we declared and implemented the
    class in a separate file to our `MainActivity` class. That file had the same name
    as the class.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的基本类演示应用时，我们在与`MainActivity`类分开的文件中声明并实现了该类。那个文件与类的名称相同。
- en: We can also declare and implement a class within a class. The only question
    remaining, of course, is why would we do this? When we implement an inner class,
    the inner class can access the member variables of the enclosing class and the
    enclosing class can access the members of the inner class. We will see this in
    action in the next two chapters.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类内部声明和实现一个类。当然，唯一的问题是，我们为什么要这样做？当我们实现内部类时，内部类可以访问封装类的成员变量，而封装类可以访问内部类的成员。我们将在接下来的两章中看到这一点。
- en: If you are not modeling deep or real-world systems, then inner classes are often
    the way to go. In fact, all the classes we will write ourselves in the rest of
    this book will be extended inner classes. This means that we will extend a type
    to make our own class within our `Activity` class. This makes our code nice and
    simple.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在模拟深度或现实世界的系统，那么内部类通常是最佳选择。实际上，我们将在本书的其余部分编写的所有类都将扩展内部类。这意味着我们将扩展一个类型，在我们的`Activity`类内部创建自己的类。这使得我们的代码既简洁又简单。
- en: Self-test questions
  id: totrans-2099
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'Q1) Find out what is wrong with this class declaration:'
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 找出这个类声明有什么问题：
- en: '[PRE342]'
  id: totrans-2101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: Q2) What is encapsulation?
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 封装是什么？
- en: Q3) I don't get it all, and actually, I have more questions now than I had at
    the start of the chapter. What should I do?
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我没有完全理解，实际上，我现在比本章开始时的问题更多。我该怎么办？
- en: Summary
  id: totrans-2104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything, then you have succeeded completely. If you just understand
    that OOP is about writing reusable, extendable, and efficient code through encapsulation,
    inheritance, and polymorphism, then you have the potential to be a Java master.
    Simply put, OOP enables us to use other people's hard work even when those people
    were not aware of exactly what we would be doing at the time they did the work.
    All you have to do is keep practicing, so let's make a retro game in the next
    chapter.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们比其他任何章节都涵盖了更多的理论。如果你没有记住所有内容，那么你已经完全成功了。如果你只是理解了面向对象编程（OOP）是通过封装、继承和多态来编写可重用、可扩展和高效代码的，那么你有潜力成为Java大师。简单来说，OOP使我们能够在那些人当时做这项工作时并不完全清楚我们会做什么的情况下，利用他们的辛勤工作。你所要做的就是不断练习，那么让我们在下一章中制作一个复古游戏。
- en: Chapter 7. Retro Squash Game
  id: totrans-2106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章.复古挤压游戏
- en: This chapter is where the fun starts. Although a retro squash game is obviously
    a step or two down from the latest big-budget game, it is the point when we start
    to look at some fundamentals—drawing, detecting when objects we have drawn bump
    into each other, and having animation that is actually controlled by us.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是乐趣开始的地方。虽然复古挤压游戏显然比最新的大型预算游戏低一个或两个级别，但这是我们开始关注一些基础的时刻——绘图、检测我们绘制的物体何时相互碰撞，以及拥有由我们控制的动画。
- en: Once you can draw a pixel and move it, it only needs a bit of imagination and
    work and you have the potential to draw anything. Then, when we combine this knowledge
    with some really simple math to simulate the physics of collision and gravity,
    we will be close to being able to implement our squash game.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能画出像素并移动它，只需一点想象力和工作，你就有潜力画出任何东西。然后，当我们结合一些非常简单的数学来模拟碰撞和重力的物理时，我们就能接近实现我们的挤压游戏。
- en: Tip
  id: totrans-2109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Sadly, this book does not have the time to go into the mathematics of turning
    a dot on the screen into realistic three-dimensional characters moving around
    in a three-dimensional world. Certainly, the technology and math behind big-budget
    titles is very advanced and complicated. However, the basics of turning pixels
    into lines and lines into triangles, texturing a triangle, building objects out
    of triangles, and positioning them in a three-dimensional world are within the
    grasp of anybody who has learned high-school-level math. Often, we hear that great
    graphics don''t make a great game, which is true, but great graphics (at least
    for me) are one of the most exciting aspects of video games, even when they are
    displayed on a game that could be more fun to play by itself. If you want to see
    how to turn pixels into magical worlds, and start to appreciate what goes on behind
    the scenes of the top game engines and graphics libraries, you could start with
    *Computer Graphics: Mathematical First Steps*, *P.A. Egerton and W.S Hall*, *Prentice
    Hall*.'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这本书没有时间深入探讨将屏幕上的点变成在三维世界中移动的逼真三维角色的数学。当然，大型预算游戏背后的技术和数学非常先进和复杂。然而，将像素变成线条，将线条变成三角形，对三角形进行纹理处理，用三角形构建物体，并在三维世界中定位它们，对于任何学过高中数学的人来说都在掌握之中。我们经常听到，优秀的图形并不一定能制作出优秀的游戏，这是真的，但优秀的图形（至少对我来说）是电子游戏中最令人兴奋的方面之一，即使它们显示在本身可能更有趣的游戏上。如果你想看看如何将像素变成神奇的世界，并开始欣赏顶级游戏引擎和图形库背后的工作，你可以从*《计算机图形学：数学第一步》*，*P.A.
    Egerton和W.S Hall*，*Prentice Hall*开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explore the Android `Canvas` class, which makes drawing easy and fun
  id: totrans-2112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Android `Canvas`类，它使绘图变得简单和有趣
- en: Write a simple Canvas demo app
  id: totrans-2113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的Canvas演示应用
- en: Learn about detecting touches on the screen
  id: totrans-2114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在屏幕上检测触摸
- en: Create the retro squash game
  id: totrans-2115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复古挤压游戏
- en: Implement the retro squash game
  id: totrans-2116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复古挤压游戏
- en: Drawing with Android Canvas
  id: totrans-2117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android Canvas绘图
- en: So far, we have been using the Android UI designer to implement all our graphics.
    This is fine when all we need are objects such as buttons and text.
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Android UI设计器来实现所有我们的图形。当我们只需要按钮和文本等对象时，这是完全可以的。
- en: It is true that there is more to the Android UI elements than we have explored
    so far. For example, we know we can do a lot more with the `Animation` class,
    and we very briefly saw that we can assign any image we like to represent one
    of the UI elements.
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，Android UI元素的内容远不止我们迄今为止所探索的。例如，我们知道我们可以使用`Animation`类做更多的事情，而且我们非常简短地看到我们可以将任何我们喜欢的图像分配给代表UI元素。
- en: As an example, we could assign game characters such as spaceships to UI elements
    and animate them.
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将游戏角色，如宇宙飞船，分配给UI元素并对其动画化。
- en: However, if we want smoothly moving spaceships with accurate collision detection,
    cute characters, and gruesome baddies with multiframe, cartoon-like animation,
    then we are going to need to move away from predefined UI elements.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要平滑移动的宇宙飞船、精确的碰撞检测、可爱的人物和具有多帧卡通动画的恐怖敌人，那么我们就需要远离预定义的UI元素。
- en: We are going to need to start looking at and designing with individual pixels,
    lines, bitmaps, and sprite sheets. Fortunately, as you might have guessed, Android
    has some classes to make this nice and easy for us. We will be learning how to
    get started with the `Canvas` and `Paint` classes.
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要开始关注并设计单个像素、线条、位图和精灵图。幸运的是，正如你可能猜到的，Android有一些类可以让我们轻松地完成这些操作。我们将学习如何使用`Canvas`和`Paint`类入门。
- en: Bitmaps and sprite sheets will be covered in the next chapter. In this chapter,
    we will learn how to draw pixels and lines to make a simple, smoothly moving pong-style
    game of squash.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 位图和精灵图将在下一章中介绍。在这一章中，我们将学习如何绘制像素和线条，以制作一个简单的、平滑移动的乒乓球风格的 squash 游戏。
- en: To achieve this, we will learn about the coordinate system we use to draw our
    pixels and lines. Then we will look at the `Paint` and `Canvas` classes themselves.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将了解我们用来绘制像素和线条的坐标系统。然后我们将查看`Paint`和`Canvas`类本身。
- en: The Android coordinate system
  id: totrans-2125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android坐标系统
- en: A pixel is the smallest graphical element we can manipulate using the `Paint`
    and `Canvas` classes. It is essentially a dot. If your device resolution is 1920
    x 1080, like some of the newer Google-branded tablets or high-end Samsung phones,
    then we have 1920 pixels across the longest length of the device and 1080 pixels
    across the width.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 像素是我们可以使用`Paint`和`Canvas`类操作的图形元素中最小的。它本质上是一个点。如果你的设备分辨率为1920 x 1080，就像一些新的谷歌品牌平板电脑或高端三星手机，那么我们沿着设备最长边有1920个像素，沿着宽度有1080个像素。
- en: We can therefore think of our screen on which we will be drawing as a grid.
    We draw using the `Canvas` and `Paint` classes on a virtual canvas. We will do
    so by plotting points (pixels), lines, shapes, and text using coordinates on this
    grid.
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们将要在其上绘制的屏幕视为一个网格。我们使用`Canvas`和`Paint`类在这个虚拟画布上绘制。我们将通过在这个网格上绘制点（像素）、线条、形状和文本来实现这一点。
- en: The coordinate system starts in the top-left corner of the screen.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系统从屏幕的左上角开始。
- en: 'As an example, take a look at this line of code:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看下面这行代码：
- en: '[PRE343]'
  id: totrans-2130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'In this, we would plot a single pixel in the top-left corner of the screen.
    Now look at the following code:'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在屏幕左上角绘制一个单独的像素。现在看看以下代码：
- en: '[PRE344]'
  id: totrans-2132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: If we use it like this, we could draw a point in the bottom-right corner of
    one of these high-end devices (while in the landscape position).
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样使用它，我们可以在这些高端设备（在横屏位置）的右下角绘制一个点。
- en: 'We could also draw lines by specifying a start and end coordinate position,
    a bit like this:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过指定起始和结束坐标位置来绘制线条，就像这样：
- en: '[PRE345]'
  id: totrans-2135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: This would draw a line from the top-left corner of the screen to the bottom
    right.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将绘制从屏幕左上角到底右角的线条。
- en: You might have noticed some potential problems. Firstly, not all Android devices
    have such a high resolution; in fact, most are significantly lower. Even devices
    with high resolution will have totally different coordinates when held in landscape
    or portrait positions. How will we write code that adapts to these devices regardless
    of the screen resolution? We will see the solution soon.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了一些潜在的问题。首先，并不是所有的Android设备都有如此高的分辨率；事实上，大多数分辨率都显著较低。即使具有高分辨率的设备，在横屏或竖屏位置时坐标也会完全不同。我们将如何编写代码以适应这些设备，而不管屏幕分辨率如何？我们很快就会看到解决方案。
- en: Animating our pixels
  id: totrans-2138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化我们的像素
- en: 'Drawing shapes, lines, and pixels is all very well, but how do we make them
    appear to move? We will be using the same animation trick used in cartoons, movies,
    and other video games:'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制形状、线条和像素都很好，但我们如何让它们看起来在移动呢？我们将使用在卡通、电影和其他视频游戏中使用的相同的动画技巧：
- en: Draw an object.
  id: totrans-2140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个对象。
- en: Rub it out.
  id: totrans-2141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 擦除它。
- en: Draw the object in its new position.
  id: totrans-2142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新位置绘制对象。
- en: Repeat fast enough to trick the player's brain that the game objects are moving.
  id: totrans-2143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速重复，以欺骗玩家的头脑，使游戏对象看起来在移动。
- en: The theory makes all of this sound more complicated than it is. Let's take a
    quick look at the `Paint` and `Canvas` classes and a quick introductory demo app.
    Then we can implement our retro squash game for real.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这一切听起来比实际要复杂。让我们快速看一下`Paint`和`Canvas`类以及一个简单的入门级演示应用。然后我们可以真正实现我们的复古网球游戏。
- en: Getting started with Canvas and Paint
  id: totrans-2145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Canvas和Paint
- en: The aptly named `Canvas` class provides just what you would expect—a virtual
    canvas to draw our graphics on.
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，`Canvas`类提供了我们预期的一切——一个虚拟画布，用于绘制我们的图形。
- en: We can make a virtual canvas using the `Canvas` class from any Android UI element.
    In our demo app, we will draw on an ImageView, and when we make our game, we will
    draw straight on a special type of view, which will bring some extra advantages,
    as we will see.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Canvas`类从任何Android UI元素创建一个虚拟画布。在我们的演示应用中，我们将在ImageView上绘制，当我们制作游戏时，我们将直接在一种特殊类型的视图中绘制，这将带来一些额外的优势，正如我们将看到的。
- en: 'To get started, we need a view to draw on. We already know how to get a view
    from our UI layout using Java code:'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一个视图来绘制。我们已经知道如何使用Java代码从我们的UI布局中获取视图：
- en: '[PRE346]'
  id: totrans-2149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: This line of code grabs a reference to an ImageView placed in the UI design
    and assigns it to our object in our Java code. As we have seen, the ImageView
    in the UI design has an assigned ID of `imageView`, and our controllable ImageView
    object in our Java code is called `ourView`.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码获取了一个放置在UI设计中的ImageView的引用，并将其分配到我们的Java代码中的对象。正如我们所见，UI设计中的ImageView有一个分配的ID为`imageView`，我们Java代码中的可控制ImageView对象被称为`ourView`。
- en: 'Now we need a bitmap. A bitmap itself has a coordinate system like the screen.
    We are creating a bitmap to turn it into a canvas:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个位图。位图本身有一个像屏幕一样的坐标系。我们正在创建一个位图，以便将其转换为画布：
- en: '[PRE347]'
  id: totrans-2152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: The previous line of code declares and creates an object of the `Bitmap` type.
    It will have a size of 300 by 600 pixels. We will keep this in mind when we draw
    on it shortly.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码声明并创建了一个`Bitmap`类型的对象。它将有300x600像素的大小。我们在稍后绘制时会记住这一点。
- en: Tip
  id: totrans-2154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The last argument in the `createBitmap` method, `Bitmap.Config.ARGB_8888`, is
    simply a format, and we can create some great games without getting into the different
    options for bitmap formats.
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: '`createBitmap`方法中的最后一个参数`Bitmap.Config.ARGB_8888`只是一个格式，我们可以在不涉及位图格式不同选项的情况下创建一些很棒的游戏。'
- en: 'Now we can prepare our bitmap for drawing by creating a `Canvas` object from
    it:'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过从它创建一个`Canvas`对象来准备我们的位图以供绘制：
- en: '[PRE348]'
  id: totrans-2157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'Next, we get ourselves an object of the `Paint` type. We can think of this
    object as the brush and the paint for our virtual canvas:'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Paint`类型的对象。我们可以把这个对象想象成虚拟画布的画笔和颜料：
- en: '[PRE349]'
  id: totrans-2159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'At this point, we are ready to use our `Paint` and `Canvas` objects to do some
    drawing. The actual code to draw a pixel in the top-left corner of the screen
    will look like this:'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好使用我们的`Paint`和`Canvas`对象进行一些绘制。在屏幕左上角绘制像素的实际代码将看起来像这样：
- en: '[PRE350]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: Let's now look at a working example.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一个工作示例。
- en: Android Canvas demo app
  id: totrans-2163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Canvas演示应用
- en: Let's make an app that uses the `Canvas` and `Paint` classes and do a bit of
    drawing. This example will be completely static (no animation), so we can clearly
    see how to use `Canvas` and `Paint` without cluttering the code with things we
    will learn later.
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用`Canvas`和`Paint`类并做一些绘制操作的应用。这个例子将完全是静态的（没有动画），这样我们就可以清楚地看到如何使用`Canvas`和`Paint`，而不会在代码中添加我们以后会学到的内容。
- en: 'In this demo app, we use some conceptually helpful variable names to help us
    grasp the role that each object is playing, but we will go through the whole thing
    at the end to make sure we know exactly what is going on at each stage. Of course,
    you don''t have to type all of this. You can open the completed code files from
    the `CanvasDemo` folder in the `Chapter7` folder of the download bundle:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示应用中，我们使用一些概念上有帮助的变量名来帮助我们理解每个对象所扮演的角色，但我们在最后会过一遍整个过程，以确保我们确切地知道每个阶段的实际情况。当然，你不必输入所有这些。你可以从下载包中`Chapter7`文件夹的`CanvasDemo`文件夹中打开完成的代码文件：
- en: Start a new project and call it `CanvasDemo`. Tidy up the unnecessary imports
    and overrides if you want to.
  id: totrans-2166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，并将其命名为`CanvasDemo`。如果你想的话，整理一下不必要的导入和覆盖。
- en: Open `activity_main.xml` in the editor. Drag an **ImageView** from the palette
    to the layout. The ImageView has an ID by default, which is `imageView`. Now we
    will use this ID in our code.
  id: totrans-2167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开 `activity_main.xml`。从调色板中拖动一个 **ImageView** 到布局中。ImageView 默认有一个 ID，即
    `imageView`。现在我们将在这个 ID 中使用我们的代码。
- en: 'Switch to `MainActivity.java` in the editor. First, we will create our `Bitmap`,
    `Canvas`, and `Paint` objects as we discussed earlier. Here is the first part
    of the code. Enter it directly after the call to the `setContentView` method:'
  id: totrans-2168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到编辑器中的 `MainActivity.java`。首先，我们将创建我们的 `Bitmap`、`Canvas` 和 `Paint` 对象，正如我们之前讨论的那样。以下是代码的第一部分。在调用
    `setContentView` 方法后直接输入：
- en: '[PRE351]'
  id: totrans-2169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'Here, we try out some of the cool things we can draw. Enter the code directly
    after the code in the previous step:'
  id: totrans-2170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们尝试绘制一些酷炫的东西。在上一步骤的代码后直接输入以下代码：
- en: '[PRE352]'
  id: totrans-2171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE352]'
- en: Run the demo on an emulator or a device.
  id: totrans-2172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行演示。
- en: 'Your output will look like what is shown in the following screenshot:'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将类似于以下截图所示：
- en: '![Android Canvas demo app](img/8859OS_07_05.jpg)'
  id: totrans-2174
  prefs: []
  type: TYPE_IMG
  zh: '![Android Canvas 示例应用](img/8859OS_07_05.jpg)'
- en: Let's go through the code again. In steps 1 and 2, we created a new project
    and placed an ImageView object with an ID of `imageView` on our UI layout.
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次审视一下代码。在步骤 1 和 2 中，我们创建了一个新项目，并在我们的 UI 布局中放置了一个 ID 为 `imageView` 的 ImageView
    对象。
- en: 'In step 3, we started by getting a reference to the `ImageView` object in our
    layout. However, we have done this often, usually with TextViews and Buttons.
    We named our ImageView `ourFrame` because it will hold our canvas:'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们首先获取了我们布局中 `ImageView` 对象的引用。然而，我们经常这样做，通常是用 TextViews 和 Buttons。我们称我们的
    ImageView 为 `ourFrame`，因为它将包含我们的画布：
- en: '[PRE353]'
  id: totrans-2177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'Then we created a bitmap to be used to make a canvas:'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个用于制作画布的位图：
- en: '[PRE354]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'After that, we created our new `Paint` object:'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了我们的新 `Paint` 对象：
- en: '[PRE355]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'In step 4, we were ready to draw, and we did so in a few different ways. First,
    we painted the entire canvas black:'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 4 中，我们准备开始绘制，并以几种不同的方式进行了绘制。首先，我们将整个画布涂成黑色：
- en: '[PRE356]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'Then we chose the color with which we will be painting. `(255, 255, 255, 255)`
    is a numerical representation of white with full opacity (no transparency):'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择了我们将要使用的颜色。`(255, 255, 255, 255)` 是白色（不透明）的数值表示：
- en: '[PRE357]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: Now we see something new, but it is quite easy to understand. We can also draw
    strings of text to the screen and position that text at precise screen coordinates,
    just like we can with a pixel.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一些新的内容，但它很容易理解。我们也可以将文本字符串绘制到屏幕上，并将文本放置在精确的屏幕坐标上，就像我们可以对像素做的那样。
- en: 'You will notice that with the `drawText` method and all other drawing methods
    of the `Canvas` class, we always pass our `Paint` object as an argument. Just
    to make what is going on in the next line of code absolutely clear, I am stating
    that `"Score: 42 Lives:3 Hi: 97`" is the string that will be drawn on the screen,
    `10, 10` are the screen coordinates, and `paint` is our `Paint` object:'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到，在 `drawText` 方法以及 `Canvas` 类的所有其他绘图方法中，我们总是将我们的 `Paint` 对象作为参数传递。为了使下一行代码中发生的事情绝对清晰，我声明
    `"Score: 42 Lives:3 Hi: 97"` 是将在屏幕上绘制的字符串，`10, 10` 是屏幕坐标，`paint` 是我们的 `Paint`
    对象：'
- en: '[PRE358]'
  id: totrans-2188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Next, we draw a line. The argument list here can be described as follows: (start
    *x* coordinate, start *y* coordinate, end *x* coordinate, end *y* coordinate,
    our `Paint` object):'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制了一条线。这里的参数列表可以这样描述：（起始 *x* 坐标，起始 *y* 坐标，结束 *x* 坐标，结束 *y* 坐标，我们的 `Paint`
    对象）：
- en: '[PRE359]'
  id: totrans-2190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Now we see that we can draw circles. We can also draw other shapes. The argument
    list here can be described as follows: (start *x* coordinate, start *y* coordinate,
    radius of circle, our `Paint` object):'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们可以绘制圆形。我们也可以绘制其他形状。这里的参数列表可以这样描述：（起始 *x* 坐标，起始 *y* 坐标，圆的半径，我们的 `Paint`
    对象）：
- en: '[PRE360]'
  id: totrans-2192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'Then we draw a humble, lonely pixel (point). The arguments we use are in this
    format: (*x* coordinate, *y* coordinate, `Paint` object):'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们绘制了一个谦逊的、孤独的像素（点）。我们使用的参数格式如下：（*x* 坐标，*y* 坐标，`Paint` 对象）：
- en: '[PRE361]'
  id: totrans-2194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'Finally, we place our bitmap canvas on our ImageView frame:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的位图画布放置在 ImageView 框架中：
- en: '[PRE362]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: We still need to get smarter with managing screen resolution and orientation,
    and we will do so in our retro squash game. Also, we need to look for a system
    that will allow us to rub out and redraw our images at a set interval to create
    the illusion of movement. Actually, we already know one such system. Think about
    how we might use threads to achieve this illusion. First of all, let's take a
    look at how the player will control the game. After all, we are not going to have
    any handy UI buttons to press for this game.
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更智能地管理屏幕分辨率和方向，我们将在我们的复古壁球游戏中这样做。此外，我们需要寻找一个系统，使我们能够以固定的时间间隔擦除并重新绘制我们的图像，以创造运动的错觉。实际上，我们已经知道这样一个系统。想想我们如何使用线程来实现这种错觉。首先，让我们看看玩家将如何控制游戏。毕竟，我们不会为这个游戏提供任何方便的UI按钮来按下。
- en: Detecting touches on the screen
  id: totrans-2198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测屏幕上的触摸
- en: In our retro squash game, we will have no UI buttons, so we cannot use the `OnClickListener`
    interface and override the `onClick` method. This is not a problem, however. We
    will just use another interface to suit our situation. We will use `OnTouchListener`
    and override the `onTouchEvent` method. It works a bit differently, so let's take
    a look at implementing it before we dive into the game code.
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的复古壁球游戏中，我们将没有UI按钮，因此我们不能使用`OnClickListener`接口并重写`onClick`方法。然而，这不是问题。我们将使用另一个接口来适应我们的情况。我们将使用`OnTouchListener`并重写`onTouchEvent`方法。它的工作方式略有不同，所以在我们深入研究游戏代码之前，让我们看看如何实现它。
- en: 'We must implement the `OnTouchListener` interface for the activity we want
    to listen to touches in, like this:'
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为想要监听触摸的活动实现`OnTouchListener`接口，如下所示：
- en: '[PRE363]'
  id: totrans-2201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: Then we can override the `onTouchEvent` method, perhaps a bit like this.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以重写`onTouchEvent`方法，可能就像这样。
- en: '[PRE364]'
  id: totrans-2203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: The `x` variable will hold the horizontal value of the position on the screen
    that was touched, and `y` will hold the vertical position. It is worth noting
    that the `motionEvent` object parameter contains lots of information as well as
    the *x* and *y* location, for example, whether the screen was touched or released.
    We can make some really useful switch statements with this information, as we
    will see later.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`变量将保存屏幕上被触摸的位置的水平值，而`y`将保存垂直位置。值得注意的是，`motionEvent`对象参数包含大量信息，以及*x*和*y*的位置，例如，屏幕是否被触摸或释放。我们可以使用这些信息制作一些非常有用的switch语句，就像我们稍后将要看到的那样。'
- en: Knowing exactly how we use this to achieve our goals in the squash game requires
    us to first consider the design of the game.
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 精确地知道我们如何使用这种方法在壁球游戏中实现我们的目标，需要我们首先考虑游戏的设计。
- en: Preparing to make the retro squash game
  id: totrans-2206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备制作复古壁球游戏
- en: Now we are ready to discuss the making of our next game. We actually know everything
    we need to. We just need to think about how to use the different techniques we
    have learned.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好讨论我们下一款游戏的制作了。我们实际上知道我们需要的一切。我们只需要考虑如何使用我们学到的不同技术。
- en: Let's first look at exactly what we want to achieve so that we have something
    to aim for.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看我们确切想要实现什么，这样我们就有目标可以追求。
- en: The design of the game
  id: totrans-2209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设计
- en: Let's look at a screenshot of the game as a good starting point. When you design
    your own games, drawing sketches of the in-game objects and mechanics of the game
    will be an invaluable part of the design process. Here, we can cheat a bit by
    taking a look at the end result.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看游戏的一个截图作为良好的起点。当你设计自己的游戏时，绘制游戏内对象和游戏机制草图将是设计过程中的无价之宝。在这里，我们可以通过查看最终结果来作弊一点。
- en: '![The design of the game](img/8859OS_07_15.jpg)'
  id: totrans-2211
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_07_15.jpg)'
- en: The UI
  id: totrans-2212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI
- en: Starting from the top, we have **Score**. Every time the player successfully
    hits the ball, a point is added. Next, we have **Lives**. The player starts with
    three lives, and every time they let a ball go past their racket, they lose one
    life. When the player has zero lives, their score is set to zero, lives are set
    back to three, and the game begins again. Next to this, we have **FPS**. FPS stands
    for frames per second. It would be nice if we monitor on the screen the number
    of times our screen is being redrawn every second, as this is the first time we
    are animating our very own graphics.
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们有**得分**。每当玩家成功击中球时，就会加一分。接下来是**生命值**。玩家开始时有三个生命值，每次他们让球从他们的球拍旁过去，就会失去一个生命值。当玩家的生命值为零时，他们的得分设置为零，生命值恢复到三个，游戏重新开始。旁边是**帧率**。FPS代表每秒帧数。如果我们在屏幕上监控每秒屏幕重绘的次数，那将很棒，因为这是我们第一次动画化我们自己的图形。
- en: Approximately in the middle of the previous screenshot is the ball. It is a
    square ball, in keeping with the traditional pong style. Squares are also easier
    when you have to perform realistic-looking collision detection.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图的大约中间位置是球。它是一个正方形球，符合传统的乒乓风格。当需要执行看起来逼真的碰撞检测时，正方形也更容易处理。
- en: Physics
  id: totrans-2215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理
- en: 'We will detect when the ball hits any of the four sides of the screen as well
    as when it hits the racket. Depending on what the ball hits and its current direction
    at the time of the collision, we will determine what happens to the ball. Here
    is a rough outline of what each type of collision will do:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检测球击中屏幕的任意四边以及击中球拍的情况。根据球击中的物体及其在碰撞时的当前方向，我们将确定球会发生什么。以下是每种类型碰撞的大致概述：
- en: '**Hit the top of the screen**: The ball will maintain the same horizontal (*x*)
    direction of travel but reverse the vertical (*y*) direction of travel.'
  id: totrans-2217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击屏幕顶部**：球将保持相同的水平 (*x*) 方向移动，但反转垂直 (*y*) 方向的移动。'
- en: '**Hit either side of the screen**: The ball will maintain its *y* direction
    of travel but reverse its *x* direction.'
  id: totrans-2218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击屏幕的任意一侧**：球将保持其 *y* 方向的移动，但会反转其 *x* 方向。'
- en: '**Hit the bottom of the screen**: The ball will disappear and restart at the
    top of the screen with a downward *y* direction of travel and a random *x* direction
    of travel.'
  id: totrans-2219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击屏幕底部**：球将消失，并在屏幕顶部以向下的 *y* 方向移动和随机的 *x* 方向移动重新开始。'
- en: '**Hit the player''s racket**: We will check whether the ball has hit the left
    or the right of the racket and alter the *x* direction of travel to match. We
    will also reverse the *y* direction of travel to send the ball back to the top
    again.'
  id: totrans-2220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击玩家的球拍**：我们将检查球是否击中了球拍的左侧或右侧，并改变 *x* 方向的移动以匹配。我们还将反转 *y* 方向的移动，使球再次回到顶部。'
- en: By enforcing these crude virtual rules of physics, we can simply create a ball
    that behaves almost as we would expect a real ball to do. We will add a few properties
    such as slightly increasing the ball speed after hitting the racket. These rules
    will work just as well in portrait or landscape orientations.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制实施这些粗略的物理虚拟规则，我们可以简单地创建一个球，其行为几乎就像我们预期一个真实球会做的那样。我们将在球击中球拍后略微增加球的速度。这些规则在纵向或横向方向上都会同样有效。
- en: The player's racket will be a simple rectangle that the player can slide left
    by holding anywhere on the left half of the screen, and right by holding anywhere
    on the right of the screen.
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的球拍将是一个简单的矩形，玩家可以通过在屏幕左侧的任何位置握住来向左滑动，通过在屏幕右侧的任何位置握住来向右滑动。
- en: For brevity, we will not be making a main menu screen to implement high scores.
    In our final game, which we start in the next chapter, we will go ahead and have
    an animated menu screen, online high scores, and achievements. However, this squash
    game will simply restart when the player reaches zero lives.
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会创建一个主菜单屏幕来实现高分。在我们的最终游戏中，我们将在下一章开始时创建一个动画菜单屏幕、在线高分和成就。然而，这个弹跳游戏将在玩家生命归零时简单地重新开始。
- en: The structure of the code
  id: totrans-2224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码结构
- en: Here, we will take a quick theoretical look at some aspects of the implementation
    that might be raising questions. When we finally get down to the implementation,
    we should find most of the code quite straightforward, with only a few bits that
    might need extra explanation.
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速从理论上审视一些可能引起疑问的实现方面。当我们最终着手实现时，我们应该会发现大部分代码相当直接，只有少数部分可能需要额外的解释。
- en: We have discussed everything we need to know, and we will also discuss specifics
    in the code as we go through the implementation. We will go over the trickier
    parts of the code at the end of each phase of implementation.
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了我们需要知道的一切，我们还将随着实现过程的进行讨论具体细节。我们将在每个实现阶段的末尾回顾代码中更复杂的部分。
- en: As usual, all the completed code files can be found in the download bundle.
    The files encompassing all the phases of this project are in the `Chapter7/RetroSquash`
    folder.
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，所有完成的代码文件都可以在下载包中找到。涵盖本项目所有阶段的文件位于 `Chapter7/RetroSquash` 文件夹中。
- en: We have learned that in an application using classes and their methods, different
    parts of the code will be dependent on other parts. Therefore, rather than jumping
    back and forth in the code, we will lay it out from the first line to the last
    in order. Of course, we will also refer to the related parts of code as we go
    along. I definitely recommend studying the code in its entirety to fully grasp
    what is going on and which parts of the code call which other parts.
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，在使用类及其方法的程序中，代码的不同部分将相互依赖。因此，我们不会在代码中来回跳跃，而是从第一行到最后一行依次展开。当然，我们也会在过程中参考相关的代码部分。我强烈建议您全面研究代码，以充分理解正在发生的事情以及哪些代码部分调用了哪些其他部分。
- en: To prevent this implementation from spreading into an enormous to-do list, it
    has been broken into four phases. This should provide convenient places to stop
    and take a break.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个实现变成一个庞大的待办事项列表，它已经被分为四个阶段。这应该提供了方便的停止和休息的地方。
- en: 'There is no layout file and only one `.java` file. This file is called `MainActivity.java`.
    The `MainActivity.java` file has a structure as indicated in the following overview
    of the code. I have indented some parts to show what parts are enclosed within
    others. This is a high-level view, and it omits quite a lot of detail:'
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 没有布局文件，只有一个`.java`文件。这个文件叫做`MainActivity.java`。`MainActivity.java`文件的结构如以下代码概览所示。我已经缩进了一些部分以显示哪些部分被包含在其他部分中。这是一个高级视图，省略了很多细节：
- en: '[PRE365]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: As previously stated, we can see that everything is in the `MainActivity.java`
    file. As usual, at the top of our file, we will have a package name and a load
    of imports for the different classes we will be using.
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以看到一切都在`MainActivity.java`文件中。像往常一样，在文件的顶部，我们将有一个包名和大量导入我们将使用的不同类。
- en: Next, as per all our other projects, we have the `MainActivity` class. It encompasses
    everything else, even the `SquashCourtView` class. This makes the `SquashCourtView`
    class an inner class and will therefore be able to access the member variables
    of the `MainActivity` class, which will be essential in this implementation.
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我们所有的其他项目一样，我们有`MainActivity`类。它包含了一切，甚至包括`SquashCourtView`类。这使得`SquashCourtView`类成为一个内部类，因此它将能够访问`MainActivity`类的成员变量，这在实现中将是至关重要的。
- en: Before the `SquashCourtView` class, however, comes the declaration of all the
    member variables in the `MainActivity` class, followed by a fairly in-depth `onCreate`
    method.
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`SquashCourtView`类之前，我们将声明`MainActivity`类中的所有成员变量，然后是一个相当深入的`onCreate`方法。
- en: We could implement the other Android lifecycle methods next, and you are welcome
    to do so. However, the code within the other Android lifecycle methods will make
    more sense once we have seen the code in the `SquashCourtView` class methods.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接下来实现其他Android生命周期方法，您也可以这样做。然而，在其他Android生命周期方法中的代码，在我们看到`SquashCourtView`类的方法之后将更有意义。
- en: After `onCreate`, we will implement the `SquashCourtView` class. This has some
    fairly long methods in it, so we will break it into phases 2 and 3.
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法之后，我们将实现`SquashCourtView`类。这个类中包含了一些相当长的函数，因此我们将将其分为第2和第3阶段。
- en: Finally, we will implement the remaining Android lifecycle methods. They are
    short but important.
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现剩余的Android生命周期方法。它们很短，但很重要。
- en: The four implementation phases in detail
  id: totrans-2238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四个实现阶段的详细说明
- en: 'Let''s take an even closer look at the implementation before we actually get
    to it. Here is how we will divide the implementation into the four phases, this
    time with a bit more detail as to what to expect in each:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正着手之前，让我们更仔细地看看实现过程。以下是我们将如何将实现过程分为四个阶段，这次将更详细地说明每个阶段可以期待什么：
- en: '**Phase 1 – MainActivity and onCreate**: In this phase, we will create the
    project itself as well as implement the following steps:'
  id: totrans-2240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段 – MainActivity和onCreate**：在这个阶段，我们将创建项目本身，并实现以下步骤：'
- en: We will add our imports and create the body of our `MainActivity` class
  id: totrans-2241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加我们的导入并创建`MainActivity`类的主体
- en: Within this, we will declare the member variables that the game needs
  id: totrans-2242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此过程中，我们将声明游戏所需的成员变量
- en: We will implement our `onCreate` method, which does loads of setup work but
    nothing that is hard to understand
  id: totrans-2243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现我们的`onCreate`方法，它做了大量的设置工作，但没有什么难以理解的
- en: '**Phase 2 – SquashCourtView part 1**: In this phase, we will start work on
    our key class, `SquashCourtView`. Specifically, we will:'
  id: totrans-2244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段 – SquashCourtView部分1**：在这个阶段，我们将开始工作于我们的关键类`SquashCourtView`。具体来说，我们将：'
- en: Implement the declaration of the `SquashCourtView` class and its member variables.
  id: totrans-2245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现声明`SquashCourtView`类及其成员变量的声明。
- en: Write a simple constructor.
  id: totrans-2246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的构造函数。
- en: Implement the `run` method to control the flow of the game.
  id: totrans-2247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现控制游戏流程的`run`方法。
- en: Implement the lengthy but fairly easy-to-understand `updateCourt` method. This
    is the method that handles collision detection and keeps track of our ball and
    racket.
  id: totrans-2248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个既长又相对容易理解的`updateCourt`方法。这是处理碰撞检测并跟踪我们的球和球拍的函数。
- en: '**Phase 3 – SquashCourtView part 2**: In this phase, we will finish the `SquashCourtView`
    class by implementing the following:'
  id: totrans-2249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段3 – SquashCourtView第二部分**：在这个阶段，我们将通过实现以下内容来完成`SquashCourtView`类：'
- en: The `drawCourt` method, which unsurprisingly does all the drawing
  id: totrans-2250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawCourt`方法，它意外地做了所有的绘图工作'
- en: The `controlFPS` method, which makes the game run at similar speeds on devices
    that have different CPUs
  id: totrans-2251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controlFPS`方法，它使游戏在不同CPU的设备上以相似的速度运行'
- en: Next, we will quickly write a couple of methods that help the Android lifecycle
    methods with similar names—the `pause` and `resume` methods
  id: totrans-2252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将快速编写几个帮助Android具有类似名称的生命周期方法的方法——`pause`和`resume`方法
- en: Finally for this phase, we will easily handle the touch controls of the game
    by overriding the `onTouchEvent` method we looked at earlier
  id: totrans-2253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，对于这个阶段，我们将通过重写之前查看的`onTouchEvent`方法轻松处理游戏的触摸控制。
- en: '**Phase 4 – Remaining lifecycle methods**: In this short phase we will add
    the finishing touches:'
  id: totrans-2254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段4 – 剩余的生命周期方法**：在这个简短的阶段，我们将添加一些收尾工作：'
- en: Quickly implement what happens in the `onPause`, `onResume`, and `onStop` methods
    by overriding them
  id: totrans-2255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速实现`onPause`、`onResume`和`onStop`方法，通过重写它们
- en: We will also handle what happens when the player presses the back button on
    their phone or tablet
  id: totrans-2256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将处理当玩家在手机或平板电脑上按下返回按钮时会发生什么
- en: Phase 1 – MainActivity and onCreate
  id: totrans-2257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**阶段1 – MainActivity和onCreate**'
- en: 'Now that we have seen what we will do in each of the phases, let''s actually
    get started with building our game by performing the following steps:'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了每个阶段我们将要做什么，那么让我们通过以下步骤开始构建我们的游戏：
- en: 'Create a new project, just as we have before, but with one slight difference.
    This time, on the **New Project** dialog, change **Minimum required SDK** to **API
    13: Android 3.2 (Honeycomb)**. Call the project `RetroSquash`. Delete the unnecessary
    overridden methods if you like.'
  id: totrans-2259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的项目，就像我们之前做的那样，但有一点不同。这次，在**新建项目**对话框中，将**最低要求的SDK**更改为**API 13: Android
    3.2 (Honeycomb**)。将项目命名为`RetroSquash`。如果你喜欢，可以删除不必要的重写方法。'
- en: 'Edit the `AndroidManifest.xml` file, just as we did at the end of [Chapter
    4](ch04.html "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and
    Methods*, to make the app use the full screen. Check back for full details if
    needed. Note that we are *not* locking orientation because this game is fun in
    both portrait and landscape. Here is the line of code to add:'
  id: totrans-2260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AndroidManifest.xml`文件，就像我们在[第4章](ch04.html "第4章. 发现循环和方法")的结尾所做的那样，使应用使用全屏。如有需要，请查看完整细节。注意，我们**不会**锁定方向，因为这款游戏在竖屏和横屏模式下都很有趣。以下是添加的代码行：
- en: '[PRE366]'
  id: totrans-2261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE366]'
- en: Make some sound effects using Bfxr, as we did in [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*. Four will be enough, but
    there is nothing stopping you from adding more sounds. For authentic 1970s-style
    sounds, try the **Blip/Select** button shown in the following screenshot. Name
    the samples `sample1.ogg`, `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`. Or
    you can just use my samples. They are in the `assets` folder of the folder named
    `RetroSquash` in the code bundle.![Phase 1 – MainActivity and onCreate](img/8859OS_07_10.jpg)
  id: totrans-2262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Bfxr制作一些声音效果，就像我们在[第5章](ch05.html "第5章. 游戏和Java基础")中做的那样，四个就足够了，但你可以添加更多声音。为了获得正宗的70年代风格的声音，尝试以下截图中的**Blip/Select**按钮。将样本命名为`sample1.ogg`、`sample2.ogg`、`sample3.ogg`和`sample4.ogg`。或者你也可以直接使用我的样本。它们位于代码包中名为`RetroSquash`的文件夹的`assets`文件夹中。![阶段1
    – MainActivity和onCreate](img/8859OS_07_10.jpg)
- en: In Project Explorer, create a directory called `assets` within the `main` directory.
    Copy the four sound files you created in the previous step to the newly created
    `assets` folder.
  id: totrans-2263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，在`main`目录下创建一个名为`assets`的目录。将上一步骤中创建的四个声音文件复制到新创建的`assets`文件夹中。
- en: 'Type the following import statements at the top of the `MainActivity.java`
    file but just after your package name, as shown in the following code:'
  id: totrans-2264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件的顶部输入以下导入语句，但仅在你包名之后，如下所示：
- en: '[PRE367]'
  id: totrans-2265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'Now type your class declaration and declare the following member variables.
    We will discuss the member variables in detail at the end of this phase:'
  id: totrans-2266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入你的类声明并声明以下成员变量。我们将在本阶段结束时详细讨论成员变量：
- en: '[PRE368]'
  id: totrans-2267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'Next, we will enter the `onCreate` method in its entirety. We are initializing
    many of the member variables that we declared in the previous step, as well as
    creating an object from our `SquashCourtView` class, which we will begin to implement
    in the next phase. Perhaps the most notable line in this block of code is the
    somewhat different call to `setContentView`. Look at the argument for `setContentView`.
    We will learn more about this argument at the end of this phase. This phase also
    sets up `SoundPool` and loads the sound samples. Type the first part of the `onCreate`
    code:'
  id: totrans-2268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将完整地进入`onCreate`方法。我们将初始化我们在上一步中声明的许多成员变量，以及从我们的`SquashCourtView`类创建一个对象，我们将在下一阶段开始实现这个类。在这个代码块中，最引人注目的行可能是对`setContentView`的调用略有不同。看看`setContentView`的参数。我们将在本阶段结束时了解更多关于这个参数的信息。这一阶段还设置了`SoundPool`并加载了声音样本。输入`onCreate`代码的第一部分：
- en: '[PRE369]'
  id: totrans-2269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'Now we initialize the variables we created earlier. Notice that there are some
    good potential candidates for a bit of encapsulation. However, to keep the code
    readable, we will not do so at this stage. Enter this code:'
  id: totrans-2270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们初始化我们之前创建的变量。请注意，有一些很好的潜在候选者可以进行一些封装。然而，为了保持代码的可读性，我们将在这一阶段不这样做。输入以下代码：
- en: '[PRE370]'
  id: totrans-2271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE370]'
- en: Phase 1 code explained
  id: totrans-2272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一阶段代码解释
- en: Let's look at what we did. From steps 1 to 4, we simply created a project and
    some sound files. Then we added the sound files to the `assets` folder as we have
    done before on other projects. In step 5, we added all the necessary imports for
    the classes we will be using.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做了什么。从步骤1到4，我们只是创建了一个项目和一些声音文件。然后，我们像在其他项目中做的那样，将这些声音文件添加到`assets`文件夹中。在步骤5中，我们添加了我们将要使用的所有类的必要导入。
- en: In step 6, we created a whole load of member variables. Let's take a closer
    look at them. We declared an object of the `Canvas` type called `canvas`. We will
    use this object to set up our drawing system. We also declared an instance of
    `SquashCourtView` called `squashCourtView`. This will be underlined as an error
    because we haven't implemented the class yet.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6中，我们创建了一大堆成员变量。让我们更仔细地看看它们。我们声明了一个名为`canvas`的`Canvas`类型的对象。我们将使用此对象来设置我们的绘图系统。我们还声明了一个名为`squashCourtView`的`SquashCourtView`实例。这将因为尚未实现该类而显示为错误。
- en: 'Here, we declared and initialized variables to be references to our sound files,
    just as we did in other projects. After this, we did something new:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明并初始化了变量，以便它们成为我们的声音文件的引用，就像我们在其他项目中做的那样。之后，我们做了一些新的事情：
- en: '[PRE371]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: We declared a `Display` object and a `Point` object. We see these in action
    in our `onCreate` method in a minute, alongside the two `int` variables, `screenWidth`
    and `screenHeight`. We use them to get the screen size in pixels so that we can
    make our game work on a screen with any resolution.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`Display`对象和一个`Point`对象。我们将在下一分钟内的`onCreate`方法中看到它们的作用，同时还有两个`int`变量，`screenWidth`和`screenHeight`。我们使用它们来获取屏幕的像素大小，以便我们的游戏可以在任何分辨率的屏幕上运行。
- en: 'Here, we declared some variables whose purpose is plain from their names. Their
    actual usage becomes clearer when we initialize them in step 8 and use them throughout
    our `SquashCourtView` class:'
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一些变量，它们的目的从它们的名称中就可以看出。它们的实际使用在我们第8步初始化它们并在我们的`SquashCourtView`类中使用它们时变得更加清晰：
- en: '[PRE372]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'Here, we have a bunch of Boolean variables to control the logic of the movement
    of both the racket and the ball. Notice that there is a variable for each possible
    direction for both the racket and the ball. Notice also that the racket can move
    in two directions—left and right—and the ball in four. Of course, the ball can
    travel in two directions at the same time. All will become clear when we write
    the `updateCourt` method in phase 2\. Here is that code again:'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一系列布尔变量来控制球拍和球的运动逻辑。请注意，对于球拍和球的可能方向，都有一个变量。请注意，球拍可以朝两个方向移动——左和右——而球可以朝四个方向移动。当然，球可以同时朝两个方向移动。所有这些都会在第二阶段的`updateCourt`方法编写时变得清晰。这是那段代码的再次展示：
- en: '[PRE373]'
  id: totrans-2281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: In the last part of step 6, we declared two fairly obvious variables, `lives`
    and `score`. But what about `lastFrameTime` and `fps`? These will be used in the
    `controlFPS` method, which we will write in phase 3\. They will be used along
    with some local variables to measure how fast our game loop runs. We can then
    lock it to run at a consistent rate so that players on devices with different
    CPU speeds get a similar experience.
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步的最后部分，我们声明了两个相当明显的变量，`lives`和`score`。那么`lastFrameTime`和`fps`呢？这些将在第3阶段我们将编写的`controlFPS`方法中使用。它们将和某些局部变量一起用来测量游戏循环的运行速度。然后我们可以将其锁定在一致的速率下运行，这样不同CPU速度的设备上的玩家都能获得相似的游戏体验。
- en: In step 7, we entered the `onCreate` method, but this time, things are different.
    We initialize `squashCourtView` as a new `SquashCourtView` object. It's fine so
    far, but then we seem to be telling `setContentView` to make this the entire view
    that the player will see, instead of the usual view created in the Android Studio
    designer, which we have become used to. We are not using any Android UI components
    in this game, so the visual designer and all of its generated XML are of no use
    to us. As you will see right at the start of phase 2, our `SquashCourtView` class
    extends (inherits from) `SurfaceView`.
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，我们进入了`onCreate`方法，但这次情况有所不同。我们将`squashCourtView`初始化为一个新的`SquashCourtView`对象。到目前为止一切正常，但随后我们似乎在告诉`setContentView`将其设置为玩家将看到的整个视图，而不是我们习惯在Android
    Studio设计器中创建的常规视图。在这个游戏中，我们不使用任何Android UI组件，所以视觉设计器和所有生成的XML对我们来说都没有用。正如你将在第2阶段开始时看到的那样，我们的`SquashCourtView`类扩展（继承自）`SurfaceView`。
- en: 'We created an object with all the facilities of a `SurfaceView`. We will just
    customize it to play our squash game. Neat! Therefore, it is perfectly acceptable
    and logical to set our `squashCourtView` object as the entire view that the player
    will see:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有所有`SurfaceView`功能的对象。我们只需自定义它来播放我们的壁球游戏。真不错！因此，将我们的`squashCourtView`对象设置为玩家将看到的整个视图是完全可接受且逻辑的：
- en: '[PRE374]'
  id: totrans-2285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: We then set up our sound effects as we have done before.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后设置了我们的音效，就像之前做的那样。
- en: In step 8, we initialized many of the variables that we declared in step 6\.
    Let's look at the values and the order in which we initialized them. You might
    have noticed that we don't initialize every variable here; some will be initialized
    later. Remember that we don't have to initialize member variables and that they
    also have default values.
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们初始化了在第6步中声明的许多变量。让我们看看它们的值和初始化的顺序。你可能已经注意到，我们在这里并没有初始化每个变量；一些将在稍后初始化。记住，我们不需要初始化成员变量，它们也有默认值。
- en: 'In the following code, we get the number of pixels (wide and high) for the
    device. The `display` object holds the details of the display after the first
    line has been executed. Then we create a new object called `size` of the `Point`
    type. We send `size` as an argument to the `display.getSize` method. The `Point`
    type has an `x` and `y` member variable, and so does the `size` object, which
    now holds the width and height (in pixels) of the display. These values are then
    assigned to `screenWidth` and `screenHeight` respectively. We will use `screenWidth`
    and `screenHeight` quite extensively in the `SquashCourtView` class:'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们获取设备的像素数（宽和高）。`display`对象在执行第一行后持有显示的详细信息。然后我们创建了一个名为`size`的新对象，它是`Point`类型。我们将`size`作为参数传递给`display.getSize`方法。`Point`类型有一个`x`和`y`成员变量，`size`对象也是如此，现在它持有显示的宽度和高度（以像素为单位）。然后这些值分别赋给`screenWidth`和`screenHeight`。我们将在`SquashCourtView`类中广泛使用`screenWidth`和`screenHeight`：
- en: '[PRE375]'
  id: totrans-2289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'Next, we initialize the variables that determine the size and position of the
    ball and racket. Here, we initialize our `racketPosition` object, which is of
    the `Point` type. Remember that it has an `x` and a `y` member variable:'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化确定球拍和球的大小和位置的变量。在这里，我们初始化我们的`racketPosition`对象，它是`Point`类型。记住，它有一个`x`和`y`成员变量：
- en: '[PRE376]'
  id: totrans-2291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'We initialize `racketPosition.x` to be whatever the current screen width in
    pixels might be, but divided by two, so the racket will start in a horizontal
    and central position regardless of the resolution of the screen:'
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`racketPosition.x`初始化为当前屏幕宽度（以像素为单位），但除以二，这样球拍将从一个水平和中央位置开始，无论屏幕的分辨率如何：
- en: '[PRE377]'
  id: totrans-2293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'In the next line of code, `racketPosition.y` is put at the bottom of the screen
    with a small 20-pixel gap:'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，`racketPosition.y`被放置在屏幕底部，留有20像素的小间隙：
- en: '[PRE378]'
  id: totrans-2295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'We make the width of the racket to one-eighth the width of the screen. We will
    see when we get to run the game that this is a fairly effective size, but we could
    make it bigger by dividing it by a lower number, or smaller by dividing it by
    a larger number. The point is that it will be the same fraction of `screenWidth`
    regardless of the resolution of the device:'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将球拍的宽度设置为屏幕宽度的八分之一。当我们运行游戏时，我们会看到这是一个相当有效的尺寸，但我们可以通过除以更小的数字来使其更大，或者通过除以更大的数字来使其更小。关键是，无论设备的分辨率如何，它都将与
    `screenWidth` 保持相同的比例：
- en: '[PRE379]'
  id: totrans-2297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'In the following line of code, we choose an arbitrary height for our racket:'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们为球拍选择一个任意的高度：
- en: '[PRE380]'
  id: totrans-2299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'Then we make our ball as small as 1/35th of the screen. Again, we could make
    it larger or smaller:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将球的大小设置为屏幕的1/35。同样，我们可以将其做得更大或更小：
- en: '[PRE381]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'In the next line of code, we will create a new point object to hold the position
    of the ball:'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们将创建一个新的点对象来保存球的位置：
- en: '[PRE382]'
  id: totrans-2303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'As we did with the racket, we start the ball in the center of the screen, like
    this:'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对待球拍一样，我们从屏幕中心开始球，如下所示：
- en: '[PRE383]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'However, we set it to start at the top of the screen just far enough to see
    the top of the ball:'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将其设置为从屏幕顶部开始，足够远以至于可以看到球的顶部：
- en: '[PRE384]'
  id: totrans-2307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'The player starts the game with three lives:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家开始游戏时有三个生命：
- en: '[PRE385]'
  id: totrans-2309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Phew! That was a fairly chunky section. Take a break if you like, and then we
    will move on to phase 2.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这部分内容相当多。如果您喜欢，可以休息一下，然后我们将继续进行第2阶段。
- en: Phase 2 – SquashCourtView part 1
  id: totrans-2311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段 – SquashCourtView 第1部分
- en: 'Finally, we get to the secret weapon of our game—the `SquashCourtView` class.
    The first three methods are presented here, and explained more fully once we have
    implemented them:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了我们游戏的秘密武器——`SquashCourtView` 类。这里展示了前三个方法，一旦我们实现了它们，将会有更详细的解释：
- en: 'Here is a class declaration that extends `SurfaceView`, giving our class all
    the methods and properties of `SurfaceView`. It also implements `Runnable`, which
    allows it to run in a separate thread. As you will see, we will put the bulk of
    the functionality in the `run` method. After the declaration, we have a constructor.
    Remember that the constructor is a method that has the same name as the class
    and is called when we initialize a new object of its type. The code in the constructor
    initializes some objects and then sends the ball off in a random direction. We
    will look at that part in detail after we have implemented this phase. Enter the
    following code before the closing curly brace of the `MainActivity` class:'
  id: totrans-2313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个扩展 `SurfaceView` 的类声明，使我们的类拥有 `SurfaceView` 的所有方法和属性。它还实现了 `Runnable` 接口，这使得它可以在一个单独的线程中运行。正如您将看到的，我们将大部分功能放在
    `run` 方法中。在声明之后，我们有一个构造函数。请记住，构造函数是一个与类名相同的函数，在我们初始化其类型的新对象时被调用。构造函数中的代码初始化了一些对象，然后使球以随机方向飞出。在实现这个阶段之后，我们将详细查看这部分。在
    `MainActivity` 类的闭合花括号之前输入以下代码：
- en: '[PRE386]'
  id: totrans-2314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'Now we have this short and sweet overriding of the `run` method. Remember that
    the `run` method contains the functionality of the thread. In this case, it has
    three calls, one to each of `updateCourt`, `drawCourt`, and `controlFPS`, the
    three key methods of our class. Enter this code:'
  id: totrans-2315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了对 `run` 方法的简短而清晰的覆盖。请记住，`run` 方法包含线程的功能。在这种情况下，它有三个调用，分别对应于 `updateCourt`、`drawCourt`
    和 `controlFPS`，这是我们类的三个关键方法。输入以下代码：
- en: '[PRE387]'
  id: totrans-2316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'We will implement just one more method in this phase (`updateCourt`), but it
    is quite long. We will split it into chunks and briefly mention what is going
    on in each chunk before we type the code. We will perform a closer examination
    of how it works when the phase is implemented. In this next chunk of code, we
    handle the left and right movement of the racket as well as detecting and reacting
    when the ball hits either the left or the right of the screen. Enter the following
    code after the code from the previous step:'
  id: totrans-2317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将实现一个方法（`updateCourt`），但它相当长。在输入代码之前，我们将将其分成几个部分，并简要说明每个部分正在发生的事情。在阶段实现后，我们将更详细地检查其工作原理。在接下来的代码块中，我们将处理球拍的左右移动，以及检测和反应球击中屏幕的左侧或右侧。在上一步骤的代码之后输入以下代码：
- en: '[PRE388]'
  id: totrans-2318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'In this next chunk of code, we check whether the ball has hit the bottom of
    the screen, that is, the player has failed to return the ball. Enter this code
    directly after the code in the previous step:'
  id: totrans-2319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们检查球是否击中了屏幕底部，即玩家未能将球返回。在上一步骤的代码之后直接输入以下代码：
- en: '[PRE389]'
  id: totrans-2320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'In this chunk of code, we handle whether the ball has hit the top of the screen.
    We also calculate all the possible movements of the ball for this frame. Now type
    the following code:'
  id: totrans-2321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段代码中，我们处理球是否击中屏幕顶部的情况。我们还计算了这一帧球的所有可能移动。现在输入以下代码：
- en: '[PRE390]'
  id: totrans-2322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'Finally, we handle collision detection and the reaction of the racket and the
    ball. We also close the `updateCourt` method, and this is the last chunk of code
    for this phase. Enter the following after your code from the previous step:'
  id: totrans-2323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理碰撞检测以及球拍和球的反应。我们还关闭了`updateCourt`方法，这是本阶段最后一段代码。在上一阶段的代码之后，输入以下内容：
- en: '[PRE391]'
  id: totrans-2324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE391]'
- en: Phase 2 code explained
  id: totrans-2325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二阶段代码解释
- en: The code in this phase was lengthy, but there is nothing too challenging when
    we break it down. Possibly, the only challenge is in unravelling some of those
    nested `if` statements. We will do this now.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 这一阶段的代码很长，但当我们分解它时，并没有什么太具挑战性的。可能唯一的挑战在于解开一些嵌套的`if`语句。我们现在将这样做。
- en: In step 1, we declare our `SquashCourView` class. This implements the `Runnable`
    interface. You might remember from [Chapter 5](ch05.html "Chapter 5. Gaming and
    Java Essentials"), *Gaming and Java Essentials*, that `Runnable` provides us with
    a thread. All we need to do is override the `run` method, and whatever is within
    it will work in a new thread.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们声明了我们的`SquashCourView`类。这实现了`Runnable`接口。你可能还记得从[第五章](ch05.html "第五章.
    游戏和Java基础")，*游戏和Java基础*，`Runnable`为我们提供了一个线程。我们只需要重写`run`方法，其中的任何内容都会在新线程中运行。
- en: Then we created a new `Thread` object called `ourThread`, and a `SurfaceHolder`
    object to hold our surface and enable us to control or lock our surface for use
    within our thread. Next, we have `playingSquash` of the `boolean` type. This wraps
    the inside of our overridden `run` method to control when the game is running.
    The odd-looking `volatile` modifier means that we will be able to change its value
    from the outside and inside of our thread.
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为`ourThread`的新`Thread`对象，以及一个`SurfaceHolder`对象来持有我们的表面并允许我们在线程内部控制或锁定我们的表面。接下来，我们有`playingSquash`，它是布尔类型的。这封装了重写的`run`方法内部，以控制游戏何时运行。看起来奇怪的`volatile`修饰符意味着我们可以从线程外部和内部改变它的值。
- en: 'Lastly, for the currently discussed block of code, we declare an object of
    the `Paint` type, called `paint`, to do our painting:'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于当前讨论的代码块，我们声明了一个名为`paint`的`Paint`类型对象，用于我们的绘图：
- en: '[PRE392]'
  id: totrans-2330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'Next, we implemented the constructor of our class, so that when we initialized
    a new `SquashCourtView` object back in `onCreate`, this is the code that runs.
    First, we see that we run the constructor of the superclass. Then we initialize
    `ourHolder` using the `getHolder` method. Next, we initialize our `paint` object:'
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了我们类的构造函数，这样当我们回到`onCreate`中初始化一个新的`SquashCourtView`对象时，就会运行以下代码。首先，我们看到我们运行了超类的构造函数。然后，我们使用`getHolder`方法初始化`ourHolder`。接下来，我们初始化我们的`paint`对象：
- en: '[PRE393]'
  id: totrans-2332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'Now, still within the constructor, we get things moving. We set our `ballIsMovingDown`
    variable to `true`. At the start of each game, we always want the ball to be moving
    down. We will see soon that the `updateCourt` method will perform the ball movement.
    Next, we send the ball in a random horizontal direction. This is achieved by getting
    a random number between 0 and 2\. We then switch for each possible case: 0, 1,
    or 2\. In each case statement, we set the Boolean variables that control horizontal
    movement differently. In `case 0`, the ball moves left, and in `case 1` and `case
    3`, the ball will move right and straight down, respectively. Then we close our
    constructor:'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在构造函数中，我们让事物开始移动。我们将`ballIsMovingDown`变量设置为`true`。在每场游戏的开始时，我们总是希望球向下移动。我们将很快看到`updateCourt`方法将执行球的移动。接下来，我们将球向一个随机的水平方向发送。这是通过获取0到2之间的随机数来实现的。然后，我们为每个可能的案例进行切换：0、1或2。在每个case语句中，我们设置不同的布尔变量来控制水平移动。在`case
    0`中，球向左移动，而在`case 1`和`case 3`中，球将分别向右和垂直向下移动。然后我们关闭我们的构造函数：
- en: '[PRE394]'
  id: totrans-2334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'In step 2, we have some really simple code, but this is the code that runs
    everything else. The overridden `run` method is what `ourThread` calls at defined
    intervals. As you can see, the code is wrapped in a `while` block controlled by
    our `playingSquash` variable of the `boolean` type. Then the code simply calls
    `updateCourt`, which controls movement and collision detection; `drawCourt`, which
    will draw everything; and `controlFPS`, which will lock our game to a consistent
    frame rate. That''s it for `run`:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步，我们有一些非常简单的代码，但这却是运行其他所有代码的代码。被重写的`run`方法是`ourThread`在定义的间隔内调用的。如您所见，代码被包裹在一个由我们的`boolean`类型的`playingSquash`变量控制的`while`块中。然后代码简单地调用`updateCourt`，它控制移动和碰撞检测；`drawCourt`，它将绘制一切；以及`controlFPS`，它将游戏锁定在一致的帧率。这就是`run`的全部内容：
- en: '[PRE395]'
  id: totrans-2336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'Then in step 3, we begin the `updateCourt` method. It was quite long, so we
    broke it down into a few manageable chunks. The first two `if` blocks check to
    see whether either the `racketIsMovingRight` or the `racketIsMovingLeft` Boolean
    variables is true. If one of them is true, the blocks add `10` to or subtract
    `10` from `racketPosition.x`. The effect of this will be seen by the player when
    the racket is drawn in the `drawCourt` method. How the Boolean variables are manipulated
    in the `onTouchEvent` method will be discussed soon:'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第3步，我们开始`updateCourt`方法。它相当长，所以我们将其分解成几个可管理的部分。前两个`if`块检查`racketIsMovingRight`或`racketIsMovingLeft`布尔变量是否为真。如果其中一个为真，则这些块将`10`加到或从`racketPosition.x`中减去。玩家将在`drawCourt`方法中绘制球拍时看到这种效果。在`onTouchEvent`方法中如何操作布尔变量将在稍后讨论：
- en: '[PRE396]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'Now, still in the `updateCourt` method, we detect and handle collisions with
    the left and right side of the screen. Checking whether `ballPosition.x` is larger
    than `screenWidth` would be enough to see whether the ball bounces back the other
    way. However, by being a bit more precise and testing for `ballPosition.x + ballWidth
    > screenWidth`, we are testing whether the right edge of the ball hits the right
    side of the screen. This creates a much more pleasing effect as it looks more
    *real*. When a collision occurs with the right side, we simply reverse the direction
    of our ball and play a sound. The reason that the `if` code for the left-side
    detection is simpler is because we have drawn the ball using `drawRect`, so `ballPosition.x`
    is the precise left side of the ball. When the ball collides with the left side,
    we simply reverse its direction and play a beep sound:'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在`updateCourt`方法中，我们检测和处理与屏幕左右两侧的碰撞。检查`ballPosition.x`是否大于`screenWidth`就足以看到球是否会反弹回来。然而，通过更加精确地测试`ballPosition.x
    + ballWidth > screenWidth`，我们实际上是在测试球的右边缘是否击中了屏幕的右侧。这创造了一个更加令人愉悦的效果，因为它看起来更加*真实*。当球与右侧发生碰撞时，我们只需反转球的方向并播放声音。左侧检测的`if`代码之所以更简单，是因为我们使用`drawRect`绘制了球，所以`ballPosition.x`是球的精确左侧。当球与左侧碰撞时，我们只需反转其方向并播放蜂鸣声：
- en: '[PRE397]'
  id: totrans-2340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'In step 4, we implemented what happens when the ball hits the bottom of the
    screen. This occurs when the player fails to return the ball, so a fair few things
    need to happen here. However, there is nothing overly complicated in this section.
    First comes the collision test. We check whether the underside of the ball has
    hit the bottom of the screen:'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们实现了球击中屏幕底部时发生的情况。这发生在玩家未能将球击回时，因此这里需要发生很多事情。然而，这一部分并没有什么过于复杂的内容。首先进行碰撞测试。我们检查球的底部是否击中了屏幕底部：
- en: '[PRE398]'
  id: totrans-2342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'If it has hit, we deduct a life. Then we check whether the player has lost
    all their lives:'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球击中，我们将扣除一个生命值。然后我们检查玩家是否已经失去了所有生命值：
- en: '[PRE399]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: 'If all lives are lost, we start the game again by resetting lives to 3 and
    score to 0\. We also play a low beep sound:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有生命值都已丢失，我们将通过将生命值重置为3和得分设置为0来重新开始游戏。我们还会播放一个低沉的蜂鸣声：
- en: '[PRE400]'
  id: totrans-2346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'As of now, we are still within the `if` block because the ball hit the bottom
    of the screen, but outside the `if` block for the player who has zero lives. Whether
    the player has zero lives or still has some lives left, we need to put the ball
    back at the top of the screen and send it in a downward trajectory and a random
    horizontal direction. This code is similar to but not the same as the code we
    have seen in the constructor to start the ball moving at the beginning of the
    game:'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们仍然处于`if`块中，因为球击中了屏幕底部，但对于那个生命值为零的玩家来说，则不在`if`块内。无论玩家是否有零生命值还是还有剩余生命值，我们都需要将球放回屏幕顶部，并使其沿向下轨迹和随机的水平方向移动。此代码与我们在构造函数中看到的开始游戏时使球移动的代码相似，但并不相同：
- en: '[PRE401]'
  id: totrans-2348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'In step 5, we handle the event of the ball hitting the top of the screen. Reverse
    the values held by `ballIsMovingDown` and `ballIsMovingUp` to reverse the direction
    of the ball. Tweak the ball position with `ballPosition.y = 1`. This stops the
    ball from getting stuck and plays a nice beep:'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们处理球击中屏幕顶部的事件。通过反转`ballIsMovingDown`和`ballIsMovingUp`的值来反转球的方向。使用`ballPosition.y
    = 1`调整球的位置。这阻止了球卡住并播放了一个悦耳的哔哔声：
- en: '[PRE402]'
  id: totrans-2350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'Now, after all this collision detection and switching around of our Boolean
    variables, we actually move the ball. For each direction that is true, we add
    to or subtract from the `ballPosition.x` and `ballPosition.y` accordingly. Notice
    that the ball travels up faster than it travels down. This is done to shorten
    the time the player is waiting to get back into the action, and also crudely simulates
    the act of acceleration after the ball is hit by the racket:'
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在所有这些碰撞检测和布尔变量的切换之后，我们实际上移动了球。对于每个为真的方向，我们相应地添加到或从`ballPosition.x`和`ballPosition.y`中减去。注意，球向上移动的速度比向下移动快。这是为了缩短玩家等待重新进入比赛的时间，并且也粗略地模拟了球被球拍击中后的加速动作：
- en: '[PRE403]'
  id: totrans-2352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: Tip
  id: totrans-2353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that by hardcoding the number of pixels the ball moves,
    we create an inconsistent speed for the ball between high-resolution and low-resolution
    screens. Take a look at the self-test questions at the end of the chapter to see
    how we can solve this.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，通过硬编码球移动的像素数，我们在高分辨率和低分辨率屏幕之间为球创建了一个不一致的速度。查看本章末尾的自我测试问题，看看我们如何解决这个问题。
- en: 'We have one last bit of collision detection to do. Has the ball hit the racket?
    This detection is done in a couple of stages. First, we check whether the underside
    of the ball has reached or gone past the top side of the racket:'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要进行最后一点碰撞检测。球是否击中了球拍？这个检测分为几个阶段。首先，我们检查球的底部是否到达或超过了球拍的顶部：
- en: '[PRE404]'
  id: totrans-2356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: 'If this condition is true, we perform some more tests. First, we declare and
    initialize an `int` variable called `halfRacket` to hold half the width of the
    racket. We will use this in the upcoming tests:'
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个条件为真，我们执行一些额外的测试。首先，我们声明并初始化一个名为`halfRacket`的`int`变量，用于存储球拍宽度的一半。我们将在接下来的测试中使用它：
- en: '[PRE405]'
  id: totrans-2358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: 'The next `if` block checks whether the right-hand side of the ball is greater
    than the far left corner of the racket, and whether it is touching it. Using the
    AND operator (`&&`), the block verifies that the ball''s left edge is not past
    the far right of the racket. If this condition is true, we definitely have a hit
    and can think about how to handle the rebound:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`块检查球的右侧是否大于球拍的远左角，并且是否接触它。使用AND运算符(`&&`)，该块验证球的左侧边缘是否没有超过球拍的远右端。如果这个条件为真，我们肯定发生了碰撞，并可以思考如何处理反弹：
- en: '[PRE406]'
  id: totrans-2360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'The first bit of code inside the `if` block, which determined a definite hit,
    is simple. Play a sound, increase the score, and set the ball on an upwards trajectory,
    like this:'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`块中的第一段代码很简单，它确定了一个明确的碰撞。播放声音，增加分数，并将球设置为向上轨迹，如下所示：'
- en: '[PRE407]'
  id: totrans-2362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: 'Now we have an `if`-`else` condition, which simply checks whether the left-hand
    edge of the ball is past the center of the racket. If it is, we send the ball
    to the right. Otherwise, we send the ball to the left:'
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`if`-`else`条件，它简单地检查球的左侧边缘是否超过了球拍的中心。如果是，我们将球发送到右侧。否则，我们将球发送到左侧：
- en: '[PRE408]'
  id: totrans-2364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: Phase 3 – SquashCourtView part 2
  id: totrans-2365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三阶段 – SquashCourtView 第二部分
- en: 'In this phase, we will complete our `SquashCourtView` class. There are two
    methods remaining that are called from the `run` method, `drawCourt` and `controlFPS`.
    Then there are a few short methods to interact with the Android lifecycle methods
    that we will implement in the fourth and final phase:'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将完成`SquashCourtView`类。还有两个方法剩余，它们从`run`方法中调用，即`drawCourt`和`controlFPS`。然后还有一些简短的方法来与Android生命周期方法交互，这些方法将在第四和最终阶段实现：
- en: 'Here is the code that draws, in the following order, the text at the top of
    the screen, the ball, and the bat. All is contained within the `drawCourt` method,
    which is called from the `run` method, right after the call to `updateCourt`.
    Here is the code for `drawCourt`. Type the following code before the closing curly
    brace of the `SquashCourtView` class:'
  id: totrans-2367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是按照以下顺序绘制屏幕顶部文本、球和球拍的代码。所有这些都在`drawCourt`方法中完成，该方法在调用`updateCourt`之后从`run`方法中调用。以下是`drawCourt`的代码。在`SquashCourtView`类的闭合花括号之前输入以下代码：
- en: '[PRE409]'
  id: totrans-2368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'And now the `controlFPS` method locks our frame rate to something smooth and
    consistent. We will soon go through its exact working. Type the following code
    after the code in the previous step:'
  id: totrans-2369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的`controlFPS`方法将我们的帧率锁定为平滑且一致的状态。我们很快就会详细了解其工作原理。在上一步骤的代码之后输入以下代码：
- en: '[PRE410]'
  id: totrans-2370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'Next, we write the code for `pause` and `resume`. These are called by their
    related Android lifecycle methods (`onPause` and `onResume`). We ensure that our
    thread is ended or started safely when the player has finished or resumed our
    game, respectively. Now type this code after the code in the previous step:'
  id: totrans-2371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写`pause`和`resume`的代码。这些是通过它们相关的Android生命周期方法（`onPause`和`onResume`）调用的。我们确保当玩家完成或恢复我们的游戏时，我们的线程能够安全地结束或启动。现在在上一步骤的代码之后输入以下代码：
- en: '[PRE411]'
  id: totrans-2372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE411]'
- en: 'Finally, we have the method that controls what happens when the player touches
    our customized `SurfaceView`. Remember that when we discussed the design of the
    game, we said that a press anywhere on the left of the screen would move the racket
    to the left, and a press anywhere on the right will move the racket to the right.
    Type the following code after the code in the preceding step:'
  id: totrans-2373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有控制当玩家触摸我们的自定义`SurfaceView`时发生什么的方法。记住，当我们讨论游戏设计时，我们说在屏幕左侧的任何地方按下都会将球拍向左移动，而在屏幕右侧的任何地方按下都会将球拍向右移动。在上一步骤的代码之后输入以下代码：
- en: '[PRE412]'
  id: totrans-2374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE412]'
- en: Phase 3 code explained
  id: totrans-2375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三阶段代码解释
- en: 'In step 1, we do all the drawing. We have seen what all the different drawing
    methods of the `Canvas` class can do, and their names are self-explanatory as
    well. However, the manner in which we arrived at the coordinates needs some explanation.
    First, inside `drawCourt`, we use `ourHolder` to get a drawing surface, and we
    check its validity (usability). Then we initialize our `canvas` and `paint` objects:'
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们完成所有的绘制。我们已经看到了`Canvas`类的所有不同绘制方法能做什么，并且它们的名称也是不言自明的。然而，我们到达坐标的方式需要一些解释。首先，在`drawCourt`内部，我们使用`ourHolder`来获取绘图表面，并检查其有效性（可用性）。然后我们初始化我们的`canvas`和`paint`对象：
- en: '[PRE413]'
  id: totrans-2377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'Next, we clear the screen from the previous frame of drawing:'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们清除上一帧绘制的屏幕：
- en: '[PRE414]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'Now we set the paint color to white:'
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将画笔颜色设置为白色：
- en: '[PRE415]'
  id: totrans-2381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'This is new but simple to explain—we set a size for our text:'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 这项新功能虽然简单，但需要解释——我们为我们的文本设置一个大小：
- en: '[PRE416]'
  id: totrans-2383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: 'Now we can draw a line of text at the top of the screen. It shows the `score`
    and `lives` variables. We have already seen how to control their values. It also
    shows the value of the `fps` variable. We will see how we can assign a value to
    that when we look at the next method, `controlFPS`:'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制屏幕顶部的文本行。它显示了`score`和`lives`变量。我们已经看到了如何控制它们的值。它还显示了`fps`变量的值。当我们查看下一个方法`controlFPS`时，我们将看到如何为它分配一个值：
- en: '[PRE417]'
  id: totrans-2385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'Then we draw the racket. Notice that we calculate the `x` start position by
    subtracting half the racket width from `racketPosition.x`, and the `x` end position
    by adding the width to `x`. This makes our collision detection code simple because
    `racketPosition.x` refers to the center of the racket:'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们绘制球拍。注意，我们通过从`racketPosition.x`中减去球拍宽度的一半来计算`x`起始位置，并通过将宽度加到`x`上来计算`x`结束位置。这使得我们的碰撞检测代码变得简单，因为`racketPosition.x`指的是球拍的中心：
- en: '[PRE418]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'Next, we draw the ball. Notice that the starting *x* and *y* coordinates are
    the same as the values held in `ballPosition.x` and `ballPosition.y`. Therefore,
    these coordinates correspond to the top-left corner of the ball. This is just
    what we need for our simple collision detection code:'
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制球。注意，起始的*x*和*y*坐标与`ballPosition.x`和`ballPosition.y`中持有的值相同。因此，这些坐标对应于球的左上角。这正是我们简单碰撞检测代码所需要的：
- en: '[PRE419]'
  id: totrans-2389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'This final line draws what we have just done to the screen:'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行将我们刚刚完成的内容绘制到屏幕上：
- en: '[PRE420]'
  id: totrans-2391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: In step 2, we essentially pause the game. We want to decide the number of times
    we recalculate the position of our objects and redraw them. Here is how it works.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们本质上暂停了游戏。我们想要决定我们重新计算对象位置并重新绘制它们的次数。以下是它是如何工作的。
- en: 'First, we enter the `controlFPS` method when it is called from the `run` method.
    We declare and initialize a `long` variable with the time in milliseconds, and
    then take away the time that the last frame took in milliseconds. The time is
    calculated in the previous run through this method, at the end, as we will see:'
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当它从`run`方法中被调用时，我们进入`controlFPS`方法。我们声明并初始化一个带有毫秒时间的`long`变量，然后减去上一帧所花费的毫秒时间。时间是在上一次通过此方法运行时计算的，我们将在下面看到：
- en: '[PRE421]'
  id: totrans-2394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'We then calculate how long we want to pause between frames, and initialize
    that value to `timeToSleep`, a new long variable. Here is how the calculation
    works: 15 milliseconds of pause gives us around 60 frames per second, which works
    well for our game and provides a very smooth animation. Therefore, `15 - timeThisFrame`
    equals the number of milliseconds we should pause for to make the frame last for
    15 milliseconds:'
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算我们希望在帧之间暂停多长时间，并将该值初始化为`timeToSleep`，一个新的长整型变量。这里的计算方法是：15毫秒的暂停可以给我们大约60帧每秒，这对我们的游戏来说效果很好，并且提供了非常平滑的动画。因此，`15
    - timeThisFrame`等于我们应该暂停多少毫秒以使帧持续15毫秒：
- en: '[PRE422]'
  id: totrans-2396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'Of course, some devices will not cope with this speed. Neither do we want to
    pause for a negative number, nor do we want to calculate the frames per second
    when `timeThisFrame` is equal to zero. Next, we wrap the calculation of frames
    per second within an `if` statement that prevents us from dividing by zero or
    a negative number:'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些设备可能无法处理这种速度。我们既不希望暂停一个负数，也不希望在`timeThisFrame`等于零时计算每秒帧数。接下来，我们将每秒帧数的计算包裹在一个`if`语句中，以防止我们除以零或负数：
- en: '[PRE423]'
  id: totrans-2398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'Likewise, we wrap the instruction to our thread to pause within a similar cautionary
    `if` statement:'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将暂停线程的指令包裹在一个类似的谨慎的`if`语句中：
- en: '[PRE424]'
  id: totrans-2400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'Finally, we see how we initialize `lastFrameTime`, ready for the next time
    `controlFPS` is called:'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到我们是如何初始化`lastFrameTime`，为下一次调用`controlFPS`做准备：
- en: '[PRE425]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'In step 3, we quickly implement two methods. They are `pause` and `resume`.
    These are not to be confused with the Android Activity lifecycle methods called
    `onPause` and `onResume`. However, the `pause` and `resume` methods are called
    from their near-namesakes. They handle stopping and starting `ourThread`, respectively.
    We should always clean up our threads. Otherwise, they can keep running even after
    the activity has finished:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们快速实现了两个方法。它们是`pause`和`resume`。这些方法不应该与Android Activity生命周期中的`onPause`和`onResume`方法混淆。然而，`pause`和`resume`方法是从它们的近义词那里调用的。它们分别处理停止和启动`ourThread`。我们应该始终清理我们的线程。否则，它们可以在活动完成后继续运行：
- en: '[PRE426]'
  id: totrans-2404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: In step 4, we handle touches on the screen. This is how we initialize our `racketIsMovingLeft`
    and `racketIsMovingRight` Boolean variables, which the `updateCourt` method uses
    to decide whether to slide the player's racket left or right, or to keep it still.
    We have talked about the `onTouchEvent` method before, but let's see how we set
    the values in those variables.
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们处理屏幕上的触摸事件。这就是我们初始化`racketIsMovingLeft`和`racketIsMovingRight`布尔变量的方式，这些变量被`updateCourt`方法用来决定是否滑动玩家的球拍向左或向右，或者保持静止。我们之前已经讨论过`onTouchEvent`方法，但现在让我们看看我们是如何设置这些变量的值。
- en: 'First, we override the method and switch to get the type of event and the *x*,
    *y* coordinates of the event:'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重写该方法并切换以获取事件类型和事件的*x*、*y*坐标：
- en: '[PRE427]'
  id: totrans-2407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'If the event type is `ACTION_DOWN`, that is, the screen has been touched, we
    enter this case:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是`ACTION_DOWN`，即屏幕已被触摸，我们进入这个情况：
- en: '[PRE428]'
  id: totrans-2409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'Then we handle the coordinates. If the player has touched a position on the
    screen with an x coordinate greater than `screenWidth / 2`, then it means they
    have touched the right-hand side of the screen, so we set `isMovingRight` to `true`
    and `isMovingLeft` to `false`. The `updateCourt` method will handle changes in
    the necessary coordinates, and the `drawCourt` method will draw the racket in
    the appropriate place:'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们处理坐标。如果玩家触摸屏幕上的一个x坐标大于`screenWidth / 2`的位置，那么这意味着他们触摸了屏幕的右侧，因此我们将`isMovingRight`设置为`true`，将`isMovingLeft`设置为`false`。`updateCourt`方法将处理必要坐标的变化，而`drawCourt`方法将在适当的位置绘制球拍：
- en: '[PRE429]'
  id: totrans-2411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'The `else` statement sets our two Boolean variables in the opposite manner
    because a touch must have occurred on the left of the screen:'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句以相反的方式设置我们的两个布尔变量，因为触摸必须发生在屏幕的左侧：'
- en: '[PRE430]'
  id: totrans-2413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Now we handle the case for the `ACTION_UP` event. But why do we care about
    two events? With the buttons, we just cared about a click and that was all, but
    by handling the `ACTION_UP` event, we can enable the functionality that allows
    our player to hold the screen to slide left or right, just as we discussed in
    the section *The design of the game* of this chapter. Thus, the `ACTION_DOWN`
    case sets the racket moving one way or the other, and the `ACTION_UP` case simply
    stops the slide completely:'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理 `ACTION_UP` 事件的情况。但我们为什么要关心两个事件呢？对于按钮，我们只关心点击事件，就这么多，但通过处理 `ACTION_UP`
    事件，我们可以启用允许我们的播放器通过左右滑动屏幕的功能，正如我们在本章的 *游戏设计* 部分所讨论的那样。因此，`ACTION_DOWN` 事件设置球拍向一个方向或另一个方向移动，而
    `ACTION_UP` 事件则简单地完全停止滑动：
- en: '[PRE431]'
  id: totrans-2415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: Notice that we don't care about the *y* coordinate. Anywhere on the left we
    go left, anywhere on the right we go right.
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不关心 *y* 坐标。无论我们在左边还是右边移动，都会向左或向右移动。
- en: Note
  id: totrans-2417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice also that all of the code will work whether a device is held in the portrait
    or landscape form, and will function the same regardless of the resolution of
    the device. However (and it is quite an important "however"), the game will be
    slightly harder on low-resolution screens. The solution to this problem is quite
    complicated and will not be discussed until the final chapter, but it might well
    help us make some decisions about the future path to learn Android, gaming, and
    Java.
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论设备是竖屏还是横屏，所有的代码都会工作，并且无论设备的分辨率如何，功能都会相同。然而（这是一个相当重要的“然而”），在低分辨率屏幕上游戏会稍微难一些。解决这个问题相当复杂，并且将在最后一章讨论，但它可能有助于我们做出关于未来学习
    Android、游戏和 Java 的路径的决定。
- en: Phase 4 – Remaining lifecycle methods
  id: totrans-2419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四阶段 – 剩余的生命周期方法
- en: 'We are nearly there; just a few more steps and we will have a working retro
    squash game. I can almost smell the nostalgia! As these remaining methods are
    quite straightforward, we will explain them as we write them:'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；只需再走几步，我们就会有一个可以工作的复古壁球游戏。我几乎能闻到怀旧的味道！由于这些剩余的方法相当直接，我们将随着编写过程进行解释：
- en: 'As we previously learned, the `onStop` method is called by the Android system
    when the app is stopped. It is implemented for us already. The only reason we
    override it here is to ensure that our thread is stopped. We do so with the line
    highlighted. Enter the following code before the closing curly brace of the `MainActivity`
    class:'
  id: totrans-2421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前所学，当应用被停止时，Android 系统会调用 `onStop` 方法。这个方法已经为我们实现了。我们在这里重写它的唯一原因是为了确保我们的线程被停止。我们通过高亮的那一行代码来实现。在
    `MainActivity` 类的闭合花括号之前输入以下代码：
- en: '[PRE432]'
  id: totrans-2422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'The `onPause` method is called by the Android system when the app is paused.
    This too is implemented for us already, and the only reason we override it here
    is to ensure that our thread is stopped. We do so with the line highlighted. Enter
    this code after the preceding code:'
  id: totrans-2423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用被暂停时，Android 系统会调用 `onPause` 方法。这也已经为我们实现了，我们在这里重写它的唯一原因是为了确保我们的线程被停止。我们通过高亮的那一行代码来实现。在前面代码之后输入以下代码：
- en: '[PRE433]'
  id: totrans-2424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'The `onResume` method is called by the Android system when the app is resumed.
    Again, this method is implemented for us already. The only reason we override
    it here is to ensure that our thread is resumed, and we do so with the line highlighted.
    Enter the following code after the code in the previous step:'
  id: totrans-2425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用被恢复时，Android 系统会调用 `onResume` 方法。同样，这个方法也已经为我们实现了。我们在这里重写它的唯一原因是为了确保我们的线程被恢复，我们通过高亮的那一行代码来实现。在上一步骤的代码之后输入以下代码：
- en: '[PRE434]'
  id: totrans-2426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'Finally, we do something completely new. We handle what happens should the
    player press the back button on their device. As you might have guessed, there
    is a method we can override to achieve this— `onKeyDown`. We pause our thread,
    just as we did in the overridden lifecycle methods, and then call `finish()`,
    which ends the activity and our app. Enter this code after the code in the previous
    step:'
  id: totrans-2427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们做一些完全新的事情。我们处理玩家在设备上按下返回按钮时会发生的情况。正如你可能猜到的，有一个我们可以重写的方法来实现这一点——`onKeyDown`。我们暂停我们的线程，就像我们在重写的生命周期方法中所做的那样，然后调用
    `finish()`，这会结束活动以及我们的应用。在前面代码之后输入以下代码：
- en: '[PRE435]'
  id: totrans-2428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE435]'
- en: We covered the code in this phase as we went through it, and this was the shortest
    phase so far. So why didn't we encapsulate everything?
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在通过它时已经覆盖了这一阶段的代码，这是迄今为止最短的阶段。那么为什么我们没有封装一切呢？
- en: Good object-oriented design
  id: totrans-2430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的面向对象设计
- en: Perhaps simple games are not the best way to demonstrate good object-oriented
    design in action, but a simple code design with fewer private variables actually
    enhances the project. It certainly makes the teaching aspects of coding games
    simpler to explain.
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 也许简单的游戏并不是展示良好面向对象设计行动的最佳方式，但具有较少私有变量的简单代码设计实际上增强了项目。这确实使编码游戏的教授方面更容易解释。
- en: However, when a game becomes more complex and more people work on the code,
    principles of object-oriented programming become more necessary.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当游戏变得更加复杂，并且有更多的人在编写代码时，面向对象编程的原则变得更加必要。
- en: Self-test questions
  id: totrans-2433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1) Can you explain how to make ball speed relative between different screen
    resolutions?
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 你能解释如何使球的速度在不同屏幕分辨率之间相对吗？
- en: Summary
  id: totrans-2435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you enjoyed animating your first game. You achieved a lot to get to this
    point. You learned not only all the Java topics but also the way the different
    classes of Android can be used to make games relatively simple.
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您喜欢制作您的第一个游戏。您达到了这个阶段，学到了很多。您不仅学习了所有的Java主题，还学会了如何使用Android的不同类来制作相对简单的游戏。
- en: In the next chapter, we will move on to a new, more complex game. I hope you
    are ready.
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续到一个新的、更复杂的游戏。我希望你已经准备好了。
- en: Chapter 8. The Snake Game
  id: totrans-2438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 蛇游戏
- en: In this chapter, we will get straight down to designing and implementing a clone
    of the highly addictive *Snake* game. We will look at the design of the game and
    learn how to animate some bitmaps. Then we will look at a few aspects of the code
    that are new, such as our coordinate system. After that, we will whiz through
    the implementation of the game. Finally, we will look at how we could enhance
    our game.
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接开始设计和实现一个极具吸引力的 *Snake* 游戏的克隆版本。我们将研究游戏的设计，并学习如何动画一些位图。然后，我们将查看代码的一些新方面，例如我们的坐标系。之后，我们将快速浏览游戏实现的步骤。最后，我们将探讨如何增强我们的游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Examine the design of our game
  id: totrans-2441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们游戏的设计
- en: Look at the coordinate system of our *Snake* game
  id: totrans-2442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们 *Snake* 游戏的坐标系
- en: Examine the code structure so that when we come to implement the game, it will
    be more straightforward
  id: totrans-2443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码结构，以便当我们开始实现游戏时，它会更加直接
- en: Learn about animation with sprite sheets at the same time as implementing the
    home screen of our game
  id: totrans-2444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现游戏的主屏幕的同时学习使用精灵表进行动画
- en: Break the code for the *Snake* game into manageable chunks and run through its
    full implementation
  id: totrans-2445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *Snake* 游戏的代码分解成可管理的块，并运行其完整实现
- en: Enhance the game a little
  id: totrans-2446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稍微增强游戏
- en: Game design
  id: totrans-2447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计
- en: 'If you haven''t played the excellent *Snake* game before, here is an explanation
    of how it works. You control a very small snake. In our version, there is just
    a head, one body segment, and a tail. Here is a screenshot of our snake, made
    out of three segments:'
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有玩过优秀的 *Snake* 游戏，这里有一个关于它是如何工作的解释。您控制一条非常小的蛇。在我们的版本中，只有头部、一个身体节段和尾部。以下是我们的蛇的截图，由三个节段组成：
- en: '![Game design](img/8859OS_08_01.jpg)'
  id: totrans-2449
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_01.jpg)'
- en: 'The following screenshot shows the three segments individually:'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了三个节段单独的样子：
- en: '![Game design](img/8859OS_08_02.jpg)'
  id: totrans-2451
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_02.jpg)'
- en: 'Now, here is the thing; our snake is very hungry and also a very quick grower.
    Every time he eats an apple, he grows a body segment. This is a screenshot of
    the apple:'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是事情的关键；我们的蛇非常饿，而且生长得非常快。每次它吃一个苹果，它就会长出一个身体节段。以下是苹果的截图：
- en: '![Game design](img/8859OS_08_03.jpg)'
  id: totrans-2453
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_03.jpg)'
- en: Life is great! Our snake just eats and grows! The problem that the player of
    our game needs to solve is that the snake is a little hyperactive. It never stops
    moving! What exacerbates this problem is that if the snake touches the side of
    the screen, it dies.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 生活很美好！我们的蛇只是吃和长！我们游戏玩家需要解决的问题是这个蛇有点过于活跃。它从不停止移动！加剧这个问题的是，如果蛇碰到屏幕的边缘，它就会死亡。
- en: 'At first, this doesn''t seem like too much of a problem, but as he grows longer
    and longer, he can''t just keep going around in circles because he will bump inevitably
    into himself. This would again result in his demise:'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎不是一个太大的问题，但随着蛇变得越来越长，它不能只是不断地在圈子里转，因为它不可避免地会撞到自己。这又会导致它的死亡：
- en: '![Game design](img/8859OS_08_04.jpg)'
  id: totrans-2456
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_04.jpg)'
- en: 'For each apple eaten, we add an increasingly large amount to the score. Here
    is a sneak peek at what the game will look like after the basic implementation
    and before the enhancements:'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个吃到的苹果，我们将分数增加一个越来越大的数值。以下是基本实现和增强之前游戏的外观预览：
- en: '![Game design](img/8859OS_08_08.jpg)'
  id: totrans-2458
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_08.jpg)'
- en: The player controls the snake by tapping on the left or the right side of the
    screen. The snake will respond by turning left or right. The turn directions are
    relative to the direction the snake is traveling, which adds to the challenge
    because the player needs to think like a snake—kind of!
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过点击屏幕的左侧或右侧来控制蛇。蛇会相应地左转或右转。转向方向相对于蛇的移动方向，这增加了挑战性，因为玩家需要像蛇一样思考——有点像！
- en: At the end of the chapter, we will also take a brief look at enhancing the game,
    use that enhanced version in the next chapter to publish it to the Google Play
    Store, and add leaderboards and achievements.
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们还将简要地看看如何增强游戏，使用这个增强版本在下一章中发布到Google Play商店，并添加排行榜和成就。
- en: The coordinate system
  id: totrans-2461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系统
- en: In the previous chapter, we drew all our game objects directly to points on
    the screen, and we used real screen coordinates to detect collisions, bounces,
    and so on. This time, we will be doing things slightly differently. This is partly
    out of necessity, but as we will see, collision detection and keeping track of
    our game objects will also get simpler. This might be surprising when we think
    about the potential of our snake to be many blocks long.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们直接将所有游戏对象绘制到屏幕上的点，并使用真实屏幕坐标来检测碰撞、反弹等。这次，我们将稍微有所不同。这既是出于必要性，但正如我们将看到的，碰撞检测和跟踪我们的游戏对象也会变得简单。当我们想到蛇可能由许多块组成时，这可能会让人感到惊讶。
- en: Keeping track of the snake segments
  id: totrans-2463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪蛇段
- en: 'To keep track of all the snake segments, we will first define a block size
    to define a portion of a grid for the entire game area. Every game object will
    reside at an (x,y) coordinate, based not on the pixel resolution of the screen
    but on a position within our virtual grid. In the game, we define a grid that
    is 40 blocks wide, like this:'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪所有蛇段，我们首先定义一个块大小来定义整个游戏区域的网格部分。每个游戏对象都将驻留在(x,y)坐标，不是基于屏幕的像素分辨率，而是在我们的虚拟网格中的位置。在游戏中，我们定义了一个宽度为40块的网格，如下所示：
- en: '[PRE436]'
  id: totrans-2465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'So we know that:'
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们知道：
- en: '[PRE437]'
  id: totrans-2467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'The height of the game screen in blocks will then simply be calculated by dividing
    the height of the screen in pixels by the previously determined value of `blockSize`
    minus a bit of space at the top for the score:'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕的高度（以块为单位）将简单地通过将屏幕的高度（以像素为单位）除以之前确定的`blockSize`值，并减去顶部的一点点空间来计算分数：
- en: '[PRE438]'
  id: totrans-2469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'This then allows us to keep track of our snake using two arrays for *x* and
    *y* coordinates, where element zero is the head and the last used element is the
    tail, a bit like this:'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 这然后允许我们使用两个数组来跟踪我们的蛇，这两个数组用于*x*和*y*坐标，其中元素零是头部，最后一个使用的元素是尾部，有点像这样：
- en: '[PRE439]'
  id: totrans-2471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: 'As long as we have a system for moving the head, perhaps something similar
    to the squash ball but based on our new game grid, we can do the following to
    make the body follow the head:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有一个移动头部的系统，可能类似于弹跳球，但基于我们新的游戏网格，我们就可以做以下事情来使身体跟随头部：
- en: '[PRE440]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: The previous code simply starts at the back section of the snake and creates
    its location in the grid irrespective of what the section in front of it was.
    It proceeds up the body doing the same until everything has been moved to the
    location of the section that used to be just ahead of it.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是从蛇的尾部开始，并在网格中创建其位置，而不考虑其前面的部分。它沿着身体向上移动，直到所有东西都移动到原来在它前面的部分的位置。
- en: This also makes collision detection (even for a very long snake) nice and easy.
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得碰撞检测（即使是对于非常长的蛇）变得非常简单。
- en: Detecting collisions
  id: totrans-2476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'Using our grid based on `blockSize`, we can detect a collision, for example,
    with the right side of the screen, like this:'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于`blockSize`的网格，我们可以检测到屏幕右侧的碰撞，例如：
- en: '[PRE441]'
  id: totrans-2478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: The previous code simply checks whether the first element of our array, which
    holds the *x* coordinate of the snake, is equal to or greater than the width of
    our game grid in blocks. Try to work out the code for collision with the left,
    top, and bottom before we see it during the implementation.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是简单地检查我们数组中的第一个元素，即蛇的*x*坐标，是否等于或大于游戏网格的宽度。在我们看到实现中的效果之前，试着推导出与左侧、顶部和底部碰撞的代码。
- en: 'Detecting the event of the snake bumping into itself is quick too. We just
    need to check whether the first element of our array (the head) is in exactly
    the same position as any of the other sections, like this:'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 检测蛇撞到自己的事件也很简单。我们只需检查我们数组中的第一个元素（头部）是否与任何其他部分完全相同的位置，如下所示：
- en: '[PRE442]'
  id: totrans-2481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Drawing the snake
  id: totrans-2482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制蛇
- en: 'We simply draw every section of the snake relative to its grid location multiplied
    by the size in pixels of a block. The `blockSize` variable handles the entire
    challenge of making the game work on different screen sizes, like this:'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地绘制蛇的每一部分，相对于其网格位置乘以一个方块的大小。`blockSize`变量处理了整个让游戏在不同屏幕尺寸上运行的任务，如下所示：
- en: '[PRE443]'
  id: totrans-2484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: Admittedly, there are probably more questions about how our implementation will
    work, but they are probably best answered by actually building the game.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于我们的实现方式可能会有更多问题，但它们可能最好通过实际构建游戏来回答。
- en: Thus, we can easily follow along by either writing the code or just reading
    from the completed project. Let's take a look at the overall structure of our
    code.
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过编写代码或只是阅读完成的项目来轻松地跟随。让我们看看我们代码的整体结构。
- en: The code structure
  id: totrans-2487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: We will have two activities, one for the menu screen and one for the game screen.
    The menu screen activity will be called `MainActivity`, and the game screen activity
    will be called `GameActivity`. You can find all the completed code files as well
    as all the assets such as images, sprite sheets, and sound files in the `Chapter8/Snake`
    folder in the download bundle.
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个活动，一个用于菜单屏幕，一个用于游戏屏幕。菜单屏幕活动将被称为`MainActivity`，游戏屏幕活动将被称为`GameActivity`。你可以在下载包中的`Chapter8/Snake`文件夹中找到所有完成的代码文件以及所有资产，如图片、精灵表和声音文件。
- en: MainActivity
  id: totrans-2489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MainActivity
- en: 'In contrast to our other projects, the menu screen will not have a UI designed
    in the Android Studio UI designer. It will consist of an animated snake head,
    a title, and a high score. The player will proceed to `GameActivity` by tapping
    anywhere on the screen. As we need to accomplish animations and user interactions,
    even the home screen will have a thread, a view object, and methods normally associated
    with our game screens, like this:'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他项目相比，菜单屏幕将不会在Android Studio UI设计器中设计UI。它将包括一个动画蛇头、一个标题和最高分。玩家将通过在屏幕上的任何地方点击来进入`GameActivity`。由于我们需要完成动画和用户交互，主屏幕也将有一个线程、一个视图对象以及通常与我们的游戏屏幕相关的方法，如下所示：
- en: '[PRE444]'
  id: totrans-2491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: We will not go deeper into the menu screen for now because at the end of this
    section, we will implement it line by line.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨菜单屏幕，因为在本节结束时，我们将逐行实现它。
- en: GameActivity
  id: totrans-2493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameActivity
- en: 'The game screen structure has many similarities to our Squash game and to the
    structure of the menu screen, although the internals of this structure vary a
    lot (as we have discussed and as we will see). There are some differences towards
    the end of the structure, most notably, a `loadSound` method and a `configureDisplay`
    method. Here is the structure (we will see afterwards why the two extra methods
    are there):'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕的结构与我们的沙包游戏以及菜单屏幕的结构有很多相似之处，尽管这个结构的内部差异很大（正如我们讨论的，以及我们将看到的）。在结构的末尾有一些差异，最值得注意的是`loadSound`方法和`configureDisplay`方法。以下是结构（我们将在之后看到为什么有两个额外的方法）：
- en: '[PRE445]'
  id: totrans-2495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: Tidying up onCreate
  id: totrans-2496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理onCreate方法
- en: 'One of the first things you might notice when you examine the code from the
    `GameActivity` class we will soon implement is just how short the `onCreate` method
    is:'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查我们即将实现的`GameActivity`类的代码时，你可能会注意到的第一件事就是`onCreate`方法有多短：
- en: '[PRE446]'
  id: totrans-2498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: We have written two methods, `loadSound` and `configureDisplay`. They do most
    of the initialization and setup present in our squash game. This makes our code
    less cluttered. All that is left in `onCreate` is the initialization of our `SnakeView`
    object and a call to `setContentView`.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了两个方法，`loadSound`和`configureDisplay`。它们处理了我们沙包游戏中的大部分初始化和设置。这使得我们的代码更加简洁。`onCreate`中剩下的只是初始化我们的`SnakeView`对象和调用`setContentView`。
- en: We will look in detail at our `loadSound` and `configureDisplay` methods when
    we implement them.
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现它们时，我们将详细查看我们的`loadSound`和`configureDisplay`方法。
- en: As we have had advanced sight of the structure as well as previous experience
    of this type of implementation, we will just go through all of the implementation
    of our game activity in one phase.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经对结构有深入的了解以及有这方面的先前经验，我们将一次性完成我们游戏活动的所有实现。
- en: Let's quickly implement the menu screen.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速实现菜单屏幕。
- en: Animation, sprite sheets, and the Snake home screen
  id: totrans-2503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画、精灵表和蛇的主屏幕
- en: In the previous chapter, we used a bitmap to draw text, a circle, a line, and
    a single pixel on the blank bitmap we created in Java code. We then displayed
    the bitmap with all of its doodling using the `Canvas` class. Now we will look
    at a technique to draw two dimensional images, sometimes referred to as sprites.
    These are made from predrawn images. The images can be as simple as a plain pong
    ball or as complex as a glorious two-dimensional character with muscle definition,
    elaborate clothing, weapons, and hair.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用位图在Java代码创建的空白位图上绘制文本、圆形、线条和单个像素。然后我们使用`Canvas`类显示带有所有涂鸦的位图。现在我们将探讨一种绘制二维图像的技术，有时也称为精灵。这些是由预先绘制的图像组成的。这些图像可以是简单的乒乓球，也可以是具有肌肉定义、复杂服装、武器和头发的辉煌二维角色。
- en: So far, we have animated with unchanging objects, that is, we have moved a static
    unchanging image around the screen. In this section, we will see how to not only
    display a predrawn bitmap image on the screen but also continually alter it to
    create the illusion of on-the-spot animation.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是不变的物体进行动画，也就是说，我们在屏幕上移动了一个静态不变的图像。在本节中，我们将看到如何不仅将预先绘制的位图图像显示在屏幕上，而且不断改变它以创造即时动画的错觉。
- en: Of course, the ultimate combination would be to animate the bitmap both by changing
    its image and moving it around at the same time. We will see that briefly when
    we look at an enhanced version of this chapter's *Snake* game, but will not be
    analyzing the code.
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终的组合将是同时通过改变图像和移动它来动画化位图。当我们查看本章的*蛇*游戏的增强版本时，我们将简要地看到这一点，但不会分析代码。
- en: 'To do this on-the-spot bitmap animation, we need some bitmaps, as you might
    expect. For example, to draw a snake''s tail swishing back and forth, we would
    need at least two frames of animation, showing the tail in different positions.
    In the following screenshot, the flower''s head is towards the left:'
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行这种即时的位图动画，正如你所预期的那样，我们需要一些位图。例如，为了绘制蛇尾巴来回摆动的动画，我们至少需要两个动画帧，展示尾巴在不同位置。在下面的屏幕截图中，花朵的头部朝向左边：
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_05.jpg)'
  id: totrans-2508
  prefs: []
  type: TYPE_IMG
  zh: '![动画、精灵表和蛇的主屏幕](img/8859OS_08_05.jpg)'
- en: 'In this screenshot, the flower has been flipped:'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，花朵已经被翻转：
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_06.jpg)'
  id: totrans-2510
  prefs: []
  type: TYPE_IMG
  zh: '![动画、精灵表和蛇的主屏幕](img/8859OS_08_06.jpg)'
- en: If the two bitmaps were shown one after the other, repeatedly, they would create
    the basic effect of a flower blowing in the wind. Of course, two frames of animation
    aren't going to contest for any animation awards, and there is another problem
    with these images as well, as we will learn, so we should add in more frames to
    make the animation as life-like as is practical.
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连续显示这两个位图，它们会创造出花朵在风中摇曳的基本效果。当然，两个动画帧不可能赢得任何动画奖项，而且我们很快就会了解到这些图像还存在另一个问题，因此我们应该添加更多的帧，使动画尽可能逼真。
- en: We have just one more thing to discuss before we make an animated snake head
    for our game's home screen. How do we get Android to switch between these bitmaps?
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为游戏的主屏幕制作动画蛇头之前，我们还有一件事要讨论。我们如何让Android在这些位图之间切换？
- en: Animating with sprite sheets
  id: totrans-2513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用精灵表进行动画
- en: 'Firstly, we need to present the frames in a manner that is easy to manipulate
    in code. This is where sprite sheets come in. The following image shows some frames
    from a basic snake head animation that we will use on our game home screen. This
    time, they are presented in a strip of frames. All of them are parts of the same
    image, a bit like a series of images in a film. Also, notice in the following
    image that the frames are centered relative to each other and are exactly equal
    in size:'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以易于在代码中操作的方式呈现帧。这就是精灵表发挥作用的地方。以下图像显示了我们将用于游戏主屏幕的基本蛇头动画的一些帧。这一次，它们以帧条的形式呈现。它们都是同一图像的一部分，有点像电影中的一系列图像。此外，注意在以下图像中，帧相对于彼此居中，并且大小完全相等：
- en: '![Animating with sprite sheets](img/8859OS_08_07.jpg)'
  id: totrans-2515
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵表进行动画](img/8859OS_08_07.jpg)'
- en: If we were to actually show the two previous flower images consecutively, they
    would not only would they sway but also jump around from one side to another on
    their stems, which is probably not the effect we were looking for.
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们连续显示之前的花朵图像，它们不仅会摇摆，还会在它们的茎上从一边跳到另一边，这可能不是我们想要的效果。
- en: Thus, with regard to the snake sprite sheet, as long as we show one frame after
    another, we will create a basic animation.
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于蛇的精灵表，只要我们一帧接一帧地显示，我们就会创建一个基本的动画。
- en: So how do we make our code jump from one part of the sprite sheet to the next?
    Each frame is exactly the same size, 64 x 64 pixels in this case, so we just need
    a way to display pixels from 0 to 63, then 64 to 127, then 128 to 192, and so
    on. As each frame of the sprite sheet image is subtly different, it allows us
    to use one image file with multiple frames to create our animation. Fortunately,
    we have a class to handle this, which is nothing quite as luxurious as a specific
    sprite sheet class but almost.
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何让我们的代码从一个精灵表的一部分跳到另一部分？每个帧的大小都是一样的，在这个例子中是64 x 64像素，所以我们只需要一种方式来显示从0到63，然后64到127，然后128到192，以此类推的像素。由于精灵表图像的每一帧都有细微的差别，这使得我们可以使用一个包含多个帧的单个图像文件来创建我们的动画。幸运的是，我们有一个类来处理这个问题，它并不像特定的精灵表类那样奢华，但几乎一样。
- en: Tip
  id: totrans-2519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Regarding sprite sheet classes, such a thing does exist, although not in the
    regular Android classes. An API specifically designed for two-dimensional games
    will usually contain classes for sprite sheets. We will look at examples of this
    in the next chapter.
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: 关于精灵表类，这样的东西确实存在，尽管它不在常规的Android类中。专门为二维游戏设计的API通常会包含精灵表类。我们将在下一章中查看这些示例。
- en: 'The `Rect` class holds the coordinates of a rectangle. Here, we create a new
    object of the `Rect` type, and initialize it to start at 0, 0 and end at 63, 63:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`类保存一个矩形的坐标。在这里，我们创建一个新的`Rect`类型对象，并将其初始化为从0, 0开始，到63, 63结束：'
- en: '[PRE447]'
  id: totrans-2522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'The `Canvas` class can then actually use our `Rect` object to define a portion
    of a previously loaded bitmap:'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`类实际上可以使用我们的`Rect`对象来定义一个之前加载的位图的某个部分：'
- en: '[PRE448]'
  id: totrans-2524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: The preceding code is much simpler than it looks. First, we see `canvas.drawBitmap`.
    We are using the `drawBitmap` method of the `Canvas` class just as we have before.
    Then we pass `headAnimBitmap`, which is our sprite sheet containing all the frames
    we want to animate, as an argument. Rect `rectToBeDrawn` represents the coordinates
    of the currently relevant frame within `headAnimationBitmap`. `destRect` simply
    represents the screen coordinates at which we want to draw the current frame,
    and of course, `paint` is our object of the `Paint` class.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来比实际要简单得多。首先，我们看到`canvas.drawBitmap`。我们正在使用`Canvas`类的`drawBitmap`方法，就像我们之前做的那样。然后我们传递`headAnimBitmap`，这是我们包含所有想要动画化的帧的精灵表，作为参数。`rectToBeDrawn`代表`headAnimationBitmap`中当前相关帧的坐标。`destRect`简单地代表我们想要绘制当前帧的屏幕坐标，当然，“paint”是我们`Paint`类的对象。
- en: All we have to do now is change the coordinates of `rectToBeDrawn` and control
    the frame rate with a thread and we are done! Let's do that and create an animated
    home screen for our *Snake* game.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的就是改变`rectToBeDrawn`的坐标，并通过一个线程来控制帧率，这样我们就完成了！让我们这样做，并为我们的*蛇*游戏创建一个动画的主屏幕。
- en: Implementing the Snake home screen
  id: totrans-2527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现蛇的主屏幕
- en: 'With the background information we just covered and our detailed look at the
    structure of the code we are about to write, there shouldn''t be any surprises
    in this code. We will break things up into chunks just to make sure we follow
    exactly what is going on:'
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚介绍过的背景信息和我们对即将编写的代码结构的详细分析之后，这段代码中不应该有任何惊喜。我们将把代码分解成块，只是为了确保我们确切地了解正在发生的事情：
- en: Create a new project of API level 13\. Call it `Snake`.
  id: totrans-2529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个API级别为13的新项目。命名为`Snake`。
- en: Make the activity full screen as we have done before, and put your graphics
    into the `drawable/mdpi` folder. Of course, you can use my graphics as usual.
    They are supplied in the code download in the `graphics` folder of the `Snake`
    project.
  id: totrans-2530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让活动全屏，就像我们之前做的那样，并将你的图形放入`drawable/mdpi`文件夹。当然，你可以像往常一样使用我的图形。它们包含在`Snake`项目的`graphics`文件夹中的代码下载中。
- en: 'Here, you will find our `MainActivity` class declaration and member variables.
    Notice the variables for our `Canvas` and `Bitmap` class as well, we are declaring
    variables to hold frame size (width and height) as well as the number of frames.
    We also have a `Rect` object to hold the coordinates of the current frame of the
    sprite sheet. We will see these variables in action soon. Type the following code:'
  id: totrans-2531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以找到我们的`MainActivity`类声明和成员变量。注意我们的`Canvas`和`Bitmap`类的变量，我们正在声明变量来保存帧大小（宽度和高度）以及帧数。我们还有一个`Rect`对象来保存精灵表当前帧的坐标。我们很快就会看到这些变量在行动中的表现。输入以下代码：
- en: '[PRE449]'
  id: totrans-2532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'The following is the implementation of the overridden `onCreate` method. We
    get the screen dimensions in the usual way. We load our sprite sheet into the
    `headAnimBitmap` Bitmap. Finally, we create a new `SnakeAnimView` and set it as
    the content view. Type the following code after the code from the previous step:'
  id: totrans-2533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是重写的 `onCreate` 方法的实现。我们以通常的方式获取屏幕尺寸。我们将精灵图加载到 `headAnimBitmap` 位图中。最后，我们创建一个新的
    `SnakeAnimView` 并将其设置为内容视图。在上一步骤的代码之后，输入以下代码：
- en: '[PRE450]'
  id: totrans-2534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE450]'
- en: 'Here is the declaration of our `SurfaceView` class, called `SnakeAnimView`,
    along with its member variables. Notice that it extends `SurfaceView` and implements
    `Runnable`. All its methods follow in the next steps. Type this code after the
    code from the preceding step:'
  id: totrans-2535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是 `SnakeAnimView` 类的声明，它被称为 `SnakeAnimView`，以及它的成员变量。注意，它扩展了 `SurfaceView`
    并实现了 `Runnable` 接口。所有的方法将在接下来的步骤中介绍。在上一步骤的代码之后，输入此代码：
- en: '[PRE451]'
  id: totrans-2536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'Here is the constructor that gets the `frameWidth` value by dividing the bitmap
    width by the number of frames, and the `frameHeight` value using the `getHeight`
    method. Type this code after the code from the previous step:'
  id: totrans-2537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是构造函数，它通过将位图宽度除以帧数来获取 `frameWidth` 值，使用 `getHeight` 方法获取 `frameHeight` 值。在上一步骤的代码之后，输入此代码：
- en: '[PRE452]'
  id: totrans-2538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Now we implement the short but crucial `run` method. It calls each of the key
    methods of this class one after the other. These three methods are implemented
    in the following three steps after this step. Type the following code after the
    code from the preceding step:'
  id: totrans-2539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现这个简短但至关重要的 `run` 方法。它依次调用这个类中的每个关键方法。这三个方法在以下三个步骤中实现。在上一步骤的代码之后，输入以下代码：
- en: '[PRE453]'
  id: totrans-2540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Here is the `update` method. It tracks and chooses the frame number that needs
    to be displayed. Each time through the `update` method, we calculate the coordinates
    of the sprite sheet to be drawn using `frameWidth`, `frameHeight`, and `frameNumber`.
    If you are wondering why we subtract `1` from each horizontal coordinate, it is
    because like the screen coordinates, bitmaps start their coordinates at 0, 0:'
  id: totrans-2541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是 `update` 方法。它跟踪并选择需要显示的帧号。每次通过 `update` 方法时，我们使用 `frameWidth`、`frameHeight`
    和 `frameNumber` 计算要绘制的精灵图的坐标。如果你想知道为什么我们从每个水平坐标中减去 `1`，那是因为像屏幕坐标一样，位图从 0,0 开始它们的坐标：
- en: '[PRE454]'
  id: totrans-2542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'Next is the `draw` method, which does nothing new until the end, when it calculates
    the place on the screen to draw the bitmap by dividing the `screenHeight` and
    `screenWidth` variables by 2\. These coordinates are then saved in `destRect`.
    Both `destRect` and `rectToDraw` are then passed to the `drawBitmap` method, which
    draws the frame required at the location required. Type this code after the code
    from the previous step:'
  id: totrans-2543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `draw` 方法，直到最后它都没有做任何新的事情，当它通过将 `screenHeight` 和 `screenWidth` 变量除以 2 来计算屏幕上绘制位图的位置。然后这些坐标被保存在
    `destRect` 中。然后 `destRect` 和 `rectToDraw` 都传递给 `drawBitmap` 方法，该方法在所需位置绘制所需的帧。在上一步骤的代码之后，输入此代码：
- en: '[PRE455]'
  id: totrans-2544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE455]'
- en: 'Our trusty old `controlFPS` method ensures that our animation appears at a
    sensible rate. The only change in this code is that the initialization of `timeTosleep`
    is changed to create a 500-millisecond pause between each frame. Type the following
    code after the code from the preceding step:'
  id: totrans-2545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可靠的旧 `controlFPS` 方法确保我们的动画以合理的速率出现。此代码的唯一变化是将 `timeTosleep` 的初始化更改为在每帧之间创建
    500 毫秒的暂停。在上一步骤的代码之后，输入以下代码：
- en: '[PRE456]'
  id: totrans-2546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'Next are our `pause` and `resume` methods, which work with the Android lifecycle
    methods to start and stop our thread. Type this code after the code from the previous
    step:'
  id: totrans-2547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `pause` 和 `resume` 方法，它们与 Android 生命周期方法一起工作，以启动和停止我们的线程。在上一步骤的代码之后，输入此代码：
- en: '[PRE457]'
  id: totrans-2548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'For our `SnakeAnimView` class and our `onTouchEvent` method, which simply starts
    the game when the screen is touched anywhere, we enter the following code. Obviously,
    we don''t have a `GameActivity` yet:'
  id: totrans-2549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的 `SnakeAnimView` 类和 `onTouchEvent` 方法，该方法在屏幕任何地方被触摸时简单地启动游戏，我们输入以下代码。显然，我们还没有
    `GameActivity`：
- en: '[PRE458]'
  id: totrans-2550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'Finally, back in the `MainActivity` class, we handle some Android lifecycle
    methods. We also handle what happens when the player presses the back button:'
  id: totrans-2551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到 `MainActivity` 类，我们处理一些 Android 生命周期方法。我们还处理玩家按下返回按钮时发生的情况：
- en: '[PRE459]'
  id: totrans-2552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE459]'
- en: 'Now you must temporarily comment out this line from step 4 to test the animation.
    The reason for this is that it causes an error until we implement the `GameActivity`
    class:'
  id: totrans-2553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您必须暂时注释掉步骤 4 中的这一行来测试动画。原因是它会导致错误，直到我们实现 `GameActivity` 类：
- en: '[PRE460]'
  id: totrans-2554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE460]'
- en: Test the app.
  id: totrans-2555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用程序。
- en: Uncomment the line from step 14 when we have implemented the `GameActivity`
    class. Here is our completed home screen:![Implementing the Snake home screen](img/8859OS_08_10.jpg)
  id: totrans-2556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们实现了`GameActivity`类时，取消注释第14步中的行。这是我们的完成后的主屏幕：![实现蛇的主屏幕](img/8859OS_08_10.jpg)
- en: In this exercise, we set up a class that extended `SurfaceView`, just like we
    did for our squash game. We had a `run` method, which controlled the thread, as
    well as an `update` method, which calculated the coordinates of the current animation
    within our sprite sheet. The `draw` method simply drew to the screen using the
    coordinates calculated by the `update` method.
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个扩展`SurfaceView`的类，就像我们为我们的弹跳游戏所做的那样。我们有一个`run`方法，它控制线程，以及一个`update`方法，它计算当前动画在精灵图集中的坐标。`draw`方法简单地使用`update`方法计算出的坐标在屏幕上绘制。
- en: As in the squash game, we had an `onTouchUpdate` method, but the code this time
    was very simple. As a touch of any type in any location was all we needed to detect,
    we added just one line of code to the method.
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在弹跳游戏中一样，我们有一个`onTouchUpdate`方法，但这次的代码非常简单。因为我们只需要检测任何类型的触摸在任何位置，所以我们只在该方法中添加了一行代码。
- en: Implementing the Snake game activity
  id: totrans-2559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现蛇游戏活动
- en: Not all of this code is new. In fact, we have either used most of it before
    or discussed it earlier in the chapter. However, I wanted to present every line
    to you in order and in context with at least a brief explanation, even when we
    have seen it before. Having said that, I haven't included the long list of imports
    as we will either be prompted to add them automatically or we can just press *Alt*
    + *Enter* when needed.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些代码都是新的。事实上，我们之前已经使用过其中大部分，或者在本章的早期讨论过。然而，我想按顺序并带有至少简要解释地展示每一行代码，即使我们之前已经见过。话虽如此，我没有包括长长的导入列表，因为我们要么会被提示自动添加它们，或者我们可以在需要时按*Alt*
    + *Enter*。
- en: 'This way, we can remind ourselves how the whole thing comes together without
    any blanks in our understanding. As usual, I will summarize as we proceed through
    the implementation, and go into a few bits of extra depth at the end:'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们可以提醒自己整个事情是如何结合在一起的，而不会在我们的理解中留下任何空白。像往常一样，我会在实施过程中进行总结，并在最后深入探讨一些细节：
- en: Add an activity called `GameActivity`. Select a blank activity when asked.
  id: totrans-2562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GameActivity`的活动。当被询问时，选择一个空白活动。
- en: Make the activity full screen as we have done before.
  id: totrans-2563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将活动设置为全屏，就像我们之前做的那样。
- en: As usual, create some sound effects or use mine. Create an `assets` directory
    in the `main` directory in the usual way. Copy and paste the sound files (`sample1.ogg`,
    `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`) into it.
  id: totrans-2564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，创建一些音效或者使用我的。按照常规方式在`main`目录中创建一个`assets`目录。将音文件（`sample1.ogg`、`sample2.ogg`、`sample3.ogg`和`sample4.ogg`）复制粘贴到其中。
- en: Create individual non-sprite-sheet versions of graphics or use mine. Copy and
    paste them in the `res/drawable-mdpi` folder.
  id: totrans-2565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图形的单独非精灵图集版本或者使用我的。将它们复制粘贴到`res/drawable-mdpi`文件夹中。
- en: 'Here is the `GameActivity` class declaration with the member variables. There
    is nothing new here until we declare our arrays for our snake (`snakeX` and `snakeY`).
    Also, notice our variables used to control our game grid (`blockSize`, `numBlocksHigh`,
    and `numBlocksWide`). Now type this code:'
  id: totrans-2566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是带有成员变量的`GameActivity`类声明。在这里，直到我们声明用于控制游戏网格的数组（`snakeX`和`snakeY`）之前，没有什么新的内容。注意我们用于控制游戏网格的变量（`blockSize`、`numBlocksHigh`和`numBlocksWide`）。现在输入此代码：
- en: '[PRE461]'
  id: totrans-2567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'As explained previously, our new, small `onCreate` method has very little to
    do because much of the work is done in the `loadSound` and `configureDisplay`
    methods. Type this code after the code from the previous step:'
  id: totrans-2568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们新的、小的`onCreate`方法几乎没有什么要做，因为大部分工作都是在`loadSound`和`configureDisplay`方法中完成的。在上一步骤的代码之后输入此代码：
- en: '[PRE462]'
  id: totrans-2569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'Here is the class declaration, member variables, and constructor for our `SnakeView`
    class. We allocate 200 `int` variables to the `snakeX` and `snakeY` arrays, and
    call the `getSnake` and `getApple` methods, which will place an apple and our
    snake on the screen. This is just what we want when the class is constructed:'
  id: totrans-2570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`SnakeView`类的类声明、成员变量和构造函数。我们为`snakeX`和`snakeY`数组分配了200个`int`变量，并调用`getSnake`和`getApple`方法，这些方法将在屏幕上放置苹果和我们的蛇。当类被创建时，这正是我们想要的：
- en: '[PRE463]'
  id: totrans-2571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'Here is how we spawn a snake and an apple in our coordinate system. In the
    `getSnake` method, we place the snake''s head in the approximate center of the
    screen by initializing `snakeX[0]` and `snakeY[0]` to the number of blocks high
    and wide divided by 2\. We then place a body segment and the tail segment immediately
    behind. Notice that we don''t need to make any special arrangement for the different
    types of segments. As long as the drawing code *knows* that the first segment
    is a head, the last segment is a tail, and everything in between is a body, then
    that will do. In the `getApple` method, the integer variables `appleX` and `appleY`
    are initialized to random locations within our game grid. This method is called
    from the constructor, as we saw in the previous step. It will also be called to
    place a new apple every time our snake manages to eat an apple, as we will see.
    Type this code after the code from the previous step:'
  id: totrans-2572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的坐标系中，这是如何生成蛇和苹果的。在 `getSnake` 方法中，我们将蛇头放置在屏幕的大约中心，通过初始化 `snakeX[0]` 和 `snakeY[0]`
    为块的高度和宽度的二分之一。然后我们在蛇头后面立即放置一个身体段和尾部段。注意，我们不需要为不同类型的段做任何特殊安排。只要绘图代码 *知道* 第一个段是头部，最后一个段是尾部，中间的一切都是身体，那就足够了。在
    `getApple` 方法中，整数变量 `appleX` 和 `appleY` 被初始化为游戏网格内的随机位置。正如我们在上一步骤中看到的那样，这个方法从构造函数中调用。每次我们的蛇成功吃到一个苹果时，也会调用这个方法来放置一个新的苹果。在上一步骤的代码之后输入以下代码：
- en: '[PRE464]'
  id: totrans-2573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'Next comes the `run` method, which controls the flow of the game. Type the
    following code after the code from the previous step:'
  id: totrans-2574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `run` 方法，它控制着游戏流程。在上一步骤的代码之后输入以下代码：
- en: '[PRE465]'
  id: totrans-2575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE465]'
- en: 'Now we will look at `updateGame`, the most complex method of the entire app.
    Having said that, it is probably slightly less complex than the same method in
    our squash game. This is because of our coordinate system, which leads to simpler
    collision detection. Here is the code for `updateGame`. Study it carefully, and
    we will dissect it line by line at the end:'
  id: totrans-2576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将查看 `updateGame` 方法，这是整个应用中最复杂的方法。虽然这么说，它可能比我们的 squash 游戏中的相同方法稍微简单一些。这是因为我们的坐标系，这导致了更简单的碰撞检测。以下是
    `updateGame` 方法的代码。仔细研究它，我们将在最后逐行分析它：
- en: '[PRE466]'
  id: totrans-2577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE466]'
- en: 'We have worked out where our game objects are on the screen, so now we can
    draw them. This code is easy to understand as we have seen most of it before:'
  id: totrans-2578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经确定了游戏对象在屏幕上的位置，所以现在我们可以绘制它们。这段代码很容易理解，因为我们之前已经看到了大部分内容：
- en: '[PRE467]'
  id: totrans-2579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'Here is the `controlFPS` method, unchanged from our squash game''s `controlFPS`
    method, except that we have a different target frame rate. Type this code after
    the code from the preceding step:'
  id: totrans-2580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 `controlFPS` 方法，与我们的 squash 游戏中的 `controlFPS` 方法没有变化，只是我们有一个不同的目标帧率。在上一步骤的代码之后输入以下代码：
- en: '[PRE468]'
  id: totrans-2581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE468]'
- en: 'Here are our unchanged `pause` and `resume` methods. Type the following code
    after the code from the previous step:'
  id: totrans-2582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们的未更改的 `pause` 和 `resume` 方法。在上一步骤的代码之后输入以下代码：
- en: '[PRE469]'
  id: totrans-2583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE469]'
- en: 'Then we have the `onTouchEvent` method, similar to that of our squash game.
    There are no new concepts here, but the way it works in this game is as follows.
    We switch on the `ACTION_UP` event. This is broadly the same as detecting a click.
    We then check whether the press was on the left or the right. If it was on the
    right, we increment `directionOfTravel`. If it was on the left, we decrement `directionOfTravel`.
    If you looked carefully at the `updateGame` method, you would have seen that `directionOfTravel`
    indicates the direction in which to move the snake. Remember, the snake never
    stops. This is why we did it differently from our squash game. Type this code
    after the code from the previous step:'
  id: totrans-2584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是我们 `onTouchEvent` 方法，与我们的 squash 游戏中的方法类似。这里没有新的概念，但在这个游戏中它的工作方式如下。我们切换到
    `ACTION_UP` 事件。这基本上等同于检测点击。然后我们检查按下是在左侧还是右侧。如果是右侧，我们增加 `directionOfTravel`。如果是左侧，我们减少
    `directionOfTravel`。如果你仔细看了 `updateGame` 方法，你会看到 `directionOfTravel` 表示蛇移动的方向。记住，蛇永远不会停止。这就是为什么我们与
    squash 游戏的做法不同。在上一步骤的代码之后输入以下代码：
- en: '[PRE470]'
  id: totrans-2585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE470]'
- en: 'Back in the `GameActivity` class, we now handle the Android lifecycle methods
    and the "back" button functionality. Type this code after the code from the preceding
    step:'
  id: totrans-2586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameActivity` 类中，我们现在处理 Android 生命周期方法和“返回”按钮功能。在上一步骤的代码之后输入以下代码：
- en: '[PRE471]'
  id: totrans-2587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'Here is our `loadSound` method, which simply tidies up the `onCreate` method
    by moving all of the sound initialization to here. Type this code after the code
    from the previous step:'
  id: totrans-2588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们的 `loadSound` 方法，它通过将所有声音初始化移动到这里来简单地整理了 `onCreate` 方法。在上一步骤的代码之后输入以下代码：
- en: '[PRE472]'
  id: totrans-2589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Then we have the `configureDisplay` method, which is called from `onCreate`
    and does the entire setup of bitmaps and screen size calculations. We will look
    at this in more detail later. Type the following code after the code from the
    previous step:'
  id: totrans-2590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们有`configureDisplay`方法，它从`onCreate`调用，并完成位图和屏幕尺寸计算的整个设置。我们将在稍后更详细地查看这个方法。在上一步骤的代码之后输入以下代码：
- en: '[PRE473]'
  id: totrans-2591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE473]'
- en: Now run the app. The game is much more playable on an actual device than it
    is on the emulator.
  id: totrans-2592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。在实际设备上玩游戏比在模拟器上玩要有趣得多。
- en: We covered the code as we progressed, but as usual, here is a piece-by-piece
    dissection of a few of the more complicated methods, starting with the `updateGame`
    method.
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进展过程中覆盖了代码，但像往常一样，这里是对几个更复杂的方法进行逐个剖析，从`updateGame`方法开始。
- en: 'First, we check whether the player has eaten an apple. More specifically, is
    the snake''s head in the same grid location as the apple? The `if` statement checks
    whether this has occurred, and then does the following:'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查玩家是否吃到了苹果。更具体地说，蛇的头部是否与苹果处于相同的网格位置？`if`语句检查这种情况是否发生，然后执行以下操作：
- en: Increases the length of the snake
  id: totrans-2595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加蛇的长度
- en: Puts another apple on the screen by calling `getApple`
  id: totrans-2596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`getApple`在屏幕上放置另一个苹果
- en: Adds a value to the player's score, relative to the length of the snake, making
    each apple worth more than the previous one
  id: totrans-2597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据蛇的长度给玩家增加分数，使得每个苹果比前一个更有价值
- en: Plays a beep
  id: totrans-2598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放蜂鸣声
- en: 'Here is the code for the actions that we have just described:'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述我们刚刚描述的动作的代码：
- en: '[PRE474]'
  id: totrans-2600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: 'Now we simply move each segment of the snake, starting from the back, to the
    position of the segment in front of it. We do this with a `for` loop:'
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们简单地移动蛇的每一部分，从尾部开始，移动到它前面部分的位置。我们使用一个`for`循环来完成这个操作：
- en: '[PRE475]'
  id: totrans-2602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'Of course, we better move the head too! We move the head last because the leading
    section of the body would move to the wrong place if we move the head earlier.
    As long as the entire move is made before any drawing is done, all will be well.
    Our `run` method ensures that this is always the case. Here is the code to move
    the head in the direction determined by `directionOfTravel`. As we saw, `directionOfTravel`
    is manipulated by the player in the `onTouchEvent` method:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们最好也移动头部！我们最后移动头部，因为如果我们在更早的时候移动头部，身体的前端就会移动到错误的位置。只要整个移动在绘制之前完成，一切都会顺利。我们的`run`方法确保这一点始终如此。以下是移动头部到由`directionOfTravel`确定的方向的代码。正如我们所见，`directionOfTravel`在`onTouchEvent`方法中被玩家操作：
- en: '[PRE476]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: 'Next, we check for a collision with a wall. We saw this code when we looked
    at collision detection earlier. Here is the complete solution, starting with the
    left wall, then right, then top, and then bottom:'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查与墙壁的碰撞。我们在查看碰撞检测时看到了这段代码。以下是完整的解决方案，从左墙开始，然后是右墙，然后是上墙，最后是下墙：
- en: '[PRE477]'
  id: totrans-2606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: 'Then we check whether the snake has collided with itself. Initially, this seemed
    awkward, but as we previously saw, we just loop through our snake array to check
    whether any of the segments are in the same place as the head, in both *x* and
    *y* coordinates:'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查蛇是否撞到了自己。最初，这看起来有些尴尬，但正如我们之前看到的，我们只是遍历我们的蛇数组，检查是否有任何部分与头部在*x*和*y*坐标上处于相同的位置：
- en: '[PRE478]'
  id: totrans-2608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: 'If any part of our collision detection code sets `dead` to `true`, we simply
    play a sound, set the `score` to `0`, and get a new baby snake:'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的碰撞检测代码中的任何部分将`dead`设置为`true`，我们只需播放一个声音，将`score`设置为`0`，并得到一条新的小蛇：
- en: '[PRE479]'
  id: totrans-2610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Now we take a closer look at the `drawGame` method. First, we get ready to
    draw by clearing the screen:'
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更仔细地看看`drawGame`方法。首先，我们准备好绘制，清除屏幕：
- en: '[PRE480]'
  id: totrans-2612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: 'Now we draw the text for the player''s score, just above `topGap` that we define
    in `configureDisplay`:'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`configureDisplay`中定义的`topGap`上方绘制玩家的分数文本：
- en: '[PRE481]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: 'Now, using `drawLine`, we draw a visible border around our game grid:'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`drawLine`，我们在游戏网格周围绘制一个可见的边界：
- en: '[PRE482]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'Next, we draw the snake''s head:'
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制蛇的头部：
- en: '[PRE483]'
  id: totrans-2618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'The snake''s head will be followed by all the body segments. Look at the condition
    of the `for` loop. This starts at `1`, which means it is not redrawing the head
    position, and ends at `snakeLength - 1`, which means it is not drawing the tail
    segment. Here is the code used to draw the body section:'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇的头部将被所有身体部分跟随。看看`for`循环的条件。它从`1`开始，这意味着它不会重新绘制头部位置，并且结束于`snakeLength - 1`，这意味着它不会绘制尾部部分。以下是绘制身体部分的代码：
- en: '[PRE484]'
  id: totrans-2620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'Here, we draw the tail of the snake:'
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们绘制蛇的尾巴：
- en: '[PRE485]'
  id: totrans-2622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'Finally, we draw the apple as follows:'
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式绘制苹果：
- en: '[PRE486]'
  id: totrans-2624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Next, we will go through the `configureDisplay` method.
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过`configureDisplay`方法。
- en: 'First, we get the screen resolution and store the results in `screenWidth`
    and `screenHeight` as normal:'
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取屏幕分辨率并将结果存储在`screenWidth`和`screenHeight`中，就像平常一样：
- en: '[PRE487]'
  id: totrans-2627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Here, we define a gap called `topGap`. It will be a space at the top of the
    screen and will not be a part of the game area. This gap is used for the score.
    We saw `topGap` used fairly extensively in the `drawGame` method. After this,
    we calculate the width and height of the remaining area in blocks:'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`topGap`的间隙。它将是屏幕顶部的空间，并且不会是游戏区域的一部分。这个间隙用于显示分数。我们在`drawGame`方法中看到了`topGap`被广泛使用。之后，我们计算剩余区域的宽度和高度，以块为单位：
- en: '[PRE488]'
  id: totrans-2629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'In the following part of the code, we load all our image files into `Bitmap`
    objects:'
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的以下部分，我们将所有图像文件加载到`Bitmap`对象中：
- en: '[PRE489]'
  id: totrans-2631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: 'Finally, we scale each bitmap to be the same width and height as `blockSize`:'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将每个位图缩放到与`blockSize`相同的宽度和高度：
- en: '[PRE490]'
  id: totrans-2633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: Now we can take a quick look at a few different ways we can improve the game.
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以快速看看几种不同的方法来改进游戏。
- en: Enhancing the game
  id: totrans-2635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强游戏
- en: Here is a series of questions and answers to lead us to an improved version
    of our *Snake* game. It doesn't matter if you can't answer some (or even all)
    of the questions. Just take a look at the questions and answers, after which you
    can take a look at the new game and the code.
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一系列问题和答案，引导我们改进我们的*蛇*游戏。如果你不能回答一些（甚至全部）问题没关系。只需看看问题和答案，然后你可以看看新的游戏和代码。
- en: Self-test questions
  id: totrans-2637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1) What can be used to provide a visual improvement for our game screen? Can
    we use a nice light green, grassy background instead of just black?
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 我们可以用什么来为我们的游戏屏幕提供视觉上的改进？我们能使用一个漂亮的浅绿色，草地的背景而不是仅仅黑色吗？
- en: Q2) How about some nice flowers?
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 一些漂亮的花朵怎么样？
- en: Q3) If you're feeling brave, make the flowers sway. Think about what we have
    learned about sprite sheets. The theory is exactly the same as that of the animated
    snake head. We just need a few lines of code to control the frame rate separately
    from the game frame rate.
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 如果你感到勇敢，可以让花朵摇摆。想想我们学到的关于精灵图集的知识。理论完全和动画蛇头的理论一样。我们只需要几行代码来分别控制帧率，而不是游戏帧率。
- en: Q4) We could set up another counter and use our snake head animation in `GameActivity`,
    but it wouldn't be that useful because the subtle tongue movements would be barely
    visible at the smaller size. But could we swish the tail segment?
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 我们可以设置另一个计数器，并在`GameActivity`中使用我们的蛇头动画，但这不会很有用，因为微妙的舌头动作在较小的尺寸下几乎看不见。但我们能摆动尾巴段吗？
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: Q5) 这是一个稍微有点棘手的增强。你无法不注意到，当蛇精灵朝向四个可能方向中的三个时，它们看起来并不正确。你能修复这个问题吗？
- en: Summary
  id: totrans-2643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This is the end of yet another successful game project. You now know how to
    create and animate sprite sheets to add more realism to our games. Now we have
    an enhanced *Snake* game.
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们又一个成功的游戏项目的结束。你现在知道如何创建和动画精灵图集，以增加我们游戏的现实感。现在我们有一个增强版的*蛇*游戏。
- en: In the next chapter, we will see how simple it is to add leaderboards and achievements.
    This will make our game social and compelling by letting the player see the high
    scores and achievements of their friends and compare them with their own.
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到添加排行榜和成就有多么简单。这将使我们的游戏更具社交性和吸引力，让玩家可以看到他们朋友的高分和成就，并与自己的进行比较。
- en: Chapter 9. Making Your Game the Next Big Thing
  id: totrans-2646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。让你的游戏成为下一个大热门
- en: The day has finally come when we can publish our first game. This chapter, despite
    being shorter than others, is probably the longest chapter to complete. It would
    be a good idea to scan through the different exercises to see what is involved
    before actually diving into them. Most of these tutorials are not suitable to
    do during the advertisements of your favorite TV program or when you get in from
    work and you are really tired.
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 终于到了我们可以发布我们的第一个游戏的日子。尽管这一章比其他章节短，但它可能是完成时间最长的章节。在真正深入之前，浏览不同的练习看看涉及的内容是个好主意。大多数这些教程不适合在你最喜欢的电视节目广告期间或下班后非常累的时候做。
- en: Read the chapter and make a plan of when to perform each stage. The stages are
    arranged so you should be able to leave the project in between each of them. If
    you are really determined, have understood all the code until now, are confident
    with files and folders, and have no interruptions, you can probably get the work
    in this chapter completed in about a day.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章，并制定每个阶段执行的计划。阶段安排得如此，你应该能够在每个阶段之间暂停项目。如果你真的很坚定，直到现在已经理解了所有代码，对文件和文件夹有信心，并且没有中断，你可能在一天内就能完成本章的工作。
- en: As always, the completed code is in the relevant folder in the download bundle,
    in this case the `Chapter9` folder.
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，完成的代码位于下载包中相关文件夹内，在本例中是 `Chapter9` 文件夹。
- en: Note
  id: totrans-2650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that because I cannot share the login credentials for my developer account,
    had to mask some ID numbers within the code with a series of black lines. You
    will see these in the code in this chapter when talking about the `ids.xml` file
    which is NOT in the code bundle because of its confidential nature. However, as
    you will see in the *Setting up the Snake project ready for implementation* section,
    it is easy to get your own ID codes. Also note that a lot of the work in this
    chapter involves set up that takes place in your developer console. The leaderboards
    and achievements will not function until you have completed the necessary steps.
    However, you can review the entire code in the `Chapter9` folder and download
    the enhanced version of the game from [Chapter 8](ch08.html "Chapter 8. The Snake
    Game"), *The Snake Game*, complete with working leaderboards and achievements
    from [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next Big Thing"),
    *Making Your Game the Next Big Thing*, from [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame).
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我无法分享我的开发者账户的登录凭证，因此不得不在代码中使用一系列黑色线条来掩盖一些 ID 号码。你将在本章讨论 `ids.xml` 文件时在代码中看到这些，该文件由于其机密性质而不包含在代码包中。然而，正如你将在
    *设置蛇项目以供实施* 部分中看到的那样，获取你自己的 ID 代码很容易。此外，请注意，本章中的大量工作涉及在你的开发者控制台中进行的设置。排行榜和成就将不会工作，直到你完成了必要的步骤。然而，你可以审查
    `Chapter9` 文件夹中的整个代码，并从 [第 8 章](ch08.html "第 8 章。蛇游戏")，*蛇游戏*，下载包含工作排行榜和成就的增强版游戏，从
    [第 9 章](ch09.html "第 9 章。让你的游戏成为下一个大热门")，*让你的游戏成为下一个大热门*，来自 [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame)。
- en: If you want to implement everything yourself and also want to start with the
    enhanced version of the game, including all the improvements from the self-test
    questions from the previous chapter, then grab the `EnhancedSnakeGame` code from
    the `Chapter8` folder, and update your working project from `Chapter8`.
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自己实现所有内容，并且想要从游戏的增强版开始，包括来自上一章自我测试问题的所有改进，那么从 `Chapter8` 文件夹中获取 `EnhancedSnakeGame`
    代码，并更新你的工作项目 `Chapter8`。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How to publish your app
  id: totrans-2654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何发布你的应用
- en: Marketing your app, including making it social with leaderboards and public
    achievements
  id: totrans-2655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推广你的应用，包括使其具有排行榜和公开成就的社交功能
- en: Implementing leaderboards and achievements with the Google Play Game Services
    API
  id: totrans-2656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Play Game Services API 实现排行榜和成就
- en: Looking at what to do next depending on what you want to achieve
  id: totrans-2657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你想要实现的目标来考虑下一步要做什么
- en: How to publish your app
  id: totrans-2658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何发布你的应用
- en: 'Some of the steps in this guide involve writing descriptions and supplying
    screenshots, so you might like to read through the entire guide before implementing
    any of the steps:'
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南中的一些步骤涉及编写描述和提供截图，因此你可能希望在实施任何步骤之前先阅读整个指南：
- en: Create an icon. Exactly how to design an icon is beyond the scope of this book,
    but simply put, you need to create a nice image for each of the Android screen
    density categories. This is easier than it sounds. Using a simple image, such
    as the snake head bitmap, you can customize and download a set from [http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html](http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html).
    There are many sites that offer a similar free service. Of course, you can just
    use the images in the enhanced snake project, and skip this step and the next.
  id: totrans-2660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图标。确切地说，如何设计图标超出了本书的范围，但简单来说，您需要为Android屏幕密度类别中的每个类别创建一个漂亮的图像。这比听起来容易。使用一个简单的图像，例如蛇头位图，您可以从
    [http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html](http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html)
    定制并下载一套。有许多网站提供类似免费服务。当然，您也可以直接使用增强蛇项目中的图像，并跳过这一步和下一步。
- en: Once you have downloaded your `.zip` file from the preceding link, you can simply
    copy the `res` folder from within the download to the `main` folder within the
    project explorer. All icons at all densities will now be updated.
  id: totrans-2661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您从上一个链接下载了您的 `.zip` 文件，您只需将下载中的 `res` 文件夹复制到项目资源管理器中的 `main` 文件夹内。现在所有密度的图标都将更新。
- en: Before we proceed further, optionally you will need to prepare some screenshots
    of the game. You will be prompted to upload a screenshot for several screen types,
    but since the game is nearly identical on all screen types, one image should do
    fine. You will also need an image of dimension 512 x 512 for a high-resolution
    icon and an image of dimension 1024 x 500 for a feature graphic. They don't need
    to be great, but you do need them to proceed. Create your own or grab a copy of
    my very simple graphics in the `Chapter9` folder.
  id: totrans-2662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，您可能需要准备一些游戏的截图。您将被提示上传几种屏幕类型的截图，但由于游戏在所有屏幕类型上几乎相同，一张图片就足够了。您还需要一张512
    x 512像素的图标图像和一张1024 x 500像素的特色图形图像。它们不需要很棒，但您确实需要它们才能继续。您可以创建自己的图像，或者从 `Chapter9`
    文件夹中获取我非常简单的图形的副本。
- en: Now, unfortunately, you will need to spend $ 25 to open a Google Play account.
    You can sign up at [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  id: totrans-2663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，不幸的是，您可能需要花费 $ 25 来开通Google Play账户。您可以在 [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/)
    上注册。
- en: Once you have signed up, you can log in to your developer console at the same
    URL as mentioned in the previous step.
  id: totrans-2664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦注册，您就可以登录到之前步骤中提到的相同URL的您的开发者控制台。
- en: Once in your console, click on the **+ Add new application** button:![How to
    publish your app](img/8859OS_09_01.jpg)
  id: totrans-2665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入您的控制台，点击 **+ 添加新应用** 按钮：![如何发布您的应用](img/8859OS_09_01.jpg)
- en: In the **Add New Application** dialog, type a name for your application, such
    as `Snake Game`. Now click on **Upload APK**.
  id: totrans-2666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **添加新应用** 对话框中，为您的应用程序输入一个名称，例如 `Snake Game`。现在点击 **上传APK**。
- en: 'We now need to make our app into the release version. Open the `AndroidManifest.xml`
    file and add the highlighted line of code in the location shown:'
  id: totrans-2667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的应用转换为发布版本。打开 `AndroidManifest.xml` 文件，并在显示的位置添加高亮显示的代码行：
- en: '[PRE491]'
  id: totrans-2668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Rebuild your signed APK for the latest version of the *Snake* game, as discussed
    in [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*.
  id: totrans-2669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建您已签名的APK，以适用于最新版本的 *Snake* 游戏，如第2章中所述，*Android入门*。
- en: Now click on **Upload your first APK to production**.
  id: totrans-2670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 **上传您的第一个生产APK**。
- en: Now go to your Snake game APK.
  id: totrans-2671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到您的 Snake 游戏APK。
- en: Wait for the APK to finish uploading. You can now see your game summary screen.
    Notice the highlighted progress indicator to the top-left corner of the next image.
    We have a green tick, indicating that the APK has been uploaded successfully:![How
    to publish your app](img/8859OS_09_02.jpg)
  id: totrans-2672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待APK上传完成。您现在可以看到您的游戏摘要屏幕。注意下一张图片右上角的高亮进度指示器。我们有一个绿色的勾号，表示APK已成功上传：![如何发布您的应用](img/8859OS_09_02.jpg)
- en: The next thing we need to do is configure our Store Listing, so click on the
    **Store Listing** link, just below the APK link.
  id: totrans-2673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要做的是配置我们的商店列表，因此点击位于APK链接下方仅有的 **Store Listing** 链接。
- en: Write a short description and a long description. Also upload your screenshots,
    feature graphics, and high-resolution icon.
  id: totrans-2674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写简短和长描述。同时上传您的截图、特色图形和高分辨率图标。
- en: In the **Application Type** drop-down menu, select **Games**. In the **Category**
    drop-down menu, **Arcade** is probably most appropriate. For **Content Rating**,
    select **Everyone**, and for **Privacy Policy**, click on the checkbox for **Not
    submitting a privacy policy at this time**.
  id: totrans-2675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用类型**下拉菜单中，选择**游戏**。在**分类**下拉菜单中，**街机**可能最合适。对于**内容评级**，选择**所有人**，对于**隐私政策**，点击**不在此时刻提交隐私政策**的复选框。
- en: Add your website and email address to the relevant boxes.
  id: totrans-2676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的网站和电子邮件地址添加到相关框中。
- en: Back at the top of the web page, click on the **Save** button.
  id: totrans-2677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回网页顶部，点击**保存**按钮。
- en: Now we are at the final stage of this guide. Click on the **Pricing and distribution**
    link. It is just underneath the **Store Listing** link from step 13.
  id: totrans-2678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经到达本指南的最终阶段。点击**定价和分发**链接。它位于第13步的**商店列表**链接下方。
- en: Click on the **Free** button at the top of the page.
  id: totrans-2679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部点击**免费**按钮。
- en: Click on the checkbox of all the countries you want your game to be listed in.
  id: totrans-2680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击所有你希望你的游戏列出的国家的复选框。
- en: Scroll down to the bottom of the page and click on the checkboxes for **Content
    guidelines** and **US Export laws**.
  id: totrans-2681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面底部并点击**内容指南**和**美国出口法**的复选框。
- en: Click on **Save** at the top of the page.
  id: totrans-2682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部点击**保存**。
- en: Finally, from the **Ready to publish** drop-down menu at the top right corner
    of the page, click on **Publish this app** and you are done.![How to publish your
    app](img/88590S_09_03.jpg)
  id: totrans-2683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从页面右上角的**准备发布**下拉菜单中，点击**发布此应用**，操作完成。![如何发布你的应用](img/88590S_09_03.jpg)
- en: Congratulations! Your game will be live on Google Play somewhere between the
    next 5 minutes and 24 hours.
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的游戏将在5分钟到24小时之间在Google Play上上线。
- en: Marketing your app
  id: totrans-2685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推广你的应用
- en: The temptation at this stage is to sit back and wait for our game to hit the
    top position in the best-selling apps. This never happens.
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，诱惑是坐下来等待我们的游戏成为畅销应用的前列。这种情况永远不会发生。
- en: 'To ensure that our app achieves its full potential, we need to do the following
    continuously:'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的应用发挥其全部潜力，我们需要持续进行以下操作：
- en: '**Improve it**'
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: '**改进它**'
- en: We have already made quite a few improvements to the *Snake* game but there
    are many more, such as difficulty settings, music, debugging (did you see the
    occasionally wonky body segments?), settings menu, and so on. You can pay a professional
    to design backgrounds and sprites, or add more sound effects. When you have improved
    your Android and Java skills further, you can rewrite the entire game using a
    smoother engine and call it Version 2.
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对*蛇*游戏进行了相当多的改进，但还有很多，比如难度设置、音乐、调试（你看到过偶尔不规则的身体部分吗？）、设置菜单等等。你可以支付专业人士来设计背景和精灵，或者添加更多音效。当你进一步提高了你的Android和Java技能后，你可以使用更平滑的引擎重写整个游戏，并将其称为版本2。
- en: '**Promote it**'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: '**推广它**'
- en: 'This could be the subject of another book but there are so many ways we can
    spread the word about our app. We can create a page/profile on all the social
    media sites—Facebook, Twitter, Flickr, and so on. Add regular updates, announcements,
    challenges (see compulsion). We can create a website to promote our app and promote
    it in all the ways we would promote any other website. We can add a message in
    the app itself asking players to rate it, perhaps pop up a message just after
    they have got a high score or achievement. We can ask everyone we know and everyone
    who visits our social media/website to give a rating and leave a review. There
    are many more ways to promote an app as well. The secret to all of them is this:
    keep doing it. For example, don''t create a Facebook page and then expect it to
    grow in popularity on its own. Keep adding to all of your channels of promotion.'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要另一本书来详细阐述，但我们可以用许多方式来宣传我们的应用。我们可以在所有社交媒体网站上创建页面/个人资料——Facebook、Twitter、Flickr等等。添加定期更新、公告、挑战（参见强制行为）。我们可以创建一个网站来推广我们的应用，并以我们推广任何其他网站的方式推广它。我们可以在应用中添加一条信息，请求玩家对其进行评分，也许在他们获得高分或成就后弹出一条信息。我们可以请求我们认识的所有人和访问我们社交媒体/网站的人给出评分并留下评论。还有许多其他推广应用的方法。所有这些方法的秘诀是：持续进行。例如，不要创建一个Facebook页面，然后期望它自己变得流行。持续向所有推广渠道添加内容。
- en: '**Keep the players'' level of compulsion**'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: '**保持玩家的强制行为水平**'
- en: Besides improving the game in the ways we have briefly mentioned, we need to
    give players a compelling reason to keep coming back to our game. One way might
    be to add new levels. For example, it won't be hard to implement levels in our
    *Snake* game. Each level could have walls in different places and the layouts
    could get progressively more challenging. All we would need to do is make an array
    of obstacles, draw them on the screen, and detect collisions. Then set a target
    for the snake length for each level and move on to the next level when it is achieved.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以我们简要提到的方式改进游戏外，我们还需要给玩家一个有说服力的理由让他们继续回到我们的游戏中。一种方法可能是添加新关卡。例如，在我们的*蛇*游戏中实现关卡并不困难。每个关卡都可以有不同的墙壁位置，布局可以逐渐变得更加具有挑战性。我们只需要制作一个障碍物数组，在屏幕上绘制它们，并检测碰撞。然后为每个关卡设定蛇的长度目标，并在达到目标后进入下一关卡。
- en: We could offer different snake designs to be be unlocked for certain challenges.
    How about the player saving all the apples they collect as a form of currency,
    and then strategically spending that currency to get a chance to continue after
    they have died?
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供不同的蛇形设计，以解锁某些挑战。玩家将他们收集的所有苹果作为货币，然后有策略地花费这些货币，在死后有机会继续游戏，怎么样？
- en: How about offering time-limited challenges? For example, complete level 10 by
    the end of the month to receive a thousand bonus apples. Perhaps, we could come
    up with more things the apples could be spent on. Cool snake accessories or levels
    that can only be unlocked with apples. The point is that all of this compulsion
    can be added and updated at the same time as we upload our improvements. Nothing
    mentioned in this discussion about compulsion would be unachievable with the skills
    we have learned so far.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供限时挑战怎么样？例如，在本月底前完成第10级，以获得一千个额外苹果。也许，我们可以想出更多苹果可以消费的东西。酷炫的蛇形配件或只能用苹果解锁的关卡。重点是，所有这些强制性都可以在我们上传改进的同时添加和更新。在我们迄今为止学到的技能中，讨论中提到的任何强制性都是可以实现的。
- en: Probably, the most compelling aspect we can add to our game is online leaderboards
    and achievements so that players can compare themselves to their friends and the
    rest of the world. Google is aware of this and have done a lot of work to make
    it as easy as possible to add leaderboards and achievements to games. We will
    see how we can yet again take advantage of other people's hard work.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，我们可以添加到我们的游戏中最吸引人的方面是在线排行榜和成就，这样玩家就可以将自己与朋友和全世界的人进行比较。谷歌意识到了这一点，并做了大量工作来简化将排行榜和成就添加到游戏中的过程。我们将看看我们如何再次利用他人的辛勤工作。
- en: 'What''s more, all the achievements that players of your game earn are fed into
    their overall Google Play profile. Here is a screenshot of my rather poor Google
    Play achievements profile:'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你在游戏中获得的全部成就都会被输入到他们的整体Google Play个人资料中。以下是我在Google Play成就个人资料中相当糟糕的截图：
- en: '![Marketing your app](img/88590S_09_50.jpg)'
  id: totrans-2698
  prefs: []
  type: TYPE_IMG
  zh: '![推广你的应用](img/88590S_09_50.jpg)'
- en: You might have noticed a few *Snake* achievements in that lot. This feature
    makes your game potentially even more compelling.
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到其中有一些*蛇*成就。这个功能使你的游戏更具吸引力。
- en: Tip
  id: totrans-2700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Let's do a quick reality check—I am not actually suggesting that you spend significant
    amounts of time trying to make a real business out of our humble Snake game. It
    just serves as a useful example for discussion. Also, if we can come up with so
    many ideas for a game this old and simple, then we can surely come up with some
    really amazing stuff for a game we are passionate about. When you have an idea
    you are passionate about, then that would be the time to go for it and expand
    the brief marketing plan we have discussed.
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个快速的现实检查——我实际上并不是建议你花大量时间试图将我们这个简陋的蛇形游戏变成一个真正的商业项目。这只是一个有用的讨论例子。此外，如果我们能为这样一个古老而简单的游戏想出这么多点子，那么我们当然可以为那些我们热衷的游戏想出一些真正惊人的东西。当你有一个你热衷的想法时，那就是你采取行动并扩展我们讨论过的简要营销计划的时候了。
- en: Adding leaderboards and achievements
  id: totrans-2702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加排行榜和成就
- en: So we know why leaderboards and achievements are a good thing. The first thing
    we need to do here is plan our achievements. A leaderboard is a high score table,
    and that's it! There isn't a great deal of things we can do to make them different.
    The achievements, however, deserve some discussion.
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道排行榜和成就是好事。在这里我们需要做的第一件事是规划我们的成就。排行榜是一个高分表，仅此而已！我们无法做太多事情来使它们有所不同。然而，成就却值得讨论。
- en: Planning the Snake achievements
  id: totrans-2704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划蛇形游戏的成就
- en: 'At first, it might seem that a really simple implementation of a really simple
    game, like our *Snake* game, isn''t deep enough to have many, or even any, achievements.
    So what follows is a quick brainstorming session of achievement ideas:'
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能觉得像我们的*蛇*游戏这样非常简单的游戏实现并不够深入，以至于没有很多，甚至没有任何成就。所以以下是一个快速头脑风暴成就想法的会话：
- en: '**Score 10, 25, 50, 100, and so on**: Simply unlock achievements at different
    levels of high score.'
  id: totrans-2706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**得分10、25、50、100等**：只需在不同的高分级别解锁成就。'
- en: '**Snake length**: Simply unlock achievements at different snake lengths.'
  id: totrans-2707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蛇的长度**：只需在不同的蛇长度解锁成就。'
- en: '**Cannibal**: Unlock an achievement the first time the player collides with
    their own tail segment.'
  id: totrans-2708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食人**：当玩家第一次与自己的尾巴部分相撞时解锁一个成就。'
- en: '**Collect x apples in total**: Keep a tally of all the apples ever collected,
    and unlock achievements at significant milestones.'
  id: totrans-2709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集x个苹果总数**：记录所有收集到的苹果数量，并在重要的里程碑处解锁成就。'
- en: '**Play 10, 25, 50, 100 games**: Reward the player for keeping on going. Whether
    they win or lose, achievements are unlocked for effort.'
  id: totrans-2710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩10、25、50、100场比赛**：奖励玩家持续进行。无论他们赢或输，都会因努力解锁成就。'
- en: '**Treasure hunt**: What if there was a hidden spot in every game? It could
    give the player a reason to explore each level. They could be rewarded with points
    and apples. They could then unlock real achievements, perhaps for every 5, 10,
    or 20 hidden spots that they find.'
  id: totrans-2711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻宝**：如果每场比赛都有一个隐藏的地点会怎样？这可以给玩家一个探索每个级别的理由。他们可以因得分和苹果而获得奖励。然后他们可以解锁真正的成就，也许是为找到的每个5、10或20个隐藏地点解锁。'
- en: Some of the achievements suggest that we would be required to keep a record
    of the player's progress. Surprisingly, Google Play Game Services can actually
    do this for us. These are known as incremental achievements. The number of apples
    collected in total is a good example of an incremental achievement. Others, such
    as snake length, are just dependent on the player's performance in any one game.
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 一些成就表明我们需要记录玩家的进度。令人惊讶的是，Google Play Game Services实际上可以为我们做这件事。这些被称为增量成就。收集到的苹果总数是一个很好的增量成就例子。其他，如蛇的长度，仅取决于玩家在任意一场游戏中的表现。
- en: We will implement the total number of apples and the snake length achievements
    so that we can see how to implement both types.
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现苹果总数和蛇长度成就，这样我们就可以看到如何实现这两种类型。
- en: 'We can have five achievements for reaching each of the following snake lengths:
    5, 10, 20, 35, and 50\. There can also be five incremental achievements for the
    total number of apples collected. Specifically, the player will get an achievement
    at 10, 25, 50, 100, 150, and 250 apples collected. Soon, we will see how to do
    it.'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为达到以下蛇长度设置五个成就：5、10、20、35和50。还可以为收集到的苹果总数设置五个增量成就。具体来说，玩家将在收集到10、25、50、100、150和250个苹果时获得一个成就。很快我们就会看到如何做到这一点。
- en: 'Finally, we need to decide how many points each achievement will be worth,
    out of the 1,000-point limit per game. As I might come back and add some more
    achievements later I am going to allocate 250 points to the apples'' achievements,
    like this:'
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要决定每个成就将值多少分，每个游戏的1000分上限。由于我可能回来添加一些更多的成就，所以我将把250分分配给苹果成就，如下所示：
- en: '| Number of eaten apples | Achievement points |'
  id: totrans-2716
  prefs: []
  type: TYPE_TB
  zh: '| 吃掉的苹果数量 | 成就点数 |'
- en: '| --- | --- |'
  id: totrans-2717
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 10 | 10 |'
  id: totrans-2718
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 10 |'
- en: '| 20 | 30 |'
  id: totrans-2719
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 30 |'
- en: '| 50 | 40 |'
  id: totrans-2720
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 40 |'
- en: '| 100 | 70 |'
  id: totrans-2721
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 70 |'
- en: '| 250 | 100 |'
  id: totrans-2722
  prefs: []
  type: TYPE_TB
  zh: '| 250 | 100 |'
- en: 'I will also allocate 250 points to the snake length achievements, as shown
    in the following table:'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将把250分分配给蛇长度成就，如下表所示：
- en: '| Length of snake | Achievement points |'
  id: totrans-2724
  prefs: []
  type: TYPE_TB
  zh: '| 蛇的长度 | 成就点数 |'
- en: '| --- | --- |'
  id: totrans-2725
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 5 | 10 |'
  id: totrans-2726
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 10 |'
- en: '| 10 | 30 |'
  id: totrans-2727
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 30 |'
- en: '| 25 | 40 |'
  id: totrans-2728
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 40 |'
- en: '| 35 | 70 |'
  id: totrans-2729
  prefs: []
  type: TYPE_TB
  zh: '| 35 | 70 |'
- en: '| 50 | 100 |'
  id: totrans-2730
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 100 |'
- en: Once you see how to implement these achievements in both the code and the developer
    console, it will be fairly simple to design and implement your own different achievements.
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到如何在代码和开发者控制台中实现这些成就，设计和实现你自己的不同成就将会相对简单。
- en: Step-by-step leaderboards and achievements
  id: totrans-2732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤式排行榜和成就
- en: This is probably the longest part of the book to complete. However, once you
    have been through this process, it will be significantly easier the next time
    you do it.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是这本书中最长的部分来完成。然而，一旦你通过了这个过程，下次就会容易得多。
- en: Installing the Google Play Services API on your PC
  id: totrans-2734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的PC上安装Google Play Services API
- en: 'First, we need to add the tools and the libraries needed to use the Game Services
    classes. This is nice and easy with Android Studio:'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加使用游戏服务类所需的工具和库。在 Android Studio 中，这既方便又简单：
- en: Click on the SDK Manager icon in the Android Studio toolbar:![Installing the
    Google Play Services API on your PC](img/88590S_09_05.jpg)
  id: totrans-2736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Android Studio 工具栏中的 SDK 管理器图标：![在您的 PC 上安装 Google Play 服务 API](img/88590S_09_05.jpg)
- en: The SDK manager will start. It looks a bit like this:![Installing the Google
    Play Services API on your PC](img/88590S_09_06.jpg)
  id: totrans-2737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK 管理器将启动。它看起来有点像这样：![在您的 PC 上安装 Google Play 服务 API](img/88590S_09_06.jpg)
- en: Scroll to the very bottom and underneath **Extras**, you will see **Google Play
    Services**. Check the box that is shown as highlighted in the following screenshot
    by clicking on it:![Installing the Google Play Services API on your PC](img/88590S_09_07.jpg)
  id: totrans-2738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面底部，在 **附加组件** 下方，您将看到 **Google Play 服务**。通过点击以下截图所示的高亮复选框来勾选它：![在您的 PC
    上安装 Google Play 服务 API](img/88590S_09_07.jpg)
- en: Now click on the checkbox for **Google Repository**, just below **Google Play
    Services**.
  id: totrans-2739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击位于 **Google Play 服务** 下方的新 **Google 仓库** 复选框。
- en: Click on **Install packages** and wait for the packages to download and install.
  id: totrans-2740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装包** 并等待包下载和安装。
- en: Save your project and restart Android Studio.
  id: totrans-2741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目并重新启动 Android Studio。
- en: We now have the tools installed to start developing Google Play Game Services
    apps. Next, we need to set up our developer console to communicate with our app,
    ready for the features we will soon write code for.
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已安装了开发 Google Play 游戏服务应用的工具。接下来，我们需要设置我们的开发者控制台以与我们的应用通信，为我们将要编写的功能做好准备。
- en: Configuring the Google Play developer console
  id: totrans-2743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Google Play 开发者控制台
- en: 'Here, we will prepare your developer console by creating a new Game Services
    application. This might sound a little counterintuitive; surely, Snake is our
    application, isn''t it? Yes, but Google Play is structured in such a way that
    you create a Game Services application, and it is with this application that your
    actual games (Snake in this case) will communicate. It is the Game Services application
    that will have the achievements and leaderboards that we will award and display
    from our Snake Game:'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过创建一个新的游戏服务应用来准备您的开发者控制台。这听起来可能有点反直觉；Snake 不是我们的应用吗？是的，但 Google Play
    的结构是这样的，您需要创建一个游戏服务应用，并且您的实际游戏（在这个例子中是 Snake）将通过这个应用进行通信。是游戏服务应用将拥有我们将从我们的 Snake
    游戏中奖励和显示的成就和排行榜：
- en: Log in to your Google Play developer console at [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  id: totrans-2745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的 Google Play 开发者控制台，请访问 [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
- en: Click on the **Game services** tab on the left of the web page.![Configuring
    the Google Play developer console](img/88590S_09_15.jpg)
  id: totrans-2746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页左侧点击 **游戏服务** 选项卡。![配置 Google Play 开发者控制台](img/88590S_09_15.jpg)
- en: Now click on the **Add a new game** button.
  id: totrans-2747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击屏幕顶部的 **添加新游戏** 按钮。
- en: Enter `Snake` as the name of your game and choose **Arcade** from the **Category**
    drop-down menu. Now click on **Continue**. All of this is shown in the next screenshot:![Configuring
    the Google Play developer console](img/88590S_09_16.jpg)
  id: totrans-2748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的游戏命名为 `Snake` 并从 **类别** 下拉菜单中选择 **街机**。现在点击 **继续**。所有这些都在下一张截图中显示：![配置 Google
    Play 开发者控制台](img/88590S_09_16.jpg)
- en: Now we can configure our game. Type a game description in the **Description**
    field, and add the same high-resolution icon and feature graphic that we added
    when we uploaded the game.
  id: totrans-2749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以配置我们的游戏。在 **描述** 字段中输入游戏描述，并添加与上传游戏时相同的相同高分辨率图标和功能图形。
- en: Click on the **Save** button at the top of the screen.
  id: totrans-2750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕顶部的 **保存** 按钮。
- en: Now we will link our Snake Game Services app with our actual *Snake* game. On
    the left of the web page, click on the **Linked apps** tab.![Configuring the Google
    Play developer console](img/88590S_09_17.jpg)
  id: totrans-2751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把我们的 Snake 游戏服务应用与实际的 *Snake* 游戏链接起来。在网页左侧，点击 **已链接应用** 选项卡。![配置 Google
    Play 开发者控制台](img/88590S_09_17.jpg)
- en: Google Play Game Services can be used with almost any platform, even Apple.
    We are using it for Android here, so click on the **Android** button.![Configuring
    the Google Play developer console](img/88590S_09_18.jpg)
  id: totrans-2752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Play 游戏服务可以与几乎任何平台一起使用，甚至包括苹果。我们在这里使用它来开发 Android 应用，因此点击 **Android**
    按钮。![配置 Google Play 开发者控制台](img/88590S_09_18.jpg)
- en: All we need to do on this screen is click on the **Package Name** search box
    and click on our **Snake game** option.![Configuring the Google Play developer
    console](img/88590S_09_19.jpg)
  id: totrans-2753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们只需要点击**包名**搜索框，然后点击我们的**Snake游戏**选项。[配置Google Play开发者控制台](img/88590S_09_19.jpg)
- en: Click on **Save and continue** at the top of the screen.
  id: totrans-2754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部点击**保存并继续**。
- en: We're nearing the end of this phase. Click on **Authorize your app now** and
    review the information.![Configuring the Google Play developer console](img/88590S_09_20.jpg)
  id: totrans-2755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正接近这个阶段的尾声。点击**立即授权您的应用**并查看信息。[配置Google Play开发者控制台](img/88590S_09_20.jpg)
- en: Finally, click on **Continue**.![Configuring the Google Play developer console](img/88590S_09_21.jpg)
  id: totrans-2756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**继续**。[配置Google Play开发者控制台](img/88590S_09_21.jpg)
- en: We now have a Google Game Services app set up, and linked to our *Snake* game.
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已设置好一个Google游戏服务应用，并将其链接到我们的**Snake**游戏。
- en: Implementing the leaderboard in the Google Play developer console
  id: totrans-2758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Google Play开发者控制台中实现排行榜
- en: 'Now we need to create our leaderboard in our developer console so that we can
    later interact with it in our Java code:'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的开发者控制台中创建我们的排行榜，以便我们可以在Java代码中稍后与之交互：
- en: Log in to your developer console.
  id: totrans-2760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的开发者控制台。
- en: Click on **Game Services**, then on **Snake**, and then on **Leaderboards**.
  id: totrans-2761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**游戏服务**，然后点击**Snake**，接着点击**排行榜**。
- en: Now click on **Add Leaderboard**. This is the **NEW LEADERBOARD** screen:![Implementing
    the leaderboard in the Google Play developer console](img/88590S_09_25.jpg)
  id: totrans-2762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**添加排行榜**。这是**新排行榜**屏幕：[在Google Play开发者控制台中实现排行榜](img/88590S_09_25.jpg)
- en: This might look like a bit of a marathon ahead, but all we need to do is enter
    a name (`Snake` will do) in the **Name** field, and we are done. It might seem
    strange entering a name for our leaderboard, but this is because it is possible
    to have multiple leaderboards for one game.
  id: totrans-2763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能看起来像是一场马拉松，但我们只需要在**名称**字段中输入一个名称（`Snake`即可），我们就完成了。为我们的排行榜输入名称可能看起来有些奇怪，但这是因为一个游戏可以有多个排行榜。
- en: Read through all the options. You will see that they are just right for us and
    no further action is required. Click on **Save**.
  id: totrans-2764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细阅读所有选项。您会发现它们非常适合我们，无需进一步操作。点击**保存**。
- en: Our leaderboard is now ready to communicate with our *Snake* app.
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的成绩排行榜现在可以与我们的**Snake**应用进行通信。
- en: Implementing the achievements in the Google Play developer console
  id: totrans-2766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Google Play开发者控制台中实现成就
- en: Here, we will set up in our developer console the achievements that we discussed
    previously.
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在我们的开发者控制台中设置之前讨论过的成就。
- en: 'You might like to prepare some graphics to represent each of these achievements.
    They need to be 512 x 512 pixels each. Alternatively, you can use an enlarged
    apple bitmap and perhaps a snake body segment for the apples and snake length
    achievements, respectively:'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想准备一些图形来代表这些成就。每个图形都需要是512 x 512像素。或者，您可以使用放大的苹果位图，也许可以用蛇的身体段来表示苹果和蛇长度成就：
- en: Log in to your developer console. Click on **Game Services**, then on **Snake**,
    and then on **Achievements**.
  id: totrans-2769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的开发者控制台。点击**游戏服务**，然后点击**Snake**，接着点击**成就**。
- en: Click on **Add Achievement** and you will see the **New Achievement** screen:![Implementing
    the achievements in the Google Play developer console](img/88590S_09_30.jpg)
  id: totrans-2770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加成就**，您将看到**新成就**屏幕：[在Google Play开发者控制台中实现成就](img/88590S_09_30.jpg)
- en: As we are implementing the incremental apple achievements, the first thing to
    do is to enter something in the **New Achievement** form. In the **Name** field,
    enter `Apple Muncher 1`.
  id: totrans-2771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在实现增量苹果成就，首先需要在**新成就**表单中输入一些内容。在**名称**字段中输入`Apple Muncher 1`。
- en: In the **Description** field, enter `Munch 10 apples`.
  id: totrans-2772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**描述**字段中输入`吃掉10个苹果`。
- en: Click on the **Add Icon** button and select your preferred 512 x 512 graphic.
  id: totrans-2773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加图标**按钮，并选择您偏好的512 x 512像素的图形。
- en: Click on the **Incremental achievements** checkbox and enter `5` in the **How
    many steps are needed** field. This is because the first achievement is for eating
    5 apples. This step is shown in the next screenshot:![Implementing the achievements
    in the Google Play developer console](img/88590S_09_31.jpg)
  id: totrans-2774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**增量成就**复选框，并在**需要多少步**字段中输入`5`。这是因为第一个成就是吃掉5个苹果。这一步骤在下一张截图中有展示：[在Google Play开发者控制台中实现成就](img/88590S_09_31.jpg)
- en: Enter `10` for the number of achievement points in the **Points** field.
  id: totrans-2775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**积分**字段中输入`10`作为成就积分的数量。
- en: Click on **Save** and repeat steps 2 to 7 four more times for all the apple
    achievements, varying the **Name**, **Description**, **How many steps are needed?**,
    and **Points** fields as per our plans and tables of values for achievements.
  id: totrans-2776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**，然后按照步骤2到7重复四次，为所有苹果成就进行操作，根据我们的计划和成就值表调整**名称**、**描述**、**需要多少步？**和**积分**字段。
- en: Now we can move on to our snake length achievements. Click on **New Achievement**.
    In the **Name** field, enter `Super Snake 1`.
  id: totrans-2777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续处理我们的蛇长度成就。点击**新建成就**。在**名称**字段中输入`超级蛇1`。
- en: In the **Description** field, enter `Grow your snake to 5 segments`.
  id: totrans-2778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**描述**字段中输入`增长你的蛇到5段`。
- en: Click on the **Add Icon** button and browse to your preferred image.
  id: totrans-2779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加图标**按钮，浏览到您喜欢的图片。
- en: Finally, enter `10` for the number of achievement points in the **Points** field.
  id: totrans-2780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**积分**字段中输入`10`作为成就积分的数量。
- en: Click on **Save** and repeat steps 9 to 13 four more times for each of the snake
    length achievements, varying the **Name**, **Description**, and **Points** fields
    as per our plans and tables of values for achievements.
  id: totrans-2781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**，然后按照步骤9到13重复四次，为每个蛇长度成就进行操作，根据我们的计划和成就值表调整**名称**、**描述**和**积分**字段。
- en: We have now set up our achievements, ready to be implemented in code.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的成就，准备在代码中实施。
- en: Setting up the Snake project ready for implementation
  id: totrans-2783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置好蛇项目，准备实施。
- en: 'What we will do in this section is prepare our app to communicate with the
    Google Play servers:'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将准备我们的应用程序与Google Play服务器通信：
- en: 'Add this highlighted code to the `AndroidManifest.xml` file, just before the
    closing `</application>` tag:'
  id: totrans-2785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到`AndroidManifest.xml`文件中，就在关闭`</application>`标签之前：
- en: '[PRE492]'
  id: totrans-2786
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Create the `ids.xml` file in the `values` folder in the Project Explorer. Now
    you need to get your unique code for your game to go to this file. Log in to your
    developer console, click on **Game Services**, and then click on **Snake**. Now
    click on **Achievements**.
  id: totrans-2787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中的`values`文件夹中创建`ids.xml`文件。现在您需要获取您游戏的唯一代码并将其放入此文件。登录到您的开发者控制台，点击**游戏服务**，然后点击**蛇**。现在点击**成就**。
- en: Just below your list of achievements is a small **Get resources** link:![Setting
    up the Snake project ready for implementation](img/88590S_09_32.jpg)
  id: totrans-2788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成就列表下方有一个小的**获取资源**链接：[设置蛇项目准备实施](img/88590S_09_32.jpg)
- en: Click on the **Get resources** link.![Setting up the Snake project ready for
    implementation](img/88590S_09_33.jpg)
  id: totrans-2789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**获取资源**链接。[设置蛇项目准备实施](img/88590S_09_33.jpg)
- en: Copy and paste the code into the `ids.xml` file. Then click on the **Finished**
    button in the developer console.
  id: totrans-2790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码复制并粘贴到`ids.xml`文件中。然后点击开发者控制台中的**完成**按钮。
- en: Now we need to get four code files from the Google Play Game Services GitHub
    repository. We will copy and paste the files directly into our project.
  id: totrans-2791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要从Google Play游戏服务GitHub仓库获取四个代码文件。我们将直接将这些文件复制粘贴到我们的项目中。
- en: Create three new empty files in the `java` folder. Right-click on **GameActivity**
    in the project explorer and navigate to **New** | **Java class file**. Name the
    new file `BaseGameActivity`. Repeat this step and name the file `GameHelper`.
    Repeat this once more and name the file `GameHelperUtils`.
  id: totrans-2792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`java`文件夹中创建三个新的空文件。在项目资源管理器中右键点击**GameActivity**，然后导航到**新建** | **Java类文件**。将新文件命名为`BaseGameActivity`。重复此步骤并命名为`GameHelper`。再重复一次并命名为`GameHelperUtils`。
- en: Now we will get the Java code to copy into the three files we just made. To
    get the code for `BaseGameActivity.java`, visit [https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils](https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils),
    where you can see further links to the code for the three files we created in
    step 7:![Setting up the Snake project ready for implementation](img/88590S_09_34.jpg)
  id: totrans-2793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将获取要复制到我们刚刚创建的三个文件中的Java代码。要获取`BaseGameActivity.java`的代码，请访问[https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils](https://github.com/playgameservices/android-basic-samples/tree/master/BasicSamples/libraries/BaseGameUtils/src/main/java/com/google/example/games/basegameutils)，在那里您可以看到进一步链接到我们在第7步中创建的三个文件的代码：[设置蛇项目准备实施](img/88590S_09_34.jpg)
- en: Click on **BaseGameActivity.java** as shown in the preceding screenshot. Select
    all of the code and copy and paste it into the identically named file that we
    created in Android Studio. Note that when we created the file, Android Studio
    created some basic template code. We need to delete all of this, except our package
    name at the top. When we paste in the copied code, we need to delete the Google
    package name.
  id: totrans-2794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如图所示的**BaseGameActivity.java**。选择所有代码并将其复制粘贴到Android Studio中创建的相同名称的文件中。注意，当我们创建文件时，Android
    Studio创建了一些基本的模板代码。我们需要删除所有这些代码，除了顶部的包名。当我们粘贴复制的代码时，我们需要删除Google包名。
- en: Click on **GameHelper.java**, as shown in the previous screenshot, and repeat
    step 9.
  id: totrans-2795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如图所示的**GameHelper.java**，并重复步骤9。
- en: Click on **GameHelperUtils.java**, as shown in the preceding screenshot, and
    repeat step 9.
  id: totrans-2796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如图所示的**GameHelperUtils.java**，并重复步骤9。
- en: There's one more file to create. Right-click on the **values** folder in the
    project explorer. Navigate to **New** | **File**. Name the file `gamehelper_strings.xml`.
  id: totrans-2797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要创建一个文件。在项目资源管理器中右键单击**values**文件夹。导航到**新建** | **文件**。将文件命名为`gamehelper_strings.xml`。
- en: 'Get the code that we need for this file in the same way as we did for the previous
    three Java files from but from this link: [https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml](https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml).'
  id: totrans-2798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与之前三个Java文件相同的方式获取此文件所需的代码，但来自此链接：[https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml](https://github.com/playgameservices/android-basic-samples/blob/master/BasicSamples/libraries/BaseGameUtils/src/main/res/values/gamehelper_strings.xml)。
- en: Paste the code in `gamehelper_strings.xml`, which we created in step 12.
  id: totrans-2799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将步骤12中创建的`gamehelper_strings.xml`中的代码粘贴进去。
- en: Now change the `MainActivity` declaration in the `MainActivity.java` file.
  id: totrans-2800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改`MainActivity.java`文件中的`MainActivity`声明。
- en: 'Consider this code:'
  id: totrans-2801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE493]'
  id: totrans-2802
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE493]'
- en: 'Change it to the following code so that we can now extend the version of Activity
    that handles all the hard work of the Game Services API:'
  id: totrans-2803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其更改为以下代码，以便我们现在可以扩展处理游戏服务API所有繁重工作的Activity版本：
- en: '[PRE494]'
  id: totrans-2804
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'Now check out the code in the `GameActivity.java` file:'
  id: totrans-2805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查`GameActivity.java`文件中的代码：
- en: '[PRE495]'
  id: totrans-2806
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'Change the preceding code to the following code so that we can now extend the
    version of Activity that handles all the hard work of the Game Services API:'
  id: totrans-2807
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将前面的代码更改为以下代码，以便我们现在可以扩展处理游戏服务API所有繁重工作的Activity版本：
- en: '[PRE496]'
  id: totrans-2808
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE496]'
- en: Notice that for both Activities, we have an error in the class declaration we
    just typed. If you hover the mouse cursor over the code we typed in the previous
    step, you can see the reason. We need to implement some abstract methods of a
    class we are using. Recall from [Chapter 6](ch06.html "Chapter 6. OOP – Using
    Other People's Hard Work"), OOP – *Using Other People's Hard Work*, that if a
    method in a class is declared abstract, then the class that extends it must implement
    it. That's us! Let's perform an empty implementation for now. Right-click on the
    line of code with the error and navigate to **Generate** | **Implement Methods**.
    Now click on **OK**. Perform this step for the `MainActivity.java` file and the
    `GameActivity.java` file. Our empty methods are now ready for our code. We will
    write the code in the next tutorial.
  id: totrans-2809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，对于这两个Activity，我们在刚刚输入的类声明中有一个错误。如果你将鼠标光标悬停在之前步骤中输入的代码上，你可以看到原因。我们需要实现我们使用的一个类的某些抽象方法。回想一下[第6章](ch06.html
    "第6章。面向对象编程 – 使用他人的辛勤工作")，面向对象编程 – 使用他人的辛勤工作，如果一个类中的方法被声明为抽象的，那么扩展它的类必须实现它。那就是我们！现在让我们为空实现。右键单击有错误的代码行，导航到**生成**
    | **实现方法**。现在点击**确定**。对`MainActivity.java`文件和`GameActivity.java`文件执行此步骤。我们的空方法现在准备好编写代码了。我们将在下一个教程中编写代码。
- en: Next, using the project explorer, find the `build.gradle` file. Be careful;
    there are two files with the same name. The file that we need to find is a couple
    of lines below the `AndroidManifest.xml` file. It is highlighted in the next screenshot.
    Open it by double-clicking on the `build.gradle` file:![Setting up the Snake project
    ready for implementation](img/88590S_09_10.jpg)
  id: totrans-2810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用项目资源管理器，找到`build.gradle`文件。请注意；有两个文件具有相同的名称。我们需要找到的文件位于`AndroidManifest.xml`文件下方几行。在下一张截图中被突出显示。通过双击`build.gradle`文件来打开它：![设置Snake项目以准备实现](img/88590S_09_10.jpg)
- en: 'Find the section of code shown here and add the line that is highlighted. This
    makes all the classes we downloaded in the previous guide available for use in
    our *Snake* game:'
  id: totrans-2811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到此处显示的代码部分，并添加高亮显示的行。这使得我们在上一指南中下载的所有类都可以在我们的*Snake*游戏中使用：
- en: '[PRE497]'
  id: totrans-2812
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'Okay, I agree that was a fairly tough tutorial, but we are now ready to implement
    our code in three final steps:'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我同意这是一个相当困难的教程，但我们现在已经准备好在三个最终步骤中实现我们的代码：
- en: Player sign-in and buttons.
  id: totrans-2814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家登录和按钮。
- en: Leaderboards.
  id: totrans-2815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排行榜。
- en: Achievements.
  id: totrans-2816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成就。
- en: We will then be able to upload our updated app and use our new leaderboards
    and achievements.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将能够上传我们的更新后的应用程序，并使用我们新的排行榜和成就。
- en: Implementing the player's sign-in, achievements, and leaderboard buttons
  id: totrans-2818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现玩家的登录、成就和排行榜按钮
- en: By the end of this section, players will be able to log in through the game
    to our empty leaderboards and achievements. The guides that follow this section
    will actually make the leaderboards and achievements work.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，玩家将能够通过游戏登录到我们的空排行榜和成就。本节之后的指南将实际上使排行榜和成就工作。
- en: First, let's enable our Game Services. All of the work we have done so far in
    the developer console needs to be published before we can use it. Log in to your
    developer console. Navigate to **Game Services** | **Snake** | **Ready to publish**
    | **Publish game**. Then you will be shown a **Publish your game** button. Click
    on it. Finally, read the brief disclaimer and click on **Publish now**.
  id: totrans-2820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们启用我们的游戏服务。我们在开发者控制台中迄今为止所做的所有工作都需要在我们可以使用之前发布。登录到你的开发者控制台。导航到**游戏服务**
    | **Snake** | **准备发布** | **发布游戏**。然后你会看到一个**发布你的游戏**按钮。点击它。最后，阅读简短的免责声明并点击**现在发布**。
- en: 'Now we need to build a UI that has **Sign in**, **Sign out**, **Leaderboards**,
    and **Achievements** buttons. Open the `layout_main.xml` file and edit it on the
    **Text** tab of the editor window by adding the following code. Obviously, there
    is a lot to type. You might like to copy and paste the code from the download
    package at `Chapter9\EnhancedSnakeGame\layout`. Here is the code. Type it in or
    copy and paste it:'
  id: totrans-2821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个包含**登录**、**登出**、**排行榜**和**成就**按钮的用户界面。打开`layout_main.xml`文件，在编辑窗口的**文本**标签页中编辑它，添加以下代码。显然，有很多内容需要输入。你可能喜欢从`Chapter9\EnhancedSnakeGame\layout`下载包中复制和粘贴代码。以下是代码。输入它或复制粘贴它：
- en: '[PRE498]'
  id: totrans-2822
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE498]'
- en: Explaining the code line by line is beyond the scope of the book, but this is
    not much different from the code we have been autogenerating when using the UI
    designer since [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*. Each block of the code in the last step defines
    a button and its position on the screen. You can switch to the design tab and
    move the buttons around to suit yourself. Note that the reason some of the buttons
    are not visible in the designer is that they are hidden until the player signs
    in. The reason we have done things this way is to make sure we implement the sign
    in button in just the right way. Note the `id` attribute for each of the buttons.
    We will be manipulating them in our Java code next. With some buttons set to `visibility
    = gone`, we see something like this:![Implementing the player's sign-in, achievements,
    and leaderboard buttons](img/88590S_09_40.jpg)
  id: totrans-2823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行解释代码超出了本书的范围，但这种方法与我们自[第2章](ch02.html "第2章. 开始使用Android")“开始使用Android”以来使用UI设计器自动生成的代码并没有太大的区别。在最后一步中，代码的每个块定义了一个按钮及其在屏幕上的位置。你可以切换到设计标签页，移动按钮以适应你的需求。请注意，有些按钮在设计师中不可见，是因为它们在玩家登录之前是隐藏的。我们这样做的原因是为了确保我们以正确的方式实现了登录按钮。注意每个按钮的`id`属性。我们将在接下来的Java代码中操作它们。当一些按钮设置为`visibility
    = gone`时，我们会看到如下所示的内容：![实现玩家的登录、成就和排行榜按钮](img/88590S_09_40.jpg)
- en: With some buttons set to `visibility = visible`, we see something like what
    is shown in the following screenshot:![Implementing the player's sign-in, achievements,
    and leaderboard buttons](img/88590S_09_41.jpg)
  id: totrans-2824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一些按钮设置为`visibility = visible`时，我们会看到如下截图所示的内容：![实现玩家的登录、成就和排行榜按钮](img/88590S_09_41.jpg)
- en: You might be wondering why we are designing a UI when `SnakeAnimView` is what
    the user sees. We could have implemented all our own buttons with bitmaps and
    used their screen coordinates to detect presses, but what we will do now is load
    our UI on top of `SnakeAnimView`, which will greatly simplify things. Switch to
    the **MainActivity** tab in the editor window.
  id: totrans-2825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在`SnakeAnimView`是用户看到的内容时还要设计一个UI。我们可以用位图实现我们所有的按钮，并使用它们的屏幕坐标来检测点击，但我们现在要做的是在`SnakeAnimView`之上加载我们的UI，这将大大简化事情。切换到编辑器窗口中的**MainActivity**选项卡。
- en: 'First of all, we want to implement the `onClickListener` interface to handle
    our button clicks. To achieve this, change the class declaration to this:'
  id: totrans-2826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要实现`onClickListener`接口来处理我们的按钮点击。为了实现这一点，将类声明更改为以下内容：
- en: '[PRE499]'
  id: totrans-2827
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Now we can get Android Studio to quickly implement the required `onClick` method
    by right-clicking on the class declaration, navigating to **Add** | **Implement
    methods**, and then clicking on **OK**.
  id: totrans-2828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过在类声明上右键单击，导航到**添加** | **实现方法**，然后单击**确定**，让Android Studio快速实现所需的`onClick`方法。
- en: 'Immediately after the previous line of code, we declare our four new buttons.
    Add this code after the code in the previous step:'
  id: totrans-2829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一行代码之后，我们声明了四个新的按钮。在上一条代码之后添加以下代码：
- en: '[PRE500]'
  id: totrans-2830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'In the `onCreate` method, just after the call to the `setContent` view, we
    use an object of the `LayoutInflater` class to load our UI on top of our `SnakeAnimView`.
    Add the highlighted code after the call to `setContentView`:'
  id: totrans-2831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，在调用`setContent`视图之后，我们使用`LayoutInflater`类的对象在`SnakeAnimView`之上加载我们的UI。在调用`setContentView`之后添加高亮显示的代码：
- en: '[PRE501]'
  id: totrans-2832
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'Immediately after the code in the previous step, we can get a reference to
    all our buttons and listen to clicks in the usual way:'
  id: totrans-2833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码之后，我们可以获取所有按钮的引用，并以通常的方式监听点击事件：
- en: '[PRE502]'
  id: totrans-2834
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE502]'
- en: 'Remember that in the previous guide, we overrode two abstract methods that
    we inherited when we extended the `BaseGameActivity` class. Now we will put some
    code into their implementation. The code is very straightforward. We hide the
    sign out button and show the sign in button when the sign-in fails, and we hide
    the sign in button and show all the other three buttons when the sign-in succeeds.
    Here are the two methods in their entirety. Type the highlighted code within the
    methods shown:'
  id: totrans-2835
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，在前面的指南中，我们覆盖了当我们扩展`BaseGameActivity`类时继承的两个抽象方法。现在我们将向它们的实现中添加一些代码。代码非常直接。当登录失败时，我们隐藏注销按钮并显示登录按钮，当登录成功时，我们隐藏登录按钮并显示其他三个按钮。以下是这两个方法的全部内容。在方法中输入高亮显示的代码：
- en: '[PRE503]'
  id: totrans-2836
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE503]'
- en: 'Now we deal with the `onClick` method and what happens when the player clicks
    on any one of our four buttons. First, we type the code for our switch block.
    We will fill in the `case` statements in the next step:'
  id: totrans-2837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们处理`onClick`方法以及玩家点击我们四个按钮中的任何一个时会发生什么。首先，我们编写我们的`switch`块代码。我们将在下一步中填写`case`语句：
- en: '[PRE504]'
  id: totrans-2838
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'Here, we handle the sign in button. We simply call the `beginUserInitiatedSignIn`
    method. It is implemented for us in the `BaseGameActivity` class. Type this code
    in the `switch` block from the previous step:'
  id: totrans-2839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们处理登录按钮。我们简单地调用`beginUserInitiatedSignIn`方法。这个方法在`BaseGameActivity`类中为我们实现。在上一步的`switch`块中输入以下代码：
- en: '[PRE505]'
  id: totrans-2840
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE505]'
- en: 'Now we handle what happens when the player signs out. We just call `signOut`,
    which is implemented for us in the `BaseGameActivity` class. We then hide all
    our buttons and show the sign in button again. Type the following code after the
    code from the previous step:'
  id: totrans-2841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们处理玩家注销时发生的情况。我们只需调用`signOut`，这个方法在`BaseGameActivity`类中为我们实现。然后我们隐藏所有按钮并再次显示登录按钮。在上一条代码之后输入以下代码：
- en: '[PRE506]'
  id: totrans-2842
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE506]'
- en: 'Next, we handle what happens when the player clicks on the achievements button.
    One line of code gives us all of the achievement functionality. This is what OOP
    is all about—someone else''s hard work doing everything for us. Type this code
    after the preceding code:'
  id: totrans-2843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们处理玩家点击成就按钮时发生的情况。一行代码就为我们提供了所有成就功能。这正是面向对象编程（OOP）的精髓——别人的辛勤工作为我们做所有事情。在前面代码之后输入以下代码：
- en: '[PRE507]'
  id: totrans-2844
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'Finally, we handle what happens when the player clicks on the **Leaderboards**
    button. Again, one line of code gives us all of the leaderboard''s functionality:'
  id: totrans-2845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理玩家点击**排行榜**按钮时发生的情况。同样，一行代码就为我们提供了排行榜的所有功能：
- en: '[PRE508]'
  id: totrans-2846
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'We explained the code as we went, but let''s summarize:'
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写代码的过程中解释了代码，但让我们总结一下：
- en: We designed a simple UI.
  id: totrans-2848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设计了一个简单的用户界面。
- en: We loaded the UI on top of `SnakeAnimView`.
  id: totrans-2849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`SnakeAnimView`之上加载了UI。
- en: We got a reference to our four buttons and listened for clicks.
  id: totrans-2850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取了四个按钮的引用，并监听点击事件。
- en: We handled what happens when people click on our buttons, which amounted to
    nothing more than hiding and showing buttons as appropriate, calling methods from
    `BaseGameActivity`, and using the `Intent` class to implement all our leaderboard
    and achievement functionalities.
  id: totrans-2851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理了当人们点击我们的按钮时会发生什么，这仅仅意味着根据需要隐藏和显示按钮，从`BaseGameActivity`调用方法，并使用`Intent`类来实现我们所有的排行榜和成就功能。
- en: You can actually run the *Snake* game and see the leaderboards and achievements
    screens. Of course, at this point, nobody will have any achievements or high scores
    yet. We will fix this now.
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以运行*蛇*游戏并看到排行榜和成就屏幕。当然，在这个阶段，还没有人会有任何成就或高分。我们现在将解决这个问题。
- en: Implementing the leaderboards in code
  id: totrans-2853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中实现排行榜
- en: 'Once more, we will witness the simplicity of using other people''s well-designed
    code. Admittedly, there was some complexity to arrive at this point, but once
    you have set it all up, then your next game will take a fraction of the time you
    took setting up:'
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将见证使用其他人精心设计的代码的简单性。诚然，到达这个阶段有一些复杂性，但一旦你设置好一切，那么你的下一款游戏将只需设置时间的一小部分：
- en: We want to submit a score to the `leaderboards` at the end of a game. Google
    Play will handle the process to check whether or not it is a high score. Google
    Play will even determine if it is a new high score for the week or month. Open
    the `GameActivity.java` file in the code editor window.
  id: totrans-2855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在游戏结束时提交一个分数到`排行榜`。Google Play将处理检查是否是高分的过程。Google Play甚至还会确定这是否是本周或月份的新高分。在代码编辑器窗口中打开`GameActivity.java`文件。
- en: 'Find the `updateGame` method and add the highlighted code among all the other
    things we do when the game is over (when `dead` equals `true`). We wrap just one
    line of code within a check to ensure that the current player is signed in:'
  id: totrans-2856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`updateGame`方法，并在游戏结束时（当`dead`等于`true`）我们做的所有其他事情中添加高亮代码。我们只将一行代码包裹在一个检查中，以确保当前玩家已登录：
- en: '[PRE509]'
  id: totrans-2857
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE509]'
- en: That's it! Build the game and play it on a real Android device. You can now
    visit the leaderboards on Google Play and see your high score.
  id: totrans-2858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！构建游戏并在真实的Android设备上玩。你现在可以访问Google Play上的排行榜并查看你的高分。
- en: 'That was nice and easy. Here, we can see the login screen:'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。在这里，我们可以看到登录屏幕：
- en: '![Implementing the leaderboards in code](img/88590S_09_45.jpg)'
  id: totrans-2860
  prefs: []
  type: TYPE_IMG
  zh: '![在代码中实现排行榜](img/88590S_09_45.jpg)'
- en: 'Then comes the welcome message and our **Achievements** and **Leaderboards**
    buttons as shown in the following screenshot:'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是欢迎信息和我们的**成就**和**排行榜**按钮，如下面的截图所示：
- en: '![Implementing the leaderboards in code](img/88590S_09_46.jpg)'
  id: totrans-2862
  prefs: []
  type: TYPE_IMG
  zh: '![在代码中实现排行榜](img/88590S_09_46.jpg)'
- en: Finally, we can see our new leaderboards with just one player—me.
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到只有一名玩家——我自己的新排行榜。
- en: '![Implementing the leaderboards in code](img/88590S_09_47.jpg)'
  id: totrans-2864
  prefs: []
  type: TYPE_IMG
  zh: '![在代码中实现排行榜](img/88590S_09_47.jpg)'
- en: Just in case you're wondering, I can do a lot better than 39.
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 就算你好奇，我也能做得比39分更好。
- en: Implementing the achievements in code
  id: totrans-2866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中实现成就
- en: 'This brief tutorial will first set up our game to post incremental updates
    to the progress of the apple achievements and the one-off achievement of the snake
    segment length:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的教程将首先设置我们的游戏，以便发布苹果成就进度和蛇段长度一次性成就的增量更新：
- en: 'In the `GameActivity.java` file, add an `applesMunchedThisTurn` variable just
    after the class declaration, as shown here:'
  id: totrans-2868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameActivity.java`文件中，在类声明之后添加一个`applesMunchedThisTurn`变量，如下所示：
- en: '[PRE510]'
  id: totrans-2869
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE510]'
- en: Find the `updateGame` method.
  id: totrans-2870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`updateGame`方法。
- en: 'Add a line of code to increment `applesMunchedThisTurn` each time an apple
    is eaten by adding the highlighted line of code where it is shown:'
  id: totrans-2871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码来增加`applesMunchedThisTurn`，每次苹果被吃掉时添加高亮代码，如下所示：
- en: '[PRE511]'
  id: totrans-2872
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'Notice that we place this highlighted line among the code that executes when
    the player dies (the `if(dead)` block). We could do it at the point the player
    eats an apple, but if we send five messages to the Google Play servers every time
    the player eats an apple, we might risk Google considering it as spam. We simply
    increment each achievement by the number of apples that have been eaten, and then
    reset the `applesMunchedThisTurn` variable to zero. We wrap our achievement method
    calls with a check that the player is signed in and that `applesMunchedThisTurn`
    is greater than zero. Now add the highlighted code:'
  id: totrans-2873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们将这条高亮显示的行放在玩家死亡时执行的代码中（`if(dead)`块）。我们本可以在玩家吃苹果时做这件事，但如果每次玩家吃苹果时都向Google
    Play服务器发送五条消息，我们可能会冒Google将其视为垃圾邮件的风险。我们只需将每个成就增加已吃苹果的数量，然后将`applesMunchedThisTurn`变量重置为零。我们用检查玩家是否已登录以及`applesMunchedThisTurn`是否大于零的检查来包装我们的成就方法调用。现在添加高亮显示的代码：
- en: '[PRE512]'
  id: totrans-2874
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE512]'
- en: 'Now we will handle the segment length achievements. In the `updateGame` method,
    in the part of the code that executes when the player eats an apple, just after
    the line of code that increments `snakeLength`, we test for any of the lengths
    that warrant a Super Snake achievement. When the desired length is achieved (5,
    10, 25, 35, or 50 segments), we ask Google Play to award it (if it hasn''t been
    awarded yet). We wrap our achievement method calls with a check that the player
    is signed in and that at least one apple has been eaten. The highlighted code
    is the new code to add:'
  id: totrans-2875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将处理段长度成就。在`updateGame`方法中，在玩家吃苹果时执行的代码部分，紧接在增加`snakeLength`的代码行之后，我们检查是否有任何长度值得获得超级蛇成就。当达到期望的长度（5、10、25、35或50个段）时，我们请求Google
    Play授予它（如果尚未授予）。我们用检查玩家是否已登录以及至少吃了一个苹果的检查来包装我们的成就方法调用。下面是添加的新代码：
- en: '[PRE513]'
  id: totrans-2876
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE513]'
- en: That's it! You can now play the game and earn achievements:![Implementing the
    achievements in code](img/88590S_09_48.jpg)
  id: totrans-2877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！你现在可以玩游戏并赚取成就：![在代码中实现成就](img/88590S_09_48.jpg)
- en: Again, that was nice and easy. You can probably see how simple it would be to
    implement all other achievement ideas that we discussed earlier in the chapter.
    Let's move on and update our game on Google Play.
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这很简单。你可能已经看到了如何实现本章中讨论的所有其他成就想法。让我们继续前进，并在Google Play上更新我们的游戏。
- en: Uploading the updated Snake game to Google Play
  id: totrans-2879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将更新的Snake游戏上传到Google Play
- en: 'This is nice and easy and is performed as follows:'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，操作如下：
- en: 'First, we need to let Google Play know this is a new version. We do this by
    changing the version number. Open the `Build.gradle` file and find these lines
    of code:'
  id: totrans-2881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要让Google Play知道这是一个新版本。我们通过更改版本号来做这件事。打开`Build.gradle`文件，找到以下代码行：
- en: '[PRE514]'
  id: totrans-2882
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE514]'
- en: Build your APK in the usual way.
  id: totrans-2883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式构建你的APK。
- en: Log in to your developer console.
  id: totrans-2884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你的开发者控制台。
- en: Click on **Snake Game 1.0**, then on **APK**, and then on **Upload new APK to
    production**.
  id: totrans-2885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Snake Game 1.0**，然后点击**APK**，然后点击**上传新APK到生产**。
- en: Go to your newly updated APK.
  id: totrans-2886
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你刚刚更新的APK。
- en: In the **What's new in this version** field, enter `Added leaderboards and achievements`.
  id: totrans-2887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**本版本新增内容**字段中，输入`Added leaderboards and achievements`。
- en: Click on **Publish now to production**.
  id: totrans-2888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**立即发布到生产**。
- en: From now onwards, everyone who downloads your game will get the updated version.
    With our first game, complete with sprite sheet animations, leaderboards and achievements,
    it is time to take a break and do a little theory.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有下载你的游戏的人都将获得更新版本。随着我们的第一款游戏，包括精灵表动画、排行榜和成就，现在是时候休息一下，做一些理论研究了。
- en: What next?
  id: totrans-2890
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: You should be proud of your creations to date, especially if this was your first
    attempt at programming. If some of the concepts, syntax, or projects are still
    not clear, then consider revisiting them after a break.
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为到目前为止的创造感到自豪，尤其是如果你这是第一次尝试编程。如果某些概念、语法或项目仍然不清楚，那么在休息后考虑重新审视它们。
- en: The one thing we haven't talked about is the even more new skills we need to
    progress further. The reason for this is that it very much depends on your initial
    motivation for reading this book.
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的是，为了进一步进步，我们需要掌握的更多新技能。这完全取决于你最初阅读这本书的动机。
- en: Getting a programmer's job
  id: totrans-2893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获得程序员的工作
- en: If you want to be a Java employee, that is, working full time with a professional
    capacity for a medium or large company, then you will probably need a college
    degree, and this book hopefully has given you a glimpse into the world of programming
    and Java itself. If this describes you, then for further study, you could consider
    a more formal Java book, followed by a pure OOP book about object-oriented analysis
    and design. You could then move on to study design patterns.
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要成为一名Java员工，也就是说，在一家中型或大型公司全职以专业能力工作，那么你可能需要一个大学学位，这本书希望让你对编程和Java本身的世界有了一个初步的了解。如果你是这样的情况，那么为了进一步学习，你可以考虑一本更正式的Java书籍，然后是一本关于面向对象分析和设计的纯OOP书籍。然后你可以继续学习设计模式。
- en: 'Some of the best books that fit into these categories are *Head First Object-Oriented
    Analysis and Design: A Brain Friendly Guide to OOA&D, Brett McLaughlin and Gary
    Pollice; Head First Design Patterns*; *Eric Freeman and Elisabeth Robson*, *O''Reilly*;
    and *Design Patterns CD: Elements of Reusable Object-Oriented Software*, *Erich
    Gamma, Richard Helm, Ralph Johnson, and John Vlissides*, *Addison Wesley*. The
    first two are very beginner-friendly. The latter is highly regarded but a much
    more challenging read for a beginner.'
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: '一些最适合这些类别的最佳书籍包括*《Head First Object-Oriented Analysis and Design: A Brain Friendly
    Guide to OOA&D》，作者Brett McLaughlin和Gary Pollice；*《Head First Design Patterns》；*《Eric
    Freeman和Elisabeth Robson》，*《O''Reilly》*；以及*《Design Patterns CD: Elements of Reusable
    Object-Oriented Software》，作者Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，*《Addison
    Wesley》。前两本书非常适合初学者。后一本书备受推崇，但对于初学者来说阅读起来更具挑战性。'
- en: My guess is that most likely, you didn't pick up a beginners' book on games
    and Java because you were headed in that direction, so let's consider our *piece
    de resistance* so far—our Snake game.
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: 我的猜测是，你之所以没有选择关于游戏和Java的初学者书籍，很可能是因为你正朝着那个方向发展，所以让我们考虑一下到目前为止的*压轴之作*——我们的贪吃蛇游戏。
- en: Building bigger and better games
  id: totrans-2897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打造更大更好的游戏
- en: If you compare our Snake game to a modern, professional title, even a two-dimensional
    game, never mind a modern big-budget First Person Shooter (FPS), then we still
    have a lot of learning to do. Let's consider some inadequacies of our *Snake*
    game compared to a professional game.
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把我们的贪吃蛇游戏与现代的专业游戏相比，即使是二维游戏，更不用说现代的大预算第一人称射击游戏（FPS），那么我们还有很多东西要学习。让我们考虑一下我们的*贪吃蛇*游戏与专业游戏相比的一些不足之处。
- en: Think about our flower and tail animations. They worked because we set up a
    crude timing system within our `controlFPS` method. But what if we had a dozen
    or more game objects that needed to be animated?
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们的花朵和尾巴动画。它们之所以有效，是因为我们在`controlFPS`方法中设置了一个粗略的时间系统。但如果我们有十几个或更多的游戏对象需要动画怎么办？
- en: Then what if they all had different frame counts and frame rates? We can further
    complicate things if some of the animations need to work on a loop and others
    need to reverse through each frame before restarting.
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们都有不同的帧数和帧率怎么办？如果一些动画需要循环播放，而另一些动画需要在重新开始之前逐帧倒放，我们还可以进一步复杂化这些事情。
- en: Now imagine a character that has to jump. How do we synchronize whatever frame
    happens to be displayed at the time the player jumps?
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个需要跳跃的角色。我们如何同步玩家跳跃时恰好显示的任何帧？
- en: Actually, all of these problems and more are solvable with a quick web search
    and some study. The point is that things are starting to get fairly complicated,
    and we have only talked about animation.
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有这些问题以及更多都可以通过快速的网络搜索和一些学习来解决。关键是事情开始变得相当复杂，而我们只讨论了动画。
- en: What about physics? How will objects in our future games behave when they bounce?
    We were able to cheat with our Squash game because the environment and the objects
    were few and simple. What if the ball was round and there were lots of objects
    of different sizes and shapes, some moving fast and some stationary? How would
    we simulate this physics model?
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 关于物理呢？当物体弹跳时，我们未来的游戏中的物体会如何表现？我们之所以能在我们的Squash游戏中作弊，是因为环境和对象很少且简单。如果球是圆的，而且有很多不同大小和形状的物体，有些移动得很快，有些是静止的，我们该如何模拟这个物理模型？
- en: Again, the answers are all out there but they add complexity. What about other
    environmental factors such as light and shadow? What happens when our screen needs
    to scroll to the left and right? What about up and down?
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有这些答案都在那里，但它们增加了复杂性。那么其他环境因素，如光和阴影呢？当我们的屏幕需要左右滚动时会发生什么？上下滚动呢？
- en: Now consider all of these problems and imagine implementing a solution in a
    virtual three-dimensional world. Once again, the solutions are out there, but
    it would take a determined beginner many months to implement their own solution
    using the raw mathematics involved in three-dimensional calculations.
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑所有这些问题，并想象在一个虚拟的三维世界中实施解决方案。再次强调，解决方案就在那里，但一个有决心的初学者可能需要数月时间才能使用三维计算中涉及的原始数学来实现自己的解决方案。
- en: Next, imagine that you want your new three-dimensional, physics-based, superbly
    animated game to be available on Android, Apple, and PC platforms.
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，想象一下，你希望你的新三维、基于物理、动画出色的游戏能够在Android、Apple和PC平台上运行。
- en: If I have discouraged you from seeking some of these solutions but you are fascinated
    to find out the answer, then my advice would be to go and find it out anyway.
    It will definitely be a fascinating journey and make you a better game developer.
    Think twice, however, before implementing any of this stuff for any reason other
    than curiosity, self-improvement, or fun.
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我已经让你对这些解决方案感到气馁，但你又渴望找到答案，那么我的建议是无论如何都要去寻找。这肯定是一次令人着迷的旅程，并使你成为一个更好的游戏开发者。然而，在出于好奇心、自我提升或娱乐之外的原因实施任何这些内容之前，请三思。
- en: The reason for this is because we are not the first people to have these and
    many other problems—the solutions have already been implemented. And guess what?
    We can use those solutions, often at no cost to ourselves.
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们并不是第一个遇到这些问题的人——这些解决方案已经得到了实施。而且你知道吗？我们可以免费使用这些解决方案。
- en: For example, there is a library called OpenGL that has one purpose—drawing in
    a three-dimensional coordinate system. It has classes and methods for everything
    you will ever need. There is even a version of OpenGL for mobile, called OpenGL
    ES, that you can program in Java. It is true that OpenGL has some complexities
    of its own, but they can be learned in a logical and straightforward manner from
    easy to hard.
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为OpenGL的库，它的唯一目的是在三维坐标系中绘图。它有你需要的一切类和方法。甚至还有一个适用于移动设备的OpenGL版本，称为OpenGL
    ES，你可以用Java来编程。OpenGL确实有一些自己的复杂性，但它们可以通过从易到难的逻辑和直接的方式学习。
- en: If you got this far with this book, take a quick refresher on [Chapter 6](ch06.html
    "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using Other People's
    Hard Work*, and then grab a copy of *OpenGL ES2 for Android*, *K. Brothaler*,
    *Pragmatic Bookshelf*. The book explores the code library and some of the mathematics
    behind it, so it should satisfy both the curious and the purely practical reader.
    Alternatively, you can check out loads of free tutorials at [http://www.learnopengles.com/](http://www.learnopengles.com/).
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经通过这本书走过了这一段路程，那么请快速回顾一下[第6章](ch06.html "第6章。面向对象编程 – 利用他人的辛勤工作"), *面向对象编程
    – 利用他人的辛勤工作*，然后获取一份*K. Brothaler*的*OpenGL ES2 for Android*，*Pragmatic Bookshelf*的副本。这本书探讨了代码库及其背后的某些数学知识，因此它应该能满足好奇的读者和纯粹实用型读者的需求。或者，你可以在[http://www.learnopengles.com/](http://www.learnopengles.com/)查看大量的免费教程。
- en: If you just want to make more games and are not particularly fussed about the
    three-dimensional features, then the next logical step would be a Java-based game
    library. There are many, but one in particular uses pure Java to build games on
    Android, iPhone, PC, and the Web.
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想制作更多的游戏，并且并不特别关心三维特性，那么下一个合乎逻辑的步骤就是使用Java的游戏库。有很多选择，但特别有一个使用纯Java在Android、iPhone、PC和网络上构建游戏。
- en: Indeed, you can build one Java game and it will run on almost any device in
    the world, even a web page. It also has classes that simplify the use of the aforementioned
    OpenGL ES. The library is called LibGDX, and I had loads of fun making a platform
    game following along with *Learning Libgdx Game development* ([https://www.packtpub.com/game-development/learning-libgdx-game-development](https://www.packtpub.com/game-development/learning-libgdx-game-development)).
    LibGDX also solves all our animation, scrolling, and physics conundrums without
    any math, although it doesn't really address three-dimensional features.
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以构建一个Java游戏，它几乎可以在世界上任何设备上运行，甚至是一个网页。它还包含简化上述OpenGL ES使用的类。这个库叫做LibGDX，我在跟随*Learning
    Libgdx Game development* ([https://www.packtpub.com/game-development/learning-libgdx-game-development](https://www.packtpub.com/game-development/learning-libgdx-game-development))制作平台游戏时玩得很开心。LibGDX还解决了我们的所有动画、滚动和物理难题，而无需任何数学知识，尽管它并没有真正解决三维特性问题。
- en: Tip
  id: totrans-2913
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that both books have some quite in-depth OOP, but this is not out of reach
    if you understood [Chapter 6](ch06.html "Chapter 6. OOP – Using Other People's
    Hard Work"), *OOP – Using Other People's Hard Work*, and are determined.
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两本书都有一些相当深入的面向对象编程（OOP），但如果你理解了 [第 6 章](ch06.html "第 6 章。OOP – 使用他人的辛勤工作")，*OOP
    – 使用他人的辛勤工作*，并且决心要学，这并不是遥不可及的。
- en: If you want to go 3D straightaway, then a really fun option is the Unreal Engine.
    Unreal Engine is used in lots of really big-budget games and can involve immense
    complexity in another programming language. However, for a way to make two-dimensional
    and three-dimensional games within a GUI development environment, it is probably
    unbeatable. Unreal Engine 4 uses a system called Blueprint, where you can drag
    and drop elements of flow chart-like elements, instead of coding. It still uses
    all the concepts of OOP as well as loops and branching, but you can do loads without
    a single line of *real* code. Take a look at the Unreal Engine version of Flappy
    Bird created without a single line of code, at [https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken](https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken).
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要立即进入 3D 领域，那么 Unreal Engine 是一个真正有趣的选择。Unreal Engine 被用于许多大预算游戏，并且可能涉及另一种编程语言的巨大复杂性。然而，对于在
    GUI 开发环境中制作二维和三维游戏来说，它可能是无与伦比的。Unreal Engine 4 使用一个名为 Blueprint 的系统，你可以拖放类似流程图的元素，而不是编写代码。它仍然使用所有面向对象编程的概念以及循环和分支，但你可以在不写一行“真实”代码的情况下做很多事情。看看没有一行代码创建的
    Unreal Engine 版本的 Flappy Bird，在 [https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken](https://play.google.com/store/apps/details?id=com.epicgames.TappyChicken)。
- en: Unreal Engine can also build games for multiple platforms, but unfortunately,
    there is a small monthly fee, and most restrictively of all, any commercial project
    you make will be subject to an agreement. Here, you pay 30 percent to Epic games,
    but for learning and having fun, it probably can't be beaten.
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 也可以为多个平台构建游戏，但遗憾的是，需要支付小额的月费，而且最限制性的条件是，你制作的任何商业项目都将受到协议的约束。在这里，你需要支付给
    Epic Games 30% 的费用，但对于学习和娱乐来说，可能没有比这更好的选择了。
- en: Alternatively, take a look at my blog ([www.gamecodeschool.com](http://www.gamecodeschool.com)),
    where I regularly add articles and fun game building guides aimed at beginner
    to intermediate game programmers. My blog discusses lots of different programming
    languages, target platforms, all the tools previously mentioned, and more.
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，看看我的博客 ([www.gamecodeschool.com](http://www.gamecodeschool.com))，我在那里定期添加文章和针对初学者到中级游戏程序员的有趣游戏构建指南。我的博客讨论了许多不同的编程语言、目标平台、之前提到的所有工具等等。
- en: Self-test questions
  id: totrans-2918
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) Try to implement local high scores on the device.
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 尝试在设备上实现本地高分记录。
- en: Q2) How many eminent computer scientists have made cameo appearances in the
    code throughout this book?
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在这本书的代码中，有多少杰出的计算机科学家有客串出现？
- en: Q3) As a final challenge, try to beat my high score on the Snake leaderboards.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 作为最后的挑战，尝试在我的 Snake 领跑榜上击败我的高分。
- en: Summary
  id: totrans-2922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot. We published our *Snake* game on Google Play.
    Then we added some online leaderboards and achievements. We also updated our publication.
    The process showed how very complicated tasks such as communication over the Internet
    can be made really simple using an API.
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们在 Google Play 上发布了我们的 *Snake* 游戏。然后我们添加了一些在线排行榜和成就。我们还更新了我们的发布。这个过程展示了如何使用
    API 将非常复杂的任务，如互联网通信，变得非常简单。
- en: While putting the finishing touches to this book, I watched a YouTube video
    of a lecture from John Carmack, a software legend. He was a key engineer in the
    development of the *Doom* game, which was published in June 1995\. I had to laugh,
    as did his audience, when he explained that while in school, he felt he was missing
    out on the technology revolution, and by the time he was old enough to work, it
    would all be over.
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这本书的最后润色工作时，我观看了一段 John Carmack 的 YouTube 讲座视频，他是一位软件传奇人物。他是 1995 年 6 月发布的
    *Doom* 游戏的关键工程师。当他解释说在学校时，他觉得自己错过了技术革命，等到他足够大可以工作时，一切都已经结束，我和他的观众都笑了。
- en: It is certainly true that lots of technology revolutions have come and many
    have gone. At least, many of the early adopters' opportunities have faded. John
    Carmack explained that there is always going to be another revolution just around
    the corner.
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多技术革命已经到来，许多已经消失。至少，许多早期采用者的机会已经消失。John Carmack 解释说，总会有另一场革命即将到来。
- en: So you are probably going to develop your skills and watch out for the next
    big thing. Or perhaps, you just want a bit of fun programming anything in any
    language for any platform.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能将要发展你的技能，并关注下一个大事件。或者，你可能只是想用任何语言为任何平台编写一些有趣的游戏程序。
- en: I hope you have enjoyed our journey through Android and Java, and that you will
    continue this journey as well. I sincerely wish you well, whichever path you choose
    for your future. Feel free to come and share your experiences and knowledge at
    [www.gamecodeschool.com](http://www.gamecodeschool.com). The perfect sequel to
    this book will be published mid 2015 called *Android Game Programming by Example*.
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢我们通过Android和Java的旅程，并且你也会继续这段旅程。我真诚地祝愿你无论选择哪条道路，未来都能一切顺利。随时来分享你的经验和知识，网址是[www.gamecodeschool.com](http://www.gamecodeschool.com)。这本书的完美续集将在2015年中出版，名为《Android游戏编程实例》。
- en: Appendix A. Self-test Questions and Answers
  id: totrans-2928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 自测题和答案
- en: Here, we have included some questions you could ask yourself to see whether
    you have understood each chapter. Don't worry! The answers are also included.
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一些你可以问自己的问题，以查看你是否理解了每一章。别担心！答案也包括在内。
- en: Chapter 2
  id: totrans-2930
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit confusing?
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 如果关于生命周期、类和方法的讨论让你感到有些困惑，你应该怎么做？
- en: A) Don't worry about them. Understanding comes a bit at a time, and if they
    are not entirely clear at this stage, it will not hold you back from thoroughly
    learning Java, and all will become clearer as we progress.
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: A) 别担心它们。理解是一点一点来的，如果它们在这个阶段并不完全清楚，这不会阻碍你彻底学习Java，随着我们的进展，一切都会变得清晰。
- en: Q2) What exactly is a Java class?
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) Java类究竟是什么？
- en: A) Classes are a fundamental building block of Java programs. They are like
    containers for our Java code, and we can even use other people's classes to simplify
    the programs we write, even without seeing or understanding the code contained
    within those classes.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: A) 类是Java程序的基本构建块。它们就像我们Java代码的容器，我们甚至可以使用其他人的类来简化我们编写的程序，即使我们没有看到或理解这些类中包含的代码。
- en: Q3) What is the difference between a method and a class?
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 方法和类之间的区别是什么？
- en: A) Methods are contained within classes and represent the specific functionality
    of the class, like another container within a container. As an example from a
    game, we might have a `Tank` class with `shoot`, `drive`, and `selfDestruct` methods.
    We can use a class and its methods by making our own class, as we will in [Chapter
    6](ch06.html "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*, or by using the `@import` statement as we did earlier
    in this chapter.
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: A) 方法包含在类中，并代表类的特定功能，就像容器中的另一个容器。以游戏为例，我们可能有一个`Tank`类，它有`shoot`、`drive`和`selfDestruct`方法。我们可以通过创建自己的类来使用类及其方法，就像我们在第6章中将要做的，或者通过使用`@import`语句，就像我们在本章前面做的那样。
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the lifecycle phases, at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 看看Android开发者网站及其对生命周期阶段的更技术性解释，在[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)。你能看到我们还没有讨论的阶段及其相关方法吗？它会在应用中何时被触发？活动从创建到销毁的精确路径是什么？
- en: A) It's the restarting phase. Its corresponding method is `onRestart`. It is
    triggered when an app has been stopped and then restarted. We won't need the `onRestart`
    method in this book, but this exercise hopefully helped clarify the concept of
    life cycles. The precise pathway will vary; we just need to handle the phases
    that are relevant to our game. So far, we have just tinkered with `onCreate`.
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: A) 它是重启阶段。它对应的方法是`onRestart`。当一个应用被停止然后重新启动时，它会触发。在这本书中，我们可能不需要`onRestart`方法，但这个练习可能有助于阐明生命周期的概念。精确的路径可能会有所不同；我们只需要处理与我们的游戏相关的阶段。到目前为止，我们只是对`onCreate`进行了修改。
- en: Chapter 3
  id: totrans-2939
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Q1) What does this code do?
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 这段代码做了什么？
- en: '[PRE515]'
  id: totrans-2941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: A) Nothing, because it is commented out with //.
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: A) 没有区别，因为它被注释掉了，用//。
- en: Q2) Which of these lines causes an error?
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 哪一行代码会导致错误？
- en: '[PRE516]'
  id: totrans-2944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: A) The fourth line, `a = a + b`, has no semicolon, so it will cause an error.
    The last line, `c = c + a;`, will also cause an error because you cannot assign
    a string to an `int` value.
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: A) 第四行，`a = a + b`，没有分号，所以会导致错误。最后一行，`c = c + a;`，也会导致错误，因为你不能将字符串赋值给 `int`
    类型的值。
- en: Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make code look complicated. However, when looked at closely, they are not as tough
    as they seem. Usually, it is just a case of splitting the expressions into smaller
    pieces to work out what is going on. Here is an expression that is more convoluted
    than anything else you will ever meet in this book. As a challenge, can you work
    out what `x` will be?
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我们讨论了很多关于运算符的内容，以及不同的运算符如何组合在一起构建复杂的表达式。从表面上看，表达式有时会使代码看起来很复杂。然而，仔细观察后，它们并没有看起来那么困难。通常，只需要将表达式拆分成更小的部分，以便弄清楚发生了什么。这里有一个比本书中任何其他表达式都复杂的表达式。作为一个挑战，你能计算出
    `x` 将会是多少吗？
- en: '[PRE517]'
  id: totrans-2947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: A) You can run the `SelfTestC3Q3` project in the `Chapter3` folder of the code
    bundle to check out the answer in the console, but `isTrueOrFalse` evaluates to
    true; here's why.
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你可以在代码包的 `Chapter3` 文件夹中运行 `SelfTestC3Q3` 项目，在控制台中检查答案，但 `isTrueOrFalse`
    评估为 `true`；原因如下。
- en: 'First, let''s break down the nasty line into manageable sections defined by
    the brackets:'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将这个讨厌的行分解成由括号定义的可管理的部分：
- en: '[PRE518]'
  id: totrans-2950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: Previously, we were asking the question, "is `x` less than or equal to `y` or
    is `x` exactly equal to `10`?". Clearly, `x` is not equal to or less than `y`
    but `x` is exactly equal to `10`, so our use of the logical OR operator, `||`,
    in the middle causes the entire part of the expression to evaluate to `true`.
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们是在问，“`x` 是否小于或等于 `y`，或者 `x` 是否正好等于 `10`？”显然，`x` 不等于也不小于 `y`，但 `x` 正好等于
    `10`，所以我们在中间使用逻辑或运算符 `||` 导致整个表达式的部分评估为 `true`。
- en: '&&'
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: '&&'
- en: 'Both sides of an `&&` operator must evaluate to `true` for the overall expression
    to be true. So let''s look at the other side:'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `&&` 运算符的两边都必须评估为 `true`，整个表达式才为 `true`。那么让我们看看另一边：
- en: '[PRE519]'
  id: totrans-2954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: Well, `isTrueOrFalse` is a Boolean. It can only be true or false so this part
    of the expression must be true because we are essentially asking, "is `isTrueOrFalse`
    false or is `isTrueOrFalse` true?". It must be one or the other. So, regardless
    of how we initialized `isTrueOrFalse`, the last part of the expression will be
    true.
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`isTrueOrFalse` 是一个布尔值。它只能是 `true` 或 `false`，所以这个表达式的这部分必须是 `true`，因为我们实际上是在问：“`isTrueOrFalse`
    是 `false` 还是 `true`？”它必须是其中一个。所以，无论我们如何初始化 `isTrueOrFalse`，表达式的最后一部分都将为 `true`。
- en: So the overall expression evaluates to `true`, and `true` is assigned to `isTrueOrFalse`.
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个表达式评估为 `true`，并将 `true` 赋值给 `isTrueOrFalse`。
- en: Chapter 4
  id: totrans-2957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Q1) What is wrong with this method?
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 这个方法有什么问题？
- en: '[PRE520]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: A) It returns a value but has a `void` return type.
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: A) 它返回一个值，但具有 `void` 返回类型。
- en: Q2) What will `x` be equal to at the end of this code snippet?
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在这段代码片段结束时，`x` 将等于多少？
- en: '[PRE521]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: A) Okay, this was a slightly tricky question. Regardless of the value of `x`,
    the `do` block always executes at least once. Then `x` is set to `11`, and after
    that, it is incremented to `12`. So when the `while` expression is evaluated,
    it is true and the `do` block executes again. Once more, `x` is set to `11` and
    then incremented to `12`. The program is stuck in a never-ending (infinite) loop.
    This code is most likely a bug.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: A) 好吧，这是一个有点棘手的问题。无论 `x` 的值如何，`do` 块总是至少执行一次。然后 `x` 被设置为 `11`，之后它被增加到 `12`。所以当
    `while` 表达式被评估时，它是 `true`，`do` 块再次执行。再次，`x` 被设置为 `11`，然后增加到 `12`。程序陷入了一个永无止境的（无限）循环。这段代码很可能是错误。
- en: Chapter 5
  id: totrans-2964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: Q1) Suppose we wanted to have a quiz where the question could be about naming
    the president, the capital city, and so on. How would we do this with multidimensional
    arrays?
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 假设我们想要进行一个测验，问题可以是关于总统的名字、首都等等。我们如何使用多维数组来完成这个任务？
- en: 'A) We would just make the inner array hold three strings, perhaps like this:'
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我们只需让内部数组包含三个字符串，可能像这样：
- en: '[PRE522]'
  id: totrans-2967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: Q2) In our persistence example, we saved a continually updating string to a
    file so that it persisted after the app had been shut down and restarted. This
    is like asking the user to click on a **Save** button. Summoning all your knowledge
    of [Chapter 2](ch02.html "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it by the button click but just when the user quits the app?
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在我们的持久化示例中，我们将一个持续更新的字符串保存到文件中，以便在应用程序关闭并重新启动后持久化。这就像要求用户点击**保存**按钮一样。回顾一下你对[第2章](ch02.html
    "第2章。Android入门")，*Android入门*的所有知识，你能想出一种方法来保存字符串，而无需通过按钮点击，只需当用户退出应用程序时？
- en: 'A) Override the `onPause` life cycle method and put the code to save the string
    in there, like this:'
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: A) 覆盖`onPause`生命周期方法，并将保存字符串的代码放在那里，如下所示：
- en: '[PRE523]'
  id: totrans-2970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Q3) Other than increasing the difficulty level, how could we make the memory
    game harder?
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 除了提高难度级别，我们还能如何使记忆游戏更难？
- en: 'A) We could simply alter the pause in our thread execution to mention a lower
    number, giving the player less thinking time, like this:'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我们可以简单地改变线程执行中的暂停时间，提到一个更小的数字，给玩家更少思考的时间，如下所示：
- en: '[PRE524]'
  id: totrans-2973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer. Can you work out how to
    use an image for our button background?
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 使用朴素的Android UI和单调的灰色按钮并不令人兴奋。看看视觉设计器中的UI元素。你能想出如何使用图片作为我们的按钮背景吗？
- en: A) Simply add some `.png` graphics to the `drawable-mdpi` folder and then find
    the background property in the **Properties** window while your button is selected.
    Click to edit the property in the usual way and choose the graphic you added to
    the `drawable-mdpi` folder.
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: A) 只需将一些`.png`图形添加到`drawable-mdpi`文件夹中，然后在按钮被选中时找到**属性**窗口中的背景属性。以通常的方式单击编辑属性并选择添加到`drawable-mdpi`文件夹中的图形。
- en: Chapter 6
  id: totrans-2976
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Q1) What is encapsulation?
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 封装是什么？
- en: A) Encapsulation is the way we pack our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to the parts of our app
    (or any app that uses our classes) that we want.
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: A) 封装是我们将变量、代码和方法打包的方式，只向我们的应用程序（或使用我们类的任何应用程序）的特定部分和功能暴露我们想要的那些部分。
- en: Q2) I don't get all this, and actually, I have more questions now than I had
    at the start of the chapter. What should I do?
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 我不明白这些，实际上，我现在比章节开始时的问题更多。我该怎么办？
- en: A) You know enough about OOP to make significant progress with games and any
    other type of Java programming. If you are desperate to know more OOP right now,
    there are plenty of highly rated books that discuss nothing but OOP. However,
    practice and familiarity with the syntax will go a long way to achieving the same
    thing and will probably be more fun. The deciding factor in whether you rush off
    and learn the intricate details of OOP now will really depend on your personal
    goals and what you want to do with your programming skills in the future. Read
    the last few pages of [Chapter 9](ch09.html "Chapter 9. Making Your Game the Next
    Big Thing"), *Making Your Game the Next Big Thing*, for more discussion.
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你对OOP的了解足以在游戏和其他类型的Java编程中取得重大进展。如果你现在迫切想了解更多OOP，有很多高度评价的书籍专门讨论OOP。然而，实践和对语法的熟悉将有助于达到同样的效果，并且可能会更有趣。你是否现在匆忙学习OOP的复杂细节，真正取决于你的个人目标和你在未来想用你的编程技能做什么。阅读[第9章](ch09.html
    "第9章。让你的游戏成为下一个大热门")的最后几页，*让你的游戏成为下一个大热门*，了解更多讨论。
- en: Chapter 7
  id: totrans-2981
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Q1) The speed of the ball is calculated in pixels. Different devices have different
    numbers of pixels. Can you explain how to make the ball speed approximately the
    same on different screen resolutions?
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 球的速度是以像素计算的。不同设备有不同的像素数。你能解释如何使球的速度在不同屏幕分辨率上大致相同吗？
- en: 'A) A simple way to accommodate different screen resolutions would be to devise
    a system that that takes into account the number of pixels the screen has. We
    have already done this for the racket and ball sizes. We could declare a member
    variable like this:'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: A) 适应不同屏幕分辨率的一个简单方法就是设计一个考虑屏幕像素数的系统。我们已经为球拍和球的大小做了这件事。我们可以声明一个成员变量，如下所示：
- en: '[PRE525]'
  id: totrans-2984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: 'We could then initialize these variables in `onCreate` after we have obtained
    the screen dimensions:'
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在获得屏幕尺寸后，在`onCreate`方法中初始化这些变量：
- en: '[PRE526]'
  id: totrans-2986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: 'Then we can move our ball a bit, like this:'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以稍微移动球，如下所示：
- en: '[PRE527]'
  id: totrans-2988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: Chapter 8
  id: totrans-2989
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: Q1) What about a visual improvement for our game screen, perhaps a nice, light
    green grassy background instead of just black?
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 关于我们游戏屏幕的视觉改进，或许是一个漂亮的浅绿色草地背景，而不是仅仅黑色？
- en: 'A) You can use most graphics programs such as Gimp or Photoshop to get the
    RGB value of a nice, light green grassy color. Alternatively, you can use an online
    color picker such as [http://www.colorpicker.com/](http://www.colorpicker.com/).
    Then look at this line in our `drawGame` method:'
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你可以使用大多数图形程序，如Gimp或Photoshop，来获取漂亮的浅绿色草地颜色的RGB值。或者，你可以使用在线颜色选择器，如[http://www.colorpicker.com/](http://www.colorpicker.com/)。然后看看我们`drawGame`方法中的这一行：
- en: '[PRE528]'
  id: totrans-2992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: 'Change it to the following line:'
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
  zh: 改成以下行：
- en: '[PRE529]'
  id: totrans-2994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: Q2) How about adding some nice flowers to the background?
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在背景中添加一些漂亮的花朵怎么样？
- en: A) Here is the way to do this. Create a flower bitmap (or use mine), load it,
    and scale it in the usual way, in the `configureDisplay` method. Decide how many
    flowers to draw. Choose and store locations on the board in the `SnakeView` constructor
    (or write and call a special method, perhaps `plantFlowers`).
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: A) 这是这样做的方法。创建一个花朵位图（或使用我的），加载它，并在`configureDisplay`方法中以通常的方式缩放它。决定要绘制多少朵花。在`SnakeView`构造函数中选择并存储板上的位置（或编写并调用一个特殊的方法，可能是`plantFlowers`）。
- en: Draw them before the snake and the apple in the `drawGame` method. This will
    ensure that they can never hide an apple or a part of the snake. You can see my
    specific implementation in the methods mentioned and a copy of the flower bitmap
    in the `EnhancedSnakeGame` project in the `Chapter8` folder.
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawGame`方法中在蛇和苹果之前绘制它们。这将确保它们永远不会隐藏苹果或蛇的一部分。你可以在提到的方法中看到我的具体实现，以及`EnhancedSnakeGame`项目中的`Chapter8`文件夹中的花朵位图副本。
- en: Q3) If you're feeling brave, make the flowers sway. Think of sprite sheets.
    The theory is exactly the same as that of the animated snake head. We just need
    a few lines of code to control the frame rate separately from the game frame rate.
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 如果你感到勇敢，让花朵摇摆。想想精灵图集。理论与动画蛇头的理论完全相同。我们只需要几行代码来控制帧率，而不是游戏帧率。
- en: A) Take a look at the new code in the `controlFPS` method. We simply set up
    a new counter for flower animations to switch flower frames once every six game
    frames. You can also copy the sprite sheet from the `EnhancedSnakeGame` project
    in the `Chapter8` folder.
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: A) 看看`controlFPS`方法中的新代码。我们只是为花朵动画设置了一个新的计数器，以便每六帧游戏帧切换一次花朵帧。你也可以从`Chapter8`文件夹中的`EnhancedSnakeGame`项目复制精灵图集。
- en: Q4) We could set up another counter and use our snake head animation, but it
    wouldn't be that useful because the subtle tongue movements would be barely visible
    due to the smaller size. Nevertheless, we could quite easily swish the tail segment.
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 我们可以设置另一个计数器并使用我们的蛇头动画，但这不会很有用，因为由于尺寸较小，微妙的舌头动作几乎看不见。尽管如此，我们相当容易地摆动尾巴段。
- en: A) There is a two-frame tail bitmap in the `EnhancedSnakeGame` project in the
    `Chapter8` folder. As this is also two frames, we could use the same frame timer
    as that used for the flower. Take a look at the implementation in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. The only required changes are in `configureDisplay`
    and `drawGame`.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: A) 在`EnhancedSnakeGame`项目的`Chapter8`文件夹中有一个两帧的尾巴位图。由于这也是两帧，我们可以使用与花朵相同的帧计时器。看看`EnhancedSnakeGame`项目中的`Chapter8`文件夹中的实现。唯一需要更改的是`configureDisplay`和`drawGame`。
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
  zh: Q5) 这里是一个稍微有点棘手的增强。你无法不注意到，当蛇精灵朝向四个可能方向中的三个时，它们看起来并不正确。你能修复这个问题吗？
- en: A) We need to rotate them depending upon the way they are heading. Android has
    a `Matrix` class, which allows us to easily rotate Bitmaps, and the `Bitmap` class
    has an overloaded version of the `createBitmap` method that takes a `Matrix` object
    as an argument.
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我们需要根据它们的朝向来旋转它们。Android有一个`Matrix`类，它允许我们轻松地旋转位图，`Bitmap`类有一个重载的`createBitmap`方法，它接受一个`Matrix`对象作为参数。
- en: 'So we can create a matrix for each angle we need to handle, like this:'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以为每个需要处理的角创建一个矩阵，如下所示：
- en: '[PRE530]'
  id: totrans-3005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'Then we can rotate a bitmap using the following code:'
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码旋转位图：
- en: '[PRE531]'
  id: totrans-3007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: 'Another problem is that as the snake twists and turns, how do we keep track
    of the individual orientation of each segment? We already have a direction finding
    scheme: 0 is up, 1 is right, and so on. So we can just create another array for
    the orientation of each segment that corresponds to a body segment in the `snakeX`
    and `snakeY` arrays. Then all we need to do is to ensure that the head has the
    correct direction, and update from the back on each frame just as we do for the
    snake''s coordinates. You can see this implemented in the `EnhancedSnakeGame`
    project in the `Chapter8` folder.'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们如何跟踪蛇的每个部分的独立方向？我们已经有了一个寻找方向的方案：0是向上，1是向右，以此类推。因此，我们只需为每个部分创建另一个数组，以对应`snakeX`和`snakeY`数组中的身体部分。然后我们只需要确保头部有正确的方向，并在每一帧从后向前更新，就像我们更新蛇的坐标一样。你可以在`Chapter8`文件夹中的`EnhancedSnakeGame`项目中看到这个实现。
- en: The finished project with a few more enhancements is in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. This is the version we will be using as a starting
    point in the next and final chapter. You can also download the game from Google
    Play at [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame).
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些增强后的完成项目位于`Chapter8`文件夹中的`EnhancedSnakeGame`项目中。这是我们将在下一章和最后一章中作为起点使用的版本。你还可以从Google
    Play下载游戏，链接为[https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame)。
- en: '![Chapter 8](img/8859OS_Appendix_01.jpg)![Chapter 8](img/8859OS_Appendix_02.jpg)'
  id: totrans-3010
  prefs: []
  type: TYPE_IMG
  zh: '![第8章](img/8859OS_Appendix_01.jpg)![第8章](img/8859OS_Appendix_02.jpg)'
- en: Chapter 9
  id: totrans-3011
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Q1) Try to implement the local high scores on the device.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 尝试在设备上实现本地高分。
- en: A) You already know how to do this. Just go back to [Chapter 5](ch05.html "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials* in case you are unsure. The
    implementation is in the code for this chapter's project as well.
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你已经知道如何做这件事了。如果你不确定，只需回到[第5章](ch05.html "第5章。游戏与Java基础")，*游戏与Java基础*。这个章节的项目代码中也有实现。
- en: Q2) How many eminent computer scientists have made cameo appearances in the
    code throughout this book?
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在这本书的代码中，有多少著名的计算机科学家在代码中客串出现？
- en: A) 9
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: A) 9
- en: Ada Lovelace
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: 艾达·洛夫莱斯
- en: Charles Babbage
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·巴贝奇
- en: Alan Turing
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 阿兰·图灵
- en: Vinton Cerf
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
  zh: 文顿·瑟夫
- en: Jeff Minter
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 杰夫·米纳
- en: Corrine Yu
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 科琳·尤
- en: André LaMothe
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈·拉莫斯
- en: Gabe Newell
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 加布·纽维尔
- en: Sid Meier
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 西德·梅尔
- en: Why not search on the Web for some of these names? There are some interesting
    stories about each of them.
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在网上搜索这些名字呢？关于他们每个人都有一些有趣的故事。
