- en: Chapter 7. Key-value Programming Approaches
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 键值编程方法
- en: Key-value coding is a really cool function that works well with key-value observing.
    It allows you to code less and create very elegant solutions and code modules.
    There are many cases in a real application when something changes and another
    part of the application should be affected. The thing is that you can do anything
    when a property of an instance or class changes, including but not limited to
    checking whether its value is valid, sending a message to someone when something
    changes to a certain value, and so on. The options are unlimited.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 键值编码是一个真正酷的功能，它与键值观察配合得很好。它允许你编写更少的代码，并创建非常优雅的解决方案和代码模块。在实际应用中，有许多情况是某个东西发生变化，而应用的另一部分应该受到影响。问题是，当实例或类的属性发生变化时，你可以做任何事情，包括但不限于检查其值是否有效，当某个值发生变化时向某人发送消息，等等。选项是无限的。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is key-value coding?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是键值编码？
- en: The NSKeyValueCoding protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSKeyValueCoding 协议
- en: Manual subsets of the NSKeyValueCoding behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSKeyValueCoding 行为的手动子集
- en: Associated objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联对象
- en: Selectors as keys
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器作为键
- en: Maximum flexibility and handling unusual keys/values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大灵活性和处理不寻常的键/值
- en: Also, do note that the NSKeyValueCoding protocol has been available since Mac
    OS X 10.0 in Cocoa, and it has also made its appearance in iOS 2.0, which came
    out in July 11, 2008\. Generally, APIs for iOS and Mac tend to make their appearance
    on the Mac platform first before making their appearance on the iOS platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，NSKeyValueCoding 协议自 Cocoa 中的 Mac OS X 10.0 以来就已经可用，它也出现在了 2008 年 7 月
    11 日发布的 iOS 2.0 中。一般来说，iOS 和 Mac 的 API 通常是先在 Mac 平台上出现，然后再在 iOS 平台上出现。
- en: What is key-value coding or KVC?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是键值编码或 KVC？
- en: 'Key-value coding is basically a mechanism to indirectly access an object''s
    properties, rather than explicitly getting and setting those properties via instance
    variables. With KVC, we use strings as properties keys, which act as an identifier.
    It is used by passing a "key", which is a string to get or set the property related
    to that key. For example, take a look at the following code sample:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 键值编码基本上是一种间接访问对象属性的方法，而不是通过实例变量显式获取和设置这些属性。使用 KVC，我们使用字符串作为属性键，它充当一个标识符。它通过传递一个“键”，即一个字符串来获取或设置与该键相关的属性。例如，看看以下代码示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created `DogClass` with two properties of `NSString`
    and `NSInteger`. Then, we used `valueForKey` and `setValue` to get the value of
    `dog_name` and `number_legs` respectively using key-value coding.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了具有两个 `NSString` 和 `NSInteger` 属性的 `DogClass`。然后，我们使用 `valueForKey`
    和 `setValue` 通过键值编码分别获取 `dog_name` 和 `number_legs` 的值。
- en: If this sounds familiar to you, you may recognize the syntactical similarity
    when using NSDictionary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很熟悉，你可能在使用 NSDictionary 时会注意到语法上的相似性。
- en: 'There is another sample code, which you can refer to for more clarification.
    Let''s check out the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个示例代码，你可以参考以获得更多澄清。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some developers who were introduced to Objective-C earlier disliked this approach
    of setting the property explicitly using the dot operator as seen in `myObject.myProperty
    = myValue`, but it is essentially helpful since it separates the property involved
    in the setting process from the action of setting itself. A normal setter is applicable
    in this context, but writing your own setters will mean that you are writing a
    lot of boilerplate code and this will make your code more verbose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些早期接触 Objective-C 的开发者不喜欢使用点操作符显式设置属性的方法，就像在 `myObject.myProperty = myValue`
    中看到的那样，但这种方法本质上是有帮助的，因为它将设置过程中涉及的属性与设置动作本身分离开来。在这个上下文中，一个正常的设置器是适用的，但编写你自己的设置器意味着你将编写大量的样板代码，这会使你的代码更加冗长。
- en: Basically, your app's accessor methods will implement the methods and patterns
    signatures determined by the KVC. The task of those accessor methods is to provide
    a way into the property values of your application's data models. There are two
    of them, `set` and `get` accessors. The `set` accessors—also known as `setters`—set
    the property's value, while the get ones—also known as `getters`—get/return the
    property's value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你的应用程序的访问器方法将实现由 KVC 确定的方法和模式签名。这些访问器方法的任务是提供一种方式来访问应用程序数据模型中的属性值。它们有两个，`set`
    和 `get` 访问器。`set` 访问器——也称为 `setters`——设置属性的值，而 `get` 访问器——也称为 `getters`——获取/返回属性的值。
- en: 'Imagine a `NSTableViewDataSource` method to handle an edit for one of the rows,
    other than the default one, without it being KVC. It should look like the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有一个`NSTableViewDataSource`方法来处理除了默认之外的一行编辑，而不使用KVC。它应该看起来像以下代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, as soon as we can use KVC, the method can be like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们可以使用KVC，方法可以像这样：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The essence of KVC is shown here; it's a better approach because each property's
    edit doesn't need to be handled as a separate condition. Another huge advantage
    is its efficiency since a table with thousands of columns will be handled by the
    same code, not even a line added to it. Notice that in the first example, we needed
    to have two `if` loops to handle two different identifiers, but using KVC, we
    can cut down on the verbose code and use `setValue` instead and achieve the same
    result with just one statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了KVC的本质；它是一个更好的方法，因为每个属性的编辑不需要作为单独的条件来处理。另一个巨大的优点是它的效率，因为一个有数千列的表将由相同的代码处理，甚至不需要添加一行。注意，在第一个例子中，我们需要有两个`if`循环来处理两个不同的标识符，但使用KVC，我们可以减少冗长的代码，使用`setValue`代替，并且只需一条语句就能达到相同的结果。
- en: Besides the fact that key-value coding simplifies your code, implementing its
    compliant accessors is an effective design principle, and it helps the data encapsulation
    and makes it easier to work with key-value observing—which we will cover later—and
    other technologies such as Cocoa bindings, Core Data, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了键值编码简化了你的代码之外，实现其兼容访问器是一个有效的设计原则，它有助于数据封装，并使得与键值观察（我们将在后面介绍）和其他技术（如Cocoa绑定、Core
    Data等）一起工作变得更加容易。
- en: '`NSKeyValueCoding` is an informal protocol that provides the essential methods
    for KVC, while `NSObject` provides its default implementations. Key-value coding
    can access three types of object values; they are attributes, one-to-one relationships,
    and one-to-many relationships, where we can access a property indirectly using
    a string.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSKeyValueCoding`是一个非正式协议，它提供了KVC的基本方法，而`NSObject`提供了其默认实现。键值编码可以访问三种类型的对象值；它们是属性、一对一关系和一对多关系，我们可以通过字符串间接访问属性。'
- en: What we call attribute is just a simple value property, so it might be a `NSString`
    or `Boolean` value, as well as `NSNumber` and other immutable object types.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的属性只是一个简单的值属性，所以它可能是一个`NSString`或`Boolean`值，以及`NSNumber`和其他不可变对象类型。
- en: When an object has properties of its own, these are known as properties, which
    are assigned a one-to-one relationship between the object and property. What is
    interesting about these properties is that they can change, without the object
    changing itself at all. To better understand this, think of a `NSView` instance's
    superview as a one-to-one relationship. A set of related objects make a one-to-many
    relationship. We can see this in `NSArray` or `NSSet` instances, where a `NSArray`
    or `NSSet` instance has a one-to-many relationship to a group of objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象具有自己的属性时，这些属性被称为属性，它们在对象和属性之间建立一对一的关系。这些属性有趣的地方在于，它们可以改变，而对象本身却没有任何改变。为了更好地理解这一点，可以想象一个`NSView`实例的superview作为一对一关系。一组相关对象构成一对多关系。我们可以在`NSArray`或`NSSet`实例中看到这一点，其中`NSArray`或`NSSet`实例与一组对象之间有一对多关系。
- en: The NSKeyValueCoding protocol
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NSKeyValueCoding`协议'
- en: The `NSKeyValueCoding` protocol is used in every sample code I've shown until
    now. I also have been calling it a protocol, but as I said earlier, it's an informal
    protocol, a `NSObject` category.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我至今展示的每个示例代码中都使用了`NSKeyValueCoding`协议。我也一直称它为协议，但正如我之前所说的，它是一个非正式协议，一个`NSObject`类别。
- en: KVC is a mechanism that enables you to indirectly access an object's properties,
    using a "key" of strings to do it. To enable KVC, `NSKeyValueCoding` must be complied
    by your classes. Most of the time, you don't need to do anything in order to get
    it done because it's complied by `NSObject`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: KVC是一种机制，允许你通过使用字符串“键”间接访问对象的属性。为了启用KVC，你的类必须遵守`NSKeyValueCoding`。大多数情况下，你不需要做任何事情就能完成它，因为它是通过`NSObject`来遵守的。
- en: To make a key-value coding compliant class for a certain property, the methods
    `setValue:forKey:` and `valueForKey:` must be implemented to work as expected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使某个属性的键值编码兼容类，必须实现`setValue:forKey:`和`valueForKey:`方法以正常工作。
- en: Compliance of attributes and one-to-one relationships
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和一对一关系的兼容性
- en: 'You must ensure that your class has the following specification in case the
    of properties that are simply attributes or one-to-one relationships; an example
    would be `[myObject setValue:myValue forKey:@"myProperty"];`, which we saw earlier:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性仅仅是属性或一对一关系，你必须确保你的类具有以下规范；一个例子是 `[myObject setValue:myValue forKey:@"myProperty"];`，这是我们之前看到的：
- en: Have an instance variable called `<key>` or `_<key>`, or have an implemented
    method called `-<key>`, which is a reference to the key in your key-value pair.
    As a rule of thumb, KVC keys start with lowercase letters, but for ones, such
    as URL, it's also acceptable if the first letter is uppercase.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为 `<key>` 或 `_<key>` 的实例变量，或者有一个名为 `-<key>` 的实现方法，这是对键值对中键的引用。一般来说，KVC 键以小写字母开头，但对于像
    URL 这样的键，如果首字母大写也是可以接受的。
- en: If the property is a mutable one, `-set<Ket>:` would be also implemented.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性是可变的，则还需要实现 `-set<Ket>:`。
- en: The implementation of the `-set<Key>:` method should not include any validation
    as validation is to be implemented by the method mentioned in the next point.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-set<Key>:` 方法的实现不应包含任何验证，因为验证将由下一点提到的方实现。'
- en: If the validation is suitable for the key, `-validate<Key>:error:` must be implemented
    here along with your validation code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证适用于该键，则必须在此处实现 `-validate<Key>:error:` 以及你的验证代码。
- en: Compliance of indexed one-to-many relationships
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引一对一关系的兼容性
- en: 'Using `NSArrays` or `NSMutableArrays` will introduce you to the concept of
    one to-many relationships, where the key-value coding compliance requirements
    for indexed to-many relationships you need to ensure are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSArrays` 或 `NSMutableArrays` 将会带你了解一对多关系的概念，对于索引多对多关系，你需要确保的关键值编码兼容性要求是：
- en: The implementation of a method called `-<key>`, returning an array
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `-<key>` 方法，返回一个数组
- en: 'Besides, you might have an `NSArray` instance variable called `<key>` or `_<key>`
    or even proceed the implementation of `-countOf<Key>` and one or all of the following:
    `-<key>AtIndexes:` or `-objectIn<Key>AtIndex:`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可能还有一个名为 `<key>` 或 `_<key>` 的 `NSArray` 实例变量，或者甚至可以继续实现 `-countOf<Key>`
    和以下一个或多个：`-<key>AtIndexes:` 或 `-objectIn<Key>AtIndex:`
- en: In order to improve performance, you can also implement `-get<Key>:range:` but
    it's not a requirement
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高性能，你也可以实现 `-get<Key>:range:`，但这不是必需的
- en: 'Otherwise, if you are dealing with mutable indexed ordered one to-many relationships,
    these are your requirements:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你处理的是可变的索引有序多对多关系，这些是你的要求：
- en: 'Get at least one of the methods implemented: `-insertObject:in<Key>AtIndex:`
    and `-insert<Key>:atIndexes:`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少实现一个方法：`-insertObject:in<Key>AtIndex:` 和 `-insert<Key>:atIndexes:`
- en: 'Get at least one of the methods implemented: `-removeObjectFrom<Key>AtIndex:`
    and `-remove<Key>AtIndexes:`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少实现一个方法：`-removeObjectFrom<Key>AtIndex:` 和 `-remove<Key>AtIndexes:`
- en: 'As an option, you can even implement one of the methods: `-replace<Key>AtIndexes:with`
    or `-replaceObjectIn<Key>AtIndex:withObject:`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为选项，你甚至可以实现以下方法之一：`-replace<Key>AtIndexes:with` 或 `-replaceObjectIn<Key>AtIndex:withObject:`
- en: Compliance of unordered many-to-many relationships
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无序多对多关系的兼容性
- en: 'NSSets are an example of an unordered collection and also have a many to-many
    relationship, so the key-value coding compliance requirements for unordered many
    to-many relationships you need to ensure are:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NSSets 是无序集合的一个例子，并且也有多对多关系，所以你需要确保的无序多对多关系的键值编码兼容性要求是：
- en: The implementation of a method called `-<key>`, returning an `NSSet`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `-<key>` 方法，返回一个 `NSSet`
- en: Otherwise, set an instance variable called `<key>` or `_<key>`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，设置一个名为 `<key>` 或 `_<key>` 的实例变量
- en: 'Or get these methods implemented: `-enumeratorOf<Key>` , `-countOf<Key>`, and
    `-memberOf<Key>:`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者实现以下方法：`-enumeratorOf<Key>`，`-countOf<Key>`，和 `-memberOf<Key>:`
- en: 'If it''s a mutable unordered to-many relationship, KVC compliance will ask
    you to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是可变的无序多对多关系，KVC 兼容性会要求你：
- en: 'Implement at least one of the following methods: `-add<Key>:` or `-add<Key>Object:`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现以下方法中的至少一个：`-add<Key>:` 或 `-add<Key>Object:`
- en: 'Implement at least one of the following methods: `-remove<Key>:` or `-remove<Key>Object:`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现以下方法中的至少一个：`-remove<Key>:` 或 `-remove<Key>Object:`
- en: In order to improve performance, you can implement `-set<Key>:` and `-insert<Key>:`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高性能，你可以实现 `-set<Key>:` 和 `-insert<Key>:`
- en: 'With NSString keys, you can set and get values using the methods `setValue:forKey:`
    and `valueForKey:`. This key is a simple string that serves as an identifier to
    an object''s property. A key must be in accordance with the following rules: starting
    with a lowercase letter, shouldn''t contain white-spaces, and make use of ASCII
    encoding. All these rules are applied in the following sample keys: `mySampleKey`,
    `pageNumber`, and `oddSum`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NSString`键，你可以使用`setValue:forKey:`和`valueForKey:`方法设置和获取值。这个键是一个简单的字符串，用作对象属性的标识符。一个键必须符合以下规则：以小写字母开头，不应包含空白字符，并使用ASCII编码。以下示例键中应用了所有这些规则：`mySampleKey`、`pageNumber`和`oddSum`。
- en: There are also key paths, they're basically a string with two or more keys separated
    by dots, as `pictures.byOwner.forYear`. If you have a hard time trying to understand,
    think about it as a UNIX directory relative path as shown here, `pictures/Vasilkoff/2014`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有键路径，它们基本上是一个由点分隔的两个或多个键的字符串，如`pictures.byOwner.forYear`。如果你很难理解，可以将其视为如这里所示的UNIX目录相对路径，`pictures/Vasilkoff/2014`。
- en: 'It''s clear that the folder 2014 is relative to `Vasilkoff`, which is relative
    to `pictures`, which in turn is relative to the user''s current directory. In
    key paths, the first key—in our preceding code sample: `pictures`—is relative
    to the receiver object.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，文件夹2014相对于`Vasilkoff`，而`Vasilkoff`相对于`pictures`，反过来又相对于用户的当前目录。在键路径中，第一个键——在我们前面的代码示例中是`pictures`——相对于接收对象。
- en: For example, using the concept of address and street as you can derive a street
    from the address. So, if you use the same concept, the `address.street` key path
    will get the value of the address property from the receiving object, and then
    you can determine the street property relative to the address object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用地址和街道的概念，你可以从地址中推导出街道。所以，如果你使用相同的概念，`address.street`键路径将从接收对象中获取地址属性的值，然后你可以根据地址对象确定街道属性。
- en: Advantages of key-value coding
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键值编码的优势
- en: Most properties support the `NSKeyValueCoding` informal protocol by default.
    Any object that inherits from `NSObject` has automatic support for `NSKeyValueCoding`.
    So, your own custom class will not have support for `NSKeyValueCoding` unless
    you explicitly make it inherit from `NSObject`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数属性默认支持`NSKeyValueCoding`非正式协议。任何从`NSObject`继承的对象都有对`NSKeyValueCoding`的自动支持。所以，你的自定义类将不会支持`NSKeyValueCoding`，除非你明确使其继承自`NSObject`。
- en: KVC will automatically look for setter and getter methods and if none is found,
    then it will even get or set instance variables.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KVC会自动查找setter和getter方法，如果找不到，它甚至会获取或设置实例变量。
- en: The possibility of using key paths is really helpful while handling multiple
    property objects.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理多个属性对象时，使用键路径的可能性非常有帮助。
- en: To be notified of the state change, KVC can be easily integrated with `NSKeyValueObserving`
    in order to implement the observer software pattern.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了通知状态变化，KVC可以很容易地与`NSKeyValueObserving`集成，以实现观察者软件模式。
- en: The possibility of dealing with undefined keys.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未定义键的可能性。
- en: This provides fallbacks.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这提供了回退机制。
- en: Disadvantages of key-value coding
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键值编码的缺点
- en: The property keys must be only `NSStrings`, which means that the compiler does
    not have any information on the type of property or any details about its existence.
    So, any type of information cannot be retrieved from the return value of ID, which
    as you know, is a pointer to an Objective-C object.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性键必须是`NSStrings`，这意味着编译器没有关于属性类型或其存在的任何信息。因此，无法从ID的返回值中检索任何类型的信息，正如你所知，ID是一个指向Objective-C对象的指针。
- en: Its extended search path makes it a very slow KVC approach.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的扩展搜索路径使其成为一个非常慢的KVC方法。
- en: The class must provide a method or an instance variable matching the name of
    the property, only then it will be found by `NSKeyValueCoding`. If there is a
    typo in your key, your application will crash during runtime and not compile time,
    so you must make sure that your key is spelled correctly to avoid a crash.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须提供一个方法或实例变量与属性名称匹配，只有这样，它才能被`NSKeyValueCoding`找到。如果你的键有误，你的应用程序将在运行时崩溃，而不是在编译时，所以你必须确保你的键拼写正确，以避免崩溃。
- en: Manual subsets of NSKeyValueCoding behavior
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSKeyValueCoding行为的手动子集
- en: The `NSKeyValueCoding` protocol acts in different ways while looking up for
    methods and instance variables. In the first case, it will look up for the method's
    selector's name, while in the last, it will look up for the instance variable's
    name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSKeyValueCoding` 协议在查找方法和实例变量时表现不同。在第一种情况下，它会查找方法选择器的名称，而在最后一种情况下，它会查找实例变量的名称。'
- en: 'This can be done manually, as we can see in the following samples:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过手动完成，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since KVC can look up for setters and getters automatically, you might only
    be required to use the preceding approach by creating your own lookup path if
    you want to avoid `NSKeyValueCoding` to find specified or ordinary methods and
    instance variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 KVC 可以自动查找设置器和获取器，如果您想避免 `NSKeyValueCoding` 查找指定的或普通的方法和实例变量，您可能只需要通过创建自己的查找路径来使用前面的方法。
- en: Advantages of creating your own lookup path
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的查找路径的优点
- en: 'To avoid `NSKeyValueCoding`, looking for methods or instance variables that
    will normally be found by `NSKeyValueCoding` and creating your own lookup path
    will be the approach you require. Let''s start with the advantages and follow
    that up with the disadvantages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用 `NSKeyValueCoding`，寻找通常由 `NSKeyValueCoding` 查找的方法或实例变量，并创建自己的查找路径将是您需要采取的方法。让我们先从优点开始，然后讨论其缺点：
- en: It may be faster than normal `NSKeyValueCoding` paths.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能比正常的 `NSKeyValueCoding` 路径更快。
- en: It gives you more control over the path. Unlike `NSKeyValueCoding` paths, it
    will also work for non `NSObject` inherited classes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它让您对路径有更多的控制。与 `NSKeyValueCoding` 路径不同，它也会适用于非 `NSObject` 继承的类。
- en: By doing it manually, non-object values can be used for get and set.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动操作，可以使用非对象值进行获取和设置。
- en: Disadvantages of creating your own lookup path
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的查找路径的缺点
- en: Generally, you will spend more time working on it than just using normal `NSKeyValueCoding`
    paths
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，您将花费比仅使用正常的 `NSKeyValueCoding` 路径更多的时间来处理它。
- en: It also provides less flexibility as you need to write more code to cover any
    unusual key/value cases, which is normally covered by the automatic method
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也提供了更少的灵活性，因为您需要编写更多的代码来覆盖任何不寻常的键/值情况，这些情况通常由自动方法覆盖。
- en: Associated objects
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联对象
- en: 'In the Objective-C 2.0 runtime used by apps in iOS and 64-bit Mac OS X, you''re
    allowed to set an association from any object to another. The object, in this
    case, without support from instance variables or methods can have a random set
    of extra properties set by the key at runtime, shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 和 64 位 Mac OS X 应用程序使用的 Objective-C 2.0 运行时中，您可以从任何对象设置关联到另一个对象。在这种情况下，对象没有实例变量或方法的支撑，可以在运行时通过键设置一组额外的属性，如下所示：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use this if you want to set a property from outside an object. If you
    would be an object and your t-shirt color a property of yours, it would be like
    someone changing its color from outside your house, and you wouldn't even notice
    it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从对象外部设置属性，可以使用它。如果您是一个对象，而您的T恤颜色是您的属性之一，那么这就像有人从您房子的外面改变它的颜色，而您甚至都没有注意到。
- en: You should use it in similar circumstances, where you want to keep the object
    away for knowing, supporting, or being involved while you set a property from
    other parts of the program. Associated objects should not be the method you want
    to use at the top of your head as lack of type information makes it easy for a
    crash to appear due to incorrect typing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在类似的情况下使用它，即您想在设置属性时让对象远离知道、支持或参与，而您从程序的其它部分设置属性。关联对象不应该是您头脑中想要使用的顶级方法，因为缺乏类型信息使得由于错误的类型而导致崩溃变得容易。
- en: Advantages of using associated objects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联对象的优点
- en: A key can be any pointer. In this case, `OBJC_ASSOCIATION_ASSIGN` can be used.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键可以是任何指针。在这种情况下，可以使用 `OBJC_ASSOCIATION_ASSIGN`。
- en: It may be the fastest key-value coding approach.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能是最快的键值编码方法。
- en: There is no support required from the method or instance variable.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要方法或实例变量的支持。
- en: Disadvantages of using associated objects
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联对象的缺点
- en: It has no effect over the object itself (instance variable or method). The object
    won't know about its own changes.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对对象本身（实例变量或方法）没有影响。对象不会知道自己的变化。
- en: In associated objects, a key is no longer `NSString`, but a pointer.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关联对象中，键不再是 `NSString`，而是一个指针。
- en: Selectors as keys
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器作为键
- en: Normally, KVC looks up for a property key and acts only after the property key
    is found. The other approach is about acting on an object's property in the lookup
    process. There is a lookup method in Objective-C core and its keys are used as
    selectors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，KVC会在找到属性键后查找属性键，并在找到后执行操作。另一种方法是在查找过程中对对象的属性进行操作。Objective-C核心中有一个查找方法，其键用作选择器。
- en: 'The following line of code is how you implement this lookup method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是如何实现这个查找方法的：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This method is very similar to the manual implementation of the instance variable's
    setter, but instead of using the key to form a selector to do a look up, it uses
    the selector itself as the key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与手动实现实例变量的设置器非常相似，但不是使用键来形成一个选择器进行查找，而是使用选择器本身作为键。
- en: Advantages of using selectors as keys
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器作为键的优势
- en: It's possible to get and set non-object data.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以获取和设置非对象数据。
- en: From all approaches that handles methods, this is the fastest one.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有处理方法的方法中，这是最快的一个。
- en: Disadvantages of using selectors as keys
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器作为键的缺点
- en: You need different selectors for get and set
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要不同的选择器来获取和设置
- en: Since selectors are not objects, it's impossible to store directly in `NSArray`
    and `NSDictionary`. Instead, you can use `NSValue` or Core Foundation
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于选择器不是对象，无法直接存储在`NSArray`和`NSDictionary`中。相反，你可以使用`NSValue`或Core Foundation
- en: Maximum flexibility and handling unusual keys/values
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大灵活性和处理不寻常的键/值
- en: After you learned so many ways to use key-value coding, there is still a very
    important way of implementation if you are looking for more flexibility while
    handling unusual keys/values. Just do it yourself. The final approach to key-value
    coding is to handle the implementation yourself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了这么多使用键值编码的方法之后，如果你在处理不寻常的键/值时寻求更多灵活性，仍然有一种非常重要的实现方式。就是自己动手做。键值编码的最终方法就是自己处理实现。
- en: Create a getter and setter method, and inside of each method properly returning
    and setting the values on a dictionary owned by the object might be the easiest
    way to do it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个获取器和设置器方法，并在每个方法中适当地在一个对象拥有的字典上返回和设置值，可能是最简单的方法。
- en: 'We can check out this approach in the following sample code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例代码中查看这种方法：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our sample code, we used `NSDictionary` for the value''s internal storage;
    however, you can use your own storage solutions, or even Cocoa key-value storage
    structures:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们使用了`NSDictionary`作为值的内部存储；然而，你可以使用自己的存储解决方案，甚至Cocoa键值存储结构：
- en: '`NSMutableDictionary`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSMutableDictionary`'
- en: '`NSMapTable`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSMapTable`'
- en: '`CFMutableDictionaryRef`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFMutableDictionaryRef`'
- en: Advantages of doing your own implementation
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行实现的优势
- en: Multiple collections can be exposed by a single object
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个对象可以暴露多个集合
- en: Any data type supported by the respective collection can be used while getting
    and setting
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取和设置时，可以使用相应集合支持的任何数据类型
- en: Among all methods of implementation, this is the most flexible one
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有实现方法中，这是最灵活的一个
- en: Disadvantages of doing your own implementation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行实现的优势
- en: It simply does not work for random objects, only the target class
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于随机对象来说，这根本不起作用，只有针对目标类才有效
- en: You're unable to use other `NSKeyValueCoding` concepts in addition to this
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了这个之外，你不能使用其他`NSKeyValueCoding`概念
- en: Key-value observing
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键值观察
- en: 'Key-value observing—also known as KVO—is a way to get notified about changes
    in a variable, but only if it was changed using KVC. We can highlight two things
    out of this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 键值观察——也称为KVO——是一种在变量更改时得到通知的方法，但仅当它使用KVC更改时。我们可以从这个中突出两点：
- en: Firstly, you need KVC in order to do KVO
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要KVC才能进行KVO
- en: Secondly, if a variable is changed directly without key-value coding by its
    default setter and getter methods, you won't get notified at all
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，如果一个变量直接通过其默认的设置器和获取器方法更改，而没有使用键值编码，你将不会得到任何通知
- en: Every variable in any key path can be observed by an object. It's useful if
    you consider using KVO. As KVO is built on top of KVC, you need KVC to implement
    KVO, and using KVO should be one of the reasons why you need to use KVC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何键路径中的任何变量都可以由一个对象进行观察。如果你考虑使用KVO，这很有用。由于KVO建立在KVC之上，你需要KVC来实现KVO，使用KVO应该是你需要使用KVC的原因之一。
- en: Implementing key-value observing
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现键值观察
- en: It is relatively easy to implement KVO, as we shall see in the following code
    example. On the specified key path, you add an observer. After this, you can create
    a method that will be called anytime the observer sees modifications in the variables
    on its key path.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现KVO相对容易，正如我们将在下面的代码示例中看到的那样。在指定的键路径上添加一个观察者。之后，你可以创建一个方法，当观察者在其键路径上看到变量发生变化时，该方法将被调用。
- en: 'An object can be registered as an observer by using the following method from
    `NSKeyCodingProtocol: addObserver:forKeyPath:options:context:`. Anytime a modification
    is performed, the following method is called `observeValueForKeyPath:ofObject:change:context:`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法从`NSKeyCodingProtocol`注册对象作为观察者：`addObserver:forKeyPath:options:context:`。任何修改执行时，都会调用以下方法`observeValueForKeyPath:ofObject:change:context:`。
- en: 'Firstly, go to your class and add the following method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入你的类并添加以下方法：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you saw earlier, this method is called when any modification is performed.
    However, the protocol is even more powerful than this; it gives you the possibility
    to be notified about a change before it occurs and also after it''s done, by using
    the respective methods: `willChangeValueForKey` and `didChangeValueForKey`. You
    might consider these methods if you need time-specific notifications.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，此方法在执行任何修改时被调用。然而，该协议比这更强大；它允许您在变化发生之前和之后通过使用相应的方法：`willChangeValueForKey`和`didChangeValueForKey`来通知变化。如果您需要时间特定的通知，您可以考虑这些方法。
- en: 'Let''s check out the following code where we register an object as an observer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码，其中我们注册一个对象作为观察者：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you look carefully, you will notice that we've used the options `NSKeyValueObservingOptionNew`
    and `NSKeyValueObservingOptionOld`. Both are used if we want to know the old and
    new values. These values will be stored in our dictionary of changes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会注意到我们使用了选项`NSKeyValueObservingOptionNew`和`NSKeyValueObservingOptionOld`。这两个选项都在我们需要知道旧值和新值时使用。这些值将存储在我们的更改字典中。
- en: 'In our example, let''s assume that development stages are represented by levels,
    `NSInteger` values from *0* to *10*, and at every modification, we need to inform
    our progress. In this case, we will create two simple methods to do it for us:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，让我们假设开发阶段由级别表示，`NSInteger`值从*0*到*10*，并且每次修改时我们都需要通知我们的进度。在这种情况下，我们将创建两个简单的方法来为我们完成这项工作：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The two preceding methods are now complete; one will inform no progress if the
    development stage doesn't change—we will consider that it's impossible to decrease,
    in our scenario, and the other one will inform the real progress by levels if
    the development stage changes. However, now, we want to call the properly methods
    after comparing the values. Remember we used the options `NSKeyValueObservingOptionNew`
    and `NSKeyValueObservingOptionOld`; they will save the old and the new values
    after a change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个方法现在已完成；一个将在开发阶段没有变化时不会通知进度——在我们的场景中，我们将考虑这是不可能减少的，另一个将在开发阶段变化时通过级别通知真实进度。然而，现在，我们想要在比较值之后调用适当的方法。记住我们使用了选项`NSKeyValueObservingOptionNew`和`NSKeyValueObservingOptionOld`；它们将在变化后保存旧值和新值。
- en: 'The old and new values will be handled inside the method that is called when
    the observer notifies a modification, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当观察者通知修改时，旧值和新值将在调用该方法的内部进行处理，如下所示：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we make sure that if the observed key is the one we are
    actually looking for, just to be really sure—in our case, the key is `developmentStage`.
    Then, we store the old and the new values in order to compare them. If there are
    positive changes, inform the progress, if not, call the other method to inform
    about the bad news.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们确保如果观察到的键是我们真正要找的，只是为了确保——在我们的例子中，键是`developmentStage`。然后，我们将旧值和新值存储起来以便比较。如果有积极的变化，通知进度，如果没有，调用其他方法通知坏消息。
- en: This is a real handy tool, even more if it is used cleverly as it is really
    powerful since it allows us to observe or watch a KVC key path on an object and
    to be notified when the value of the object changes, which can be useful in some
    programming contexts. Having control even on the change of your properties is
    a really powerful feature, and I'm sure you will find great cases to use in your
    own projects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常实用的工具，尤其是如果它被巧妙地使用，因为它真的很强大，因为它允许我们观察或监视对象上的KVC键路径，并在对象值发生变化时收到通知，这在某些编程环境中可能很有用。即使在属性变化上也能有所控制，这是一个非常强大的功能，我相信您将在自己的项目中找到很多很好的用例。
- en: Performance considerations
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: You must be careful while overriding KVC methods implementation as the default
    implementation caches Objective-C runtime information in order to be more effective
    and less erroneous, and unnecessary overriding implementations can affect the
    performance of your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写KVC方法实现时，你必须小心，因为默认实现会缓存Objective-C运行时信息，以便更有效且更少出错，不必要的重写实现可能会影响你应用程序的性能。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have taken a deep dive into key-value coding and other details such
    as various implementation methods, their advantages and disadvantages, and also
    key-value observing—a mechanism built on top of key-value coding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入探讨了键值编码和其他细节，例如各种实现方法、它们的优缺点，以及键值观察——这是建立在键值编码之上的一个机制。
- en: We also saw some working code for key-value coding and key-value observing with
    some explanation on why we prefer to use key-value coding over other similar methods
    such as using a dot operator to access properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一些关于键值编码和键值观察的工作代码，并解释了为什么我们更倾向于使用键值编码而不是其他类似方法，例如使用点操作符来访问属性。
- en: With this, I hope all these will help to give you an understanding of key-value
    coding and key-value observing. So with this, let's move on to the next chapter
    where we will wade into the brand new language by Apple called Swift.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我希望这能帮助你理解键值编码和键值观察。因此，让我们继续前进到下一章，我们将深入探讨苹果公司推出的全新语言Swift。
