- en: Enemy Characters with AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有AI的敌人角色
- en: In the previous chapter, we saw how to import 3D geometry and textures into
    the project, set up the character and add animation to the character. In this
    chapter, we will put that knowledge to use and start making a fighting game with
    basic control scheme.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何将3D几何和纹理导入到项目中，设置角色并给角色添加动画。在这一章中，我们将运用这些知识，开始制作一个具有基本控制方案的动作游戏。
- en: We will import the player character first and set the different animation frames
    required for the different animations for the fighting like idle, punch, block,
    and get hit. We will also be creating the different states using the Animation
    Controller. Animation Controller let us decide the animation flow based on the
    behavior of the character.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入玩家角色，并为不同的战斗动画设置所需的动画帧，如空闲、出拳、阻挡和被击中。我们还将使用动画控制器创建不同的状态。动画控制器让我们可以根据角色的行为来决定动画流程。
- en: We will also be looking at game balancing and how to be fair to the player.
    If the game is unfair, the player will get frustrated and quit the game and will
    not recommend the game to anyone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨游戏平衡以及如何公平对待玩家。如果游戏不公平，玩家会感到沮丧并退出游戏，并且不会向任何人推荐这款游戏。
- en: We will be implementing controls using mouse and keyboard but, in a later chapter,
    we will see how to implement touch controls for handheld devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用鼠标和键盘来实现控制，但在后面的章节中，我们将看到如何为手持设备实现触摸控制。
- en: At the end of the chapter we will have a basic fighting system in which we get
    to hit the enemy and the enemy will take hits or block our attack.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个基本的战斗系统，其中我们可以击打敌人，敌人会受到打击或阻挡我们的攻击。
- en: 'This chapter includes the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Importing player model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入玩家模型
- en: Creating player using Animation Controller
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画控制器创建玩家
- en: Scripting player controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写玩家控制脚本
- en: Adding enemy character
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加敌人角色
- en: Enemy behavior and AI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人行为和AI
- en: Finalizing the fight
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成战斗
- en: Importing the player model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入玩家模型
- en: First, make sure you create a new Unity 3D project. This is not like the first
    project we created as this is going to be a 3D project, not a 2D project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你创建一个新的Unity 3D项目。这不像我们之前创建的第一个项目，因为这个项目是一个3D项目，而不是2D项目。
- en: 'Once you''ve created the project, you will find the `Dude.FBX` file in the
    assets for this chapter, so drag and drop the file into the Unity project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，你将在本章的资产中找到`Dude.FBX`文件，所以将文件拖放到Unity项目中：
- en: '![](img/image_04_001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_001.png)'
- en: 'In your case the model will be gray, not red as shown here. To make it red,
    double-click on the `Materials` folder. You will see the `01- Default` file. When
    you select it, you''ll will get an option to change the color of the object. Click
    on the gray box next to the Albedo option in the Inspector panel and select a
    red color to change the color of the character:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，模型将是灰色，而不是像这里显示的红色。要使其变红，双击`材质`文件夹。你会看到`01- Default`文件。当你选择它时，你会得到一个选项来更改物体的颜色。点击检查器面板中Albedo选项旁边的灰色方块，并选择红色来更改角色的颜色：
- en: '![](img/image_04_002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_002.png)'
- en: 'The next thing that needs to be done by us is to create animation clips for
    all the animations that we have in the game. Click on the Dude character in the
    `Assets` folder of the project. Now look at the Inspector pane. In the Inspector
    pane you will see three tabs called Model, Rig, and Animations, as shown in the
    following screenshot. Click on the Animations tab:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是为游戏中所有的动画创建动画剪辑。点击项目“资产”文件夹中的Dude角色。现在查看检查器面板。在检查器面板中，你会看到三个标签页，分别称为模型、绑定和动画，如下面的截图所示。点击动画标签页：
- en: '![](img/image_04_003.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_003.png)'
- en: This shows all the animation clips that currently exist. As of now, there is
    only one animation clip, called `Take 001`, that starts at 0 and ends at 80 frames.
    You can even preview the animation by clicking on the play button at the bottom
    of the panel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了当前存在的所有动画剪辑。到目前为止，只有一个动画剪辑，名为`Take 001`，从第0帧开始，到第80帧结束。你甚至可以通过点击面板底部的播放按钮来预览动画。
- en: You will see that `Take 001` has all the animations that were imported, along
    with the FBX file, and it has the idle, guard, punch and get hit animations. Since
    all the animations are in a single clip, we have to break up the animations into
    individual clips.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`Take 001`包含了所有导入的动画，以及FBX文件，包括空闲、防御、出拳和被击中的动画。由于所有动画都在一个剪辑中，我们必须将动画拆分成单独的剪辑。
- en: 'To do that, first we extract the idle clip which runs from frame 0 to frame
    29\. So, we change the name to idle and set the end frame to 29 for the animation
    clip as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，首先我们需要提取从帧0到帧29的空闲剪辑。因此，我们将名称更改为空闲，并将动画剪辑的结束帧设置为29，如下面的截图所示：
- en: '![](img/image_04_004.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_004.png)'
- en: Make sure to click on the Apply button at the bottom for the changes to take
    effect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保点击底部的应用按钮以使更改生效。
- en: Also, observe that the Loop Time checkbox is ticked. This is because the animation
    has to be looped so if we don't check this box, then the animation will just play
    once and stop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，循环时间复选框已被勾选。这是因为动画需要循环播放，如果我们不勾选此框，则动画将只播放一次并停止。
- en: 'Now let''s extract the second animation clip which is the `guard`/`defend`
    animation. For this click on the + icon in the Clips menu. This will create a
    default animation called `Take 001` as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提取第二个动画剪辑，即“守卫”/“防御”动画。为此，在剪辑菜单中点击加号图标。这将创建一个默认动画，称为“Take 001”，如下面的截图所示：
- en: '![](img/image_04_005.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_005.png)'
- en: 'Now, once again, select the Take 001 clip, rename it to defend, and change
    the start and end time to 32 and 49\. Click Loop Time and click on the Apply button
    at the end:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次选择“Take 001”剪辑，将其重命名为defend，并将开始和结束时间更改为32和49。点击循环时间，并在最后点击应用按钮：
- en: '![](img/image_04_006.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_006.png)'
- en: Now add the animation clip for **punch** and **getHit** animations as well.
    The punch animation starts from 51 and ends at 60 and the getHit animation starts
    at 71 and ends at 75.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加**打击**和**被击中**动画的动画剪辑。打击动画从51开始，到60结束，被击中动画从71开始，到75结束。
- en: 'For these animations, the Loop Time option doesn''t need to be checked as they
    don''t need to loop. Once you have all the required animations, the Clips window
    should look like the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些动画，不需要勾选循环时间选项，因为它们不需要循环。一旦你有了所有所需的动画，剪辑窗口应该看起来像下面的截图：
- en: '![](img/image_04_007.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_007.png)'
- en: Once we have finished extracting the animations, we can create the Animation
    Controller for the player character.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了动画的提取，我们就可以为玩家角色创建动画控制器。
- en: Player Animation Controller
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家动画控制器
- en: 'To create a new Animation Controller right-click on the `Assets` folder in
    the project, select the Create option, and then select Animation Controller from
    the list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的动画控制器，请在项目中的“资产”文件夹上右键单击，选择创建选项，然后从列表中选择动画控制器：
- en: '![](img/image_04_008.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_008.png)'
- en: 'Rename the file to dudeAC and double-click on it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件重命名为dudeAC，并双击它：
- en: '![](img/image_04_009.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_009.png)'
- en: 'When you double-click on it, a new panel will open up called Animation, as
    shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你双击它时，将打开一个名为动画的新面板，如下面的截图所示：
- en: '![](img/image_04_010.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_010.png)'
- en: 'The Animation Controller basically controls the flow of the animation. There
    are three states that are added in by default; these are Entry, Any State, and
    Exit:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器基本上控制动画的流程。默认添加了三个状态；这些是入口、任何状态和退出：
- en: The Entry state specifies which animation will be played at the start of the
    scene. So, in most cases the first animation that gets played is the idle animation.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口状态指定在场景开始时播放哪个动画。因此，在大多数情况下，首先播放的是空闲动画。
- en: The Any State specifies which animation needs to be executed irrespective of
    the previous animation that is being played.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何状态指定无论之前播放的动画是什么，都需要执行哪个动画。
- en: The Exit state is the animation that is played at the exit of the scene.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出状态是在场景退出时播放的动画。
- en: Let's set up the states for the player, which will be the same setup for the
    enemy as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置玩家的状态，敌人的设置也将相同。
- en: 'First, we will create the default animation so that, when the scene starts,
    the idle animation gets played. In the Animator panel, right-click anywhere, select
    Create State option from the list, and then select the Empty option, as depicted
    in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建默认动画，以便当场景开始时，播放空闲动画。在动画器面板中，右键单击任何位置，从列表中选择创建状态选项，然后选择空选项，如下面的截图所示：
- en: '![](img/image_04_011.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_011.png)'
- en: Select the New State created and open the Inspector panel.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择创建的新状态，并打开检查器面板。
- en: 'Next, we need to create a transition from the Entry state. Right-click on it,
    a Make transition option will open, so click on this option. An arrow will start
    from the clicked state. Now click on the state that we need to transition. This
    will create a transition to that new state as depicted in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从入口状态创建一个转换。右键单击它，将打开“创建转换”选项，因此点击此选项。从点击的状态开始出现一个箭头。现在点击我们需要转换到的状态。这将创建到该新状态的转换，如以下截图所示：
- en: '![](img/image_04_012.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_012.png)'
- en: 'Next, rename the new state to idle. Click on the new state and rename the state
    to Idle and change the Motion field to idle by selecting the small circle next
    to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将新状态重命名为空闲。点击新状态，将状态重命名为Idle，并通过选择它旁边的小圆圈将运动字段更改为空闲：
- en: '![](img/image_04_013.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_013.png)'
- en: 'To test if the controller works, drag and drop `theDude` character on to the
    hierarchy and place him perpendicular to the camera as shown in the following
    screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试控制器是否工作，将`theDude`角色拖放到层次结构中，并将其放置在相机垂直的位置，如图以下截图所示：
- en: '![](img/image_04_014.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_014.png)'
- en: 'Select the Dude character in the scene and in the Inspector panel, then drag
    and drop the Animation Controller on the Controller field in the Animator component
    as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中选择Dude角色，然后在检查器面板中，将动画控制器拖放到动画组件中的控制器字段，如图以下截图所示：
- en: '![](img/image_04_015.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_015.png)'
- en: Click the play button up top and you should see the character with the idle
    animation playing. Now that we are sure that it is working properly, we can go
    into the Animation Controller and add states that are required for the game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击顶部的播放按钮，你应该会看到带有空闲动画的角色正在播放。现在我们已经确认它工作正常，我们可以进入动画控制器并添加游戏中所需的状态。
- en: In Any State state, we should be able to have the defend, Punch and also GetHit
    animations. If the player is not in any of these states then he should revert
    to idle state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何状态状态下，我们应该能够拥有防御、拳头和被击中动画。如果玩家不处于这些状态中的任何一个，他应该回到空闲状态。
- en: So, in the Animation Controller, add the three states, attach the respective
    animations in the motion, and change the name of each state accordingly. After
    creating the three states, we also need to transition between the Any State state
    and each of these states, and when each of the states has finished, it needs to
    transition back to the idle state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在动画控制器中，添加三个状态，将相应的动画附加到运动中，并相应地更改每个状态的名字。在创建三个状态后，我们还需要在“任何状态”状态和这些状态之间进行转换，并且当每个状态完成时，它需要转换回空闲状态。
- en: 'To create a transition from a given state, right-click on it: a Make Transition
    option will open. Click on it, and an arrow will start from the clicked state.
    Next, click on the state that we want to transition to. This will create a transition
    to that state. The transitions are shown in the following figure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要从给定状态创建转换，右键单击它：将打开“创建转换”选项。点击它，从点击的状态开始出现一个箭头。接下来，点击我们想要转换到的状态。这将创建到该状态的转换。转换在以下图中显示：
- en: '![](img/image_04_016.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_016.png)'
- en: Each of these transitions will be controlled through a script. To trigger each
    of the states, we will use either Booleans or triggers to enable these state changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的转换都将通过脚本进行控制。为了触发每个状态，我们将使用布尔值或触发器来启用这些状态变化。
- en: To create these parameters, click on the Parameters tab at the side of the Animator
    panel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些参数，点击动画面板旁边的“参数”选项卡。
- en: To create a new parameter, click on the + sign next to the search bar. You can
    either create a float, integer, Boolean, or a trigger parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新参数，点击搜索栏旁边的加号。你可以创建浮点数、整数、布尔值或触发器参数。
- en: 'For our purpose, we created a Boolean parameter, called bIsDefending, and two
    trigger parameters, called tGotHit and tIsPunching, as shown in the following
    screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们创建了一个布尔参数，称为bIsDefending，以及两个触发器参数，称为tGotHit和tIsPunching，如图以下截图所示：
- en: '![](img/image_04_017.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_017.png)'
- en: The difference between a Boolean and a trigger is that a trigger will set itself
    to false once it has been activated where as a Boolean has to have `true` and
    `false` set programmatically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值和触发器的区别在于，触发器一旦被激活就会将自己设置为false，而布尔值必须通过程序设置`true`和`false`。
- en: Let us see how it is implemented in the current game. First, we'll set the transitions
    for Punch and GetHit animations; we will then look at defend after. Select the
    transition arrow from Any State to Punch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在当前游戏中的实现方式。首先，我们将设置打击和被击动画的过渡；然后我们将查看防御状态。选择从任何状态到打击的过渡箭头。
- en: 'You know the transition has been selected when the arrow turns blue. The screenshot
    shows how the default state looks. We are going to make some changes here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当箭头变成蓝色时，你知道已经选择了过渡。截图显示了默认状态的外观。我们在这里要做一些更改：
- en: '![](img/image_04_018.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_018.png)'
- en: First of all, we want this transition to occur only when the player is punching.
    So in the Conditions tab, press the + sign and add the tInPunching condition.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望这个过渡只在玩家正在打击时发生。所以，在条件选项卡中，按下加号并添加tInPunching条件。
- en: Secondly, uncheck the Has Exit Time option. If this is checked then the transition
    will only occur once the previous animation has completed playing. We don't want
    that. We want the player to start playing the punching animation as soon as we
    click the Punch button.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点，取消勾选“具有退出时间”选项。如果勾选此选项，则过渡将仅在之前的动画播放完成后才会发生。我们不希望这样。我们希望玩家在点击打击按钮后立即开始播放打击动画。
- en: Thirdly, and most importantly, the animation preview window shows the animation
    played during the transition. Initially it shows that the animation will start
    from zero, play the idle animation, and then transition to the punch animation.
    We actually only want the punch animation to start immediately, and we just want
    one frame of transition between idle and punch animations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点，也是最重要的一点，动画预览窗口显示了过渡过程中播放的动画。最初它显示动画将从零开始，播放空闲动画，然后过渡到打击动画。我们实际上只想让打击动画立即开始，并且我们只想在空闲动画和打击动画之间有一个过渡帧。
- en: 'So, we bring the Punch back to the start and also make the start and stop really
    small as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将打击动画放回开始位置，并将开始和停止时间设置得非常小，如下截图所示：
- en: '![](img/image_04_019.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_019.png)'
- en: 'Now let''s look at the Punch to Idle animation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下打击到空闲动画：
- en: '![](img/image_04_020.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_020.png)'
- en: Here, we keep the Has Exit Time option checked as we want the animation to finish
    and then play the idle animation. Also, the idle animation is pulled back to the
    start and the animation play time is also reduced to one frame.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持“具有退出时间”选项勾选，因为我们希望动画播放完毕后播放空闲动画。此外，空闲动画被拉回开始位置，动画播放时间也减少到一帧。
- en: 'The same is done for the transition from Any State to GetHit as shown in the
    following screenshot. But here the condition is changed to tGotHit instead:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的操作也应用于从任何状态到GetHit的过渡，如下截图所示。但在这里，条件更改为tGotHit：
- en: '![](img/image_04_021.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_021.png)'
- en: 'Similarly, from GetHit to idle state:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从被击到空闲状态：
- en: '![](img/image_04_022.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_022.png)'
- en: 'Let''s look at how to create transitions from Any State to the defend state,
    and then from defend to the idle state. The transition from Any State to the defend
    state should be changed to as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从任何状态到防御状态，然后从防御状态到空闲状态的过渡。从任何状态到防御状态的过渡应更改为以下截图所示：
- en: '![](img/image_04_023.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_023.png)'
- en: 'Here, once again, we move the defend animation back and change the play to
    one frame. The Has Exit Time option is checked and now the condition is changed
    to bIsDefending, which is set to true. For the transition from defend to idle
    animation, we set the bIsDefending to false and change the animation width as
    usual:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次将防御动画拉回，并将播放时间更改为一帧。勾选“具有退出时间”选项，并将条件更改为bIsDefending，设置为true。对于从防御到空闲动画的过渡，我们将bIsDefending设置为false，并像往常一样更改动画宽度：
- en: '![](img/image_04_024.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_024.png)'
- en: 'For the transition from idle to defend, we do it similarly to how we did for
    Any State to defend, except we uncheck the Has Exit Time checkbox, as shown in
    the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从空闲到防御的过渡，我们以与从任何状态到防御相同的方式进行，只是取消勾选“具有退出时间”复选框，如下截图所示：
- en: '![](img/image_04_025.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_025.png)'
- en: With that we are through the Animation Controllers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就完成了动画控制器。
- en: Scripting player controls
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写玩家控制脚本
- en: To control the states we need to attach a script to the player. We will be using
    the left and right mouse clicks to control the player. The left mouse click will
    be for attacking, and the right mouse click will be for defending. If neither
    are clicked, then the idle animation will be played.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制状态，我们需要将脚本附加到玩家上。我们将使用鼠标的左右键来控制玩家。左键点击用于攻击，右键点击用于防御。如果两者都没有点击，则播放空闲动画。
- en: 'The controls can be changed under Unity''s Projects Settings option in the
    Edit menu. Select the Input option from the list, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在编辑菜单的 Unity 项目设置选项下更改控制。从列表中选择输入选项，如下面的截图所示：
- en: '![](img/image_04_026.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_026.png)'
- en: 'Keep the name in mind, as, while referring in the code, we will be using the
    name of the button. So, for left-click, we will be referring to the name Fire1\.
    You can check the names of the different buttons in the Inspector panel:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住名称，因为在代码中引用时，我们将使用按钮的名称。所以，对于左键点击，我们将引用 Fire1。你可以在检查器面板中检查不同按钮的名称：
- en: '![](img/image_04_027.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_027.png)'
- en: Let's create a new script by right-clicking in the Assets folder option | Create
    | C# Script and name it `playerScript`. Double-click on it and it should open
    in Visual Studio.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在资产文件夹选项中右键单击 | 创建 | C# 脚本来创建一个新的脚本，并将其命名为 `playerScript`。双击它，它应该在 Visual
    Studio 中打开。
- en: 'Add the following code to the script:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到脚本中：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the top, we create a `private` variable to get the Animator component and
    store it in the variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们创建一个 `private` 变量来获取动画器组件并将其存储在该变量中。
- en: Next, in the start function, we get the Animator component and assign it to
    `anim,` as otherwise we would have to do this for every frame which would get
    very taxing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `start` 函数中，我们获取动画器组件并将其分配给 `anim`，否则我们每帧都要做这件事，这将非常耗时。
- en: In the `Update` function, we first check for defending. If the `Fire 2` button,
    which is the right-click on the mouse, is pressed then we set the `bIsDefending`
    to `true`. The `bIsDefending` variable is the same as that we defined as a parameter
    in the Animation Controller option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Update` 函数中，我们首先检查防御状态。如果按下 `Fire 2` 按钮，即鼠标的右键，我们将 `bIsDefending` 设置为 `true`。`bIsDefending`
    变量与我们定义在动画控制器选项中的参数相同。
- en: If the button is up, then we set the `bIsDefending` variable to `false`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮被释放，我们将 `bIsDefending` 变量设置为 `false`。
- en: Next, we set the attacking state. If the `Fire1` button is pressed, then we
    first set defending to `false`, and then set `tIsPunching` to `true`. We also
    debug logout so that, we can see the specific code of hit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置攻击状态。如果按下 `Fire1` 按钮，我们首先将防御设置为 `false`，然后将 `tIsPunching` 设置为 `true`。我们还进行调试注销，以便我们可以看到击打的特定代码。
- en: 'To see if this really works, we have to attach it to the player character in
    the scene and add it as a component: drag the code and add it as a component to
    `theDude` character. Now, if you look in the Inspector, you can see that the script
    has been added:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这确实是否有效，我们必须将其附加到场景中的玩家角色上，并将其添加为组件：将代码拖动并添加到 `theDude` 角色上。现在，如果你查看检查器，你可以看到脚本已被添加：
- en: '![](img/image_04_028.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_028.png)'
- en: Now, if you right-click on the mouse, the player should block, and if you left-click
    with the mouse, the player should punch.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你右键点击鼠标，玩家应该进行防御，如果你用鼠标左键点击，玩家应该进行击打。
- en: '![](img/image_04_029.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_029.png)'
- en: Let's give the player an enemy to punch at.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给玩家一个敌人来击打。
- en: Adding an enemy character
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人角色
- en: Just as we dragged the player into the scene, drag theDude character from `Assets`
    into the `Hierarchy`. Rename this character to Enemy in the `Hierarchy`. This
    dude will also be red, which we don't want, so we'll create a new material.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将玩家拖入场景一样，将 `Assets` 中的 Dude 角色拖入 `Hierarchy`。在 `Hierarchy` 中将此角色重命名为敌人。这个家伙也会是红色，这不是我们想要的，所以我们将创建一个新的材料。
- en: Right-click on the Material folder and then select Create | Material. Name the
    material enemy as `Material`. Change the color next to Albedo color control from
    the default to blue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击材料文件夹，然后选择创建 | 材料项目。将材料命名为 `Material`。将 Albedo 颜色控制旁边的颜色从默认值改为蓝色。
- en: 'Now drag and drop the material to the enemy character. Also place and rotate
    the character so that it is standing opposite to the player character, as shown
    in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将材料拖放到敌人角色上。同时放置并旋转角色，使其与玩家角色相对，如下面的截图所示：
- en: '![](img/image_04_030.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_030.png)'
- en: 'Also drag the dudeAC Animation Controller to the Controller component in the
    Animator component for the enemy as well:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要将 dudeAC 动画控制器拖到敌人 Animator 组件的 Controller 组件中：
- en: '![](img/image_04_031.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_031.png)'
- en: Enemy behavior and AI
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人行为和 AI
- en: The enemy will start with the idle animation as you play the game. Let's add
    some behavior to the enemy character.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩游戏时，敌人将开始于空闲动画。让我们给敌人角色添加一些行为。
- en: The AI is implemented by creating a pattern, which will determine when the next
    state change for the enemy will take place, and the period of time that the enemy
    will either be idle, defend, or attack.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个模式来实现 AI，该模式将确定敌人下一次状态改变的时间，以及敌人将处于空闲、防御或攻击状态的时间段。
- en: The pattern is an array and has 20 elements in it. After all the elements are
    exhausted the patterns is randomized and the counter is set to 0 again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是一个数组，包含 20 个元素。当所有元素耗尽后，模式将被随机化，计数器再次设置为 0。
- en: Some intervals last for 10 frames, while others last for up to 120 frames or
    two seconds. The player has to judge and make sure that he doesn't get hit, and
    he has to defeat the `enemy` before they kill him. This will make more sense once
    we go through the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些间隔持续 10 帧，而其他间隔持续长达 120 帧，即两秒钟。玩家必须判断并确保自己不被击中，并且必须在敌人杀死他之前击败 `enemy`。一旦我们通过代码，这会更有意义。
- en: Create a new C# script and name it `enemy`. Add the following script to the
    code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本并将其命名为 `enemy`。将以下脚本添加到代码中。
- en: 'First, we initialize our variables:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的变量：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Start` function, we get the `Animator` component and set the pattern,
    which we will randomizing later:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 函数中，我们获取 `Animator` 组件并设置模式，稍后我们将对其进行随机化：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Update` function we update the values that we set initially:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Update` 函数中，我们更新我们最初设置的值：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Shuffle` function randomizes the initial pattern that we created:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shuffle` 函数随机化我们创建的初始模式：'
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As in the case of the player at the top of the code, we create a `private` variable
    to store the enemy animator variable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码顶部的玩家一样，我们创建一个 `private` 变量来存储敌人 animator 变量。
- en: We also create a bunch of integer variables called `myTick`, `currentTick`,
    `prevTick`, `nextTick`, `patternLength` and `patternCount`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一组名为 `myTick`、`currentTick`、`prevTick`、`nextTick`、`patternLength` 和 `patternCount`
    的整数变量。
- en: The `myTick` variable is just a counter, which keeps incrementing. The `CurrentTick`
    and `prevTick` variables keep track of the current frame tick and `prevTick` keeps
    track of the tick when an action last occurred.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`myTick` 变量只是一个计数器，它不断递增。`CurrentTick` 和 `prevTick` 变量分别跟踪当前帧的 tick 和 `prevTick`
    跟踪上一次动作发生的 tick。'
- en: The `patternLength` variable keeps track of the number of the items in the pattern
    array and `patternCount` keeps track of the current pattern number in use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`patternLength` 变量跟踪模式数组中的项目数量，而 `patternCount` 跟踪正在使用的当前模式编号。'
- en: Pattern is an array containing the intervals for the actions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是一个包含动作间隔的数组。
- en: In the `Start` function, we get the Animator component and set the `isDenfendingbool`
    variable to `true` so that the enemy starts off defending. We shuffle the pattern
    and assign the `patternLength` and `nextTick` to the first element of the pattern.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 函数中，我们获取 Animator 组件并将 `isDenfendingbool` 变量设置为 `true`，这样敌人一开始就会开始防御。我们打乱模式并将
    `patternLength` 和 `nextTick` 赋值给模式的第一个元素。
- en: Next in the `Update` function, we first increment the tick and assign `myTick`
    to the `currentTick`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在 `Update` 函数中，我们首先递增 tick 并将 `myTick` 赋值给 `currentTick`。
- en: We then check whether it is time for the next action to perform by checking
    if the `currentTick` is equal to the sum of the previous tick and `nextTick`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否是执行下一个动作的时间，通过检查 `currentTick` 是否等于上一个 tick 和 `nextTick` 的和。
- en: If it is equal, then we create a random number from one to three. Depending
    upon whether the returned value is 1, 2, or 3, there is a `switch` statement and
    the enemy will punch, defend, or be idle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们相等，那么我们生成一个从 1 到 3 的随机数。根据返回值是 1、2 还是 3，将有一个 `switch` 语句，敌人将出拳、防御或保持空闲。
- en: At the end, we assign the `currentTick` to `previousTick`, and `nextTick` to
    next `patternCount`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `currentTick` 赋值给 `previousTick`，将 `nextTick` 赋值给下一个 `patternCount`。
- en: We also need to increment the `patternCount` and to check if the `patternCount`
    variable's value has exceeded the length. If it is has exceeded it, then we need
    to reset it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要递增 `patternCount` 并检查 `patternCount` 变量的值是否超过了长度。如果超过了，那么我们需要将其重置。
- en: So, if the value of `patternCount++` is greater than or equal to the value of
    `patternLegth`, then we reset the pattern to zero and shuffle the pattern, otherwise
    we just increment the `patterCount`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`patternCount++`的值大于或等于`patternLegth`的值，则将模式重置为零并打乱模式，否则我们只需递增`patterCount`。
- en: 'Finally, we also have a function which shuffles the pattern so that it doesn''t
    get repeated. Add this script component to the enemy object in the scene and watch
    him be idle, block, and punch:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个函数可以随机打乱模式，这样就不会重复。将此脚本组件添加到场景中的敌人对象，并观察他闲置、阻挡和出拳：
- en: '![](img/image_04_032.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_032.png)'
- en: Finalizing the fight
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束战斗
- en: 'Let us make the player react to the enemy''s attacks by changing the behavior
    of the player. In the `playerScript`, add the following line of code. At the top
    of the class, create a new `public` variable of type `GameObject` and call it
    `enemy`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让玩家通过改变玩家的行为来对敌人的攻击做出反应。在`playerScript`中添加以下代码行。在类顶部创建一个新的`public`变量，类型为`GameObject`，并将其命名为`enemy`：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, at the start of the `Update` function, get the `Animator` component of
    the enemy:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Update`函数的开始处，获取敌人的`Animator`组件：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, after the attacking function in the update, add the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在更新函数中的攻击函数之后，添加以下内容：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we check if the enemy is punching. If the enemy is punching and the player
    is not defending, then we set the `gotHit` trigger to be `true`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查敌人是否在出拳。如果敌人正在出拳而玩家没有防守，那么我们将`gotHit`触发器设置为`true`。
- en: 'Drag `theDude` character to the enemy script component as shown in the following
    screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将`theDude`角色拖放到如图所示的敌人脚本组件中：
- en: '![](img/image_04_033.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_033.png)'
- en: Similarly, in the enemy script add a public GameObject variable called player.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在敌人脚本中添加一个名为`player`的公共`GameObject`变量。
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just before the end of the `Update` function, add the following.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数结束之前，添加以下内容。
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Drag and drop the player in the `GameObject` in the enemy script take a hit
    when he is not defending:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将玩家拖放到敌人脚本中的`GameObject`，当他不防守时受到攻击：
- en: '![](img/image_04_034.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_034.png)'
- en: 'Now play the game and you will see that the enemy will take a hit when he is
    not defending:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏，你会看到当敌人不防守时会被击中：
- en: Also, as of now the player can keep left-clicking and the hero character can
    keep punching. To limit the number of punches the player can do, add the following
    code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，到目前为止，玩家可以持续左键点击，英雄角色可以持续出拳。为了限制玩家可以出的拳数，请添加以下代码。
- en: 'Add the following at the top:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部添加以下内容：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the start of the `Update` function, increment the time:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`函数的开始处，增加时间：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The attack code needs to be changed to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击代码需要更改为：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw how to import an FBX model, import the animations, and
    set names for the individual animations. We created an Animation Controller and
    transitions between animations. Once the animations controller had been created,
    we then controlled the animation using the code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何导入FBX模型，导入动画，并为单个动画设置名称。我们创建了一个动画控制器和动画之间的转换。一旦创建了动画控制器，我们就使用代码来控制动画。
- en: We also created player controls, created a very basic AI, and controlled the
    AI behavior with a pattern which we randomized to avoid pattern repetition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了玩家控制，创建了一个非常基本的AI，并使用随机化的模式来避免模式重复，用模式来控制AI行为。
- en: Now that we have a basic skeleton to work with, we will improve this and add
    a proper game loop in the next chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的工作框架，我们将对其进行改进，并在下一章中添加一个合适的游戏循环。
