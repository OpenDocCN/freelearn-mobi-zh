- en: Chapter 2. Discovering New Territories – Linux at Last!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 探索新领域 – Linux 终于来了！
- en: Until recently, developing for Swift meant you needed a Mac, loaded with the
    Xcode IDE. However, all of that changed when Apple open sourced the Swift programming
    language in December 2015\. A brave new world has been opened to us as developers,
    as Swift can now run on Linux! In addition, you now have access to preview releases
    and have direct access to the development trunk from which you can download development
    snapshots (for example, non-official prebuilt binaries of Swift).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，为 Swift 开发意味着您需要一个装有 Xcode IDE 的 Mac。然而，所有这些都随着苹果公司在 2015 年 12 月开源 Swift
    编程语言而发生了变化。作为开发者，我们进入了一个全新的世界，因为 Swift 现在可以在 Linux 上运行！此外，您现在可以访问预览版本，并可以直接访问开发主干，从中可以下载开发快照（例如，Swift
    的非官方预构建二进制文件）。
- en: This is going to be a packed chapter, and I want to highlight what we will cover.
    My goal is to show you where to find the latest Swift source for both Mac and
    Linux. I will also provide instruction on how to use *toolchains* and explain
    how the Swift package manager works. Last, we will develop our first program on
    Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个内容丰富的章节，我想强调我们将要涵盖的内容。我的目标是向您展示如何在 Mac 和 Linux 上找到最新的 Swift 源代码。我还会提供如何使用
    *工具链* 的说明，并解释 Swift 包管理器的工作原理。最后，我们将在 Linux 上开发我们的第一个程序。
- en: Downloading Swift
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载 Swift
- en: 'In order to get started working with Swift 3, you need to download either a
    prebuilt binary (also known as a *toolchain*) or the source code to build the
    Swift library yourself. The Swift.org ([https://swift.org](https://swift.org))
    website hosts a **Download** section [https://swift.org/download/](https://swift.org/download/)
    that maintains a list of releases, previews and snapshots:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用 Swift 3，您需要下载预构建的二进制文件（也称为 *工具链*）或源代码来自己构建 Swift 库。Swift.org ([https://swift.org](https://swift.org))
    网站托管了一个 **下载** 部分 [https://swift.org/download/](https://swift.org/download/)，其中维护了一个发布版本、预览版本和快照的列表：
- en: '**Release builds**:Maintains links to the current release and older official
    releases of Swift.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布版本**：维护到当前发布版本和旧版官方 Swift 发布版本的链接。'
- en: '**Preview builds**:Contains links to developer previews, also known as *seeds*
    or *betas*. These binaries are not considered final releases but do provide a
    fairly stable version of the work completed to that date for upcoming releases.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预览版本**：包含开发者预览版本，也称为 *种子* 或 *测试版*。这些二进制文件不被视为最终发布版本，但确实提供了到那时已完成工作的相当稳定的版本，用于即将发布的版本。'
- en: '**Developer snapshots** - Are pre-built binaries from the development branch.
    These builds contain the latest development changes and have gone through automated
    unit testing but are not guaranteed to be stable. Snapshot builds are not put
    through the full testing process.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者快照** - 是开发分支的预构建二进制文件。这些构建包含最新的开发更改，并已通过自动化单元测试，但并不保证稳定性。快照构建没有经过完整的测试流程。'
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since learning to build the binary isn't critical to your knowledge of learning
    Swift 3, we will leave compiling the source as an exercise for you to try on your
    own at some point. You can find the source code on Apple's GitHub ([https://github.com/apple](https://github.com/apple))
    along with build instructions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于学习构建二进制文件对于您学习 Swift 3 的知识不是关键，我们将把编译源代码作为一项练习留给您自己尝试，在某个时候自行完成。您可以在苹果的 GitHub
    ([https://github.com/apple](https://github.com/apple)) 上找到源代码，以及构建说明。
- en: Swift 3 on Mac
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac 上的 Swift 3
- en: To get up and going on a Mac, you simply need to choose the type of Swift *toolchain*
    you want to develop against. You can choose a version from the **Download** section.
    Swift on a Mac is included with Xcode, making it really easy to get started. Swift
    3 requires you to have macOS 10.11.5 (El Capitan) or later and Xcode 8\. Let's
    walk through the steps together and install Swift 3 on a Mac.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac 上开始，您只需选择您想要开发的 Swift *工具链* 类型。您可以从 **下载** 部分选择一个版本。Mac 上的 Swift 包含在
    Xcode 中，这使得开始使用变得非常容易。Swift 3 要求您拥有 macOS 10.11.5（El Capitan）或更高版本和 Xcode 8。让我们一起来走一遍步骤，并在
    Mac 上安装 Swift 3。
- en: '**Download a toolchain** - Grab the latest Swift 3 release or preview candidate
    from the downloads page on [https://swift.org/](https://swift.org/). Xcode is
    created and maintained by Apple, selecting a release to download from [https://swift.org/](https://swift.org/)
    will take you to Apple''s downloads section on their developer portal.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载工具链** - 从 [https://swift.org/](https://swift.org/) 的下载页面获取最新的 Swift 3 发布版本或预览候选版本。Xcode
    由苹果公司创建和维护，从 [https://swift.org/](https://swift.org/) 选择下载的版本将带您到苹果开发者门户上的下载部分。'
- en: Note
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An Xcode toolchain is a special binary with a toolchain extension that includes
    Xcode and all of the tools and libraries that make up Swift (LLVM, LLDB, REPL,
    and other tools) all targeted at a specific Swift version. You can think of a
    toolchain as a bundled development environment that you install and extract onto
    your system to work with a specific release. When you want to try out a different
    version, you have to download and install the toolchain that corresponds to the
    target version.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Xcode工具链是一个特殊的二进制文件，具有工具链扩展，它包括Xcode以及构成Swift的所有工具和库（LLVM、LLDB、REPL和其他工具），所有这些都针对特定的Swift版本。您可以将工具链视为一个捆绑的开发环境，您将其安装并提取到您的系统上，以便与特定版本一起工作。当您想要尝试不同的版本时，您必须下载并安装与目标版本相对应的工具链。
- en: '**Run the package installer** - This will install Xcode (toolchain).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行包安装器** - 这将安装Xcode（工具链）。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Xcode package that you download for a release or developer snapshot should
    be digitally signed with a developer ID (Developer ID Installer: Swift Open Source
    (V9AUD2URP3)) of the open source project to protect against malicious code and
    tampering. The Swift installer should display a lock on the right side of the
    title bar. When you click the lock, you should see details on the developer signature.'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您为发布或开发者快照下载的Xcode包应该使用开源项目的开发者ID（开发者ID安装器：Swift Open Source (V9AUD2URP3)）进行数字签名，以防止恶意代码和篡改。Swift安装器应该在标题栏的右侧显示一个锁。当您点击锁时，您应该看到开发者签名的详细信息。
- en: '**Select a Toolchain [Optional]** - If this is the only Swift version on your
    machine, you can skip this step. However, if you have multiple developer snapshots
    or previews, you can tell Xcode which version to use by navigating to Preferences,
    choosing **Components** | **Toolchains** or using the **Toolchains** menu listed
    under **Preferences...** directly:![Swift 3 on Mac](img/image_02_001.jpg)'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择工具链[可选]** - 如果这是您机器上的唯一Swift版本，您可以跳过此步骤。但是，如果您有多个开发者快照或预览，您可以通过导航到首选项，选择**组件**
    | **工具链**或直接使用**首选项...**下列出的**工具链**菜单来告诉Xcode使用哪个版本：![Swift 3 on Mac](img/image_02_001.jpg)'
- en: Selecting Toolchains in Xcode 8
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Xcode 8中选择工具链
- en: Next, you select the **Toolchain** you want to develop against, which will only
    change the Xcode settings. If you want your command line tools settings to change
    as well, you need to configure those using the *xcrun* and *xcodebuild*.![Swift
    3 on Mac](img/image_02_002.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您选择要开发的**工具链**，这将仅更改Xcode设置。如果您想更改命令行工具设置，您需要使用*xcrun*和*xcodebuild*进行配置。![Swift
    3 on Mac](img/image_02_002.jpg)
- en: Toolchains menu in Xcode
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Xcode中的工具链菜单
- en: Each command has an option to point to a specified Swift `toolchain`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个命令都有一个选项，可以指向指定的Swift `工具链`。
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have your *toolchain* installed on your Mac, you simply need to launch
    Xcode and you can begin developing. Since we will spend the majority of the next
    few chapters tackling new Swift features using Xcode, we are going to shift gears
    and spend the rest of this chapter discussing Swift on Linux.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在Mac上安装了*工具链*，您只需启动Xcode，就可以开始开发了。由于我们将在接下来的几章中主要使用Xcode来处理新的Swift特性，我们将转换方向，在本章的剩余部分讨论Linux上的Swift。
- en: Swift 3 on Linux
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux上的Swift 3
- en: The Swift team currently supports installing Linux on Ubuntu 14.04 or 15.10
    (64-bit). On Linux, Swift packages are distributed as tar archives. Each package
    includes the Swift compiler, the LLDB debugger, and tools related to doing development
    in Swift.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Swift团队目前支持在Ubuntu 14.04或15.10（64位）上安装Linux。在Linux上，Swift包以tar存档的形式分发。每个包都包括Swift编译器、LLDB调试器和与在Swift中进行开发相关的工具。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't have access to a Linux box, you can create a virtual machine using
    VirtualBox [https://www.virtualbox.org](https://www.virtualbox.org) and Vagrant
    [https://www.vagrantup.com](https://www.vagrantup.com).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法访问Linux服务器，您可以使用VirtualBox [https://www.virtualbox.org](https://www.virtualbox.org)和Vagrant
    [https://www.vagrantup.com](https://www.vagrantup.com)创建虚拟机。
- en: VirtualBox is a virtualization application that runs on multiple platforms and
    allows you to install another OS. You can download the latest version from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox是一个可以在多个平台上运行的虚拟化应用程序，允许您安装另一个操作系统。您可以从[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)下载最新版本。
- en: Vagrant is a configuration and provisioning package that allows you to install
    and configure a complete development environment. You can find instructions on
    how to install and configure a Linux box at this location [https://www.vagrantup.com/](https://www.vagrantup.com/)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一个配置和预配包，允许您安装和配置完整的发展环境。您可以在以下位置找到如何安装和配置Linux盒子的说明[https://www.vagrantup.com/](https://www.vagrantup.com/)
- en: 'We need to install our required dependencies. Run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装我们的必需依赖项。运行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`clang` : The C language front-end for LLVM compiler.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang`：LLVM编译器的C语言前端。'
- en: '`libicu-dev` : An Ubuntu package written in C++ and C that provides a solid
    full-featured Unicode and local support.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libicu-dev`：一个用C++和C编写的Ubuntu包，提供强大的全面Unicode和本地支持。'
- en: We need to download a *toolchain* along with a *.sig* file that serves as the
    *toolchain*'s digital signature. The *toolchain* has the format `swift-<VERSION>-<PLATFORM>.tar.gz`,
    and the digital signature file has the same format with extension *`.sig`.*
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要下载一个*工具链*以及一个作为*工具链*数字签名的*.sig*文件。*工具链*的格式为`swift-<VERSION>-<PLATFORM>.tar.gz`，数字签名文件的格式相同，但扩展名为*`.sig`*。
- en: We are going to install a preview *toolchain* for Ubuntu 14.04\. Copy the link
    for the *toolchain* and download the files to your Linux machine.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为Ubuntu 14.04安装一个预览*工具链*。复制*工具链*的链接并将其下载到您的Linux机器上。
- en: 'Download the `toolchain` file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`toolchain`文件：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Download the digital signature file:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载数字签名文件：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Import PGP keys for verifying the integrity of our *toolchain*. You only need
    to download the keys once:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入PGP密钥以验证*工具链*的完整性。您只需要下载一次密钥：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We verify our downloaded *toolchain* using the PGP key we imported.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用导入的PGP密钥验证我们下载的*工具链*。
- en: 'Refresh your keys and download any newly available certificates:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新您的密钥并下载任何新可用的证书：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we verify that the signature file we downloaded is good:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们验证我们下载的签名文件是否良好：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If our `*gpg*` verify statement returns a `Bad signature` then do not open the
    *toolchain* and report the problem to `swift-infrastructure@swift.org`.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们的`*gpg*`验证语句返回`Bad signature`，则不要打开*工具链*并向`swift-infrastructure@swift.org`报告问题。
- en: 'Extract the *toolchain* from the archive:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存档中提取*工具链*：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to include the */usr* directory to our path so that we can execute
    the swift command for using the REPL environment. Add the Swift *toolchain* to
    your path:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将*/usr*目录添加到我们的路径中，这样我们就可以执行用于使用REPL环境的swift命令。将Swift *工具链*添加到您的路径：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the REPL
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REPL
- en: Once we have Swift installed, we can use the Swift REPL (Read Evaluate Print
    Loop) environment and give Swift a test run on Linux. The Swift REPL environment
    and LLDB debugger are tightly linked to the *toolchain*, which aids in Swift type
    inference, syntax, and expression evaluation. Basically, it makes the compiler,
    debugger, and REPL environment's jobs easier if there is only one version of Swift
    to worry about at a time. Let's start the REPL environment and execute a few commands
    to get familiar with the REPL environment's capabilities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Swift，我们就可以使用Swift REPL（读取评估打印循环）环境，并在Linux上对Swift进行测试运行。Swift REPL环境和LLDB调试器与*工具链*紧密相连，有助于Swift类型推断、语法和表达式评估。基本上，如果一次只关注一个版本的Swift，它会使编译器、调试器和REPL环境的工作变得更简单。让我们启动REPL环境并执行一些命令，以熟悉REPL环境的功能。
- en: 'To start the Swift REPL, you type the swift command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Swift REPL，您输入swift命令：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we add statements, the REPL environment is smart enough to only execute once
    you have completely entered a statement. We can create assignment statements,
    functions, or even entire classes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加语句，REPL环境足够智能，只有在您完全输入一个语句后才会执行。我们可以创建赋值语句、函数，甚至整个类。
- en: 'At the REPL prompt, let''s assign:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL提示符下，让我们分配：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each time we execute a statement, the REPL environment adds the result of the
    statement on the following line. In our case, we have assigned the numerical values
    to two different variables (`oneMillion` and `twoMillion`). Our third statement
    adds the two variables together. Notice that the result displays as `$R0 Int =
    3000000`. The Swift REPL environment will create a variable name for you if you
    don't assign an expression to a variable. We can use the assigned variable in
    future expressions. In our fourth expression, we use the value stored in `$R0to`
    create a new expression that divides the value by `1,000,000`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们执行一个语句时，REPL 环境都会在下一行添加该语句的结果。在我们的例子中，我们已将数值赋给了两个不同的变量（`oneMillion` 和 `twoMillion`）。我们的第三个语句将这两个变量相加。注意，结果显示为
    `$R0 Int = 3000000`。如果你没有将表达式赋给变量，Swift REPL 环境会为你创建一个变量名。我们可以在未来的表达式中使用分配的变量。在我们的第四个表达式中，我们使用存储在
    `$R0` 中的值创建一个新的表达式，该表达式将值除以 `1,000,000`。
- en: 'As I mentioned earlier in this section, the debugger is tightly coupled to
    the REPL environment. If we add a bad expression, the REPL environment displays
    the error message as a result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在这部分前面提到的，调试器与 REPL 环境紧密耦合。如果我们添加了一个错误的表达式，REPL 环境会显示错误信息作为结果：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The REPL environment also supports multi-line statements, which you could use
    to create a function or class. To create a multi-line statement, you simply need
    to arrow down instead of pressing enter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 环境也支持多行语句，你可以使用它来创建函数或类。要创建多行语句，你只需箭头向下而不是按回车键。
- en: If you haven't used the REPL environment in past versions of Swift, you should
    give it a try. I believe the REPL environment could be very useful for experimenting
    on creating algorithms or testing out a function for rapid development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过 Swift 的 REPL 环境，你应该试一试。我相信 REPL 环境对于实验创建算法或快速开发测试函数非常有用。
- en: Swift Package Manager
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 包管理器
- en: The Swift Package Manager is the Swift Army Knife that allows you to manage
    your code dependencies, share your own packages, and use the libraries created
    by others. It's an extremely important tool, one that you need to know in order
    to do anything productive with Swift. My goal is to provide you with a quick overview
    and then dive into some examples so we can use it in an example to solidify the
    core concepts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 包管理器是 Swift 的瑞士军刀，它允许你管理你的代码依赖项，分享你自己的包，并使用其他人创建的库。这是一个极其重要的工具，了解它是用 Swift
    进行任何有成效工作的必要条件。我的目标是为你提供一个快速概述，然后深入一些示例，这样我们就可以在示例中使用它来巩固核心概念。
- en: Like other languages, Swift allows you to organize and group your Swift code.
    Swift refers to these groupings as modules. Modules in Swift allow the developer
    to enforce control on the functionality that is exposed publicly (outside of the
    module) and the functionality that is only visible within the module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，Swift 允许你组织和分组你的 Swift 代码。Swift 将这些分组称为模块。Swift 中的模块允许开发者对公开（模块外部）的功能性和仅在模块内部可见的功能性进行控制。
- en: As developers, we use modules that we create or that other developers create
    to write our software. When we use other developers' modules, we create a dependency
    on their code. Swift allows us to create a package, which consists of the Swift
    code we write plus a manifest file to manage everything we need to build our products.
    The manifest file that we include in the package defines what we are building,
    as it includes a package name and a listing of the contents included. A Swift
    package can have one or more targets, each of which specifies a product or one
    or more dependencies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们使用我们创建的或其他开发者创建的模块来编写我们的软件。当我们使用其他开发者的模块时，我们就在他们的代码上创建了一个依赖。Swift 允许我们创建一个包，它由我们编写的
    Swift 代码和一个清单文件组成，用于管理我们构建产品所需的一切。我们包含在包中的清单文件定义了我们正在构建的内容，因为它包括一个包名和包含内容的列表。一个
    Swift 包可以有一个或多个目标，每个目标指定一个产品或一个或多个依赖项。
- en: If you have ever worked with Node.js, you can quickly see the similarities between
    node's package manager and Swift's package manager. Both allow the developer to
    define manifest files that describe the types of dependencies required to make
    an application work. Swift's package manager requires you to provide either a
    relative or absolute URL to the source and the version required. Once provided,
    the package manager takes over, downloading and compiling the required dependencies
    for you. In fact, the package manager recursively checks each dependency, evaluating
    a dependency to see if it has any dependencies and repeats this process until
    it covers the entire graph. This could be a big task depending on the size of
    your package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 Node.js，你可以很快看到 node 的包管理器和 Swift 的包管理器之间的相似之处。两者都允许开发者定义描述应用程序所需依赖类型的清单文件。Swift
    的包管理器要求你提供源代码的相对或绝对 URL 以及所需的版本。一旦提供，包管理器就会接管，为你下载和编译所需的依赖。实际上，包管理器会递归地检查每个依赖，评估依赖是否有任何依赖，并重复此过程，直到覆盖整个图。这可能会是一个很大的任务，取决于你的包的大小。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More Resources**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多资源**'
- en: ':'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: 'You can access the source for the Swift Package Manager here: [https://github.com/apple/swift-package-manager](https://github.com/apple/swift-package-manager).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里访问 Swift 包管理器的源代码：[https://github.com/apple/swift-package-manager](https://github.com/apple/swift-package-manager).
- en: 'You can learn more about how to structure your manifest files here: [https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于如何结构化你的清单文件的信息：[https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md)
- en: 'You can get insights on creating your own packages here: [https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解如何创建自己的包：[https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md)
- en: Our first Swift program
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个 Swift 程序
- en: 'Let''s create our first program on Linux using Swift. Our first project will
    be a package. Create a directory named `guesswho` and then enter the directory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Linux 上使用 Swift 创建我们的第一个程序。我们的第一个项目将是一个包。创建一个名为 `guesswho` 的目录，然后进入该目录：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next we need to initialize a new package with the type being an executable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化一个新的包，类型为可执行文件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I want to point out a couple of things about the output of swift package init.
    First, using the swift package init command is optional and meant only to be a
    utility mechanism for generating files and directories you may need. Second, the
    package manager expects you to put your sources files within the Sources directory.
    You can further nest additional directories under the `Sources` directory and
    the package manager will treat those directories as modules. Finally, when you
    want to create an executable, you need to include a `main.swift` file in the module's
    subdirectory or directly within the `Sources` directory in cases when you only
    have one target. Let's look at an example of a Swift package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出关于 swift package init 命令输出的一些事项。首先，使用 swift package init 命令是可选的，它仅作为一个生成你可能需要的文件和目录的工具机制。其次，包管理器期望你在
    Sources 目录下放置你的源文件。你可以在 `Sources` 目录下进一步嵌套额外的目录，包管理器会将这些目录视为模块。最后，当你想要创建一个可执行文件时，你需要在该模块的子目录中包含一个
    `main.swift` 文件，或者在只有一个目标的情况下，直接在 `Sources` 目录中包含该文件。让我们看看一个 Swift 包的示例。
- en: 'Creating a package with multiple modules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含多个模块的包：
- en: '`mymodule/Sources/worker/workerbot.swift`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/Sources/worker/workerbot.swift`'
- en: '`mymodule/Sources/manager/manager.swift`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/Sources/manager/manager.swift`'
- en: 'Running swift build on the package above creates:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述包上运行 swift build 会创建以下内容：
- en: '`mymodule/.build/debug/workerbot.a`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/.build/debug/workerbot.a`'
- en: '`mymodule/.build/debug/manager.a`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/.build/debug/manager.a`'
- en: 'Creating a package with one executable and one library module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含一个可执行文件和一个库模块的包：
- en: '`mymodule/Sources/worker/main.swift`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/Sources/worker/main.swift`'
- en: '`mymodule/Sources/manager/manager.swift`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/Sources/manager/manager.swift`'
- en: 'Running swift build in this time would result in:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时间运行 swift build 将会产生以下结果：
- en: '`mymodule/.build/debug/workerbot`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/.build/debug/workerbot`'
- en: '`mymodule/.build/debug/manager.a`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mymodule/.build/debug/manager.a`'
- en: Notice that our executable doesn't have an extension; however, our library file
    is created with a `*.a*` extension.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的可执行文件没有扩展名；然而，我们的库文件是以 `*.a*` 扩展名创建的。
- en: Open main.swift and remove the code that is currently in there. We are going
    to replace the existing code with some new logic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 main.swift 文件，并移除其中现有的代码。我们将用一些新的逻辑替换现有的代码。
- en: 'Let''s add a function that will recursively call itself and remove the first
    letter of its input string from the remaining characters, repeating the task until
    there are no letters left in the string. Once we are finished, we execute a closure
    to let the caller know we are done:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个函数，该函数将递归地调用自身，并从其输入字符串的剩余字符中移除第一个字母，重复此任务，直到字符串中没有字母为止。一旦我们完成，我们将执行一个闭包来通知调用者我们已经完成：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we need to handle the arguments passed when executing our swift program.
    First in line 1, we store the argument lists as an array. Next, in line 2 we check
    to make sure we have at least one argument that we can process using our `breakWord(combine:)`
    function. Lines 3-8 iterate over our argument list and call our`breakWord(combine:)`
    function for each argument. In line 4, we use a closure expression to print the
    final result of our `breakWord(combine:)` routine:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理在执行 Swift 程序时传递的参数。首先，在第 1 行，我们将参数列表存储为一个数组。然后，在第 2 行，我们检查是否至少有一个参数可以使用我们的
    `breakWord(combine:)` 函数进行处理。第 3-8 行遍历我们的参数列表，并对每个参数调用我们的 `breakWord(combine:)`
    函数。在第 4 行，我们使用闭包表达式来打印 `breakWord(combine:)` 过程的最终结果：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer to see the source all in one place, you can download the code
    from this chapter using the following link.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将源代码全部放在一个地方查看，你可以通过以下链接下载本章的代码。
- en: 'Close and save `main.swift` and then compile the program using swift build.
    You can execute the program by typing `guesswho` along with one or more arguments:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭并保存 `main.swift` 文件，然后使用 swift build 命令编译程序。你可以通过输入 `guesswho` 以及一个或多个参数来执行程序：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to get your development environment configured
    for Swift development on a Mac or Linux machine. We learned about *toolchains*,
    using the REPL environment, and the Swift Package Manager. We also created our
    first Swift package, which we're able to execute on Linux. If you're still with
    me, we will cover even more awesome things in Swift in the forthcoming chapters!
    If you're observant, you've probably noticed that our example package lacked a
    few things. Rest assured, we will take a deep dive into creating and executing
    tests and debugging techniques in [Chapter 9](ch09.html "Chapter 9. Improving
    Your Code with Xcode Server and LLDB Debugging"), *Improving Your Code with Xcode
    Server and LLDB Debugging*. We'll also come back to Linux to tackle a more complicated
    use case that includes adding dependencies to our package in [Chapter 10](ch10.html
    "Chapter 10. Exploring Swift on the Server"),* Exploring Swift on the Server*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何将你的开发环境配置为在 Mac 或 Linux 机器上开发 Swift。我们学习了 *工具链*、使用 REPL 环境、以及 Swift
    包管理器。我们还创建了我们的第一个 Swift 包，我们能够在 Linux 上执行它。如果你还在这里，我们将在接下来的章节中介绍更多关于 Swift 的精彩内容！如果你足够细心，你可能已经注意到我们的示例包缺少一些东西。请放心，我们将在第
    9 章 [改进代码：使用 Xcode 服务器和 LLDB 调试](ch09.html "Chapter 9. Improving Your Code with
    Xcode Server and LLDB Debugging")中深入探讨创建和执行测试以及调试技术，*改进代码：使用 Xcode 服务器和 LLDB 调试*。我们还将回到
    Linux，处理一个更复杂的使用案例，包括在我们的包中添加依赖项，在第 10 章 [在服务器上探索 Swift](ch10.html "Chapter 10.
    Exploring Swift on the Server")，*在服务器上探索 Swift*。
