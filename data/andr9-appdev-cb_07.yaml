- en: Data Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Storing simple data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储简单数据
- en: Read and writing a text file to internal storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本文件读取和写入到内部存储
- en: Read and writing a text file to external storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本文件读取和写入到外部存储
- en: Including resource files in your project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的项目中包含资源文件
- en: Creating and using an SQLite database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用SQLite数据库
- en: Accessing data in the background using a Loader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Loader在后台访问数据
- en: Accessing external storage with scoped directories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用作用域目录访问外部存储
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Since most applications, big or small, require saving data – from default user
    selections to user accounts – Android offers many options. From saving a simple
    value to creating full databases using SQLite, storage options include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数应用程序，无论大小，都需要保存数据——从默认用户选择到用户账户——Android提供了许多选项。从保存一个简单的值到使用SQLite创建完整数据库，存储选项包括以下内容：
- en: 'Shared preferences: Simple name/value pairs'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享首选项：简单的名称/值对
- en: 'Internal storage: Data files in private storage'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部存储：私有存储中的数据文件
- en: 'External storage: Data files in private or public storage'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部存储：私有或公共存储中的数据文件
- en: 'SQLite database: Private data (can be made public through a Content Provider)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库：私有数据（可以通过内容提供者使其公开）
- en: 'Cloud storage: Private server or service provider'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云存储：私有服务器或服务提供商
- en: 'There are benefits and trade-offs to using internal and external storage. We
    will list some of the differences here to help you decide which option best fits
    your needs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内部和外部存储都有利弊。我们将在此列出一些差异，以帮助您决定哪个选项最适合您的需求：
- en: '**Internal storage**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部存储**：'
- en: Unlike external storage, internal storage is always available but generally
    has less free space
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部存储不同，内部存储始终可用，但通常有更少的空闲空间
- en: Files are not accessible to the user (unless the device has root access)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件对用户不可访问（除非设备有root访问权限）
- en: Files are automatically deleted when your app is uninstalled (or with the Clear
    Cache/Cleanup File option in the App Manager)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的应用程序被卸载时，文件会自动删除（或在应用程序管理器的清除缓存/清理文件选项中）
- en: '**External storage**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部存储**：'
- en: The device may not have external storage or it may be inaccessible (such as
    when it's connected to a computer)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备可能没有外部存储，或者可能无法访问（例如，当它连接到计算机时）
- en: Files are accessible to the user (and other apps) without requiring root access
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件对用户（和其他应用程序）是可访问的，无需root访问权限
- en: Files are not deleted when your app is uninstalled (unless you use `getExternalFilesDir()`
    to get app-specific public storage)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的应用程序被卸载时，文件不会被删除（除非你使用`getExternalFilesDir()`来获取应用程序特定的公共存储）
- en: In this chapter, we will demonstrate working with shared preferences, internal
    and external storage, and SQLite databases. For cloud storage, take a look at
    the internet recipes in [Chapter 12](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何使用共享首选项、内部和外部存储以及SQLite数据库。对于云存储，请参阅第12章的互联网食谱，*Telephony, Networks*。
- en: Storing simple data
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储简单数据
- en: It's a common requirement to store simple data, and Android makes it simple
    using the Preferences API. It's not limited to just user preferences either; you
    can store any of the primitive data types using a name/value pair.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 存储简单数据是一个常见需求，Android通过使用首选项API使其变得简单。它不仅限于用户首选项；您可以使用名称/值对存储任何原始数据类型。
- en: 'We''ll demonstrate saving a name from an `EditText` and displaying it when
    the application starts. The following screenshots shows how the application looks
    the first time with no saved name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何从`EditText`保存一个名字并在应用程序启动时显示它。以下截图显示了应用程序第一次启动且没有保存名字时的样子：
- en: '![](img/3ed2bbe2-b637-4865-a352-2db38ed9d601.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ed2bbe2-b637-4865-a352-2db38ed9d601.png)'
- en: 'This is an example of how it looks after saving a name:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保存名字后的样子示例：
- en: '![](img/306a0343-f644-4791-b986-16282f6f2ad9.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/306a0343-f644-4791-b986-16282f6f2ad9.png)'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `Preferences`. Use the default Phone
    & Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`Preferences`。使用默认的`Phone & Tablet`选项，并在`Add
    an Activity to Mobile`对话框中选择`Empty Activity`。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll use the existing TextView to display a Welcome back message and create
    a new `EditText` button to save the name. Start by opening `activity_main.xml`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现有的`TextView`来显示欢迎回来信息，并创建一个新的`EditText`按钮来保存名字。首先打开`activity_main.xml`：
- en: 'Replace the existing TextView with the following new views:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下新视图替换现有的`TextView`：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `ActivityMain.java` and add the following global declarations:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActivityMain.java`并添加以下全局声明：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code to `onCreate()` to save a reference to `EditText` and
    to load any saved name:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`onCreate()`中，以保存对`EditText`的引用并加载任何已保存的名称：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following `saveName()` method:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`saveName()`方法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the program on a device or emulator. Since we are demonstrating persisting
    data, it loads the name during `onCreate()`, so save a name and restart the program
    to see it load.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。由于我们正在演示持久化数据，它将在`onCreate()`期间加载名称，因此保存一个名称并重新启动程序以查看它如何加载。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To load the name, we first get a reference to `SharedPreference` and call the
    `getString()` method. We pass in the key for our name/value pair (we created a
    constant called `NAME`) and the default value to return if the key is not found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载名称，我们首先获取对`SharedPreference`的引用并调用`getString()`方法。我们传入我们的名称/值对的键（我们创建了一个名为`NAME`的常量）以及如果找不到键则返回的默认值。
- en: To save the preference, we first need to get a reference to the Preference Editor.
    We use `putString()` with our `NAME` constant and follow it with `commit().` Without
    `commit()`, the change will not be saved.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存首选项，我们首先需要获取对首选项编辑器的引用。我们使用`putString()`与我们的`NAME`常量，然后跟随`commit()`。如果没有`commit()`，更改将不会被保存。
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Our example stores all the preferences in a single file. We can also store preferences
    in different files using `getSharedPreferences()` and passing in the name. One
    example where this option could be useful is you wanted to have separate profiles
    in a multi-user app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将所有首选项存储在一个单独的文件中。我们也可以使用`getSharedPreferences()`和传入名称来在不同的文件中存储首选项。一个可以使用此选项的例子是在多用户应用程序中拥有单独的配置文件。
- en: Read and write a text file to internal storage
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本文件读取和写入内部存储
- en: When simple name/value pairs are not sufficient, Android also supports regular
    file operations, including working with text and binary data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当简单的名称/值对不足以满足需求时，Android还支持常规的文件操作，包括处理文本和二进制数据。
- en: The following recipe demonstrates how to read and write a file to internal or
    private storage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何读取和写入内部或私有存储的文件。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `InternalStorageFile`. Use
    the default Phone & Tablet options and select Empty Activity in the Add an Activity
    to Mobile dialog.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`InternalStorageFile`。使用默认的`Phone & Tablet`选项，并在`Add
    an Activity to Mobile`对话框中选择`Empty Activity`。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To demonstrate both reading and writing text, we''ll need a layout with an
    `EditText` and two buttons. Start by opening `main_activity.xml` and follow these
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示读取和写入文本，我们需要一个包含`EditText`和两个按钮的布局。首先打开`main_activity.xml`并按照以下步骤操作：
- en: 'Replace the existing `<TextView>` element with the following views:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`<TextView>`元素替换为以下视图：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open `ActivityMain.java` and add the following global variables:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`ActivityMain.java`并添加以下全局变量：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following to the `onCreate()` method, after `setContentView ()`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中`setContentView()`之后添加以下内容：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following `writeFile()` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`writeFile()`方法：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, add the `readFile()` method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`readFile()`方法：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program on a device or emulator.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We use the `InputStream` and `FileOutputStream` classes to read and write, respectively.
    Writing to the file is as simple as getting the text from `EditText `and calling
    the `write()` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`InputStream`和`FileOutputStream`类分别进行读取和写入。写入文件就像从`EditText`获取文本并调用`write()`方法一样简单。
- en: Reading back the contents is a little more involved. We could use the `FileInputStream`
    class for reading, but when working with text, the helper classes make it easier.
    In our example, we open the file with `openFileInput()`, which returns an `InputStream`
    object. We then use `InputStream` to get a `BufferedReader`, which offers the
    `ReadLine()` method. We loop through each line in the file and append it to our
    `StringBuilder`. When we're finished reading the file, we assign the text to `EditText`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 读取内容稍微复杂一些。我们可以使用`FileInputStream`类进行读取，但在处理文本时，辅助类使操作更简单。在我们的示例中，我们使用`openFileInput()`打开文件，它返回一个`InputStream`对象。然后我们使用`InputStream`获取一个`BufferedReader`，它提供了`ReadLine()`方法。我们遍历文件中的每一行并将其追加到我们的`StringBuilder`中。当我们完成文件读取后，我们将文本分配给`EditText`。
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: The previous example used the private storage to save the file. Here's how you
    can use the cache folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了私有存储来保存文件。以下是使用缓存文件夹的方法。
- en: Caching files
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存文件
- en: 'If all you need is to temporarily store data, you can also use the cache folder.
    The following method returns the cache folder as a `File` object (the next recipe
    demonstrates working with the `File` object):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要临时存储数据，您也可以使用缓存文件夹。以下方法返回缓存文件夹作为一个`File`对象（下一个配方将演示如何与`File`对象一起工作）：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The main benefit of the cache folder is that the system can clear the cache
    if running low on storage space. (The user can also clear the cache folder from
    Apps Management in Settings.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存文件夹的主要好处是，当存储空间不足时，系统可以清除缓存。（用户也可以在设置中的应用管理中清除缓存文件夹。）
- en: For example, if your app downloads news articles, you could store those in the
    cache. When your app starts, you can display the news already downloaded. These
    are files that are not required to make your app work. If the system is low on
    resources, the cache can be cleared without adversely affecting your app. (Even
    though the system may clear the cache, it's still a good idea for your app to
    remove old files as well.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的应用下载新闻文章，您可以将这些文章存储在缓存中。当您的应用启动时，您可以显示已下载的新闻。这些文件不是使您的应用工作所必需的。如果系统资源不足，缓存可以被清除，而不会对您的应用产生不利影响。（即使系统可能会清除缓存，但仍然建议您的应用也删除旧文件。）
- en: See also
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Read and write a text file to external storage*.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个配方，*读取和写入外部存储中的文本文件*。
- en: Read and write a text file to external storage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入外部存储中的文本文件
- en: The process of reading and writing files to external storage is basically the
    same as using internal storage. The difference is in obtaining a reference to
    the storage location. Also, as mentioned in the *Introduction*, external storage
    may not be available, so it's best to check availability before attempting to
    access it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件读取和写入外部存储的过程基本上与使用内部存储相同。区别在于，在尝试访问之前，最好检查存储的可用性。如*简介*中所述，外部存储可能不可用，因此最好在尝试访问之前进行检查。
- en: This recipe will read and write a text file, as we did in the previous recipe.
    We'll also demonstrate how to check the external storage state before we access
    it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将读取和写入一个文本文件，就像我们在上一个配方中所做的那样。我们还将演示在访问它之前如何检查外部存储状态。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ExternalStorageFile`. Use
    the default Phone & Tablet options and select Empty Activity on the Add an Activity
    to Mobile dialog. We will use the same layout as the previous recipe, so you can
    just copy and paste if you typed it in already. Otherwise, use the layout from
    step 1 in the previous recipe, *Read and write a text file to internal storage*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`ExternalStorageFile`。使用默认的`Phone & Tablet`选项，并在`Add
    an Activity to Mobile`对话框中选择`Empty Activity`。我们将使用与上一个配方相同的布局，所以如果您已经输入了它，可以直接复制粘贴。否则，使用上一个配方中步骤1的布局，*读取和写入内部存储中的文本文件*。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As mentioned previously in the *Getting ready* section, we''ll use the layout
    from the previous recipe. With the layout file done, the first step will be to
    add permission to access the write to external storage. Here are the steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在*准备就绪*部分所述，我们将使用上一个配方中的布局。布局文件完成后，第一步将是添加访问外部存储写入权限。以下是步骤：
- en: 'Open the Android Manifest and add the following permission:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AndroidManifest文件并添加以下权限：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, open `ActivityMain.java` and add the following global variables:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`ActivityMain.java`并添加以下全局变量：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following to the `onCreate()` method, after `setContentView()`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，在`setContentView()`之后添加以下内容：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following two methods to check the storage state:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两种方法来检查存储状态：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following method to verify the app has permission to access the external
    storage:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以验证应用是否有权限访问外部存储：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following `writeFile()` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`writeFile()`方法：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following `readFile()`method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`readFile()`方法：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the program on a device or emulator with external storage.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在具有外部存储的设备或模拟器上运行程序。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Reading and writing files are basically the same for both internal and external
    storage. The main difference is that we should check for the availability of the
    external storage before attempting to access it, which we do with the `isExternalStorageWritable()`
    and `isExternalStorageReadable()` methods. When checking the storage state, `MEDIA_MOUNTED`
    means we can read and write to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件对于内部和外部存储基本上是相同的。主要区别在于，在尝试访问之前，我们应该检查外部存储的可用性，这是通过`isExternalStorageWritable()`和`isExternalStorageReadable()`方法来完成的。在检查存储状态时，`MEDIA_MOUNTED`表示我们可以对其进行读写操作。
- en: 'Unlike the internal storage example, we request the working path, which we
    do in this line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与内部存储示例不同，我们请求工作路径，这是我们在这一行代码中做的：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The actual reading and writing is done with the same classes, as it is just
    the location that is different.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的读取和写入使用相同的类，因为只是位置不同。
- en: It is not safe to hard code an external folder path. The path can vary between
    versions of the OS and especially between hardware manufacturers. It is always
    best to call `getExternalStorageDirectory()` as shown.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部文件夹路径硬编码是不安全的。路径可能在操作系统版本之间以及特别是在硬件制造商之间有所不同。始终最好按照所示调用`getExternalStorageDirectory()`。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: You probably noticed the `checkStoragePermission()` function from step 5 wasn't
    mentioned. This is because permissions aren't specific to storage but are required
    for the app to access various device features. Unlike the previous recipe, which
    used local app storage, "external" storage is considered risky for the user. (It
    wouldn't be good if just any app could go through a user's private files.) For
    that reason, the app must make additional effort to check if it has the required
    permission to access storage. If it does not, the user will be prompted. Note
    that this additional dialog is coming from the OS, not the app itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了第5步中提到的`checkStoragePermission()`函数没有提及。这是因为权限不仅限于存储，而且应用程序访问各种设备功能也需要这些权限。与之前使用本地应用程序存储的配方不同，“外部”存储被认为对用户来说是危险的。（如果任何应用程序都可以浏览用户的私人文件，那就不好了。）因此，应用程序必须做出额外努力来检查它是否有访问存储所需的权限。如果没有，用户将被提示。请注意，这个额外的对话框来自操作系统，而不是应用程序本身。
- en: When you first run the app, if you are prompted for permission but still get
    an error writing, exit the app and restart. For a more in-depth explanation and
    handling of the new Android permission model, see the *See also...* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行应用程序时，如果你被提示请求权限但仍然在写入时出错，请退出应用程序并重新启动。有关对新Android权限模型的深入解释和处理，请参阅*另请参阅...*部分。
- en: Getting public folders
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取公共文件夹
- en: 'The `getExternalStorageDirectory()` method returns the root folder of the external
    storage. If you want to obtain specific public folders, such as the `Music` or
    `Ringtone` folder, use `getExternalStoragePublicDirectory()` and pass in the desired
    folder type, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`getExternalStorageDirectory()`方法返回外部存储的根文件夹。如果你想获取特定的公共文件夹，例如`Music`或`Ringtone`文件夹，请使用`getExternalStoragePublicDirectory()`并传入所需的文件夹类型，例如：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Checking available space
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用空间
- en: 'One issue consistent between internal and external storage is limited space.
    If you know how much space you will need ahead of time, you can call the `getFreeSpace()`
    method on the `File` object. (`getTotalSpace()` will return the total space.)
    Here is a simple example, using the call to `getFreeSpace()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存储和外部存储之间一个一致的问题是空间有限。如果你提前知道你需要多少空间，你可以在`File`对象上调用`getFreeSpace()`方法。（`getTotalSpace()`将返回总空间。）以下是一个简单的示例，使用对`getFreeSpace()`的调用：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deleting a file
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'There are many helper methods available through the `File` object, including
    deleting a file. If we wanted to delete the text file we created in the example,
    we could call `delete()` as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`File`对象提供了许多辅助方法，包括删除文件。如果我们想删除示例中创建的文本文件，我们可以按照以下方式调用`delete()`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Working with directories
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与目录一起工作
- en: 'Although it''s called a `File` object, it supports directory commands as well,
    such as making and removing directories. If you want to make or remove a directory,
    build the `File` object, then call the respective methods: `mkdir()` and `delete()`.
    (There''s also a method called `mkdirs()` (plural) that will create parent folders
    as well.)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它被称为`File`对象，但它也支持目录命令，例如创建和删除目录。如果你想创建或删除目录，构建`File`对象，然后调用相应的方法：`mkdir()`和`delete()`。（还有一个名为`mkdirs()`（复数）的方法，它将创建父文件夹。）
- en: Refer to the link in the *See also* section for a complete list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*另请参阅*部分中的链接以获取完整列表。
- en: Preventing files from being included in galleries
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止文件包含在图库中
- en: Android employs a **media scanner** that automatically includes sound, video,
    and image files in system collections, such as the Image Gallery. To exclude your
    directory, create an empty file called `.nomedia` (note the preceding period)
    in the same directory as the files you wish to exclude.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用一个**媒体扫描器**，它会自动将声音、视频和图像文件包含在系统集合中，例如图片库。要排除你的目录，在你要排除的文件所在的目录中创建一个名为`.nomedia`（注意前面的点）的空文件。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on the Android 6.0 permission model, see the corresponding
    recipe in [Chapter 15](98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml),* Getting Your
    App Ready for the Play Store*
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Android 6.0 权限模型的更多信息，请参阅第 15 章[为 Play 商店准备您的应用](98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml)中的相应食谱
- en: For a complete list of methods available in the `File` class, visit
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `File` 类中可用方法的完整列表，请访问
- en: '[http://developer.android.com/reference/java/io/File.html](http://developer.android.com/reference/java/io/File.html)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/reference/java/io/File.html](http://developer.android.com/reference/java/io/File.html)'
- en: Including resource files in your project
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中包含资源文件
- en: 'Android provides two options for including files in your project: the `raw`
    folder and the `assets` folder. Which option you use depends on your requirements.
    To start, we''ll give a brief overview of each option to help you decide the best
    use:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Android 为包含项目中的文件提供了两种选项：`raw` 文件夹和 `assets` 文件夹。您使用哪种选项取决于您的需求。首先，我们将简要概述每个选项，以帮助您决定最佳用途：
- en: '**Raw files**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始文件**'
- en: 'Included in the resource directory: `/res/raw`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在资源目录中：`/res/raw`
- en: 'As a resource, accessed through the raw identifier: `R.raw.<resource>`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为资源，通过原始标识符访问：`R.raw.<资源>`
- en: A good place for storing media files such as MP3, MP4, and OGG files
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储媒体文件的好地方，例如 MP3、MP4 和 OGG 文件
- en: '**Asset files**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产文件**'
- en: Creates a file compiled in your APK (does not provide a resource ID)
  id: totrans-136
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的 APK 中创建一个编译后的文件（不提供资源 ID）
- en: Access files using their filenames, generally making them easier to use with
    dynamically created names
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它们的文件名访问文件，通常使它们更容易与动态创建的名称一起使用
- en: Some APIs do not support a Resource Identifier and therefore require including
    as an Asset
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 API 不支持资源标识符，因此需要将其作为资产包含
- en: Generally, `raw` files are easier to work with since they are accessed through
    the resource identifier. As we'll demonstrate in this recipe, the main difference
    is how you access the file. In this example, we will load both a `raw` text file
    and an `asset` text file and display the contents.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`raw` 文件更容易处理，因为它们是通过资源标识符访问的。正如我们将在本食谱中展示的那样，主要区别在于您如何访问文件。在这个例子中，我们将加载一个
    `raw` 文本文件和一个 `asset` 文本文件，并显示其内容。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ReadingResourceFiles`. Use
    the default Phone & Tablet options and select Empty Activity in the Add an Activity
    to Mobile dialog.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `ReadingResourceFiles`。使用默认的“电话和平板电脑”选项，并在“添加活动到移动设备”对话框中选择“空活动”。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To demonstrate reading content from both resource locations, we''ll create
    a split layout. We also need to create both resource folders as they are not included
    in the default Android project. Here are the steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示从两个资源位置读取内容，我们将创建一个分割布局。我们还需要创建这两个资源文件夹，因为它们不包括在默认的 Android 项目中。以下是步骤：
- en: 'Open `activity_main.xml` and replace the contents with the following layout:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将内容替换为以下布局：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `raw` resource folder in the `res` folder. It will read as follows:
    `res/raw`. You can easily create it manually or let Android Studio do it for you
    by right-clicking on the `res` folder and selecting New | Android Resource Directory.
    When the Select Resource Directory dialog opens, select raw as the `Resource type`,
    as shown in this screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res` 文件夹中创建 `raw` 资源文件夹。它将如下所示：`res/raw`。您可以轻松手动创建它，或者让 Android Studio 帮您创建，方法是在
    `res` 文件夹上右键单击并选择“新建 | Android 资源目录”。当打开“选择资源目录”对话框时，选择“raw”作为“资源类型”，如图所示：
- en: '![](img/5e832b7e-dd40-4271-a0f3-82b56494d0bc.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e832b7e-dd40-4271-a0f3-82b56494d0bc.png)'
- en: Create a new text file by right-clicking on the `raw` folder and select New
    | File. Name the file `raw_text.txt` and type some text in the file. (This text
    will be displayed when you run the application.)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击 `raw` 文件夹并选择“新建 | 文件”来创建一个新的文本文件。将文件命名为 `raw_text.txt` 并在文件中输入一些文本。（运行应用程序时将显示此文本。）
- en: 'Create the `asset` folder. The `asset` folder is trickier to create manually
    as it needs to be at the correct folder level. Fortunately, Android Studio provides
    a menu option that makes creating it very easy. Go to the File menu (or right-click
    on the app node) and select New | Folder | Assets Folder, as shown in this screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `asset` 文件夹。手动创建 `asset` 文件夹比较困难，因为它需要位于正确的文件夹级别。幸运的是，Android Studio 提供了一个菜单选项，可以轻松创建它。转到文件菜单（或在应用节点上右键单击）并选择“新建
    | 文件夹 | 资源文件夹”，如图所示：
- en: '![](img/3ebd91ff-349c-40e8-8746-fc4cd3d6f047.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ebd91ff-349c-40e8-8746-fc4cd3d6f047.png)'
- en: 'Create a text file in the asset folder called `asset_text.txt`. Again, whatever
    text you type here will be shown when you run the app. Here''s how the final result
    should look after both text files are created:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资产文件夹中创建一个名为 `asset_text.txt` 的文本文件。同样，你在这里输入的任何文本都会在运行应用程序时显示出来。以下是创建两个文本文件后的最终结果：
- en: '![](img/b681874c-85c9-47fa-9084-6d53269ee5e7.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b681874c-85c9-47fa-9084-6d53269ee5e7.png)'
- en: 'Now, it''s time for the code. Open `MainActivity.java` and add the following
    method to read the text file (which is passed into the method):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写代码了。打开 `MainActivity.java` 并添加以下方法来读取文本文件（该文件作为参数传递给方法）：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, add the following code to the `onCreate()` method:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到 `onCreate()` 方法中：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program on a device or emulator.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To summarize, the only difference is in how we get a reference to each file.
    This line of code reads the `raw` resource:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，唯一的区别在于我们获取每个文件的引用方式。此行代码读取 `raw` 资源：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And this code reads the `asset` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码读取 `asset` 文件：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Both calls return an `InputStream`, which the `getText()` method uses to read
    the file contents. It is worth noting, though, that the call to open the `asset`
    text file requires an additional `try`/`catch`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 两个调用都返回一个 `InputStream`，`getText()` 方法使用它来读取文件内容。不过，值得注意的是，打开 `asset` 文本文件的调用需要额外的
    `try`/`catch`。
- en: As noted in the recipe introduction, resources are indexed so we have compile-time
    verification, which the `asset` folder does not have.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如菜谱介绍中所述，资源被索引，因此我们有编译时验证，而 `asset` 文件夹没有。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A common approach is to include resources in your APK, but download new resources
    as they become available. (See the network communication in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks, and the Web*.) If new resources aren't available, you can
    always fall back on the resources in your APK.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是将资源包含在 APK 中，但下载新的资源以供使用。（参见第 13 章[网络通信](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml)，*电话、网络和互联网*。）如果新的资源不可用，你总是可以回退到
    APK 中的资源。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Network communication recipes in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),
    *Telephony, Networks, and the Web.*
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 13 章](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml)中的网络通信食谱，*电话、网络和互联网*。'
- en: Creating and using an SQLite database
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用 SQLite 数据库
- en: In this recipe, we're going to demonstrate working with an SQLite database.
    If you are already familiar with SQL databases from other platforms, then much
    of what you know will apply. If you are new to SQLite, take a look at the reference
    links in the *See also* section as this recipe assumes a basic understanding of
    database concepts, including schemas, tables, cursors, and raw SQL.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示如何与 SQLite 数据库一起工作。如果你已经熟悉来自其他平台上的 SQL 数据库，那么你所知道的大部分内容都将适用。如果你是
    SQLite 的新手，请查看 *参见* 部分的参考链接，因为这个菜谱假设对数据库概念有基本的了解，包括模式、表、游标和原始 SQL。
- en: 'To get you up and running with an SQLite database quickly, our example implements
    the basic CRUD operations. Generally, when creating a database in Android, you
    create a class that extends `SQLiteOpenHelper`, which is where your database functionality
    is implemented. Here is a list of the CRUD (create, read, update, and delete)
    functions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速使用 SQLite 数据库，我们的示例实现了基本的 CRUD 操作。通常，在 Android 中创建数据库时，你会创建一个扩展 `SQLiteOpenHelper`
    的类，这是实现数据库功能的地方。以下是 CRUD（创建、读取、更新和删除）函数的列表：
- en: 'Create: `insert()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建：`insert()`
- en: 'Read: `query()` and `rawQuery()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取：`query()` 和 `rawQuery()`
- en: 'Update: `update()`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新：`update()`
- en: 'Delete: `delete()`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：`delete()`
- en: To demonstrate a fully working database, we will create a simple `Dictionary`
    database where we'll store words and their definitions. We'll demonstrate the
    CRUD operations by adding new words (with their definitions) and updating existing
    word definitions. We'll show words in a `ListView` using a cursor. Pressing a
    word in the `ListView` will read the definition from the database and display
    it in a Toast message. A long press will delete the word.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个完全工作的数据库，我们将创建一个简单的 `Dictionary` 数据库，我们将存储单词及其定义。我们将通过添加新的单词（及其定义）和更新现有单词的定义来演示
    CRUD 操作。我们将使用游标在 `ListView` 中显示单词。在 `ListView` 中按下一个单词将读取数据库中的定义并在 Toast 消息中显示它。长按将删除该单词。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `SQLiteDatabase`. Use the
    default Phone & Tablet options and select Empty Activity on the Add an Activity
    to Mobile dialog.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `SQLiteDatabase`。使用默认的 Phone & Tablet 选项，并在添加到移动对话框中选择
    Empty Activity。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we''ll create the UI, which will consist of two `EditText` fields, a
    button, and a `ListView`. As we add words to the database, they will populate
    the `ListView`. Start by opening `activity_main.xml` and follow these steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 UI，它将包括两个 `EditText` 字段、一个按钮和一个 `ListView`。当我们向数据库添加单词时，它们将填充 `ListView`。首先打开
    `activity_main.xml` 并按照以下步骤操作：
- en: 'Replace the default XML with the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换默认的 XML：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a new Java class to the project named `DictionaryDatabase`. This class
    extends from `SQLiteOpenHelper` and handles all the SQLite functions. Here is
    the class declaration:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `DictionaryDatabase` 的新 Java 类。此类从 `SQLiteOpenHelper` 继承，并处理所有 SQLite
    功能。以下是类声明：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Below the declaration, add the following constants:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明下方添加以下常量：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following constructor, `OnCreate()`, and `onUpgrade()` methods:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数、`OnCreate()` 和 `onUpgrade()` 方法：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following methods are responsible for creating, updating, and deleting
    the records:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方法负责创建、更新和删除记录：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And these methods handle reading the information from the database:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而这些方法处理从数据库读取信息：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the database, class finished, open `MainActivity.java`. Add the following
    global variables below the class declaration:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库和类完成后，打开 `MainActivity.java`。在类声明下方添加以下全局变量：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following method to save the fields when the button is clicked:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以在按钮点击时保存字段：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add this method to populate the `ListView`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法添加到填充 `ListView`：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, add the following code to `onCreate()`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到 `onCreate()`：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the program on a device or emulator and try it out.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序并尝试它。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ll start by explaining the `DictionaryDatabase` class as that''s the heart
    of an SQLite database. The first item to note is the constructor:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释 `DictionaryDatabase` 类，因为它是 SQLite 数据库的核心。首先要注意的是构造函数：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice `DATABASE_VERSION`? Only when you make changes to your database schema
    do you need to increment this value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `DATABASE_VERSION`？只有当你修改你的数据库模式时，你才需要增加这个值。
- en: Next is `onCreate()`, where the database is actually created. This is only called
    the first time the database is created, not each time the class is created. It's
    also worth noting the `_id` field. Android does not require tables to have a primary
    field, but some classes, such as the `SimpleCursorAdapter`, may require an `_id`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `onCreate()`，在这里实际上创建了数据库。这仅在创建数据库第一次调用，而不是每次创建类时调用。还值得注意的是 `_id` 字段。Android
    不要求表必须有主字段，但某些类，如 `SimpleCursorAdapter`，可能需要一个 `_id`。
- en: We're required to implement the `onUpgrade()` callback, but as this is a new
    database, there's nothing to do. This method will only be called when the database
    version is incremented.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现 `onUpgrade()` 回调，但由于这是一个新数据库，没有要做的事情。此方法仅在数据库版本增加时调用。
- en: The `saveRecord()` method handles calling `addRecord()` or `updateRecord()`,
    as appropriate. Since we are going to modify the database, both methods use `getWritableDatabase()` to
    get an updatable database reference. A writable database requires more resources
    so if you don't need to make changes, get a read-only database instead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveRecord()` 方法处理调用 `addRecord()` 或 `updateRecord()`，根据需要。由于我们将修改数据库，这两个方法都使用
    `getWritableDatabase()` 获取可更新的数据库引用。可写数据库需要更多资源，所以如果你不需要进行更改，请获取只读数据库。'
- en: 'The last method to note is `getWordList()`, which returns all the words in
    the database using a cursor object. We use this cursor to populate the `ListView`,
    which brings us to `ActivityMain.java`. The `onCreate()` method does the standard
    initialization we''ve seen before and also creates an instance of the database
    with the following line of code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的方法是 `getWordList()`，它使用游标对象返回数据库中的所有单词。我们使用这个游标来填充 `ListView`，这把我们带到了
    `ActivityMain.java`。`onCreate()` 方法执行我们之前看到的标准初始化，并使用以下代码行创建数据库实例：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `onCreate()` method is also where we set up the events to show the word
    definition (with a Toast) when an item is pressed and to delete the word on a
    long press. Probably the most complicated code is in `updateWordList()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreate()` 方法也是我们设置事件的地方，当按下项目时显示单词定义（使用 Toast），以及在长按时删除单词。可能最复杂的代码在 `updateWordList()`
    方法中。'
- en: This isn't the first time we've used an adapter, but this is the first cursor
    adapter, so we'll explain. We use the `SimpleCursorAdapter` to create a mapping
    between our field in the cursor and the `ListView` item. We use the `layout.simple_list_item_1`
    layout, which only includes a single text field with the ID `android.R.id.text1`.
    In a real application, we'd probably create a custom layout and include the definition
    in the `ListView` item, but we wanted to demonstrate a method to read the definition
    from the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们第一次使用适配器，但这是第一个光标适配器，所以我们将进行解释。我们使用`SimpleCursorAdapter`来在游标中的字段和`ListView`项之间创建映射。我们使用`layout.simple_list_item_1`布局，该布局只包含一个ID为`android.R.id.text1`的单个文本字段。在实际应用中，我们可能会创建一个自定义布局，并将其定义包含在`ListView`项中，但我们的目的是演示从数据库中读取定义的方法。
- en: 'We call `updateWordList()` in three places: during `onCreate()` to create the
    initial list, then again after we add/update an item, and lastly when deleting
    an item.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在三个地方调用`updateWordList()`：在`onCreate()`期间创建初始列表，然后在我们添加/更新一个项目后再次调用，最后在删除一个项目时调用。
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although this is a fully functioning example of SQLite, it is still just the
    basics. There are many books dedicated to SQLite for Android and they are worth
    checking out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个完整的SQLite示例，但它仍然只是基础知识。有许多关于SQLite的书籍专门针对Android，值得一看。
- en: Upgrading a database
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级数据库
- en: As we mentioned previously, when we increment the database version, the `onUpgrade()`
    method will be called. What you do here is dependent on the changes made to the
    database. If you changed an existing table, ideally you'll want to migrate the
    user data to the new format by querying the existing data and inserting it into
    the new format. Keep in mind that there is no guarantee the user will upgrade
    in consecutive order, so they could jump from version 1 to version 4, for example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们增加数据库版本时，`onUpgrade()`方法将被调用。你在这里所做的是依赖于对数据库所做的更改。如果你更改了一个现有的表，理想情况下，你将希望通过查询现有数据并将其插入到新格式中来迁移用户数据。请注意，没有保证用户会按顺序升级，他们可能会从版本1跳到版本4，例如。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'SQLite homepage: [https://www.sqlite.org/](https://www.sqlite.org/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite主页：[https://www.sqlite.org/](https://www.sqlite.org/)
- en: 'SQLite database Android reference: [http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库Android参考：[http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)
- en: Accessing data in the background using a Loader
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Loader在后台访问数据
- en: Any potentially long-running operations should not be done on the UI thread,
    as this can cause your application to be slow or become unresponsive. The Android
    OS will bring up the **Application Not Responding** (**ANR**) dialog when apps
    become unresponsive.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能长时间运行的操作都不应该在UI线程上执行，因为这可能会导致你的应用程序变慢或无响应。当应用程序无响应时，Android OS将弹出**应用程序无响应**（**ANR**）对话框。
- en: Since querying databases can be time-consuming, Android introduced the Loader
    API in Android 3.0\. A Loader processes the query on a background thread and notifies
    the UI thread when it finishes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询数据库可能耗时，Android在Android 3.0中引入了Loader API。Loader在后台线程上处理查询，并在完成时通知UI线程。
- en: 'The two primary benefits to Loaders are the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Loaders的两个主要好处如下：
- en: Querying the database is (automatically) handled on a background thread
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询数据库是在后台线程上（自动）处理的
- en: The query auto-updates (when using a Content Provider data source)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询自动更新（当使用内容提供者数据源时）
- en: To demonstrate a Loader, we will modify the previous SQLite database example
    to use a `CursorLoader` to populate `ListView`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示加载器，我们将修改之前的SQLite数据库示例，使用`CursorLoader`来填充`ListView`。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the project from the previous example, *Creating and using an SQLite
    database,* as the base for this recipe. Create a new project in Android Studio
    and call it `Loader`. Use the default Phone & Tablet options and select Empty
    Activity on the Add an Activity to Mobile dialog. Copy the `DictionaryDatabase`
    class and the layout from the previous recipe. Although we will use parts of the
    previous `ActivityMain.java` code, we will start at the beginning in this recipe
    to make it easier to follow.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一个示例中的项目，*创建和使用 SQLite 数据库*，作为本菜谱的基础。在 Android Studio 中创建一个新的项目，命名为 `Loader`。使用默认的
    Phone & Tablet 选项，并在“添加一个活动到移动”对话框中选择 Empty Activity。从上一个菜谱复制 `DictionaryDatabase`
    类和布局。虽然我们将使用前一个 `ActivityMain.java` 代码的一部分，但在这个菜谱中我们将从头开始，以便更容易理解。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'With the project set up as described in *Getting ready*, we''ll continue by
    creating two new Java classes, and then tie it all together in `ActivityMain.java`.
    Here are the steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 按照在 *准备就绪* 中描述的设置项目，我们将继续创建两个新的 Java 类，然后在 `ActivityMain.java` 中将它们全部结合起来。以下是步骤：
- en: 'Create a new Java class called `DictionaryAdapter` that extends `CursorAdapter`.
    This class replaces the `SimpleCursorAdapater` used in the previous recipe. Here
    is the full code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Java 类，命名为 `DictionaryAdapter`，并扩展 `CursorAdapter` 类。这个类替换了上一个菜谱中使用的
    `SimpleCursorAdapater`。以下是完整的代码：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, create another new Java class and call this one `DictionaryLoader`. Although
    this is the class that handles the data loading on the background thread, it''s
    actually very simple:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建另一个新的 Java 类，并将其命名为 `DictionaryLoader`。尽管这个类处理后台线程中的数据加载，但实际上它非常简单：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, open `ActivityMain.java`. We need to change the declaration to implement
    the `LoaderManager.LoaderCallbacks<Cursor>` interface as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `ActivityMain.java`。我们需要将声明改为实现 `LoaderManager.LoaderCallbacks<Cursor>`
    接口，如下所示：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the adapter to the global declarations. The complete list is as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将适配器添加到全局声明中。完整的列表如下：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Change `onCreate()` to use the new adapter and add a call to update the Loader
    after deleting a record. The final `onCreate()` method should look as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onCreate()` 改为使用新的适配器，并在删除记录后添加一个调用更新 Loader 的调用。最终的 `onCreate()` 方法应如下所示：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We no longer have the `updateWordList()` method, so change `saveRecord()`
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再有 `updateWordList()` 方法，因此将 `saveRecord()` 方法
- en: 'as follows:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, implement these three methods for the Loader interface:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 Loader 接口这三个方法：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the program on a device or emulator.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The default `CursorAdapter` requires a Content Provider URI. Since we are accessing
    the SQLite database directly (and not through a Content Provider), we don't have
    a URI to pass, so instead, we created a custom adapter by extending the `CursorAdapter`
    class. `DictionaryAdapter` still performs the same functionality as `SimpleCursorAdapter`
    from the previous recipe, namely mapping the data from the cursor to the item
    layout.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `CursorAdapter` 需要一个 Content Provider URI。由于我们直接访问 SQLite 数据库（而不是通过 Content
    Provider），我们没有 URI 可以传递，因此我们创建了一个自定义适配器，通过扩展 `CursorAdapter` 类来实现。`DictionaryAdapter`
    仍然执行与上一个菜谱中的 `SimpleCursorAdapter` 相同的功能，即从游标映射数据到项目布局。
- en: The next class we added was `DictionaryLoader`, which handles populating the
    adapter. As you can see, it's actually very simple. All it does is return the
    cursor from `getWordList()`. The key here is that this query is being handled
    in a background thread and will call the `onLoadFinished()` callback (in `MainActivity.java`)
    when it finishes. Fortunately, most of the heavy lifting is handled in the base
    class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的下一个类是 `DictionaryLoader`，它负责填充适配器。正如你所见，它实际上非常简单。它所做的只是从 `getWordList()`
    返回游标。关键在于这个查询是在后台线程中处理的，并在完成后调用 `onLoadFinished()` 回调（在 `MainActivity.java` 中）。幸运的是，大部分繁重的工作都在基类中处理。
- en: 'This takes us to `ActivityMain.java`, where we implemented the following three
    callbacks from the `LoaderManager.LoaderCallbacks` interface:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到 `ActivityMain.java`，在那里我们实现了 `LoaderManager.LoaderCallbacks` 接口中的以下三个回调：
- en: '`onCreateLoader()`: It''s initially called in `onCreate()` with the `initLoader()`
    call. It''s called again with the `restartLoader()` call after we make changes
    to the database.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateLoader()`: 它最初在 `onCreate()` 中通过 `initLoader()` 调用。在更改数据库后，它会在 `restartLoader()`
    调用后再次被调用。'
- en: '`onLoadFinished()`: It''s called when the Loader `loadInBackground()` finishes.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadFinished()`: 当 `Loader` 的 `loadInBackground()` 方法完成时被调用。'
- en: '`onLoaderReset()`: It''s called when the Loader is being recreated (such as
    with the `restart()` method). We set the old cursor to `null` because it will
    be invalidated and we don''t want a reference kept around.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoaderReset()`：当Loader正在被重新创建时（例如使用`restart()`方法）会被调用。我们设置旧的游标为`null`，因为它将被无效化，我们不希望保留引用。'
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you saw in the previous example, we need to manually notify the Loader to
    re-query the database using `restartLoader()`. One of the benefits of using a
    Loader is that it can auto-update, but it requires a Content Provider as the data
    source. A Content Provider supports using an SQLite database as the data source
    and is recommended for a serious application. (See the following Content Provider
    link to get started.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的示例中看到的，我们需要手动通知Loader使用`restartLoader()`重新查询数据库。使用Loader的一个好处是它可以自动更新，但它需要一个Content
    Provider作为数据源。Content Provider支持使用SQLite数据库作为数据源，并且对于严肃的应用程序是推荐的。（请参阅以下Content
    Provider链接以开始。）
- en: See also
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *AsyncTask* recipe in [Chapter 14](01fd07ae-9274-4fb2-a536-bc3ed6ec088c.xhtml),
    *Location and Using Geofencing*.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第14章的*AsyncTask*配方中，*位置和地理围栏使用*。
- en: 'Creating a Content Provider: [http://developer.android.com/guide/topics/providers/content-provider-creating.html](http://developer.android.com/guide/topics/providers/content-provider-creating.html).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Content Provider：[http://developer.android.com/guide/topics/providers/content-provider-creating.html](http://developer.android.com/guide/topics/providers/content-provider-creating.html)。
- en: It's also worth checking out Paging and LiveData in the Android Jetpack Components: [https://developer.android.com/jetpack/](https://developer.android.com/jetpack/).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，可以在Android Jetpack组件中查看Paging和LiveData：[https://developer.android.com/jetpack/](https://developer.android.com/jetpack/)。
- en: The Loader (and AsyncTask) are both included in the Android SDK. A non-SDK option
    (and highly recommended) is RXJava for Android: [https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid).
    RXJava is gaining popularity on Android and we're seeing more and more support
    for RXJava observables.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loader（和AsyncTask）都包含在Android SDK中。一个非SDK选项（并且强烈推荐）是RXJava for Android：[https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid)。RXJava在Android上越来越受欢迎，我们看到了越来越多的对RXJava可观察者的支持。
- en: Accessing external storage with scoped directories in Android N
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android N中使用范围目录访问外部存储
- en: With security awareness on the rise, users are becoming more skeptical about
    allowing apps to have unnecessary permissions. Android N introduces a new option
    called Scoped Directory Access, allowing your application to request access to
    only the required permissions, instead of general access to all folders.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 随着安全意识的提高，用户对允许应用程序拥有不必要的权限变得更加怀疑。Android N引入了一个名为范围目录访问的新选项，允许您的应用程序仅请求所需的权限，而不是对所有文件夹的通用访问。
- en: If your application requests `READ_EXTERNAL_STORAGE` and/or `WRITE_EXTERNAL_STORAGE`
    permission, but only needs access to a specific directory, you can use Scoped
    Directory access instead. This recipe will demonstrate how to request access to
    a specific directory, the `Music` folder in this case.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序请求`READ_EXTERNAL_STORAGE`和/或`WRITE_EXTERNAL_STORAGE`权限，但只需要访问特定目录，则可以使用范围目录访问。本配方将演示如何请求访问特定目录，即本例中的`Music`文件夹。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it `ScopedDirectoryAccess`.
    In the Target Android Device dialog, be sure to select API 24: Android 7.0 (Nougat)
    or higher for the Phone & Tablet option. Select Empty Activity on the Add an Activity
    to Mobile dialog.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`ScopedDirectoryAccess`。在“目标Android设备”对话框中，确保选择API
    24：Android 7.0（Nougat）或更高版本，对于“手机和平板”选项。在“添加移动活动”对话框中选择“Empty Activity”。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To initiate the user access request, we''ll add a button to the layout. Start
    by opening `activity_main.xml` and follow these steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动用户访问请求，我们将在布局中添加一个按钮。首先打开`activity_main.xml`，然后按照以下步骤操作：
- en: 'Replace the existing `TextView` with this button XML:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用此按钮XML替换现有的`TextView`：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, open `MainActivity.java` and add the following line of code to the class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`MainActivity.java`，并将以下代码行添加到类中：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the method to handle the button click:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理按钮点击的方法：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Override the `onActivityResult()` method as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下重写`onActivityResult()`方法：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The access request is handled by the OS, not by the app. To request access,
    we need to call `createAccessIntent()`, which we do with this line of code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 访问请求由操作系统处理，而不是由应用程序处理。要请求访问，我们需要调用`createAccessIntent()`，我们通过以下代码行来完成：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We call the Intent using the `startActivityForResult()` method, which we’ve
    used before. Since we are looking for a result to come back, we need to pass a
    unique identifier to know when the returned result callback is from our request.
    (The `onActivityResult()` callback method can receive callbacks for multiple requests.)
    If the request code matches our request, we then check whether the result code
    equals `Activity.RESULT_OK`, which means the user granted the permission request.
    We pass the result to `takePersistableUriPermission()` so we will not need to
    prompt the user the next time we need to access the same directory.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`startActivityForResult()`方法调用Intent，这是我们之前使用过的。由于我们正在寻找一个返回的结果，我们需要传递一个唯一的标识符，以便知道返回的结果回调是否来自我们的请求。（`onActivityResult()`回调方法可以接收多个请求的回调。）如果请求代码与我们的请求匹配，我们然后检查结果代码是否等于`Activity.RESULT_OK`，这意味着用户已授予权限请求。我们将结果传递给`takePersistableUriPermission()`，这样我们就不需要在下次需要访问同一目录时提示用户。
- en: Access to a directory also includes access to all sub-directories.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对目录的访问也包括对所有子目录的访问。
- en: There's more...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For the best user experience, observe the following best practices:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳用户体验，请遵循以下最佳实践：
- en: Make sure to persist the URI after the user grants permission to avoid repeatedly
    requesting the same permission (as we do with `takePersistableUriPermission()`)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在用户授予权限后持久化URI，以避免重复请求相同的权限（就像我们使用`takePersistableUriPermission()`那样）
- en: If the user denies the permission request, don't annoy your users by continuously
    asking
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户拒绝权限请求，不要通过不断询问来烦扰用户
- en: See also
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the following link for more information on the Storage Access Framework: [http://developer.android.com/guide/topics/providers/document-provider.html](http://developer.android.com/guide/topics/providers/document-provider.html)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关存储访问框架的更多信息，请参阅以下链接：[http://developer.android.com/guide/topics/providers/document-provider.html](http://developer.android.com/guide/topics/providers/document-provider.html)
