- en: Chapter 7. Testing Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。测试秘籍
- en: This chapter provides practical examples of different common situations that
    you will encounter by applying the disciplines and techniques described in the
    previous chapters. The examples are presented in a Cookbook style so you can adapt
    and use them for your projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了应用前几章中描述的纪律和技术时可能会遇到的不同常见情况的实际示例。这些示例以食谱风格呈现，以便你可以根据项目需求进行调整和使用。
- en: 'The following are the topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Android Unit tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 单元测试
- en: Testing activities and applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试活动和应用程序
- en: Testing databases and ContentProviders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据库和内容提供者
- en: Testing local and remote services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试本地和远程服务
- en: Testing UIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用户界面
- en: Testing exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异常
- en: Testing parsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试解析器
- en: Testing for memory leaks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试内存泄漏
- en: After this chapter you will have a reference to apply testing to your projects
    and to know what to do in every situation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将有一个参考，可以应用于你的项目，并了解在每种情况下应该做什么。
- en: Android Unit tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 单元测试
- en: There are some cases where you really need to test parts of the application
    in isolation with little connection to the underlying system. In such cases we
    have to select a base class that is high enough in the hierarchy to remove some
    of the dependencies but not high enough for us to be responsible for some of the
    basic infrastructure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况，你确实需要将应用程序的部分在几乎与底层系统没有关联的情况下单独测试。在这种情况下，我们必须选择一个足够高的基类来消除一些依赖，但又不能高到让我们负责一些基本基础设施。
- en: 'The candidate base class in this case is possibly `AndroidTestCase`. This example
    has been taken from the **Android CTS** test suite ([http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，候选基类可能是 `AndroidTestCase`。这个例子是从 **Android CTS** 测试套件中取出的（[http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html)）：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Up to here we have:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有：
- en: The standard Android Open Source Project copyright.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的 Android 开源项目版权。
- en: The package definition. This test lives in `com.android.cts.appaccessdata`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包定义。这个测试位于 `com.android.cts.appaccessdata`。
- en: Some imports.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些导入。
- en: The definition of `AccessPrivateDataTest`, which extends `AndroidTestCase` because
    it's a unit test that doesn't require the system infrastructure. In this particular
    case we could have also used `TestCase` directly, because we are not accessing
    Context.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessPrivateDataTest` 的定义，它扩展了 `AndroidTestCase`，因为它是一个不需要系统基础设施的单元测试。在这种情况下，我们也可以直接使用
    `TestCase`，因为我们没有访问 Context。'
- en: 'The definition of the constant `APP_WITH_DATA_PKG`, indicating the package
    name of the application containing the private data we are trying to access:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量 `APP_WITH_DATA_PKG` 的定义，表示包含我们试图访问的私有数据的应用程序包名：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this second part, we have:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第二部分，我们有：
- en: The definition of `PRIVATE_FILE_NAME`, containing the name of the file we will
    try to access
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE_FILE_NAME` 的定义，包含我们将尝试访问的文件名'
- en: The test method `testAccessPrivateData`, which actually exercises the feature
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试方法 `testAccessPrivateData`，它实际上测试了功能
- en: This test method, `testAccessPrivateData()`, tests the access to other packages'
    private data and fails if this is possible. To achieve this, the expected exceptions
    are caught and if this doesn't happen `fail()` is invoked with a custom message.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法 `testAccessPrivateData()` 测试对其他包的私有数据的访问，如果这是可能的，则测试失败。为了实现这一点，捕获了预期的异常，如果没有发生，则使用自定义消息调用
    `fail()`。
- en: Testing activities and applications
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试活动和应用程序
- en: This section shows some examples of activities and applications tests. They
    cover some common cases that you will find in your day-to-day testing and you
    can adapt them to suit your specific needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了活动和应用程序测试的一些示例。它们涵盖了你在日常测试中可能会遇到的一些常见情况，你可以根据具体需求对这些示例进行调整。
- en: Applications and preferences
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序和首选项
- en: In Android parlance, application refers to a base class used when it is needed
    to maintain a global application state. This is usually utilized for dealing with
    shared preferences. We expect that tests altering these preferences' values don't
    affect the behavior of the real application. Imagine the tests deleting user account
    information for an application storing these values as shared preferences. It
    doesn't sound like a good idea. So what we really need is the ability to mock
    a `Context` that also mocks the access to the `SharedPreferences`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android术语中，应用指的是在需要维护全局应用状态时使用的一个基类。这通常用于处理共享首选项。我们期望测试改变这些首选项值的操作不会影响真实应用的行为。想象一下测试删除存储这些值作为共享首选项的应用的用户账户信息。这听起来不是一个好主意。所以，我们真正需要的是能够模拟一个`Context`，它也能模拟对`SharedPreferences`的访问。
- en: Our first attempt could be to use `RenamingDelegatingContext`, but unfortunately,
    it does not mock `SharedPreferences`, although it is close because it mocks database
    and filesystem access. So, first we need to create a specialized mock `Context`
    that also mocks the latter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种尝试可能是使用`RenamingDelegatingContext`，但不幸的是，它并不模拟`SharedPreferences`，尽管它很接近，因为它模拟了数据库和文件系统访问。所以，首先我们需要创建一个专门的模拟`Context`，它也能模拟后者。
- en: The RenamingMockContext class
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`RenamingMockContext`类'
- en: Let's create the specialized `Context`. The class `RenamingDelegatingContext`
    is a very good point to start from because as we mentioned before, database and
    filesystem access will be mocked. The problem is how to mock `SharedPreferences`
    access.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门的`Context`。`RenamingDelegatingContext`类是一个很好的起点，因为我们之前提到，数据库和文件系统访问将被模拟。问题是如何模拟`SharedPreferences`的访问。
- en: 'Remember that `RenamingDelegatingContext` as its name suggests, delegates everything
    to a `Context`. So the root of our problem lies in this `Context`. Because it
    is a mock `Context` as well, `MockContext` seems to be the correct base class.
    As you may remember, in [Chapter 3](ch03.html "Chapter 3. Building Blocks on the
    Android SDK"), *Building Blocks on the Android SDK*, we looked at the mock object
    and we noted that `MockContext` can only be used to inject other dependencies
    and all methods are non-functional and throw `UnsupportedOperationException`.
    However, this is also a feature we can use to our advantage in detecting the minimum
    set of methods that needs to be implemented in a case like this. So let''s start
    creating an empty `MockContext` to whom the other `Context`, that we can name
    `RenamingMockContext`, delegates:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，正如其名称所暗示的，`RenamingDelegatingContext`将一切委托给一个`Context`。所以，我们问题的根源在于这个`Context`。因为它也是一个模拟的`Context`，所以`MockContext`似乎是一个正确的基类。如您所记得，在[第3章](ch03.html
    "第3章。Android SDK的构建块")中，我们探讨了模拟对象，并指出`MockContext`只能用于注入其他依赖项，并且所有方法都是非功能的，会抛出`UnsupportedOperationException`。然而，这也是我们可以利用的一个特性，以检测在这种情况下需要实现的最小方法集。所以，让我们开始创建一个空的`MockContext`，它将委托给其他`Context`，我们可以将其命名为`RenamingMockContext`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created a mock `Context, RenamingMockContext`, that delegates to another
    empty `MockContext, DelegatedMockContext`, and uses a renaming prefix.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模拟的`Context`，名为`RenamingMockContext`，它委托给另一个空的`MockContext`，即`DelegatedMockContext`，并使用一个重命名前缀。
- en: The TemperatureConverterApplicationTests class
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TemperatureConverterApplicationTests`类'
- en: We have the `RenamingMockContext`, now we need a test that uses it. Because
    we will be testing an application, the base class for the test would be `ApplicationTestCase`.
    This test case provides a framework in which you can test application classes
    in a controlled environment. It provides basic support for the lifecycle of an
    application, and hooks by which you can inject various dependencies and control
    the environment in which your application is tested. We can inject the `RenamingMockContext`
    before the `Application` is created using the `setContext()` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了`RenamingMockContext`，现在我们需要一个使用它的测试。因为我们将会测试一个应用，所以测试的基类将是`ApplicationTestCase`。这个测试用例提供了一个框架，在其中你可以在一个受控环境中测试应用类。它提供了对应用生命周期的基本支持，以及一些钩子，通过这些钩子你可以注入各种依赖项并控制你的应用被测试的环境。我们可以在创建`Application`之前使用`setContext()`方法注入`RenamingMockContext`。
- en: 'Our `TemperatureConverter` application, which we started in [Chapter 4](ch04.html
    "Chapter 4. Test Driven Development"), *Test Driven Development*, will be storing
    the decimal places as a shared preference. Consequently we will be creating a
    test to set the decimal places and then retrieving it to verify its value:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。测试驱动开发")“测试驱动开发”中开始的`TemperatureConverter`应用程序，将存储小数位数作为共享偏好设置。因此，我们将创建一个测试来设置小数位数，然后检索它以验证其值：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We extend `ApplicationTestCase` using the `TemperatureConverterApplication`
    template parameter. Soon, we will be creating the class extending `Application`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TemperatureConverterApplication`模板参数扩展`ApplicationTestCase`。很快，我们将创建一个扩展`Application`的类。
- en: Then we use the **Given name constructor** pattern that we discussed in [Chapter
    3](ch03.html "Chapter 3. Building Blocks on the Android SDK"), *Building Blocks
    on the Android SDK.*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们在[第3章](ch03.html "第3章。Android SDK的构建块")“Android SDK的构建块”中讨论的**给定名称构造函数**模式。
- en: In the `setUp()` method we create the mock context and set the context for this
    test using `setContext()` method; we create the application using `createApplication()`
    and finally hold a reference to it as it will be used frequently in our tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp()`方法中，我们创建模拟上下文并使用`setContext()`方法设置此测试的上下文；我们使用`createApplication()`创建应用程序，并最终持有它的引用，因为它将在我们的测试中频繁使用。
- en: Regarding our tests, using the **Test preconditions** pattern that we reviewed
    previously, we check that the recently created application is not null.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的测试，使用我们之前审查过的**测试前提条件**模式，我们检查最近创建的应用程序不为空。
- en: Lastly is the test that actually tests for the required behavior setting the
    decimal places, retrieving it, and verifying its value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是测试实际测试所需行为，设置小数位数，检索它，并验证其值。
- en: 'Our first objective is to get these tests to compile. Later we will focus on
    the success of these tests. To get it to compile, we need to create the class
    `TemperatureConverterApplication` and the getter and setter for decimal places,
    that ultimately should use `SharedPreferences` to store and retrieve the specific
    preference:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是让这些测试编译通过。稍后我们将关注这些测试的成功。为了编译通过，我们需要创建`TemperatureConverterApplication`类以及小数位数的getter和setter，最终应该使用`SharedPreferences`来存储和检索特定的偏好设置：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the tests we obtain a failure related to the fact that we are not storing
    the decimal places anywhere. We can implement this using `SharedPreferences` in
    this way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，我们得到一个失败，原因是我们没有在任何地方存储小数位数。我们可以通过以下方式使用`SharedPreferences`来实现这一点：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we complete these steps, compile and run the tests, we discover that they
    fail with an `UnsupportedOperationException` in `MockContext.getPackageName()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们完成这些步骤，编译并运行测试，我们会发现它们在`MockContext.getPackageName()`中失败，抛出`UnsupportedOperationException`。
- en: 'We change `DelegateMockContext` to override `getPackageName()`, delegating
    to the original context passed as a parameter to the constructor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`DelegateMockContext`改为覆盖`getPackageName()`，将构造函数中传递的原始上下文委托出去：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running the tests again, this time we obtain a different, though somewhat expected,
    `UnsupportedOperationException`. This exception is received while invoking `getSharedPreferences()`.
    Thus, the next step is to override this method in `DelegatedMockContext:`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，这次我们得到了一个不同但多少有些预期的`UnsupportedOperationException`。这个异常是在调用`getSharedPreferences()`时接收到的。因此，下一步是覆盖`DelegatedMockContext`中的这个方法：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Any time that a `SharedPreference` is requested, this method will invoke the
    delegating context, adding the prefix for the name. The original `SharedPreferences`
    used by the application are unchanged.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每次请求`SharedPreference`时，此方法将调用委托上下文，并为名称添加前缀。应用程序使用的原始`SharedPreferences`保持不变。
- en: We can verify this behavior by furnishing the `TemperatureConverterApplication`
    class with the previously mentioned methods, then storing some value in the shared
    preferences, running the tests, and eventually verifying that this value was not
    affected by running the tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`TemperatureConverterApplication`类提供之前提到的这些方法，然后在共享偏好设置中存储一些值，运行测试，并最终验证这个值没有被测试运行所影响来验证这种行为。
- en: Testing activities
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试活动
- en: The next example shows how an activity can be tested in complete isolation using
    `ActivityUnitTestCase<Activity>` base class as opposed to `ActivityInstrumentationTestCase2<Activity>`.
    This method requires more care and attention but also provides a greater flexibility
    and control over the `Activity` under test. This kind of test is intended for
    testing general `Activity` behavior and not an `Activity` instance's interaction
    with other system components or UI related tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用 `ActivityUnitTestCase<Activity>` 基类在完全隔离的情况下测试活动，而不是使用 `ActivityInstrumentationTestCase2<Activity>`。这种方法需要更多的注意力和关注，但也提供了对要测试的
    `Activity` 的更大灵活性和控制。这种测试旨在测试一般的 `Activity` 行为，而不是 `Activity` 实例与其他系统组件或 UI 相关的测试：
- en: 'We are taking this example from the ApiDemos sample application ([http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html))
    that is provided as an SDK companion. This sample is somewhat long so we have
    split it into several code snippets to improve its readability:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个 ApiDemos 示例应用程序中获取这个例子（[http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html)），这个应用程序作为
    SDK 伴侣提供。由于这个示例相对较长，所以我们将其拆分为几个代码片段以提高其可读性：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个代码片段除了必要的版权声明和导入之外，没有其他内容：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This second snippet includes the test case definition extending `ActivityUnitTestCase<Forwarding>`
    as we mentioned earlier as a unit test for an Activity class. This activity under
    test will be disconnected from the system so it is only intended to test internal
    aspects of it and not its interaction with other components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段包括测试用例定义，它扩展了 `ActivityUnitTestCase<Forwarding>`，正如我们之前提到的，这是一个 Activity
    类的单元测试。要测试的活动将从系统中断开连接，因此它仅用于测试其内部方面，而不是与其他组件的交互：
- en: 'The no-argument constructor is also defined here as we mentioned in previous
    examples:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中提到的，这里也定义了无参构造函数：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `setUp()` method follows the pattern of invoking the super method and initializes
    the field with the Intent used to start the Activity. In this case we are saving
    the `Intent` as member `mStartIntent:`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `setUp()` 方法遵循调用超类方法并使用启动 Activity 的 Intent 初始化字段的模式。在这种情况下，我们将 `Intent`
    保存为成员 `mStartIntent`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This defines the `testPreconditions()` method that we also explained before.
    As noted in the method''s comment, remember that this name is just a convention
    and no execution order is guaranteed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了 `testPreconditions()` 方法，我们之前也解释过。正如方法注释中提到的，请记住这个名称只是一个约定，没有保证执行顺序：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This test performs a click on the "go" button of the Forwarding Activity. The
    `onClickListener` of that button invokes `startActivity()` with an `Intent` defining
    the component as the `ForwardTarget` class, thus this is the `Activity` that will
    be started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在 Forwarding Activity 的“go”按钮上执行点击操作。该按钮的 `onClickListener` 调用 `startActivity()`
    并使用一个定义组件为 `ForwardTarget` 类的 `Intent`，因此这就是将被启动的 `Activity`：
- en: After performing this action we verify that the `Intent` used to launch the
    new `Activity` is not null and that `finish()` was called on our `Activity`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个动作后，我们验证用于启动新 `Activity` 的 `Intent` 不为 null，并且在我们的 `Activity` 上调用了 `finish()`：
- en: 'Once the activity under test is started using `startActivity(mStartIntent,
    null, null)`, the components are verified to assure that they are as expected.
    In order to do that, the recently started activity is verified for "not null"
    using an assertion on `getActivity()` and then the button that was obtained by
    `findViewById()` is also verified for a "not null" value:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用 `startActivity(mStartIntent, null, null)` 启动了要测试的活动，就会验证组件以确保它们符合预期。为了做到这一点，使用
    `getActivity()` 的断言来验证最近启动的活动不为“null”，然后也验证通过 `findViewById()` 获取的按钮是否为“null”值：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is perhaps the most interesting test method in this test case. This test
    case demonstrates how to exercise the `Activity` lifecycle. After starting the
    `Activity, onCreate()` was automatically called, and we then exercise other lifecycle
    methods by invoking them manually. To be able to invoke these methods we use the
    `Intrumentation` of this test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是这个测试用例中最有趣的测试方法。这个测试用例演示了如何测试 `Activity` 生命周期。在启动 `Activity` 后，自动调用了 `onCreate()`，然后我们通过手动调用它们来测试其他生命周期方法。为了能够调用这些方法，我们使用这个测试的
    `Intrumentation`。
- en: Finally, we don't manually invoke `onDestroy()` as it will be invoked for us
    in `tearDown().`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不需要手动调用 `onDestroy()`，因为它将在 `tearDown()` 中为我们调用：
- en: Next, we have the `testSubLaunch()` test. This test checks for various conditions
    after starting the `Activity` under test using `startActivity(mStartIntent, null,
    null)`. The `Button` is obtained using `findViewById()` and then it is pressed
    issuing `performClick().` The action when this button is touched is to launch
    a new `Activity` and this is precisely the condition that is checked, asserting
    that `getStartedActivityIntent()` returns "not null". The latter method returns
    the Intent that was used if the `Activity` under tests invoked `startActivity(Intent)`
    or `startActivityForResult(Intent, int)`. The last step is to verify that `finish()`
    was called if the other `Activity` was launched and we do that by verifying the
    return value of `isFinishCalled()`, which returns true if one of the finish methods
    (`finish(), finishFromChild(Activity)`, or `finishActivity(int)`) were called
    in the `Activity` under test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`testSubLaunch()`测试。这个测试在通过`startActivity(mStartIntent, null, null)`启动测试中的`Activity`后检查各种条件。使用`findViewById()`获取`Button`，然后通过`performClick()`来按下它。当这个按钮被触摸时，它的动作是启动一个新的`Activity`，这正是需要检查的条件，断言`getStartedActivityIntent()`返回"not
    null"。后者方法返回如果测试中的`Activity`调用了`startActivity(Intent)`或`startActivityForResult(Intent,
    int)`，则使用的Intent。最后一步是验证如果启动了其他`Activity`，则调用了`finish()`，我们通过验证`isFinishCalled()`的返回值来完成这一点，如果测试中的`Activity`中调用了finish方法（`finish()`、`finishFromChild(Activity)`或`finishActivity(int)`），则返回true。
- en: It's time to exercise the `Activity` lifecycle for which the `testLifeCycleCreate()`
    method is used. This method starts the `Activity` in the same way as the previously
    analyzed test.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试`Activity`的生命周期了，这可以通过`testLifeCycleCreate()`方法来实现。该方法以与之前分析过的测试相同的方式启动`Activity`。
- en: After that, the activity is started, its `onCreate()` method is called, and
    the `Instrumentation` is used to invoke other lifecycle methods like `getInstrumentation().callActivityOnStart(activity)`
    and `getInstrumentation().callActivityOnResume(activity)` to complete the `Activity`
    under test start up.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，活动启动，其`onCreate()`方法被调用，使用`Instrumentation`调用其他生命周期方法，如`getInstrumentation().callActivityOnStart(activity)`和`getInstrumentation().callActivityOnResume(activity)`来完成测试中的`Activity`启动。
- en: The `Activity` is now completely started and its time to test for the aspects
    we are interested in. Once this is achieved, we can follow other steps in the
    lifecycle. Note that this sample test does not test for anything special here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Activity`已经完全启动，是时候测试我们感兴趣的方面了。一旦实现这一点，我们就可以遵循生命周期中的其他步骤。请注意，这个示例测试在这里没有测试任何特殊的内容。
- en: To finish the lifecycle, we will call `getInstrumentation().callActivityOnPause(activity)`
    and `getInstrumentation().callActivityOnStop(activity)`. As it's mentioned in
    the method's comments, we don't have to worry about calling `onDestory()` as it
    will be automatically called by `tearDown()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成生命周期，我们将调用`getInstrumentation().callActivityOnPause(activity)`和`getInstrumentation().callActivityOnStop(activity)`。正如方法注释中提到的，我们不必担心调用`onDestroy()`，因为它将由`tearDown()`自动调用。
- en: 'If you want to run the tests, once you have the `ApiDemos.apk` and its tests
    installed onto a device or emulator, you can run this command line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行测试，一旦你将`ApiDemos.apk`及其测试安装到设备或模拟器上，你可以运行以下命令行：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '**com.example.android.apis.app.ForwardingTest:... Test results for InstrumentationTestRunner=...
    Time: 0.614 OK (3 tests)**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**com.example.android.apis.app.ForwardingTest:... 仪器测试运行器的测试结果=... 时间：0.614
    OK (3 tests)**'
- en: This test represents a skeleton you can reuse to test your `Activities` in isolation
    and to test lifecycle related cases. The injection of mock object could also facilitate
    testing other aspects of the `Activity` such as accessing system resources.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代表了一个可以重用的骨架，用于单独测试你的`Activities`以及测试与生命周期相关的案例。注入模拟对象也可以方便测试`Activity`的其他方面，例如访问系统资源。
- en: Testing files, databases, and ContentProviders
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件、数据库和ContentProviders
- en: Some test cases have the need to exercise databases or ContentProviders operations,
    and soon comes the need to mock these operations. For example, if we are testing
    an application on a real device, we don't want to interfere with the normal operation
    of applications on such devices, mainly when we change values that may be shared
    by more than one application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试用例需要执行数据库或ContentProviders的操作，很快就需要对这些操作进行模拟。例如，如果我们正在测试一个真实设备上的应用程序，我们不想干扰这些设备上应用程序的正常运行，尤其是在我们更改可能被多个应用程序共享的值时。
- en: Such cases can take advantage of another mock class that is not a part of `android.test.mock`
    package but of `android.test` instead, namely `RenamingDelegatingContext`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以利用另一个模拟类，它不是 `android.test.mock` 包的一部分，而是 `android.test` 包的一部分，即 `RenamingDelegatingContext`。
- en: This class lets us mock file and database operations. A prefix supplied in the
    constructor is used to modify the target of these operations. All other operations
    are delegated to the delegating `Context` that you must specify in the constructor
    too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类让我们可以模拟文件和数据库操作。在构造函数中提供的前缀用于修改这些操作的目标。所有其他操作都委托给在构造函数中指定的委托 `Context`。
- en: Suppose our `Activity` under test uses some files or databases that we want
    to control in some way, maybe to introduce specialized content to drive our tests,
    and we don't want to, or we cannot use real files or database. In such cases we
    create `RenamingDelegatingContext` specifying a prefix. We provide mock files
    using this prefix and introduce any content we need to drive our tests, and the
    `Activity` under test could you use them with no alteration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的被测试 `Activity` 使用一些我们想要以某种方式控制的文件或数据库，也许是为了引入专门的内容来驱动我们的测试，而我们不想使用或无法使用真实的文件或数据库。在这种情况下，我们创建一个指定前缀的
    `RenamingDelegatingContext`。我们使用这个前缀提供模拟文件，并引入我们需要的任何内容来驱动我们的测试，并且被测试的 `Activity`
    可以使用它们而无需更改。
- en: The advantage of keeping our `Activity` unchanged, that is not modifying it
    to read from a different source, is that this assures all tests are valid. If
    we introduce a change only intended for our tests, we will not be able to assure
    that under real conditions, the `Activity` behaves the same.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们的 `Activity` 不变，即不修改它以从不同的源读取，其优势是这确保了所有测试都是有效的。如果我们只为测试引入更改，我们就无法确保在实际条件下，`Activity`
    的行为相同。
- en: To demonstrate this case, we will create an extremely simple `Activity`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种情况，我们将创建一个非常简单的 `Activity`。
- en: 'The activity `MockContextExampleActivity` displays the content of a file inside
    `TextView`. What we intend to demonstrate is how it displays different content
    during normal operation of `Activity` as compared to when it is under test:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 活动类 `MockContextExampleActivity` 在 `TextView` 中显示文件内容。我们想要展示的是，与测试时相比，它在 `Activity`
    的正常操作中如何显示不同的内容：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is our simple `Activity`. It reads the content of the `myfile.txt` file
    and displays it on a `TextView`. It also displays any error that may occur.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们简单的 `Activity`。它读取 `myfile.txt` 文件的内容，并在 `TextView` 上显示。它还会显示可能发生的任何错误。
- en: 'We need some content for this file. Probably the easiest way of creating the
    files is as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个文件提供一些内容。可能最简单的方法是按照以下方式创建文件：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We created two different files, one named `myfile.txt` and the other `test.myfile.txt`,
    with different content. The latter indicates that it is a mock content.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个不同的文件，一个名为 `myfile.txt`，另一个名为 `test.myfile.txt`，内容不同。后者表示它是一个模拟内容。
- en: 'The following code demonstrates the use of this mock data in our activity tests:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了在我们的活动测试中使用此模拟数据：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The class `MockContextExampleTest` extends `ActivityUnitTestCase` because we
    are looking for isolated testing of `MockContextExampleActivity` and because we
    are going to inject a mocked context; in this case the injected context is a `RenamingDelegatinContext`
    as a dependency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `MockContextExampleTest` 扩展了 `ActivityUnitTestCase`，因为我们正在寻找对 `MockContextExampleActivity`
    的隔离测试，并且我们打算注入一个模拟上下文；在这种情况下，注入的上下文是一个作为依赖项的 `RenamingDelegatinContext`。
- en: Our fixture consists of the mock context, `mMockContext`, the `RenamingDelegatingContext`
    using the target context obtained by.getInstrumentation().getTargetContext().
    Note that the context where the instrumentation is run is different than the context
    of the `Activity` under test.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试设置包括模拟上下文 `mMockContext`，使用通过 `.getInstrumentation().getTargetContext()`
    获取的目标上下文创建的 `RenamingDelegatingContext`。请注意，运行测试的上下文与被测试 `Activity` 的上下文不同。
- en: Here a fundamental step follows—since we want to make the existing files and
    databases accessible to this test we have to invoke `makeExistingFilesAndDbsAccessible()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个基本步骤紧随其后——因为我们想要使现有的文件和数据库对这次测试可用，我们必须调用 `makeExistingFilesAndDbsAccessible()`。
- en: Then, our test named `testSampleTextDisplayed()` injects the mock context using
    `setActivityContext()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的测试名为 `testSampleTextDisplayed()` 的测试用例使用 `setActivityContext()` 注入模拟上下文。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You must invoke `setActivityContext()` to inject a mock context **before** you
    start the Activity under test by invoking `startActivity()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `startActivity()` 启动被测试的 `Activity` 之前，您必须调用 `setActivityContext()` 来注入模拟上下文
    **之前**。
- en: Then the `Activity` is started by `startActivity()` using an `Intent` just created.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过使用刚刚创建的`Intent`调用`startActivity()`来启动`Activity`。
- en: The `Activity` under test is obtained using `getActivity()` and it is verified
    for a "not null" value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的`Activity`是通过`getActivity()`获取的，并且会验证其值为“非空”。
- en: We obtain the text value held by the `TextView` by using a getter we added to
    the `Activity`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为`Activity`添加的getter方法来获取`TextView`持有的文本值。
- en: Finally, the text value obtained is checked against the `String`*"This is MOCK*
    data"*. It is important here to notice that the value used for this test is the
    test file content not the real file content.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取到的文本值会与`String`*"This is MOCK* data"*进行比对。在这里需要注意的是，用于此测试的值是测试文件内容，而不是实际文件内容。
- en: The BrowserProvider tests
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器提供者测试
- en: These tests are taken from the Android Open Source Project (AOSP). Source code
    can be obtained as a component of the Browser.git project at [http://android.git.kernel.org/?p=platform/packages/apps/Browser.git](http://android.git.kernel.org/?p=platform/packages/apps/Browser.git).
    They are intended to test some aspects of the Browser Bookmarks content provider,
    BrowserProvider, which is part of the standard Browser included with the Android
    platform.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试来自Android开源项目（AOSP）。源代码可以作为Browser.git项目的组成部分获取，项目地址为[http://android.git.kernel.org/?p=platform/packages/apps/Browser.git](http://android.git.kernel.org/?p=platform/packages/apps/Browser.git)。它们旨在测试浏览器书签内容提供者`BrowserProvider`的一些方面，它是Android平台标准浏览器的一部分。
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一个代码片段除了必要的版权声明和导入之外，没有其他内容：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This second snippet includes the test case definition extending `AndroidTestCase`.
    The class `BrowserProviderTests` extends `AndroidTestCase` because a `Context`
    is needed to access provider content.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段代码包括扩展`AndroidTestCase`的测试用例定义。类`BrowserProviderTests`扩展`AndroidTestCase`，因为需要`Context`来访问提供者内容。
- en: The fixture created in the `setUp()` method creates an `ArrayList` of `Uris`
    that is used to keep track of the inserted `Uris` to be deleted in the `tearDown()`
    method. Perhaps we could have saved all this hassle using a mock content provider,
    maintaining the isolation between our tests and the system. Anyway, `tearDown()`
    iterates over this list and deletes the stored `Uris`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp()`方法中创建的测试环境创建了一个`Uris`的`ArrayList`，用于跟踪在`tearDown()`方法中要删除的已插入`Uris`。也许我们可以通过使用模拟内容提供者来避免所有这些麻烦，保持测试与系统之间的隔离。无论如何，`tearDown()`会遍历这个列表并删除存储的`Uris`。
- en: 'There is no need to override the constructor here as `AndroidTestCase` is not
    a parameterized class and we don''t need to do anything special in it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不需要重写构造函数，因为`AndroidTestCase`不是一个参数化类，我们也不需要在其中做任何特殊处理：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next test, `testHasDefaultBookmarks()`, is a test for the default bookmarks.
    Upon startup a cursor iterates over the default bookmarks obtained by invoking
    `getBookmarksSuggest("")`, which returns the bookmarks unfiltered; that is why
    the query parameter is "".
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试`testHasDefaultBookmarks()`是针对默认书签的测试。启动时，光标会遍历通过调用`getBookmarksSuggest("")`获得的默认书签，该调用返回未过滤的书签；这就是为什么查询参数是""。
- en: Then, `testPartialFirstTitleWord(), testFullFirstTitleWord(), testFullFirstTitleWordPartialSecond()`,
    and `testFullTitle()` test for the insertion of bookmarks. To achieve this they
    invoke `assertInsertQuery()` using the bookmarked `Url`, its title, and the query.
    The method `assertInsertQuery()` adds the bookmarks to the bookmark provider,
    inserting the `Url` issued as a parameter with the specified title. The `Uri`
    returned is verified to be not null and not exactly the same as the default one.
    Finally the `Uri` is inserted in the list of `Uri` instances to be deleted in
    `testDown():`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`testPartialFirstTitleWord()`、`testFullFirstTitleWord()`、`testFullFirstTitleWordPartialSecond()`和`testFullTitle()`测试了书签的插入。为了实现这一点，它们使用书签的`Url`、标题和查询调用`assertInsertQuery()`方法。`assertInsertQuery()`方法将书签添加到书签提供者中，插入作为参数提供的`Url`以及指定的标题。返回的`Uri`会被验证，确保它不是null，并且与默认值不完全相同。最后，`Uri`会被插入到`testDown()`中要删除的`Uri`实例列表中：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These tests are similar to the tests presented before, but in this case they
    use Japanese titles and queries. It is recommended to test the application's components
    under different conditions like in this case where other languages with different
    character sets are used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试与之前展示的测试类似，但在这个案例中，它们使用了日语文本标题和查询。建议在不同的条件下测试应用程序的组件，例如在这个案例中使用了不同字符集的其他语言。
- en: 'We have several tests that are intended to verify the utilization of this bookmark
    provider for other locales and languages than just English. These particular cases
    cover the Japanese language utilization in bookmark titles. The tests `testFullTitleJapanese(),
    testPartialTitleJapanese()`, and `testSoundmarkTitleJapanese()` are the Japanese
    versions of the tests introduced before using Unicode characters:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个测试，旨在验证除了英语之外的其他地区和语言的此书签提供者的使用情况。这些特定案例涵盖了书签标题中的日语使用。测试 `testFullTitleJapanese()`、`testPartialTitleJapanese()`
    和 `testSoundmarkTitleJapanese()` 是之前引入的测试的日语版本，使用 Unicode 字符：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Several utility methods follow. These are the utilities used in the tests. We
    briefly looked at `assertInsertQuery()` before, so now let's look at the other
    methods as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是几个实用方法。这些是在测试中使用的实用工具。我们之前简要地看过 `assertInsertQuery()`，现在让我们也看看其他方法。
- en: 'The method `assertInsertQuery()` invokes `assertQueryReturns(url, title, query)`,
    after `addBookmark()`, to verify that the `Cursor` returned by `getBookmarksSuggest(query)`
    contains the expected data. This expectation can be summarized as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addBookmark()` 之后，`assertInsertQuery()` 方法调用 `assertQueryReturns(url, title,
    query)`，以验证 `getBookmarksSuggest(query)` 返回的 `Cursor` 包含预期的数据。这种期望可以总结为：
- en: Number of rows returned by the query is greater than 0
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的行数大于 0
- en: Number of rows returned by the query is equal to 1
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的行数等于 1
- en: The title in the returned row is not null
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回行中的标题不为空
- en: The title returned by the query is exactly the same as the method parameter
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的标题与方法参数完全相同
- en: The second line for the suggestion is not null
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议的第二行不为空
- en: The URL returned by the query is not null
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的 URL 不为空
- en: This URL matches exactly the URL issued as the method parameter
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此 URL 与作为方法参数发布的 URL 完全匹配
- en: 'This is a simplified Activity Diagram that will help us understand the relationship
    among these methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的活动图，将帮助我们理解这些方法之间的关系：
- en: '![The BrowserProvider tests](img/3500OS_07_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器提供者测试](img/3500OS_07_01.jpg)'
- en: These tests follow the basic structure described before and are depicted in
    the UML activity diagram. Firstly, `assertInsertQuery()` is invoked which in turns
    invokes `addBookmark()` and `assertQueryReturns()`. Then, `getBookmarksSuggest()`
    is called and finally the asserts to validate the conditions we are testing. The
    most outstanding thing here is the utilization of asserts in these utility methods,
    which helps us test conditions along the way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试遵循之前描述的基本结构，并在 UML 活动图中表示。首先，调用 `assertInsertQuery()`，它反过来调用 `addBookmark()`
    和 `assertQueryReturns()`。然后，调用 `getBookmarksSuggest()`，最后进行断言以验证我们正在测试的条件。这里最突出的是在这些实用方法中对断言的利用，这有助于我们在测试过程中测试条件。
- en: This strategy provides an interesting pattern to follow in our tests. Some of
    the utility methods that we need to create to complete our tests can also carry
    their own verification of several conditions and improve our test quality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略为我们测试提供了一种有趣的模式。我们需要创建以完成测试的一些实用方法也可以携带它们自己的多个条件的验证，并提高我们的测试质量。
- en: Creating assert methods in our classes allows us to introduce domain-specific
    testing language that can be reused when testing other parts of the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中创建断言方法允许我们引入特定领域的测试语言，该语言可以在测试系统的其他部分时重复使用。
- en: Testing exceptions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常
- en: We have mentioned this before. In [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Testing"), *Getting Started* with *Testing* we stated that you should
    test for exceptions and wrong values instead of just testing positive cases.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过。在 [第 1 章](ch01.html "第 1 章。开始测试") 中，我们提到应该测试异常和错误值，而不仅仅是测试正面案例。
- en: 'We have also presented this test before but here we are digging deeper into
    it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也介绍过这个测试，但在这里我们更深入地探讨它：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Every time we have a method that is supposed to generate an exception, we should
    test this condition. The best way of doing it is by invoking the method inside
    a try-catch block, catching the expected `Exception`, and failing otherwise. In
    this precise case we test for `InvalidTemperature:`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有一个应该抛出异常的方法时，我们应该测试这个条件。最好的方法是调用方法内部的 try-catch 块，捕获预期的 `Exception`，否则失败。在这个特定情况下，我们测试
    `InvalidTemperature:`
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing local and remote services
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试本地和远程服务
- en: This test is also from a ApiDemos sample application ([http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试也来自 ApiDemos 示例应用程序 ([http://developer.android.com/resources/samples/ApiDemos/index.html](http://developer.android.com/resources/samples/ApiDemos/index.html))。
- en: 'The idea is to extend the `ServiceTestCase<Service>` class to test a service
    in a controlled environment:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是扩展 `ServiceTestCase<Service>` 类以在受控环境中测试服务：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This first code snippet has nothing more than the required copyrights and imports:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个代码片段除了必要的版权声明和导入之外，没有其他内容：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we are using the no argument constructor as we did before, invoking the
    super constructor using the service class `LocalService:`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像之前一样使用无参数构造函数，使用服务类 `LocalService:` 调用超类构造函数：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we are using the pattern of invoking the super methods in `setUp()` and
    `tearDown()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用在 `setUp()` 和 `tearDown()` 中调用超类方法的模式。
- en: 'We are not setting up any specific fixture in this test so we are just invoking
    super methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中我们没有设置任何特定的固定装置，所以我们只是调用超类方法：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have an empty `testPreconditions()`. We don''t need any preconditions
    tested here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个空的 `testPreconditions()`。在这里我们不需要测试任何先决条件：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The constructor, as in other similar cases, invokes the parent constructor passing
    this service class as a parameter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，与其他类似情况一样，调用父构造函数，传递这个服务类作为参数。
- en: This is followed by a `testStartable()` test. It is annotated with the `SmallTest`
    annotation to categorize this test. Next we start the service using an Intent
    that we create here, setting its class to the class of the service under test.
    We also use the instrumented Context for this Intent. This class allows for some
    dependency injection, as every service depends on the Context in which it runs,
    and the application with which it is associated. This framework allows you to
    inject modified, mock, or isolated replacements for these dependencies, and thus
    performs a true unit test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是一个 `testStartable()` 测试。它被 `SmallTest` 注解标记，以分类这个测试。接下来我们使用我们在这里创建的 Intent
    启动服务，将其类设置为正在测试的服务类。我们也为这个 Intent 使用了 instrumented Context。这个类允许进行一些依赖注入，因为每个服务都依赖于它运行的上下文以及与之关联的应用程序。这个框架允许你注入修改过的、模拟的或隔离的替代品来替换这些依赖项，从而执行真正的单元测试。
- en: As we simply run our tests as-is, the `Service` will be injected with a fully-functional
    `Context`, and a generic `MockApplication` object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是按原样运行测试，`Service` 将被注入一个完全功能的 `Context` 和一个通用的 `MockApplication` 对象。
- en: Then we start the service using the `startService(startIntent)` method, in the
    same way as if it was started by `Context.startService()`, providing the arguments
    it supplied. If you use this method to start the service, it will automatically
    be stopped by `tearDown()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `startService(startIntent)` 方法启动服务，就像它是由 `Context.startService()` 启动的一样，提供它所提供的参数。如果你使用这个方法来启动服务，它将自动由
    `tearDown()` 停止。
- en: Another test, `testBindable(),` which is categorized as `MediumTest`, will be
    testing if the service can be bound. This test uses `bindService(startIntent)`,
    which starts the service under test, in the same way as if it was started by `Context.bindService()`,
    providing the arguments it supplied. It returns the communication channel to the
    service. It may return null if clients cannot bind to the service. Most probably
    this test should check for the null return value in the service with an assertion
    like `assertNotNull(service)` to verify that the service was bound correctly,
    but it doesn't. Be sure to include this test when you write code for similar cases.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试，`testBindable()`，被分类为 `MediumTest`，将测试服务是否可以被绑定。这个测试使用 `bindService(startIntent)`，以与
    `Context.bindService()` 相同的方式启动正在测试的服务，提供它所提供的参数。它返回到服务的通信通道。如果客户端无法绑定到服务，它可能返回
    null。最可能的是，这个测试应该通过一个断言如 `assertNotNull(service)` 来检查服务的 null 返回值，以验证服务是否正确绑定，但它没有这样做。确保在编写类似情况的代码时包含这个测试。
- en: 'The returned `IBinder` is usually for a complex interface that has been described
    using AIDL. In order to test with this interface, your service must implement
    a `getService()` method, as shown in `samples.ApiDemos.app.LocalService`, which
    has this implementation of that method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `IBinder` 通常用于一个使用 AIDL 描述的复杂接口。为了测试这个接口，你的服务必须实现一个 `getService()` 方法，正如在
    `samples.ApiDemos.app.LocalService` 中的实现所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Extensive use of mock objects
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广泛使用模拟对象
- en: In previous chapters we described and used the mock classes that are present
    in the Android SDK. While these classes could cover a great number of cases, that
    is not all and you may have the need for other mock objects to furnish your test
    cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述并使用了Android SDK中存在的模拟类。虽然这些类可以覆盖大量情况，但这并不是全部，你可能还需要其他模拟对象来完善你的测试用例。
- en: Several libraries provide the infrastructure to satisfy our mocking needs, but
    we are now concentrating on EasyMock which is perhaps the most widely used in
    Android.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 几个库提供了满足我们的模拟需求的基础设施，但我们现在专注于EasyMock，这可能是Android中使用最广泛的。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is not an EasyMock tutorial. We will just be analyzing its use in Android,
    so if you are not familiar with it I would recommend you take a look at the documentation
    available at its website: [http://easymock.org/](http://easymock.org/).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个EasyMock教程。我们只是分析其在Android中的应用，所以如果你不熟悉它，我建议你查看其网站上的文档：[http://easymock.org/](http://easymock.org/)。
- en: EasyMock, an Open Source software project available under the Apache 2.0 license,
    provides mock objects mainly for interfaces. It is a perfect match for Test Driven
    Development due to the way of recording expectations and its dynamically generated
    mock objects because they support refactoring, and test code will not break when
    renaming methods or changing its signature.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: EasyMock是一个开源软件项目，在Apache 2.0许可下可用，主要提供接口的模拟对象。由于其记录期望的方式和动态生成的模拟对象（因为它们支持重构，并且在重命名方法或更改其签名时测试代码不会中断），它非常适合测试驱动开发。
- en: 'According to its documentation, the most relevant benefits of EasyMock are
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其文档，EasyMock最相关的优点如下：
- en: Hand-writing classes for Mock Objects are not needed.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要手动编写模拟对象的类。
- en: Supports refactoring-safe Mock Objects. Test code will not break at runtime
    when renaming methods or reordering method parameters.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持重构安全的模拟对象。当重命名方法或重新排序方法参数时，测试代码在运行时不会中断。
- en: Supports return values and exceptions.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持返回值和异常。
- en: Supports checking the order of method calls, for one or more Mock Objects.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持检查一个或多个模拟对象的方法调用顺序。
- en: To demonstrate its usage and to establish a style that can be later reproduced
    for other tests we are completing and expanding test cases produced before for
    our application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其用法并建立一个可以后来复制的风格，我们正在完成和扩展之前为我们的应用程序产生的测试用例。
- en: In our previous `TemperatureConverter` example, we decided to extend `EditText`
    to create `EditNumber`, a text field that accepts only signed decimal numbers.
    `EditNumber` uses an `InputFilter` to provide this feature. In the following tests
    we will be exercising this filter to verify that the correct behavior is implemented.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`TemperatureConverter`示例中，我们决定扩展`EditText`来创建`EditNumber`，这是一个只接受有符号十进制数字的文本字段。`EditNumber`使用`InputFilter`来提供这个功能。在接下来的测试中，我们将测试这个过滤器以验证是否实现了正确的行为。
- en: To create the test we will be using a property that `EditNumber` inherits from
    `EditText`, that can add a listener, actually a `TextWatcher`, to provide methods
    that are called whenever the text of `EditText` changes. This `TextWatcher` is
    a collaborator for the test and we could have implemented it as a separate class,
    but this is tedious and may introduce more errors, so the approach taken is to
    use EasyMock to avoid the need of writing it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建测试，我们将使用`EditNumber`从`EditText`继承的一个属性，这个属性可以添加一个监听器，实际上是一个`TextWatcher`，在`EditText`的文本变化时调用方法。这个`TextWatcher`是测试的协作者，我们本可以将其实现为一个单独的类，但这很麻烦，可能会引入更多错误，因此采取的方法是使用EasyMock来避免编写它。
- en: And this is precisely how we are introducing a mock `TextWatcher` to check method
    invocations while text changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这样，我们引入了一个模拟`TextWatcher`来检查文本变化时的方法调用。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of EasyMock supported by Android as of this writing is EasyMock
    2.5.2\. You may want to try out a different one but it is likely you will encounter
    problems.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文写作时，Android支持的EasyMock最新版本是EasyMock 2.5.2。你可能想尝试不同的版本，但很可能会遇到问题。
- en: The first thing we should do is add `easymock-2.5.2.jar` to the Test project
    properties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事是将`easymock-2.5.2.jar`添加到测试项目的属性中。
- en: 'The following screenshot shows how the easymock JAR file was added to the **Java
    Build Path** of the Test project:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何将easymock JAR文件添加到测试项目的**Java构建路径**中：
- en: '![Extensive use of mock objects](img/3500_07_02.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![广泛使用模拟对象](img/3500_07_02.jpg)'
- en: 'In order to use EasyMock in our tests we only need to statically import its
    methods from `org.easymockEasyMock`, which are the only non-internal, non-deprecated
    methods of EasyMock 2:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的测试中使用 EasyMock，我们只需要从 `org.easymockEasyMock` 静态导入其方法，这些方法是 EasyMock 2
    的唯一非内部、非弃用的方法：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is preferable to use specific imports instead of using the wildcard, but
    it's not so easy to create the static import statement in Eclipse. However, if
    we organize imports (using **Source | Organize Imports** or the shortcut *Shift+Ctrl+O)*,
    Eclipse will create the specific statements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定导入而不是使用通配符更可取，但在 Eclipse 中创建静态导入语句并不容易。然而，如果我们组织导入（使用 **源 | 组织导入** 或快捷键
    *Shift+Ctrl+O)*，Eclipse 将创建特定的语句。
- en: Importing libraries
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入库
- en: 'We have added an EasyMock library to the project''s Java Build Path. This is
    usually not a problem, but sometimes rebuilding the project leads us to the following
    error that avoids the final APK. The problem is found when this final APK cannot
    be created because there is a problem while it is archived:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 EasyMock 库添加到项目的 Java 构建路径中。这通常不是问题，但有时重新构建项目会导致我们遇到以下错误，从而避免生成最终的 APK。问题出现在无法创建最终
    APK 时，因为存档过程中出现了问题：
- en: '**[2010-10-28 01:12:29 - TemperatureConverterTest] Error generating final archive:
    duplicate entry: LICENSE**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**[2010-10-28 01:12:29 - TemperatureConverterTest] 生成最终存档时出错：重复条目：LICENSE**'
- en: This depends on how many libraries are included by the project and what they
    are.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于项目包含多少库以及它们是什么。
- en: Most of the available Open Source libraries have a similar content as proposed
    by GNU and include files like LICENSE, NOTICE, CHANGES, COPYRIGHT, INSTALL, among
    others. We will find this problem as soon as we try to include more than one in
    the same project to ultimately build a single APK.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可用的开源库都有类似于 GNU 提出的类似内容，包括 LICENSE、NOTICE、CHANGES、COPYRIGHT、INSTALL 等文件。当我们尝试在同一个项目中包含多个库以最终构建单个
    APK 时，我们会发现这个问题。
- en: The solution to this problem is to repackage the library content renaming these
    files; for example, `LICENSE` could be renamed to `LICENSE.<library>`. It is recommended
    to add the suffix **android** to the repackaged library to keep track of these
    changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是重新打包库内容，重命名这些文件；例如，`LICENSE` 可以重命名为 `LICENSE.<library>`。建议将后缀 **android**
    添加到重新打包的库中，以跟踪这些更改。
- en: 'This is an example of the steps you may need to rename those files:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可能需要重命名这些文件的步骤示例：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The idea is to move the common file names to a name suffixed by the library
    name to provide some uniqueness.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是将常见的文件名移动到以库名称后缀的名称中，以提供一些唯一性。
- en: The testTextChanged test
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 `testTextChanged`
- en: This test will exercise `EditNumber` behavior, checking the method calls on
    the `TextWatcher` mock and verifying the results.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将测试 `EditNumber` 的行为，检查对 `TextWatcher` 模拟的方法调用并验证结果。
- en: We are using an `AndroidTestCase` because we are interested in testing `EditNumber`
    in isolation of other components or `Activities`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `AndroidTestCase`，因为我们对在与其他组件或 `Activities` 分离的情况下测试 `EditNumber` 感兴趣。
- en: 'This test defines two `String` arrays: sai and sar. `sai` stands for `String`
    array input and `sar` for `String` array result. As you may have guessed already,
    `sai` contains the input and `sar` the expected result for the corresponding element
    in the input after filters have been applied.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试定义了两个 `String` 数组：`sai` 和 `sar`。`sai` 代表 `String` 数组输入，`sar` 代表 `String`
    数组结果。正如你可能已经猜到的，`sai` 包含输入，而 `sar` 包含在应用过滤器后输入中相应元素的预期结果。
- en: 'In real life you should select more descriptive names for the variables used
    in the tests as you should do for your code, but here we are constrained by the
    space and thus we have selected very short names. The names `saInput` and `saResult`
    would be good choices:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你应该为测试中使用的变量选择更具描述性的名称，就像你应该对你的代码做的那样，但在这里我们受限于空间，因此选择了非常短的名字。`saInput`
    和 `saResult` 会是不错的选择：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin creating `sai` and `sar`. As we explained before they are two `String`
    arrays containing the inputs and results expected.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始创建 `sai` 和 `sar`。正如我们之前解释的，它们是包含输入和预期结果的两个 `String` 数组。
- en: Then we create a mock `TextWatcher` using `createMock(TextWatcher.class)` and
    assign it to `mEditNumber`, the `EditNumber` created in the test fixture.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `createMock(TextWatcher.class)` 创建一个模拟 `TextWatcher` 并将其分配给在测试用例中创建的
    `EditNumber`。
- en: We create a loop to iterate over every element of the `sai` array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个循环来遍历 `sai` 数组的每个元素。
- en: 'Next, we take the seven common steps usually needed to use the mock object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们采取通常需要的七个步骤来使用模拟对象：
- en: Create the mock using `createMock(), createNiceMock(),` or `createStrictMock()`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `createMock(), createNiceMock(),` 或 `createStrictMock()` 创建模拟。
- en: Record the expected behavior; all methods invoked will be recorded.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录预期的行为；所有调用的方法都将被记录。
- en: Replay, to change the state of the object from record to play when it really
    behaves like a mock object.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重放，将对象的状态从记录变为播放，当它真正表现得像模拟对象时。
- en: Exercise the methods, usually by invoking methods of the class under test.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习方法，通常是通过调用被测试类的方
- en: Test the results of the exercised methods using asserts. This step is optional
    for simpler cases.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用断言测试已执行方法的输出结果。对于简单情况，这一步是可选的。
- en: Verify that the behavior specified was actually followed. If this was not the
    case we will receive an exception.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证指定的行为是否确实被执行。如果不是这种情况，我们将收到一个异常。
- en: Reset can be used to reuse a mock object, clearing its state.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置可以用来重用模拟对象，清除其状态。
- en: In the record step we declare all the methods we are expecting to be invoked
    on the mock object together with its arguments. We use comparators for the arguments.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录步骤中，我们声明所有预期在模拟对象上调用及其参数的方法。我们使用比较器来处理参数。
- en: We will be using a special `Comparator, stringCmp()`, because we are interested
    in comparing the `String` content for different classes used by Android, such
    as `Editable, CharSequence, String`, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个特殊的 `Comparator, stringCmp()`，因为我们感兴趣的是比较 Android 中不同类使用的 `String` 内容，例如
    `Editable, CharSequence, String` 等。
- en: The other comparator, `eq()`, expects an `int` that is equal to the given value.
    The latter is provided by EasyMock for all primitive types and `Object`, but we
    need to implement `stringCmp()` as it supports some Android-specific usage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个比较器 `eq()` 期望一个等于给定值的 `int`。后者由 EasyMock 为所有原始类型和 `Object` 提供，但我们需要实现 `stringCmp()`，因为它支持一些
    Android 特定的用法。
- en: 'EasyMock has a predefined matcher that would help us in creating our comparator:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: EasyMock 有一个预定义的匹配器，可以帮助我们创建比较器：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `cmp` comparator method expects an argument that will be compared using
    the provided comparator using the operator. The comparison that will take place
    is `comparator.compare(actual, value) operator 0` where operator can be one of
    logical operator values in EasyMock's `LogicalOperator enum`, representing <,<=,>,>=,
    or ==.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 比较器方法期望一个参数，该参数将使用提供的比较器通过运算符进行比较。将要进行的比较是 `comparator.compare(actual,
    value) operator 0`，其中运算符可以是 EasyMock 的 `LogicalOperator enum` 中的逻辑运算符值之一，代表 <,<=,>,>=
    或 ==。'
- en: As you may have already realized, its frequent use in a test could be really
    complex and may lead to errors, so to simplify this process we will be using a
    helper class that we call `StringComparator:`
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经意识到，在测试中频繁使用可能会非常复杂，并可能导致错误，因此为了简化此过程，我们将使用一个我们称之为 `StringComparator:`
    的辅助类。
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This class implements the `Comparator<T>` interface, which has an abstract
    method named `compare`. We implement this method by returning the result of the
    comparison of the objects passed as arguments after they are converted to String.
    Remember that `compareTo(String string)` applied to a String compares the string
    specified as a parameter to the string using the Unicode values of the characters.
    Its return value is:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了 `Comparator<T>` 接口，该接口有一个名为 `compare` 的抽象方法。我们通过在将传递给参数的对象转换为字符串后返回比较结果来实现此方法。记住，应用于
    String 的 `compareTo(String string)` 比较是将作为参数指定的字符串与使用字符的 Unicode 值进行比较的字符串。它的返回值是：
- en: 0 (zero) if the strings contain the same characters in the same order
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串包含相同的字符且顺序相同，则为 0（零）
- en: A negative integer if the first non-equal character in this string has a Unicode
    value which is less than the Unicode value of the character at the same position
    in the specified string, or if this string is a prefix of the specified string
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个字符串中第一个不相同的字符的 Unicode 值小于指定字符串中相同位置的字符的 Unicode 值，或者如果这个字符串是指定字符串的前缀，则为负整数
- en: A positive integer if the first non-equal character in this string has a Unicode
    value which is greater than the Unicode value of the character at the same position
    in the specified string, or if the specified string is a prefix of this string
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个字符串中第一个不相同的字符的 Unicode 值大于指定字符串中相同位置的字符的 Unicode 值，或者如果指定字符串是这个字符串的前缀，则是一个正整数
- en: We could invoke `EasyMock.cmp()` directly using this comparator but to simplify
    things even further we will create a generic static method `stringCmp:`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用这个比较器调用 `EasyMock.cmp()`，但为了进一步简化事情，我们将创建一个通用的静态方法 `stringCmp:`。
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method will invoke `EasyMock.cmp()` using the right comparator for the
    specific type and using `EQUAL` as the operator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将使用特定类型的正确比较器和 `EQUAL` 作为操作符调用 `EasyMock.cmp()`。
- en: 'That is why in our test we can simply use:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么在我们的测试中我们可以简单地使用：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Introducing Hamcrest
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Hamcrest
- en: While the previous method is valid, a more generic approach would be to introduce
    **hamcrest**, a library of matcher objects (also known as constraints or predicates)
    allowing *match* rules to be defined declaratively, to be used in other frameworks.
    Hamcrest also provides adaptors for EasyMock 2.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前一种方法有效，但更通用的方法是将 **hamcrest** 引入，这是一个匹配器对象库（也称为约束或谓词），允许声明性地定义 *匹配* 规则，以便在其他框架中使用。Hamcrest
    还为 EasyMock 2 提供适配器。
- en: We will be revisiting our previous example introducing hamcrest for our matchers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视之前介绍 hamcrest 用于匹配器的示例。
- en: To be able to use hamcrest we need to include it to the **Java Build Path**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用 hamcrest，我们需要将其包含到 **Java 构建路径** 中。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example we use hamcrest-1.2, which is the latest release. Instead of
    using `hamcrest-1.2-all.jar` we use the individual components and the method described
    before to avoid several `LICENSE.txt` files from clashing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 hamcrest-1.2，这是最新版本。我们使用单个组件和之前描述的方法，而不是使用 `hamcrest-1.2-all.jar`，以避免多个
    `LICENSE.txt` 文件冲突。
- en: Download hamcrest library from [http://code.google.com/p/hamcrest.](http://code.google.com/p/hamcrest.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://code.google.com/p/hamcrest.](http://code.google.com/p/hamcrest.) 下载
    hamcrest 库
- en: 'You need to include the following JAR files:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要包含以下 JAR 文件：
- en: '`hamcrest-core`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hamcrest-core`'
- en: '`hamcrest-library`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hamcrest-library`'
- en: '`hamcrest-integration`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hamcrest-integration`'
- en: 'The following screenshot shows the new project properties after adding hamcrest
    libraries:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加 hamcrest 库后的新项目属性：
- en: '![Introducing Hamcrest](img/3500_07_03.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Hamcrest](img/3500_07_03.jpg)'
- en: Hamcrest matchers
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hamcrest 匹配器
- en: 'Hamcrest comes with a library of useful matchers. Here are some of the most
    important ones:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Hamcrest 随带一组有用的匹配器。以下是一些最重要的匹配器：
- en: '**Core**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Core**'
- en: '**anything:** Always matches; useful if you don''t care what the object under
    test is'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**anything:** 总是匹配；如果你不关心被测试的对象是什么，则很有用'
- en: '**describedAs:** Decorator to adding custom failure description'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**describedAs:** 添加自定义失败描述的装饰器'
- en: '**is:** Decorator to improve readability'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**is:** 提高可读性的装饰器'
- en: '**Logical**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Logical**'
- en: '**allOf:** Matches if all matchers match, short circuits (like Java &&)'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allOf:** 如果所有匹配器匹配，则匹配，短路（类似于 Java &&）'
- en: '**anyOf:** Matches if any matchers match, short circuits (like Java ||)'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**anyOf:** 如果任何匹配器匹配，则匹配，短路（类似于 Java ||）'
- en: '**not:** Matches if the wrapped matcher doesn''t match and vice versa'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**not:** 如果包装的匹配器不匹配，则匹配，反之亦然'
- en: '**Object**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**'
- en: '**equalTo:** Test object equality using `Object.equals`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**equalTo:** 使用 `Object.equals` 测试对象相等性'
- en: '**hasToString:** Test `Object.toString`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hasToString:** 测试 `Object.toString`'
- en: '**instanceOf, isCompatibleType:** Test type'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**instanceOf, isCompatibleType:** 测试类型'
- en: '**notNullValue, nullValue:** Test for null'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**notNullValue, nullValue:** 测试空值'
- en: '**sameInstance:** Test object identity'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sameInstance:** 测试对象身份'
- en: '**Beans**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beans**'
- en: '**hasProperty:** Test JavaBeans properties'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hasProperty:** 测试 JavaBeans 属性'
- en: '**Collections**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collections**'
- en: '**Array:** Test an array''s elements against an array of matchers'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组:** 测试数组元素与匹配器数组的匹配'
- en: '**hasEntry, hasKey, hasValue:** Test a map containing an entry, key, or value'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hasEntry, hasKey, hasValue:** 测试包含条目、键或值的映射'
- en: '**hasItem, hasItems:** Test a collection containing elements'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hasItem, hasItems:** 测试包含元素的集合'
- en: '**hasItemInArray:** Test an array containing an element'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hasItemInArray:** 测试包含元素的数组'
- en: '**Number**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**'
- en: '**closeTo:** Test floating point values are close to a given value'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**closeTo:** 测试浮点值接近给定值'
- en: '**greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo:** Test ordering'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo:** 测试排序'
- en: '**Text**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Text**'
- en: '**equalToIgnoringCase:** Test string equality ignoring case'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**equalToIgnoringCase:** 测试字符串忽略大小写的相等性'
- en: '**equalToIgnoringWhiteSpace:** Test string equality ignoring differences in
    runs of whitespace'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**equalToIgnoringWhiteSpace:** 测试忽略空白字符差异的字符串相等性'
- en: '**containsString, endsWith, startsWith:** Test string matching'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**containsString, endsWith, startsWith:** 测试字符串匹配'
- en: The hasToString matcher
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`hasToString` 匹配器'
- en: 'Our next step is to create the matcher to replace the previous use of the `stringCmp()`
    Comparator. `EasyMock2Adapter` is an adapter class provided by hamcrest:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建匹配器以替换之前使用的 `stringCmp()` 比较器。`EasyMock2Adapter` 是 hamcrest 提供的适配器类：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Having this matcher implemented, the following step is still required. We need
    to adapt the `testTextChanged()` method to include this newly created matcher
    instead of `stringCmp():`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了这个匹配器之后，接下来的步骤仍然是必要的。我们需要将`testTextChanged()`方法修改为包含这个新创建的匹配器，而不是`stringCmp():`
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Testing Views in isolation
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离测试视图
- en: The test we are analyzing here also belongs to the ApiDemos project. It demonstrates
    how some properties of the `Views` conforming a `Layout` can be tested when the
    behavior itself cannot be isolated. Testing focus is one of these situations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里分析的测试也属于ApiDemos项目。它展示了当行为本身无法隔离时，如何测试符合`Layout`的`Views`的一些属性。测试焦点就是这种情况之一。
- en: To avoid creating the full `Activity`, this test is extending `AndroidTestCase:`
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建完整的`Activity`，这个测试扩展了`AndroidTestCase:`
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As in previous cases we start with the required copyright and imports:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前例中一样，我们首先开始于所需的版权和导入：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we mentioned before, this test extends `AndroidTestCase` to provide a lightweight
    alternative to `ActivityInstrumentationTestCase<Activity>` when possible.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个测试扩展了`AndroidTestCase`，以便在可能的情况下提供一个轻量级的替代方案`ActivityInstrumentationTestCase<Activity>`。
- en: 'You may have thought about using just `TestCase`, but unfortunately this is
    not possible as we need a `Context` to inflate the XML layout via `LayoutInflater`,
    and `AndroidTestCase` will provide us with this component:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能考虑过只使用`TestCase`，但不幸的是，这是不可能的，因为我们需要一个`Context`来通过`LayoutInflater`展开XML布局，而`AndroidTestCase`将为我们提供这个组件：
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The fixture set up is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置的设置如下：
- en: '`FocusFinder` is a class that provides the algorithm used to find the next
    focusable `View`. It implements the singleton pattern and that''s why we use `FocusFinder.getInstance()`
    to obtain a reference to it. This class has several methods to help us find focusable
    and touchable items as we mentioned, given various conditions as the nearest in
    a given direction or searching from a particular rectangle.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FocusFinder`是一个提供查找下一个可聚焦`View`所使用的算法的类。它实现了单例模式，这就是为什么我们使用`FocusFinder.getInstance()`来获取其引用。这个类有几个方法可以帮助我们在给定各种条件下找到可聚焦和可触摸的项目，如我们之前提到的，给定方向上的最近项或从特定矩形中进行搜索。'
- en: Then we get the `LayoutInflater` and inflate the layout under test.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取`LayoutInflater`并展开测试中的布局。
- en: One thing we need to take into account, as our test is isolated from other parts
    of the system, is that we have to manually measure and layout the components.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要考虑的一件事是，由于我们的测试与其他系统部分是隔离的，我们必须手动测量和布局组件。
- en: 'Then, we use the *find views* pattern and we assign the found views to the
    fields:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用*查找视图*模式，并将找到的视图分配给字段：
- en: '[PRE43]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once the fixture has been configured we describe the precondition in a test
    which, as we mentioned earlier is named `testPreconditions()`. However, because
    tests are found using reflection, there is no guarantee that it will run in a
    particular order, as all of the test methods are looked for by evaluating if their
    name begins with test.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了固定装置，我们就在测试中描述预条件，正如我们之前提到的，该测试被命名为`testPreConditions()`。然而，由于测试是通过反射发现的，因此无法保证它将以特定的顺序运行，因为所有测试方法都是通过检查其名称是否以“test”开头来查找的。
- en: These preconditions include the verification of the relative position on the
    screen for the components. In this case their edges relative to the parent are
    used.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预条件包括对组件在屏幕上的相对位置的验证。在这种情况下，它们相对于父组件的边缘被使用。
- en: 'In a previous chapter we enumerated all the available asserts in our arsenal
    and you may remember that to test `Views` position, we had a complete set of assertions
    in the `ViewAsserts` class. However, this depends on how the layout is defined:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们列举了我们武器库中所有可用的断言，你可能还记得，为了测试`Views`的位置，我们在`ViewAsserts`类中有一个完整的断言集。然而，这取决于布局是如何定义的：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The method `testGoingRightFromLeftButtonJumpsOverCenterToRight()`, as its name
    suggests, tests the focus gained by the right button when the focus moves from
    the right to the left button. To achieve this search, the instance of `FocusFinder`
    obtained during the `setUp()` method is employed. This class has a `findNextFocus()`
    method to obtain the View receiving focus in a given direction. The value obtained
    is checked against our expectations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`testGoingRightFromLeftButtonJumpsOverCenterToRight()`方法，正如其名称所暗示的，测试当焦点从右侧移动到左侧按钮时，右侧按钮获得的焦点。为了实现这个搜索，我们在`setUp()`方法期间获得的`FocusFinder`实例被使用。这个类有一个`findNextFocus()`方法来获取在给定方向上接收焦点的View。获取的值与我们的期望值进行核对。'
- en: In a similar way, the test `testGoingLeftFromRightButtonGoesToCenter()`, tests
    the focus going in the other direction.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，测试`testGoingLeftFromRightButtonGoesToCenter()`测试了焦点向相反方向移动。
- en: Testing parsers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试解析器
- en: There are many occasions where your Android application relies on external XML,
    JSON messages, or documents obtained from web services. These documents are used
    for data interchange between the local application and the server. There are many
    use cases where XML or JSON documents are obtained from the server or generated
    by the local application to be sent to the server. Ideally, methods invoked by
    these activities have to be tested in isolation to have real unit tests and to
    achieve this, we need to include some mock files somewhere in our APK to run the
    tests.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你的Android应用程序依赖于从网络服务获取的外部XML、JSON消息或文档。这些文档用于本地应用程序和服务器之间的数据交换。有许多用例，其中XML或JSON文档从服务器获取或由本地应用程序生成，以发送到服务器。理想情况下，由这些活动调用的方法必须独立测试，以实现真正的单元测试，为此，我们需要在我们的APK中包含一些模拟文件以运行测试。
- en: But the question is where can we include these files?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是我们在哪里可以包含这些文件？
- en: Let's find out.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探究一下。
- en: Android assets
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android资产
- en: 'To begin, a brief review of the assets definition can be found in the Android
    SDK documentation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以在Android SDK文档中找到对资产定义的简要回顾：
- en: The difference between "resources" and "assets" isn't much on the surface, but
    in general, you'll use resources to store your external content much more often
    than you'll use assets. The real difference is that anything placed in the resources
    directory will be easily accessible from your application from the R class, which
    is compiled by Android. Whereas, anything placed in the assets directory will
    maintain its raw file format and, in order to read it, you must use the AssetManager
    to read the file as a stream of bytes. So keeping files and data in resources
    (res/) makes them easily accessible.
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “资源”和“资产”在表面上没有太大的区别，但一般来说，你更频繁地使用资源来存储外部内容，而不是使用资产。真正的区别在于，放置在资源目录中的任何内容都将通过Android编译的R类轻松访问，而放置在资产目录中的任何内容将保持其原始文件格式，为了读取它，你必须使用AssetManager以字节流的形式读取文件。因此，将文件和数据保存在资源（res/）中使它们易于访问。
- en: Clearly, assets are what we need to store the files that will be parsed to test
    the parser.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，资产是我们需要存储将要解析以测试解析器的文件。
- en: So our XML or JSON files should be placed on the assets folder to prevent manipulation
    at compile time and to be able to access their raw content while the application
    or test run.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的XML或JSON文件应该放置在资产文件夹中，以防止编译时的操作，并在应用程序或测试运行时能够访问它们的原始内容。
- en: But be careful; we need to place them in the assets folder of our **test project**
    because they are not part of the application and we don't want them packed with
    it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意；我们需要将它们放置在我们的**测试项目**的资产文件夹中，因为它们不是应用程序的一部分，我们不希望它们被打包进去。
- en: The parser activity
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析活动
- en: 'This is an extremely simple activity to demonstrate the case. Our activity
    obtains an XML or JSON document from a server and then parses it. Let''s assume
    we have a `parseXml` method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其简单的活动，用于演示这种情况。我们的活动从服务器获取XML或JSON文档，然后对其进行解析。假设我们有一个`parseXml`方法：
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is an oversimplified example of an activity that includes a parser method
    to illustrate the use of assets. Your real application may look very different
    and your parser could be implemented as an external class that could be tested
    in isolation and integrated at a later stage.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含解析方法的活动示例，用于说明资产的使用。你的实际应用程序可能看起来非常不同，你的解析器可以作为一个外部类实现，可以在稍后阶段独立测试和集成。
- en: The parser test
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器测试
- en: 'This test implements an `ActivityInstrumentationTestCase2` for the `ParserExampleActivity`
    class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试实现了`ParserExampleActivity`类的`ActivityInstrumentationTestCase2`：
- en: '[PRE46]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Almost all the methods are simple implementations of the default ones and the
    only interesting method for us is `testParseXml().` Firstly, the activity is obtained
    by invoking `getActivity()`. Then an `InputStream` is obtained, opening the file
    `my_document.xml` from the assets by `getInstrumentation().getContext().getAssets()`.
    Note that the `Context` and thus the assets obtained here are from the tests package
    not from the `Activity` under test.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的方法都是默认方法的简单实现，对我们来说唯一有趣的方法是`testParseXml()`。首先，通过调用`getActivity()`获取活动。然后通过`getInstrumentation().getContext().getAssets()`从资产中打开文件`my_document.xml`以获取`InputStream`。请注意，这里的`Context`以及获取到的资产来自测试包，而不是被测试的`Activity`。
- en: Next, the activity `parseXml()` method is invoked using the recently obtained
    `InputStream`. If there is an `Exception, fail()` is invoked and if everything
    goes well we test that the result is not null.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用最近获得的`InputStream`调用活动`parseXml()`方法。如果发生`Exception`，则调用`fail()`，如果一切顺利，我们测试结果不为null。
- en: We should then provide the XML we want to use for the test in an asset named
    `my_document.xml`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将用于测试的XML文件命名为`my_document.xml`。
- en: 'The content could be:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 内容可能如下：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Testing for memory leaks
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试内存泄漏
- en: Sometimes memory consumption is an important factor to measure the good behavior
    of the test target, be it an Activity, Service, ContentProvider, or other Component.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内存消耗是衡量测试目标良好行为的一个重要因素，无论是Activity、Service、ContentProvider还是其他组件。
- en: 'To test for this condition, we can use a utility test that you can invoke from
    other tests mainly after having run a test loop:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试此条件，我们可以使用一个实用测试，您可以在运行测试循环后从其他测试中调用它：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This assertion can be called from other tests. At the beginning it obtains the
    `MemoryInfo` from `ActivityManager` using `getMemoryInfo()`, after getting the
    instance using `getSystemService()`. The field `lowMemory` is set to true if the
    system considers itself to currently be in a low memory situation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此断言可以从其他测试中调用。开始时，它使用`getMemoryInfo()`从`ActivityManager`获取`MemoryInfo`，在通过`getSystemService()`获取实例后。如果系统认为当前处于低内存状态，则将`lowMemory`字段设置为true。
- en: In some cases we want to dive even deeper in the resource usage and we can obtain
    more detailed information from the process table.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望更深入地了解资源使用情况，我们可以从进程表中获取更详细的信息。
- en: 'We can create another helper method to obtain process information and use it
    in our tests:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个辅助方法来获取进程信息，并在我们的测试中使用它：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To obtain this information, a command (in this case, `ps` is used but you can
    adapt it to your needs) is executed using `Runtime.exec()`. The output of this
    command is concatenated in a `String` that is later returned. We can use the return
    value to print it to the logs in our test or we can further process the content
    to obtain summary information.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些信息，执行一个命令（在这种情况下，使用`ps`，但您可以根据需要对其进行调整）并使用`Runtime.exec()`。该命令的输出被连接到一个`String`中，稍后返回。我们可以使用返回值将其打印到测试中的日志，或者我们可以进一步处理内容以获取摘要信息。
- en: 'This is an example if logging the output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个记录输出的示例：
- en: '[PRE50]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When this test is run we obtain information about the running processes:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此测试时，我们获得有关正在运行的进程的信息：
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): USER PID PPID VSIZE RSS WCHAN
    PC NAME**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): USER PID PPID VSIZE RSS WCHAN
    PC NAME**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 1 0 312 220 c009b74c 0000ca4c
    S /init**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 1 0 312 220 c009b74c 0000ca4c
    S /init**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 2 0 0 0 c004e72c 00000000
    S kthreadd**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 2 0 0 0 c004e72c 00000000
    S kthreadd**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 3 2 0 0 c003fdc8 00000000
    S ksoftirqd/0**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 3 2 0 0 c003fdc8 00000000
    S ksoftirqd/0**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 4 2 0 0 c004b2c4 00000000
    S events/0**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 4 2 0 0 c004b2c4 00000000
    S events/0**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 5 2 0 0 c004b2c4 00000000
    S khelper**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 5 2 0 0 c004b2c4 00000000
    S khelper**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 6 2 0 0 c004b2c4 00000000
    S suspend**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 6 2 0 0 c004b2c4 00000000
    S suspend**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 7 2 0 0 c004b2c4 00000000
    S kblockd/0**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 7 2 0 0 c004b2c4 00000000
    S kblockd/0**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 8 2 0 0 c004b2c4 00000000
    S cqueue**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 8 2 0 0 c004b2c4 00000000
    S cqueue**'
- en: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 9 2 0 0 c018179c 00000000
    S kseriod**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-12 21:10:29.182: DEBUG/ActivityTest(1811): root 9 2 0 0 c018179c 00000000
    S kseriod**'
- en: '**[…]**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**[...]**'
- en: The output was cut for brevity but you will get the complete list of processes
    running on the system.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输出被截断以节省空间，但您将获得系统上运行的进程的完整列表。
- en: 'A brief explanation of the information obtained is as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的信息的简要说明如下：
- en: '| Column | Description |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| Column | Description |'
- en: '| --- | --- |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| USER | This is the textual user ID. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| USER | 这是文本用户ID。|'
- en: '| PID | Process ID number of the process. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| PID | 进程的进程ID号。|'
- en: '| PPID | Parent process ID. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| PPID | 父进程ID。|'
- en: '| VSIZE | Virtual memory size of the process in KiB. This is the virtual memory
    the process reserves. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| VSIZE | 进程的虚拟内存大小（KiB）。这是进程保留的虚拟内存。|'
- en: '| RSS | Resident set size, the non-swapped physical memory that a task has
    used (in pages). This is the actual amount of real memory the process takes in
    pages.This does not include pages which have not been demand-loaded in. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| RSS | 居住集大小，任务使用的非交换物理内存（以页面为单位）。这是进程实际占用的页面数。这不包括尚未按需加载的页面。|'
- en: '| WCHAN | This is the "channel" in which the process is waiting. It is the
    address of a system call, and can be looked up in a namelist if you need a textual
    name. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| WCHAN | 这是进程等待的“通道”。它是系统调用的地址，如果需要文本名称，可以在名称表中查找。|'
- en: '| PC | The current EIP (instruction pointer). |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| PC | 当前 EIP（指令指针）。|'
- en: '| State (no header) | The process state.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '| 状态（无标题） | 进程状态。|'
- en: S for sleeping in an interruptible state
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S 表示处于可中断的睡眠状态
- en: R for running
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 表示运行状态
- en: T for a stopped process
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T 表示一个停止的进程
- en: Z for a zombie
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z 表示僵尸进程
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| NAME | Command name. Application processes in Android are renamed after its
    package name. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| NAME | 命令名称。Android 中的应用进程在其包名之后被重命名。|'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, several real world examples of tests that cover a wide range
    of cases were presented. You can use them as a starting point while creating your
    own tests.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了几个涵盖广泛案例的测试的真实世界示例。您可以在创建自己的测试时将它们作为起点。
- en: We covered a variety of testing recipes that you can extend for your own tests.
    We used mock contexts and showed how a `RenamingDelegatingContext` can be used
    in various situations to change the data obtained by the tests. We also analyzed
    the injection of these mock context into test dependencies.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了各种测试配方，您可以将其扩展到自己的测试中。我们使用了模拟上下文，并展示了如何在不同情况下使用 `RenamingDelegatingContext`
    来更改测试获得的数据。我们还分析了将这些模拟上下文注入测试依赖项的过程。
- en: Then, we used `ActivityUnitTestCase` to test Activities in complete isolation.
    We tested Views in isolation using `AndroidTestCase`. We demonstrated the use
    of EasyMock 2 to mock objects combined with Hamcrest to provide comparators. Finally
    we treated the analysis of potential memory leaks.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `ActivityUnitTestCase` 来在完全隔离的状态下测试 Activity。我们使用 `AndroidTestCase`
    来单独测试 View。我们展示了如何使用 EasyMock 2 来模拟对象，并结合 Hamcrest 提供比较器。最后，我们处理了潜在内存泄漏的分析。
- en: The next chapter focuses on automating the testing process using Continuous
    Integration.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍使用持续集成来自动化测试过程。
