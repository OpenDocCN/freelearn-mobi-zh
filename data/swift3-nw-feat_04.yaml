- en: Chapter 4. Changes to Swifts Core Will Have You Asking for More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：Swift 核心变更将让你欲罢不能
- en: Many of the libraries have been touched to pull off this effort including-the
    Swift standard library, all of Cocoa and Cocoa Touch frameworks, Core Graphics,
    and Grand Central Dispatch. With the release of Swift 3, we can expect changes
    that reduce the awkwardness of the language's link to Objective-C, exuding way
    more *Swifty-ness*. The Swift team has introduced new API guidelines with the
    intention of giving the language its own character. The result is a huge renaming
    and refactoring effort that flows throughout the language. Swift 3 has undergone
    a huge facelift in terms of its interaction with Objective-C and C APIs. The Swift
    team is aiming to make your development experience feel more like Swift and less
    like directly dumping Objective-C into your code. Swift is its own language and
    should have its own feel just like any other programming language. Yet prior versions
    of Swift were heavily influenced by the need to interact with Objective-C and
    C APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库都受到了影响以完成这项工作，包括 Swift 标准库、所有 Cocoa 和 Cocoa Touch 框架、Core Graphics 和 Grand
    Central Dispatch。随着 Swift 3 的发布，我们可以期待一些减少语言与 Objective-C 链接尴尬性的变化，展现出更多的 *Swifty-ness*。Swift
    团队引入了新的 API 指南，目的是赋予语言其自身的特色。结果是整个语言范围内的大规模重命名和重构工作。Swift 3 在与 Objective-C 和 C
    API 的交互方面经历了一次巨大的改头换面。Swift 团队的目标是让你的开发体验感觉更像 Swift，而不是直接将 Objective-C 倒入你的代码中。Swift
    是它自己的语言，应该有自己的感觉，就像任何其他编程语言一样。然而，Swift 的早期版本受到了与 Objective-C 和 C API 交互需求的强烈影响。
- en: In this chapter, we will quickly highlight the philosophies for writing good
    Swift APIs. Afterward, we will spend the remaining chapter on language improvements
    for referencing and using Objective-C features in Swift 3 and importing code from
    Objective-C and C to Swift 3\. Every language change to Swift 3 is covered by
    one or more Swift Evolution proposals. As we cover a new feature, I'll also provide
    the proposal number that documents the rationale behind the change. While knowing
    the actual rational for a new feature is not critical to your understanding of
    how to implement its code, I think it is interesting to know the efforts and sometimes
    debates behind why a particular change was implemented. The Swift Evolution repository
    contains tons of information on accepted and rejected proposals. If you are a
    careful observer, you will also see proposals that were accepted for the Swift
    3 release but didn't get implemented in time for the release.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速概述编写良好 Swift API 的哲学。之后，我们将用剩余的章节来探讨 Swift 3 中对 Objective-C 功能的引用和使用以及从
    Objective-C 和 C 导入代码到 Swift 3 的语言改进。Swift 3 的每一次语言变化都由一个或多个 Swift Evolution 提案所涵盖。当我们介绍一个新特性时，我还会提供记录该变更背后理由的提案编号。虽然了解新特性的实际理由对于理解如何实现其代码不是至关重要的，但我认为了解背后所付出的努力和有时发生的辩论是有趣的。Swift
    Evolution 仓库包含了大量关于已接受和被拒绝提案的信息。如果你是一个细心的观察者，你还会看到一些被接受用于 Swift 3 发布但未能及时在发布中实现提案。
- en: The grand renaming
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大规模重命名
- en: 'Let''s start with the proposals for the Swift API Design Guidelines. The Grand
    Renaming proposals represent, collectively, a very large undertaking and are covered
    by proposals *SE-0005*, *SE-0006*, *SE-0086*, and *SE-0088*. Implementing the
    API guidelines represents the largest change to the language for Swift 3\. I couldn''t
    possibly cover every API change resulting in the Grand Renaming proposals in this
    short book. Thankfully, you don''t have to understand every line that changed
    in the libraries to be productive with Swift 3\. You have two fantastic resources
    that will pay dividends with very little effort on your part. The first resource
    is the Swift migration tool which converts existing Swift projects to the latest
    syntax. When you use the Swift migrator, you can convert your Swift 2.2 projects
    to Swift 3 and receive most of the changes for free. The second extremely valuable
    resource is the Swift API Guidelines, which were developed to help make your code
    more *Swifty*. The Swift API Guidelines are based on the following principles
    as quoted on [https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Swift API 设计指南的提案开始。大规模重命名提案共同代表了一个非常大的任务，包括 SE-0005、SE-0006、SE-0086 和
    SE-0088。实现 API 指南代表了 Swift 3 语言的最大变化。我无法在这本简短的书中涵盖所有导致大规模重命名提案的 API 变化。幸运的是，你不需要理解库中每行更改的内容就能在
    Swift 3 中高效工作。你有两个极有价值的资源，只需付出很少的努力就能带来回报。第一个资源是 Swift 迁移工具，它可以将现有的 Swift 项目转换为最新的语法。当你使用
    Swift 迁移器时，你可以将你的 Swift 2.2 项目转换为 Swift 3，并免费获得大多数更改。第二个极其宝贵的资源是 Swift API 指南，它旨在帮助你编写更“Swift”的代码。Swift
    API 指南基于以下原则，如 [https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/)
    上引用：
- en: '**Clarity at the point of use**:This is your most important goal. Entities
    such as methods and properties are declared only once but used repeatedly. Design
    APIs to make those uses clear and concise. When evaluating a design, reading a
    declaration is seldom sufficient, always examine a use case to make sure it looks
    clear in context.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用点的清晰度**：这是你的最重要的目标。例如方法和属性等实体只声明一次但被反复使用。设计 API 以使这些使用清晰简洁。在评估设计时，阅读声明通常是不够的，总是要检查使用案例以确保它在上下文中看起来清晰。'
- en: '**Clarity is more important than brevity**: Although Swift code can be compact,
    it is a *non-goal* to enable the smallest possible code with the fewest characters.
    Brevity in Swift code, where it occurs, is a side-effect of the strong type system
    and features that naturally reduce the boilerplate.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰度比简洁性更重要**：虽然 Swift 代码可以很紧凑，但使用尽可能少的字符来实现最小化代码并不是目标。在 Swift 代码中，简洁性（如果存在）是强大类型系统和自然减少模板代码的特性的副作用。'
- en: '**Write a documentation comment**: This for and every declaration. Insights
    gained by writing documentation can have a profound impact on your design, so
    don''t put it off.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写文档注释**：这是针对每个声明。通过编写文档获得的见解可能会对你的设计产生深远的影响，所以不要推迟。'
- en: For more details on adopting these guidelines, please refer to the WWDC 2016
    lecture on Swift API Guidelines at [https://developer.apple.com/videos/play/wwdc2016/403/](https://developer.apple.com/videos/play/wwdc2016/403/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有关采用这些指南的更多详细信息，请参阅 WWDC 2016 关于 Swift API 指南的讲座 [https://developer.apple.com/videos/play/wwdc2016/403/](https://developer.apple.com/videos/play/wwdc2016/403/)。
- en: Referencing Objective-C code in Swift 3
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Swift 3 中引用 Objective-C 代码
- en: With Swift 3, we get a slew of changes that make working with Objective-C and
    C APIs more enjoyable. We are going to cover the important changes that will make
    writing code more productive in Swift 3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift 3，我们得到了一系列使使用 Objective-C 和 C API 更愉快的变化。我们将介绍这些重要变化，这些变化将使在 Swift
    3 中编写代码更加高效。
- en: Referencing the Objective-C selector of property getters and setters - SE-0064
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用属性获取器和设置器的 Objective-C 选择器 - SE-0064
- en: 'In Objective-C, we can use a type called a **selector** to reference the name
    of a method. Swift 2.2 introduced `#selector` expressions to remove the error-prone
    nature of providing string literals as the selector name. In Swift 3, the language
    builds on #selector expressions by allowing you to reference getter and setter
    methods. This feature allows us to refer to getter and setter properties of objects.
    Let''s look at an example to see how we could access the setter for one of the
    properties on our `ClassRoom` class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，我们可以使用一个称为 **选择器** 的类型来引用方法的名称。Swift 2.2 引入了 `#selector` 表达式，以消除提供字符串字面量作为选择器名称时的易错性。在
    Swift 3 中，语言通过允许你引用获取器和设置器方法来构建在 `#selector` 表达式之上。这个特性允许我们引用对象的获取器和设置器属性。让我们通过一个例子来看看我们如何访问
    `ClassRoom` 类上某个属性的设置器：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now access the setter for the `roomNum` using `#selector(setter: ClassRoom.roomNum)`
    or the getter using `#selector(getter: ClassRoom.roomNum)`. Once we have our reference,
    we can use any of the NSObject perform methods available in Objective-C.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在可以使用 `#selector(setter: ClassRoom.roomNum)` 或 `#selector(getter: ClassRoom.roomNum)`
    来访问 `roomNum` 的设置器。一旦我们有了引用，我们就可以使用 Objective-C 中可用的任何 NSObject 执行方法。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md](https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md](https://github.com/apple/swift-evolution/blob/master/proposals/0064-property-selectors.md)
    阅读提案
- en: Referencing Objective-C key paths [SE-0062]
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用 Objective-C key paths [SE-0062]
- en: Similar to selectors, using Objective-C *keypaths* in Swift 2.2 required us
    to use string literals. Swift 3 introduces the `#keyPath` expressions to improve
    accuracy by replacing error-prone string literals with objects that can be checked
    at compile time. Our example below demonstrates how keypaths were done in Swift
    2.2 and how referencing keypaths improves with Swift 3.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与选择器类似，在 Swift 2.2 中使用 Objective-C *keypaths* 需要我们使用字符串字面量。Swift 3 引入了 `#keyPath`
    表达式，通过用可以在编译时检查的对象替换易错的字符串字面量来提高准确性。下面的例子展示了 Swift 2.2 中是如何处理 keypaths 的，以及 Swift
    3 中引用 keypaths 的改进。
- en: 'For Objective-C:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Objective-C：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Swift 2.2:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Swift 2.2：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Swift 3:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Swift 3：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our Swift 3 example above, we use the `#keyPath` expressions that are compile
    time checked that allow us to safely access values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的 Swift 3 示例中，我们使用了编译时检查的 `#keyPath` 表达式，这允许我们安全地访问值。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md](https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md](https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md)
    阅读提案
- en: Importing code from Objective-C and C APIs to Swift 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Objective-C 和 C API 导入到 Swift 3
- en: If you maintain Objective-C or C libraries and want to expose cleaner syntax
    for Swift, this section is for you! We now have the ability to provide more control
    over how constants, global functions, and generics are imported from Objective-C
    and C into Swift.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你维护 Objective-C 或 C 库，并希望为 Swift 提供更干净的语法，本节是为你准备的！我们现在有能力提供更多控制，以确定如何从 Objective-C
    和 C 导入常量、全局函数和泛型到 Swift。
- en: Importing Objective-C constants as Swift types [SE-0033]
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Objective-C 常量作为 Swift 类型导入 [SE-0033]
- en: Constants with global scope, defined in header files, are imported with the
    same global scope in Swift. In many cases, it would be more helpful to have related
    constants grouped together. In Swift 3, you can now annotate your type declarations
    with `NS_STRING_ENUM` or `NS_EXTENSIBLE_STRING_ENUM` to have those declarations
    imported as members of a common type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中定义的全局常量，在 Swift 中以相同的全局作用域导入。在许多情况下，将相关的常量分组在一起会更有帮助。在 Swift 3 中，你现在可以使用
    `NS_STRING_ENUM` 或 `NS_EXTENSIBLE_STRING_ENUM` 注释你的类型声明，以便将这些声明导入为公共类型的成员。
- en: Importing as Struct
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将其作为结构体导入
- en: 'If you want your constants to be imported as members of a struct, then add
    `NS_EXTENSIBLE_STRING_ENUM` to the end of your constant type declaration. For
    more consistent importing into Swift, name your constants using the same type
    as a prefix. In our example, we created a `MPPlatformIdentifier` type that we
    use as a prefix to name our constants: `MPPlatformIdentifierIOS`, `MPPlatformIdentifierMacOS`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的常量作为结构体的成员导入，那么请将 `NS_EXTENSIBLE_STRING_ENUM` 添加到你的常量类型声明的末尾。为了更一致地导入到
    Swift，请使用与类型相同的名称作为前缀。在我们的例子中，我们创建了一个 `MPPlatformIdentifier` 类型，我们将其用作前缀来命名我们的常量：`MPPlatformIdentifierIOS`、`MPPlatformIdentifierMacOS`。
- en: 'For Objective-C:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Objective-C：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This imports into Swift as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入到 Swift 中作为：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Importing as Enum
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以枚举方式导入
- en: Your other option is to have your constants imported as an enumeration type.
    Your constants are imported as an enum when you add `NS_STRING_ENUM` to the end
    of your type. Each constant that you define using this new type will be added
    to the enum in Swift.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您的另一个选择是将常量导入为枚举类型。当您在类型末尾添加 `NS_STRING_ENUM` 时，您的常量将作为枚举导入。您使用此新类型定义的每个常量都将添加到
    Swift 中的枚举中。
- en: 'For Objective-C:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Objective-C：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This imports into Swift as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式导入到 Swift 中：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md](https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置阅读提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md](https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md)
- en: Importing Objective-C lightweight generics [SE-0057]
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入 Objective-C 轻量级泛型 [SE-0057]
- en: In Swift 2, you could import and interact with Objective-C lightweight generics.
    While you could import lightweight generics of any form into Swift 2, only the
    Foundation types (`NSArray`, `NSSet`, and `NSDictionary`) preserved their type
    information after import.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，您可以导入并交互 Objective-C 轻量级泛型。虽然您可以将任何形式的轻量级泛型导入到 Swift 2 中，但只有 Foundation
    类型（`NSArray`、`NSSet` 和 `NSDictionary`）在导入后保留了它们的类型信息。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about lightweight generics by reading the Swift documentation
    on the subject here: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读有关此主题的 Swift 文档来了解更多关于轻量级泛型的信息：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html)
- en: With Swift 3, you can import your own Objective-C generics without losing information
    on the type. In our example below, we have several property types defined using
    Foundation collection types and a custom generic class. Notice that in both Swift
    2 and Swift 3, generics import their type information correctly for the Foundation
    collection types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中，您可以导入自己的 Objective-C 泛型而不会丢失类型信息。在我们的示例中，我们使用 Foundation 集合类型和自定义泛型类定义了几个属性类型。请注意，在
    Swift 2 和 Swift 3 中，泛型都正确地导入了 Foundation 集合类型的类型信息。
- en: 'For Objective-C:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Objective-C：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Imports into Swift 2 as:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式导入到 Swift 2 中：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sadly, we lose the type information for our custom generic property `myCollection`,
    when importing into Swift 2\. Swift rightly determines that the `myCollection`
    property is of `MyCollection` type, but the parameterized data is lost. Since
    we lost our type information on import, accessing `addItem()` of `myCollection`
    class results in a method signature that uses `AnyObject` for the parameter type.
    This is a subpar result as we expect the type to be `MyClass`, matching the Objective-C
    signature.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，当我们导入到 Swift 2 时，我们自定义泛型属性 `myCollection` 的类型信息丢失了。Swift 正确地确定 `myCollection`
    属性的类型为 `MyCollection`，但参数化数据丢失了。由于我们在导入时丢失了类型信息，访问 `myCollection` 类的 `addItem()`
    方法将导致使用 `AnyObject` 作为参数类型的签名。这不是我们期望的类型 `MyClass`，与 Objective-C 签名匹配。
- en: In Swift 3, this import issue is fixed. Our custom Objective-C generics are
    imported as expected. Examining our Swift 3 import, we can see that all of our
    generics keep their type information and our class methods will completely match
    their Objective-C counterparts for our custom generic classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中，这个导入问题得到了解决。我们的自定义 Objective-C 泛型按预期导入。检查我们的 Swift 3 导入，我们可以看到所有的泛型都保留了它们的类型信息，并且我们的类方法将完全匹配自定义泛型类的
    Objective-C 对应者。
- en: 'Imports into Swift 3 as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式导入到 Swift 3 中：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read the proposal at : [https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md](https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置阅读提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md](https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md)
- en: Importing as member [SE-0044]
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以成员方式导入 [SE-0044]
- en: Many C APIs provide functions that allow you to create, access, and modify C
    structures. Importing these libraries as-is will add these functions to your global
    namespace in Swift. While this is fine in many cases, it might be preferable to
    group these imports under common types in Swift. Swift 3 allows us to use the
    `CF_SWIFT_NAME` macro to control how initializers, properties, and methods display
    in Swift. Let's look at how we can accomplish these tasks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C API 提供了允许你创建、访问和修改 C 结构的函数。以原样导入这些库将把这些函数添加到你的 Swift 全局命名空间中。虽然这在许多情况下是可行的，但可能更倾向于将这些导入分组在
    Swift 的常见类型下。Swift 3 允许我们使用 `CF_SWIFT_NAME` 宏来控制初始化器、属性和方法在 Swift 中的显示方式。让我们看看我们如何完成这些任务。
- en: Defining an initializer
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个初始化器
- en: We can modify a C function to create a Swift initializer by appending a `CF_SWIFT_NAME`
    macro to the function definition in the header file. To tell Swift we want the
    function added as an initializer on a specific type, we need to provide the type
    (`MyPlatform`) followed by a dot and the *init* format we want (that is the parameters
    from the C function definition). Swift will import our new initializer as an extension
    on `MyPlatform`, representing our common type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在头文件中函数定义后附加 `CF_SWIFT_NAME` 宏来修改 C 函数以创建 Swift 初始化器。为了告诉 Swift 我们想要将函数添加为特定类型的初始化器，我们需要提供类型（`MyPlatform`）后跟一个点和我们想要的
    *init* 格式（即 C 函数定义中的参数）。Swift 将我们的新初始化器作为 `MyPlatform` 的扩展导入，代表我们的常见类型。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The common type needs to exist for Swift to add any extensions. Swift will not
    create this type for you and will fail silently if no type exists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 添加任何扩展都需要存在一个常见类型。Swift 不会为你创建这个类型，如果不存在类型，Swift 将会静默失败。
- en: 'For C:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This imports into Swift as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入到 Swift 中为：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating getters and setters
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建获取器和设置器
- en: In addition to initializers, we can also create computed properties. We can
    define the getters and setters that will be imported into Swift. For the property's
    getter, we need to add the `CF_SWIFT_NAME` macro to the end of the C function
    that will serve as the getter and provide a common type and a property name. Our
    setter will be similar in that we add the macro to the C function that serves
    as our setter property. See below for the syntax in action. In Swift 3, the getter
    and setter will be added to the common type `MyPlatform` using an extension.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始化器之外，我们还可以创建计算属性。我们可以定义将被导入到 Swift 中的获取器和设置器。对于属性的获取器，我们需要在作为获取器的 C 函数末尾添加
    `CF_SWIFT_NAME` 宏，并提供一个常见类型和属性名称。我们的设置器将与获取器类似，我们将在作为设置属性服务的 C 函数中添加宏。下面是语法在实际中的应用。在
    Swift 3 中，获取器和设置器将通过扩展添加到常见类型 `MyPlatform`。
- en: 'For C:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This imports into Swift as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入到 Swift 中为：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding methods
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加方法
- en: We can group methods under a common type during our import into Swift 3\. This
    is accomplished using the `CF_SWIFT_NAME` macro appended to the C function definition
    in our header file. You will need to provide the macro a common type and a method
    signature that uses the same number of variables as the C function. Swift will
    handle determining the parameter type. You just need to provide names you want
    to use as the signature in Swift.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将内容导入到 Swift 3 的过程中，我们可以将方法分组在常见类型下。这是通过在我们的头文件中 C 函数定义后附加 `CF_SWIFT_NAME`
    宏来实现的。你需要为宏提供一个常见类型和一个与 C 函数使用相同数量变量的方法签名。Swift 将处理确定参数类型。你只需要提供你想要在 Swift 中用作签名的名称。
- en: 'For C:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This imports into Swift as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入到 Swift 中为：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating static variables
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建静态变量
- en: Finally, we can import global variables as static variables associated with
    a common type in Swift 3\. We just need to provide a common type and variable
    name to our `CF_SWIFT_NAME` macro. Our static variable will be added to the common
    type in Swift via an extension.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 Swift 3 中将全局变量作为与常见类型关联的静态变量导入。我们只需要为我们的 `CF_SWIFT_NAME` 宏提供一个常见类型和变量名称。我们的静态变量将通过扩展添加到
    Swift 中的常见类型。
- en: 'For C:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This imports into Swift as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入到 Swift 中为：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read the proposal at: [https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md](https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置阅读提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md](https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md)
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We just finished covering the principles of Swift's API Guidelines. In addition,
    I provided you with resources on how to find the Swift Evolution proposals that
    document the motivations for each change. We also covered new features to work
    with `#selector` and `#keyPath` expressions when working with Objective-C APIs
    in Swift. Finally, we explored working with C APIs and controlling how they are
    imported into Swift 3\. In the next chapter, we will cover more language changes.
    Stay tuned as we still a have a lot of new things to cover!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了Swift API指南原则的讲解。此外，我还提供了如何查找记录每个变更动机的Swift Evolution提案的资源。我们还涵盖了在Swift中使用Objective-C
    API时处理`#selector`和`#keyPath`表达式的全新功能。最后，我们探讨了如何与C API一起工作并控制它们如何导入到Swift 3中。在下一章中，我们将介绍更多的语言变更。请保持关注，因为我们还有很多新内容要介绍！
