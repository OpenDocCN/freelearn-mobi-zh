- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Software Design with Dependency Injection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于依赖注入的软件设计
- en: Having introduced navigation and the Shell in .NET MAUI, we’ve laid the groundwork
    for building a comprehensive application. However, we are currently utilizing
    a mock data service, which we intend to modify in this chapter. Before diving
    into this, let’s first review the best practices in software design, starting
    with an overview of design principles. Later, we will explore how to leverage
    dependency injection in our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了.NET MAUI中的导航和Shell之后，我们已经为构建一个综合应用程序打下了基础。然而，我们目前正使用一个模拟数据服务，我们打算在本章中对其进行修改。在深入探讨之前，让我们首先回顾一下软件设计的最佳实践，从设计原则概述开始。稍后，我们将探讨如何在我们的应用程序中利用依赖注入。
- en: Software design principles and patterns typically form the backbone of best
    practices in software design. These principles offer rules and guidelines that
    software designers adhere to in crafting an efficient and clean design structure.
    They play a key role in shaping the software design process as they dictate the
    most effective practices. Design patterns are effectively best practices that
    experienced developers in object-oriented software employ. They function as templates
    designed to address repetitive design problems in specific contexts, offering
    reusable solutions that can be applied to prevalent issues in software design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计原则和模式通常是软件设计最佳实践的骨架。这些原则提供了规则和指南，软件设计师在构建高效和清晰的设计结构时遵循这些规则和指南。它们在塑造软件设计过程中起着关键作用，因为它们规定了最有效的实践。设计模式是经验丰富的面向对象软件开发者采用的有效最佳实践。它们作为模板，旨在解决特定上下文中的重复性设计问题，提供可重用的解决方案，这些解决方案可以应用于软件设计中的常见问题。
- en: '**Dependency Injection** (**DI**) is a software design pattern and technique
    that ensures a class is not dependent on its dependencies. It achieves this through
    decoupling an object’s utilization from its creation. The goal here is to create
    a system that is more adaptable, modular, and simpler to debug and maintain. DI
    is embodied in the **Dependency Inversion Principle (DIP)**, one of the five SOLID
    principles in object-oriented programming and design.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入（DI**）是一种软件设计模式和技巧，它确保一个类不依赖于其依赖项。它通过解耦对象的利用与其创建来实现这一点。这里的目的是创建一个更适应性强、模块化且易于调试和维护的系统。DI体现在**依赖倒置原则（DIP**）中，这是面向对象编程和设计中的五个SOLID原则之一。'
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: A brief overview of design principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计原则概述
- en: Implementing DI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现依赖注入（DI）
- en: Replacing the mock data store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换模拟数据存储
- en: DI is a method for implementing the design principle of dependency inversion,
    also known as the DIP. The DIP is one of the SOLID design principles, and we will
    learn how to incorporate SOLID principles into our design process. An overview
    of the SOLID design principles will be provided at the beginning of this chapter,
    before delving into the discussion on DI.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DI是实现依赖倒置设计原则的方法，也称为DIP。DIP是SOLID设计原则之一，我们将学习如何将SOLID原则融入我们的设计过程。在本章的开头，我们将提供SOLID设计原则的概述，然后再深入讨论DI。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章的源代码，您需要在您的PC或Mac上安装Visual Studio 2022。有关详细信息，请参阅*第1章*，*开始使用.NET MAUI*中的*开发环境设置*部分。
- en: 'The source code for this chapter is available in the following branch on GitHub:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter06](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/8067aa8a0ea9a275b33e64adaae7b09f7414851b).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub分支中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter06](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/8067aa8a0ea9a275b33e64adaae7b09f7414851b)。
- en: 'To check out the source code of this chapter, we can use the below command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书源代码的信息，请参阅*第2章*，*构建我们的第一个.NET MAUI应用程序*中的*管理本书的源代码*部分。
- en: A brief overview of design principles
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则概述
- en: Design principles are high-level guidelines that offer valuable advice on design
    considerations. These principles can provide essential guidance to help you make
    better design decisions. Some general design principles are applicable not only
    to software design but also to other design disciplines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则是高级指导方针，提供了关于设计考虑的有价值建议。这些原则可以提供基本指导，帮助你做出更好的设计决策。一些通用设计原则不仅适用于软件设计，也适用于其他设计领域。
- en: Let’s review some general design principles before we explore the commonly used
    design principles (SOLID) in software development.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨软件开发中常用的设计原则（SOLID）之前，让我们先回顾一些通用设计原则。
- en: Exploring types of design principles
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索设计原则的类型
- en: Design principles encompass a vast subject area. Thus, rather than delving into
    intricate details, I will provide insights from my experiences in implementing
    design principles during development, offering a concise overview of the principles
    discussed in this book. We will begin with high-level principles such as **DRY**,
    **KISS**, and **YAGNI**, and then progress to those more commonly used in software
    development. In the realm of **object-oriented programming** (**OOP**), the most
    widely used design principles are the SOLID principles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则涵盖了一个广泛的主题领域。因此，而不是深入细节，我将从我在开发过程中实施设计原则的经验中提供见解，对本书中讨论的原则提供一个简洁的概述。我们将从高级原则如
    **DRY**、**KISS** 和 **YAGNI** 开始，然后逐步过渡到在软件开发中更常用的那些。在面向对象编程（**OOP**）的领域，最广泛使用的设计原则是
    SOLID 原则。
- en: Don’t Repeat Yourself (DRY)
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复即冗余 (DRY)
- en: As people often say, don’t reinvent the wheel; we should strive to reuse existing
    components instead of redeveloping what has already been created.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人们常说的，不要重复造轮子；我们应该努力重用现有的组件，而不是重新开发已经创建的内容。
- en: Keep It Simple, Stupid (KISS)
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单至上，愚蠢 (KISS)
- en: We should choose a simple and straightforward approach rather than involve unnecessary
    complexity in a design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该选择简单直接的方法，而不是在设计过程中引入不必要的复杂性。
- en: You Aren’t Gonna Need It (YAGNI)
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你不会需要它 (YAGNI)
- en: We should implement functionality when it is required. In software development,
    there is a tendency to futureproof a design. This may create something that is
    actually not needed and increase the complexity of the solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在需要时实现功能。在软件开发中，有一种趋势是使设计具有前瞻性。这可能会创造出实际上并不需要的东西，并增加解决方案的复杂性。
- en: SOLID design principles
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOLID 设计原则
- en: 'SOLID design principles are widely employed in software development and serve
    as high-level guidelines for numerous design patterns. SOLID is an acronym that
    encapsulates the following five principles:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 设计原则在软件开发中被广泛采用，并作为众多设计模式的高级指导方针。SOLID 是一个首字母缩略词，它包含了以下五个原则：
- en: '**Single Responsibility Principle (SRP)**: A class should have a single responsibility.
    Adhering to this design principle, a developer should have only one reason to
    modify a class. By considering this principle during implementation, the resulting
    code becomes easier to comprehend and more effectively adapts to evolving requirements.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则 (SRP)**: 一个类应该只有一个职责。遵循这个设计原则，开发者应该只有一个理由去修改一个类。通过在实现过程中考虑这个原则，生成的代码更容易理解，并且更有效地适应不断变化的需求。'
- en: '**Open/Closed Principle (OCP)**: Classes should be open for extension but closed
    for modification. The central concept behind this principle is to prevent disruptions
    to existing code when introducing new features.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则 (OCP)**: 类应该对扩展开放，但对修改封闭。这个原则背后的核心概念是在引入新功能时防止对现有代码造成破坏。'
- en: '**Liskov Substitution Principle (LSP)**: If the object of the parent type can
    be used in a context, an object with a child type should also be able to function
    in the same manner without causing any errors or disruptions.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则 (LSP)**: 如果父类型的对象可以在某个上下文中使用，那么具有子类型的对象也应该能够以相同的方式运行，而不会引起任何错误或中断。'
- en: '**Interface Segregation Principle (ISP)**: A design should not implement an
    interface that it doesn’t use, and a class should not be forced to depend on methods
    it doesn’t intend to implement. We should design concise and simple interfaces
    rather than large and complex ones.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则 (ISP)**: 设计不应该实现它不使用的接口，并且一个类不应该被迫依赖于它不打算实现的方法。我们应该设计简洁简单的接口，而不是庞大复杂的接口。'
- en: '**Dependency Inversion Principle (DIP)**: This principle emphasizes the decoupling
    of software modules. High-level modules should not depend on low-level modules
    directly. Both should depend on abstractions. Abstractions should not depend on
    details. Details should depend on abstractions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则（DIP）**：这个原则强调软件模块的解耦。高级模块不应该直接依赖于低级模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。'
- en: Design principles are guidelines to help us to make better design decisions.
    However, the responsibility ultimately lies with us to determine the most suitable
    course of action during the actual implementation, rather than solely relying
    on these principles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则是帮助我们做出更好设计决策的指南。然而，最终的责任在于我们，在实施过程中确定最合适的行动方案，而不是仅仅依赖于这些原则。
- en: Since we will focus on the usage of DI in this chapter, please refer to the
    *Further reading* section to find more information about design principles (SOLID)
    and design patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将专注于本章中DI的使用，请参阅*进一步阅读*部分以获取有关设计原则（SOLID）和设计模式的更多信息。
- en: Using design principles
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设计原则
- en: Having discussed various design principles, allow me to share insights and lessons
    learned from implementing them in practice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了各种设计原则后，让我分享一些在实践实施中获得的见解和经验教训。
- en: 'In our app’s model, I utilized the **KeePassLib** from Dominik Reichl. While
    porting it to .NET Standard, I modified the inheritance hierarchy, as depicted
    in *Figure 6.1*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的模型中，我使用了来自Dominik Reichl的**KeePassLib**。在将其移植到.NET Standard的过程中，我修改了继承层次结构，如图*图6.1*所示：
- en: '![Figure 6.1: Class diagram of Item, PwEntry, and PwGroup](img/B21554_06_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：Item、PwEntry和PwGroup的类图](img/B21554_06_01.png)'
- en: 'Figure 6.1: Class diagram of Item, PwEntry, and PwGroup'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Item、PwEntry和PwGroup的类图
- en: In the process of porting KeePassLib to .NET Standard, I developed an abstract
    parent class, `Item`, for the group (`PwGroup`) and entry (`PwEntry`). This modification
    appears to violate OCP within the SOLID principles. The rationale behind this
    approach is rooted in a lesson I learned from the past implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在将KeePassLib移植到.NET Standard的过程中，我开发了一个抽象父类`Item`，用于组（`PwGroup`）和条目（`PwEntry`）。这种修改似乎违反了SOLID原则中的OCP。这种方法的理由源于我从过去实施中学到的一课。
- en: In earlier versions, prior to 1.2.3, I had not implemented **KPCLib** in the
    manner described. Instead, I directly used `PwGroup` and `PwEntry`, which required
    handling groups and entries separately. This resulted in increased complexity
    in `ItemsPage` and `ItemsViewModel`. This approach’s most significant consequence
    was the inability to distinctly separate the model and the view model. Consequently,
    I had to manage numerous details using **KeePassLib** directly within the view
    model. However, upon introducing the `Item` abstract parent class, I successfully
    concealed most of the intricate implementation within services (`IDataStore` and
    `IUserService`) and `PassXYZLib`. This led to the elimination of any code reliant
    on KeePassLib within the view and view model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本中，在1.2.3之前，我没有按照描述的方式实现**KPCLib**。相反，我直接使用了`PwGroup`和`PwEntry`，这需要分别处理组和条目。这导致了`ItemsPage`和`ItemsViewModel`的复杂性增加。这种方法最显著的影响是无法明确区分模型和视图模型。因此，我不得不在视图模型中直接使用**KeePassLib**来管理许多细节。然而，在引入`Item`抽象父类之后，我成功地隐藏了服务（`IDataStore`和`IUserService`）和`PassXYZLib`中的大部分复杂实现。这导致了视图和视图模型中任何依赖KeePassLib的代码的消除。
- en: The inspiration behind this change came from the KISS principle rather than
    merely adhering to OCP. When considering other SOLID principles, such as LSP and
    SRP, this modification significantly improved the overall architecture. It’s essential
    to recognize that, in practical work, conflicts can arise among various design
    principles. It is ultimately our responsibility to make informed decisions instead
    of adhering dogmatically to design principles. The most effective design decisions
    typically arise from the insights gained from prior failures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的灵感来自KISS原则，而不仅仅是遵循OCP。在考虑其他SOLID原则，如LSP和SRP时，这种修改显著提高了整体架构。重要的是要认识到，在实际工作中，各种设计原则之间可能会出现冲突。最终，我们的责任是做出明智的决定，而不是教条地遵循设计原则。最有效的设计决策通常源于从先前的失败中获得的见解。
- en: Returning to our main focus, we will now discuss enhancing the design by employing
    one of the SOLID principles—dependency inversion. As part of the SOLID design
    principles, dependency inversion emphasizes the separation of software modules,
    and it also provides guidelines on how to achieve this. The fundamental concept
    behind it is the preference of relying on abstractions whenever possible. In practice,
    DI is a technique routinely used to implement the idea of dependency inversion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的主要焦点，我们现在将讨论通过采用 SOLID 设计原则之一——依赖反转来增强设计。作为 SOLID 设计原则的一部分，依赖反转强调软件模块的分离，并提供了一些如何实现这一点的指导。其背后的基本概念是在可能的情况下优先依赖抽象。在实践中，DI
    是一种经常用来实现依赖反转概念的技巧。
- en: Implementing DI
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现依赖注入（DI）
- en: DI is a technique that can be utilized in .NET MAUI. Although not a novel concept,
    it has been extensively employed in backend frameworks like ASP.NET Core and the
    Java Spring Framework. DI facilitates dependency inversion (DIP) by decoupling
    an object’s usage from its creation, eliminating the need for direct reliance
    on the object. In our app, once we have separated the `IDataStore` interface implementation,
    we can commence with a mock implementation and subsequently replace it with the
    actual implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是一种可以在 .NET MAUI 中使用的技巧。尽管这不是一个新颖的概念，但它已经在像 ASP.NET Core 和 Java Spring Framework
    这样的后端框架中被广泛使用。DI 通过将对象的用法与其创建解耦，从而简化了依赖反转（DIP），消除了对对象的直接依赖。在我们的应用中，一旦我们分离了 `IDataStore`
    接口的实现，我们就可以开始使用模拟实现，并随后替换为实际实现。
- en: In .NET MAUI, the `Microsoft.Extensions.DependencyInjection` service, which
    we will refer to as MS.DI throughout this chapter, is readily available for us
    to utilize as a built-in feature.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，我们将称之为 MS.DI 的 `Microsoft.Extensions.DependencyInjection` 服务作为内置功能可供我们使用。
- en: In the realm of .NET, numerous DI containers are available besides MS.DI. Some
    of these alternatives, such as the Autofac DI container and the Simple Injector
    DI container, offer enhanced power and flexibility compared to MS.DI. At this
    point, one may wonder why we are choosing MS.DI over the other potent and adaptable
    DI containers. It is essential to revisit the KISS and YAGNI principles in this
    context. We should not opt for a more powerful solution with the assumption that
    we may utilize certain features in the future. Instead, the most straightforward
    and efficient approach is to leverage what we already possess without any additional
    effort.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 领域，除了 MS.DI 之外，还有许多可用的 DI 容器。其中一些替代方案，如 Autofac DI 容器和 Simple Injector
    DI 容器，与 MS.DI 相比提供了更强大的功能和灵活性。在这个时候，人们可能会想知道为什么我们选择 MS.DI 而不是其他强大且灵活的 DI 容器。在这种情况下，重新审视
    KISS（保持简单）和 YAGNI（不要过早优化）原则是至关重要的。我们不应该选择一个更强大的解决方案，假设我们可能会在未来使用某些功能。相反，最简单、最有效的方法是利用我们已有的东西，而不需要任何额外的努力。
- en: With MS.DI, we can avoid introducing extra dependencies. Regardless of our intention
    to use it, it is already incorporated in the .NET MAUI configuration. By simply
    adding a few lines of code, we can enhance our design. Alternative DI containers
    may offer more sophisticated features, but we would need to include additional
    dependencies and perform the necessary configuration in our code before utilizing
    them. If you are working on a complex system design, it’s recommended to evaluate
    the available DI containers and select the most suitable one for your system.
    In our scenario, **PassXYZ.Vault** is a relatively straightforward app, and we
    will not directly benefit from the advanced DI features offered by Autofac or
    Simple Injector. The functionalities provided by MS.DI are adequate for our implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MS.DI，我们可以避免引入额外的依赖。无论我们的意图如何，它已经包含在 .NET MAUI 的配置中。通过简单地添加几行代码，我们就可以增强我们的设计。其他
    DI 容器可能提供更复杂的功能，但我们需要在我们的代码中包含额外的依赖，并在使用它们之前进行必要的配置。如果你正在处理复杂系统设计，建议评估可用的 DI 容器，并选择最适合你系统的那个。在我们的场景中，**PassXYZ.Vault**
    是一个相对简单的应用，我们不会直接从 Autofac 或 Simple Injector 提供的先进 DI 功能中受益。MS.DI 提供的功能对于我们的实现来说是足够的。
- en: 'In our app, the module we aim to decouple is the model layer, which derives
    from a third-party library provided by KeePass. As depicted in the package diagram
    in *Figure 6.2*, our system comprises three distinct assemblies: **KPCLib**, **PassXYZLib**,
    and **PassXYZ.Vault**.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们旨在解耦的模块是来自 KeePass 提供的第三方库的模型层。如图 *图 6.2* 所示，我们的系统由三个不同的程序集组成：**KPCLib**、**PassXYZLib**
    和 **PassXYZ.Vault**。
- en: '![A diagram of a computer server  Description automatically generated](img/B21554_06_02.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![计算机服务器的图  描述自动生成](img/B21554_06_02.png)'
- en: 'Figure 6.2: Package diagram'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：包图
- en: The **KPCLib** package encompasses two namespaces, **KeePassLib** and **KPCLib**.
    **PassXYZLib** serves as an extension package to augment the **KPCLib** package’s
    functionality using .NET MAUI-specific implementation. **PassXYZ.Vault**, our
    app, relies directly on the **PassXYZLib** package and indirectly on the **KPCLib**
    package. In accordance with the DI principle, we aim to establish dependencies
    on abstractions rather than concrete implementations. To achieve this, we have
    designed two interfaces, `IDataStore` and `IUserService`, which enable us to decouple
    from the actual implementations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**KPCLib** 包包含两个命名空间，**KeePassLib** 和 **KPCLib**。**PassXYZLib** 作为扩展包，使用 .NET
    MAUI 特定的实现来增强 **KPCLib** 包的功能。我们的应用程序 **PassXYZ.Vault** 直接依赖于 **PassXYZLib** 包，间接依赖于
    **KPCLib** 包。根据 DI 原则，我们旨在建立对抽象的依赖，而不是对具体实现的依赖。为了实现这一点，我们设计了两个接口，`IDataStore`
    和 `IUserService`，使我们能够从实际实现中解耦。'
- en: 'The actual implementations that require access to KPCLib and PassXYZLib are
    encapsulated in the classes that implement these two interfaces: `IDataStore`
    and `IUserService`. The remainder of the code needed to access the functionalities
    in **KPCLib** and **PassXYZLib** can utilize these two interfaces. The key point
    is that we always have the flexibility to replace the implementations of `IDataStore`
    and `IUserService` if necessary. The remaining code will not be affected by these
    changes.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要访问 KPCLib 和 PassXYZLib 的实际实现被封装在实现这两个接口的类中：`IDataStore` 和 `IUserService`。访问
    **KPCLib** 和 **PassXYZLib** 中功能所需的其余代码可以利用这两个接口。关键点是我们始终有灵活性，在必要时替换 `IDataStore`
    和 `IUserService` 的实现。剩余的代码不会受到这些更改的影响。
- en: 'In order to utilize MS.DI as a DI service, two primary steps are involved:
    registration and resolution.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 MS.DI 作为 DI 服务使用，涉及两个主要步骤：注册和解析。
- en: Initially, we must register our interfaces (such as `IDataStore`) and their
    corresponding implementations (such as `MockDataStore`) during the program’s startup.
    Following that, we can utilize these registered interfaces throughout our program
    without manually creating them. We can then resolve these registered dependencies
    using the DI container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们必须在程序启动期间注册我们的接口（如 `IDataStore`）及其相应的实现（如 `MockDataStore`）。之后，我们可以在整个程序中利用这些已注册的接口，而无需手动创建它们。然后，我们可以使用
    DI 容器解决这些已注册的依赖项。
- en: 'The `ServiceCollection` class serves as the means for registration, while the
    `ServiceProvider` class facilitates resolution, as depicted in *Figure 6.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceCollection` 类作为注册的手段，而 `ServiceProvider` 类则促进解析，如图 6.3 所示：'
- en: '![Figure 6.3: Usage of MS.DI](img/B21554_06_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：MS.DI 的使用](img/B21554_06_03.png)'
- en: 'Figure 6.3: Usage of MS.DI'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：MS.DI 的使用
- en: '*Figure 6.3* presents a simplified class diagram of `ServiceCollection` and
    `ServiceProvider` at the top. `ServiceCollection` serves as the default implementation
    of the `IServiceCollection` interface, while `ServiceProvider` acts as the default
    implementation of the `IServiceProvider` interface.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.3* 展示了 `ServiceCollection` 和 `ServiceProvider` 的简化类图，位于顶部。`ServiceCollection`
    作为 `IServiceCollection` 接口的默认实现，而 `ServiceProvider` 则作为 `IServiceProvider` 接口的默认实现。'
- en: These interfaces, `IServiceCollection` and `IServiceProvider`, allow us to register
    and resolve dependencies. At the bottom of *Figure 6.3*, there’s a sequence diagram
    illustrating how to use both interfaces to achieve this. For a clearer understanding,
    we’ll use the `IDataStore` service as an example to explain the utilization of
    `IServiceCollection` and `IServiceProvider`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口，`IServiceCollection` 和 `IServiceProvider`，允许我们注册和解析依赖。在图 6.3 的底部，有一个序列图说明了如何使用这两个接口来实现这一点。为了更清晰地理解，我们将使用
    `IDataStore` 服务作为示例来解释 `IServiceCollection` 和 `IServiceProvider` 的使用。
- en: 'To utilize DI for implementing the `IDataStore` service, we can follow the
    steps outlined in the subsequent code block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 DI 实现 `IDataStore` 服务，我们可以遵循后续代码块中概述的步骤：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**(1)** To begin, we must first create an instance of the `ServiceCollection`
    class that implements the `IServiceCollection` interface.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1**）首先，我们必须创建一个实现 `IServiceCollection` 接口的 `ServiceCollection` 类的实例。'
- en: '**(2)** The `IServiceCollection` interface does not inherently specify any
    methods. Instead, a collection of extension methods is defined in the MS.DI namespace.
    Among these, the `AddSingleton` extension method can be utilized to register the
    concrete `MockDataStore` class that implements the `IDataStore` interface. The
    method `AddSingleton` is explained in the following section. This method employs
    a generic type to specify both the interface and its implementation. Additionally,
    there are several overloaded variations of the `AddSingleton` extension method
    at your disposal.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** `IServiceCollection` 接口本身并不指定任何方法。相反，在 MS.DI 命名空间中定义了一系列扩展方法。在这些方法中，可以使用
    `AddSingleton` 扩展方法来注册实现 `IDataStore` 接口的具体 `MockDataStore` 类。`AddSingleton` 方法将在下一节中解释。此方法使用泛型类型来指定接口及其实现。此外，`AddSingleton`
    扩展方法还有几个重载变体可供使用。'
- en: '**(3)** In order to access objects, we can obtain an instance of `ServiceProvider`
    by invoking the `BuildServiceProvider` extension method associated with `IServiceCollection`.
    The `ServiceProvider` class complies with the `IServiceProvider` interface. Notably,
    the `IServiceProvider` interface is located within the `System` namespace and
    exclusively defines the `GetService` method. Additional methods are designated
    as extension methods and can be found in the `Microsoft.Extensions.DependencyInjection`
    namespace, as illustrated in *Figure 6.3*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** 为了访问对象，我们可以通过调用与 `IServiceCollection` 关联的 `BuildServiceProvider` 扩展方法来获取
    `ServiceProvider` 的实例。`ServiceProvider` 类符合 `IServiceProvider` 接口。值得注意的是，`IServiceProvider`
    接口位于 `System` 命名空间中，并专门定义了 `GetService` 方法。其他方法被指定为扩展方法，可以在 `Microsoft.Extensions.DependencyInjection`
    命名空间中找到，如图 *6.3* 所示。'
- en: '**(4)** Once we have an instance of `ServiceProvider`, we can resolve the `IDataStore`
    interface using the `GetRequiredService` extension method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**(4)** 一旦我们有了 `ServiceProvider` 的实例，我们可以使用 `GetRequiredService` 扩展方法解析 `IDataStore`
    接口。'
- en: 'To manage the scope of a service, we can resolve it within the scope as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理服务的范围，我们可以在该范围内解析它如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will discuss the scope in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论范围。
- en: 'Though MS.DI is a lightweight DI service, it offers a sufficient range of features
    for .NET MAUI applications, as outlined below:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MS.DI是一个轻量级的依赖注入服务，但它为.NET MAUI应用程序提供了足够的功能，如下所述：
- en: Lifetime management of instances
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的终身管理
- en: Constructor, method, and property injections
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数、方法和属性注入
- en: In the upcoming sections, we will delve deeper into these features.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨这些功能。
- en: Lifetime management
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终身管理
- en: When using DI, you should consider how long instances of a registered service
    should be reused or retained before they are disposed of or new instances are
    created. Lifetime management is crucial in defining the scope within which a service
    instance is generated and shared.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用依赖注入（DI）时，你应该考虑注册服务的实例在销毁或创建新实例之前应该被重用或保留多长时间。终身管理对于定义服务实例生成和共享的范围至关重要。
- en: 'Here are a few aspects to consider for lifecycle management:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在生命周期管理方面，以下是一些需要考虑的方面：
- en: '**Resource management**: Resources, such as database connections utilized by
    a service, should not be left open indefinitely. For example, if a singleton service
    keeps a database connection open, it holds that resource for the application’s
    lifespan.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：资源，例如由服务使用的数据库连接，不应无限期地保持开启状态。例如，如果单例服务保持数据库连接开启，它将保留该资源直到应用程序的生命周期结束。'
- en: '**Performance**: It might not always be the most efficient approach to create
    a new instance of a service each time it’s needed, particularly if constructing
    the service is resource-intensive.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：每次需要服务时都创建一个新的服务实例可能并不总是最有效的方法，尤其是如果构建服务是资源密集型的。'
- en: '**Isolation**: If your service requires isolation (for instance, if it maintains
    some state), it’s essential to configure its lifecycle in accordance with the
    scope that satisfies such isolation requirements.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：如果你的服务需要隔离（例如，如果它维护某些状态），根据满足这种隔离要求的范围配置其生命周期是至关重要的。'
- en: '**Threading issues**: Singleton services need to be thread-safe as they’re
    shared among different requests, usually processed in parallel on separate threads.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程问题**：单例服务需要是线程安全的，因为它们在不同的请求之间共享，通常在单独的线程上并行处理。'
- en: Using MS.DI, we can manage the lifespan of these instances by configuring the
    `ServiceCollection`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MS.DI，我们可以通过配置 `ServiceCollection` 来管理这些实例的生命周期。
- en: 'There are commonly three types of lifetimes in dependency injection, and we
    can configure them using extension methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入中通常有三种生命周期类型，我们可以使用扩展方法来配置它们：
- en: '**Singleton**: A single instance of the service is created when requested for
    the first time and then reused for all subsequent requests throughout the application’s
    lifetime. All callers receive the same instance, meaning a singleton service behaves
    like a shared global resource. Singleton services can retain state and are useful
    for providing centralized management of resources, such as logging, caching, or
    configuration. The extension method `AddSingleton` can be used to create a single
    instance throughout the life of the application.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singleton**：当首次请求服务时创建服务的单个实例，并在整个应用程序的生命周期内重用。所有调用者都接收相同的实例，这意味着单例服务表现得像一个共享的全局资源。单例服务可以保留状态，并且对于提供资源（如日志记录、缓存或配置）的集中式管理非常有用。可以使用扩展方法`AddSingleton`在整个应用程序的生命周期内创建单个实例。'
- en: '**Scoped**: A scoped service creates a new instance per scope, typically per
    request in a web application. Each scope has its instance of the service, which
    is shared among all components within that specific scope. Scoped services are
    useful for maintaining state specific to a single request or user interaction,
    such as user information, request details, or database connections in a per-request
    context. The extension method `AddScoped` can be used to create one instance and
    reuses the same instance within the defined scope.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scoped**：作用域服务为每个作用域创建一个新的实例，通常在Web应用程序中为每个请求创建。每个作用域都有一个服务的实例，该实例在该特定作用域内的所有组件之间共享。作用域服务适用于维护特定于单个请求或用户交互的状态，例如用户信息、请求详情或请求上下文中的数据库连接。可以使用扩展方法`AddScoped`创建一个实例并在定义的作用域内重用该实例。'
- en: '**Transient**: Transient services create a new instance each time the service
    is requested, ensuring that each caller gets a unique instance without sharing
    state or resources. Transient services are useful for services without an internal
    state or a need for resource management. They are often lightweight and don’t
    require sharing across different components. The extension method `AddTransient`
    can be used to create an instance for each call.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transient**：每次请求服务时，`Transient`服务都会创建一个新的实例，确保每个调用者都得到一个唯一的实例，而不共享状态或资源。`Transient`服务适用于没有内部状态或资源管理需求的服务的服务。它们通常轻量级，不需要在不同组件之间共享。可以使用扩展方法`AddTransient`为每次调用创建一个实例。'
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, in the lines marked by **(1)**, we registered `IUserService`
    as a `Singleton` object, `IDataStore` as a `Scoped` object, and `ItemsViewModel`
    as a `Transient` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，在标记为**（1）**的行中，我们将`IUserService`注册为`Singleton`对象，`IDataStore`注册为`Scoped`对象，`ItemsViewModel`注册为`Transient`对象。
- en: Following the registration, in the line marked by **(2)**, we instantiated a
    `ServiceProvider` and stored it in a `rootContainer` variable. In the lines marked
    by **(3)**, utilizing the `rootContainer`, we generated two scopes, named **scope1**
    and **scope2**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册之后，在标记为**（2）**的行中，我们实例化了一个`ServiceProvider`并将其存储在`rootContainer`变量中。在标记为**（3）**的行中，利用`rootContainer`，我们生成了两个作用域，分别命名为**scope1**和**scope2**。
- en: 'The lifetime management of these created objects can be examined in *Figure
    6.4*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些创建的对象的生命周期管理可以在*图6.4*中检查：
- en: '![A diagram of a software application  Description automatically generated](img/B21554_06_04.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![软件应用程序的图示 自动生成描述](img/B21554_06_04.png)'
- en: 'Figure 6.4: Lifetime management in MS.DI'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：MS.DI中的生命周期管理
- en: The variable`userService` is created as a `Singleton` object, ensuring that
    only one instance exists, and its lifetime is equal to that of the application.
    The two scopes—namely, **scope1** and **scope2**—possess distinct lifetimes determined
    by our design. The `Scoped` objects—**dataStore1** and **dataStore2**—have the
    same lifetime as the scope to which they belong. Meanwhile, the instances of `ItemViewModel`
    are `Transient` objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`userService`被创建为一个`Singleton`对象，确保只有一个实例存在，并且其生命周期与应用程序相同。两个作用域——即**scope1**和**scope2**——具有由我们的设计决定的独立生命周期。`Scoped`对象——**dataStore1**和**dataStore2**——与它们所属的作用域具有相同的作用域。同时，`ItemViewModel`的实例是`Transient`对象。
- en: In the case of the three methods—`AddSingleton`, `AddScoped`, and `AddTransient`—numerous
    overloaded variations have been defined to cater to an array of requirements pertaining
    to `ServiceCollection` configuration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种方法——`AddSingleton`、`AddScoped`和`AddTransient`——中，已经定义了多种重载变体，以满足与`ServiceCollection`配置相关的各种需求。
- en: 'In our application, we have two versions of the `IDataStore` interface implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们有`IDataStore`接口实现的两个版本：
- en: '`DataStore`: This version represents the actual implementation.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataStore`：这个版本代表实际的实现。'
- en: '`MockDataStore`: This version is employed for testing purposes.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockDataStore`：这个版本用于测试目的。'
- en: 'With MS.DI, we have the ability to utilize `MockDataStore` in the Debug build
    and employ `DataStore` in the Release build. This configuration can be executed
    as demonstrated in the subsequent code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MS.DI，我们能够在调试构建中使用`MockDataStore`，并在发布构建中使用`DataStore`。此配置可以按照后续代码片段中所示执行：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Configuring DI in .NET MAUI
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI配置DI
- en: MS.DI is incorporated into the .NET release, making it accessible for all types
    of applications in .NET 5 or subsequent versions. As we discussed in the previous
    section, we can implement DI using `ServiceCollection` and `ServiceProvider`.
    However, there is a more straightforward approach to utilizing MS.DI in .NET MAUI.
    With DI integrated as part of the .NET Generic Host configuration, there is no
    need for us to create an instance of `ServiceCollection` manually. This allows
    us to employ the preconfigured DI service directly, without any additional effort.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: MS.DI被纳入.NET发布版，使其在.NET 5或后续版本的所有类型的应用程序中可用。正如我们在上一节中讨论的，我们可以使用`ServiceCollection`和`ServiceProvider`来实现DI。然而，在.NET
    MAUI中利用MS.DI有一个更直接的方法。由于DI作为.NET通用主机配置的一部分集成，我们无需手动创建`ServiceCollection`的实例。这使我们能够直接使用预配置的DI服务，无需任何额外的工作。
- en: To gain a deeper understanding of the preconfigured DI service in .NET MAUI,
    let’s revisit the .NET MAUI application startup process as depicted in *Figure
    6.5*. This figure encompasses both a class diagram and a sequence diagram, illustrating
    the classes involved in the process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解.NET MAUI中预配置的DI服务，让我们回顾一下*图6.5*中所示的.NET MAUI应用程序启动过程。此图包含一个类图和一个时序图，展示了参与过程的类。
- en: 'Please be aware that the number in *Figure 6.5* represents the type of object
    (**(1)** = MauiProgram, **(2)** = MauiApp, and **(3)** = MauiAppBuilder):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*图6.5*中的数字代表对象的类型（**(1)** = MauiProgram，**(2)** = MauiApp，和**(3)** = MauiAppBuilder）：
- en: '![A diagram of a program  Description automatically generated](img/B21554_06_05.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![程序图描述自动生成](img/B21554_06_05.png)'
- en: 'Figure 6.5: .NET MAUI DI configuration'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：.NET MAUI DI配置
- en: 'In *Figure 6.5*, at the top, we observe that the initiation of the .NET MAUI
    application involves four different classes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.5*的顶部，我们可以看到.NET MAUI应用程序的初始化涉及四个不同的类：
- en: '**Platform entry point**: The initiation of the .NET MAUI application occurs
    in platform-specific code. For the .NET MAUI project, this can be found in the
    **Platforms** folder. Distinct classes have been defined for each platform, as
    illustrated in *Table 6.1*. In *Figure 6.5*, we use the `MauiApplication` Android
    version as a representative example.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台入口点**：.NET MAUI应用程序的初始化发生在特定平台的代码中。对于.NET MAUI项目，这可以在**Platforms**文件夹中找到。为每个平台定义了不同的类，如*表6.1*所示。在*图6.5*中，我们使用`MauiApplication`的Android版本作为代表示例。'
- en: '| **Platform** | **Entry point class** | **Implement Interface** |'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **平台** | **入口点类** | **实现接口** |'
- en: '| Android | `MauiApplication` | `IPlatformApplication` |'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Android | `MauiApplication` | `IPlatformApplication` |'
- en: '| iOS/macOS | `MauiUIApplicationDelegate` |'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| iOS/macOS | `MauiUIApplicationDelegate` |'
- en: '| Windows | `MauiWinUIApplication` |'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Windows | `MauiWinUIApplication` |'
- en: 'Table 6.1: Entry points in different platforms'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表6.1：不同平台中的入口点
- en: 'All entry-point classes implement the `IPlatformApplication` interface, as
    we can see in the following code snippet:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有入口点类都实现了`IPlatformApplication`接口，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `IPlatformApplication` interface defines a property called `Services`, which
    is of the type `IServiceProvider`. Once the application is initialized, this property
    can be utilized directly to resolve DI objects.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IPlatformApplication`接口定义了一个名为`Services`的属性，其类型为`IServiceProvider`。一旦应用程序初始化，这个属性就可以直接用来解析DI对象。'
- en: All platform entry-point classes also implement an override method, `CreateMauiApp`,
    which calls the static method `CreateMauiApp` defined in the `MauiProgram` class.
    Please refer to the following code, *Table 6.1*, and *Figure 6.5*.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有平台入口点类也实现了一个重写方法，`CreateMauiApp`，它调用在`MauiProgram`类中定义的静态方法。请参考以下代码，*表6.1*和*图6.5*。
- en: '`MauiProgram` **(1)**: In the subsequent `MauiProgram` implementation code,
    it becomes apparent that every .NET MAUI application must define a static `MauiProgram`
    class and include a `CreateMauiApp` method. The `CreateMauiApp` method gets called
    by an override function, which is present in all platform entry points. This override
    function ultimately returns a `MauiApp` instance:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MauiProgram` **(1)**: 在随后的 `MauiProgram` 实现代码中，可以明显看出，每个 .NET MAUI 应用程序都必须定义一个静态的
    `MauiProgram` 类，并包含一个 `CreateMauiApp` 方法。`CreateMauiApp` 方法由所有平台入口点的重写函数调用。这个重写函数最终返回一个
    `MauiApp` 实例：'
- en: '[PRE7]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`MauiApp` **(2)**: Inside `CreateMauiApp`, it creates a `MauiAppBuilder` instance
    by calling the function `MauiApp.CreateBuilder`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MauiApp` **(2)**: 在 `CreateMauiApp` 中，通过调用函数 `MauiApp.CreateBuilder` 创建一个
    `MauiAppBuilder` 实例。'
- en: '`MauiAppBuilder` **(3)**: `MauiAppBuilder` incorporates an attribute called
    `Services`, which is of the `IServiceCollection` interface type. This attribute
    allows us to configure DI for the .NET MAUI application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MauiAppBuilder` **(3)**: `MauiAppBuilder` 包含一个名为 `Services` 的属性，该属性是 `IServiceCollection`
    接口类型。这个属性允许我们为 .NET MAUI 应用程序配置依赖注入。'
- en: Based on the above analysis of the .NET MAUI app startup process, it is apparent
    that both `IServiceCollection` and `IServiceProvider` are initialized during this
    procedure. As a result, we can conveniently utilize them without the need for
    additional configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对 .NET MAUI 应用程序启动过程的上述分析，很明显，`IServiceCollection` 和 `IServiceProvider` 都在这个过程中被初始化。因此，我们可以方便地使用它们，而无需额外的配置。
- en: 'The `MauiProgram` implementation can be observed in the code provided below.
    Here, we have registered interfaces—`IDataStore` and `IUserService`—as well as
    multiple classes including `LoginService`, view models, and pages. It is important
    to note that all of these components are singleton objects, except for `ItemsViewModel`
    and `ItemsPage`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了 `MauiProgram` 的实现。在这里，我们注册了接口——`IDataStore` 和 `IUserService`——以及包括
    `LoginService`、视图模型和页面在内的多个类。需要注意的是，所有这些组件都是单例对象，除了 `ItemsViewModel` 和 `ItemsPage`：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After configuring DI for interfaces and classes, we can utilize them in our
    implementation. The `IServiceProvider` interface enables us to resolve objects
    effectively. When implementing DI, there are three primary methods for injecting
    dependencies: constructor injection, method injection, and property injection.
    In the subsequent sections, we will explore how to apply these methods to our
    programming.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在为接口和类配置了依赖注入之后，我们可以在实现中使用它们。`IServiceProvider` 接口使我们能够有效地解析对象。在实现依赖注入时，有三种主要的注入依赖的方法：构造函数注入、方法注入和属性注入。在接下来的章节中，我们将探讨如何将这些方法应用到我们的编程中。
- en: Constructor injection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: 'With constructor injection, the necessary dependencies for a class are supplied
    as arguments to the constructor, allowing us to resolve dependencies using the
    constructor itself. In the code-behind of `ItemsPage`, `ItemsPage` relies on its
    view model, `ItemsViewModel`. We can establish the constructor of `ItemsPage`
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数注入，一个类的必要依赖作为构造函数的参数提供，允许我们通过构造函数本身来解析依赖。在 `ItemsPage` 的代码背后，`ItemsPage`
    依赖于其视图模型 `ItemsViewModel`。我们可以将 `ItemsPage` 的构造函数设置如下：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `ItemsPage` constructor, we inject the dependency through the argument
    `viewModel`. In this instance, MS.DI resolves `viewModel` according to the configuration
    defined in `MauiProgram`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ItemsPage` 的构造函数中，我们通过参数 `viewModel` 注入依赖。在这个例子中，MS.DI 根据在 `MauiProgram`
    中定义的配置解析 `viewModel`。
- en: Constructor injection is the most common and most advised form of DI because
    the object always gets created with the required dependencies. The biggest advantage
    is that it makes dependencies explicit, and the object never exists in an incomplete
    state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入是最常见且最推荐的形式的依赖注入，因为对象总是带有所需的依赖项被创建。最大的优点是它使依赖项明确，对象永远不会处于不完整的状态。
- en: Often, it may not be feasible to inject dependencies through the constructor,
    such as when a class comprises optional dependencies or when there’s a need to
    alter dependencies dynamically. In these circumstances, utilizing method injection
    or property injection would be the recommended approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，可能无法通过构造函数注入依赖，例如当一个类包含可选依赖项或需要动态更改依赖项时。在这些情况下，使用方法注入或属性注入将是推荐的方法。
- en: Method injection
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法注入
- en: Instead of using constructor injection to provide required dependencies when
    the object is instantiated, method injection passes the dependencies directly
    to the methods that use them. Method injection is a technique in DI where dependencies
    are provided to an object through method parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与在对象实例化时使用构造函数注入来提供所需依赖项不同，方法注入直接将依赖项传递给使用它们的那些方法。方法注入是依赖注入（DI）技术中的一种，其中依赖项通过方法参数提供给对象。
- en: 'In our code, we can set up dependencies through a method instead of a constructor,
    as illustrated in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们可以通过方法而不是构造函数来设置依赖项，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, `IDataStore` is set using the method `SetDataStore` instead
    of being injected through the constructor. However, it has a disadvantage where
    the dependent object might forget to set the dependency. As a result, the object
    can exist in an incomplete state.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`IDataStore`是通过`SetDataStore`方法设置的，而不是通过构造函数注入。然而，它有一个缺点，即依赖对象可能会忘记设置依赖项。结果，对象可能处于不完整的状态。
- en: In the code example provided, using method injection enables us to utilize both
    the actual and mock DataStore implementations within the same code. Method injection
    also allows for more fine-grained control over when dependencies are created,
    passed, and disposed of compared to constructor injection. However, it can also
    make the method’s call more complex since the caller is responsible for providing
    the dependencies as parameters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码示例中，使用方法注入使我们能够在同一代码中利用实际的和模拟的DataStore实现。与构造函数注入相比，方法注入还可以提供更细粒度的控制，以创建、传递和销毁依赖项。然而，它也可能使方法的调用更加复杂，因为调用者负责以参数的形式提供依赖项。
- en: In general, constructor injection is often preferred for simplicity and better
    encapsulation, but method injection can be valuable for specific use cases.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了简单性和更好的封装性，构造函数注入更受欢迎，但方法注入在某些特定用例中可能非常有价值。
- en: Property injection
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性注入
- en: In property injection, dependencies are set through properties. Generally, method
    and property injection can be used to replace each other. It is similar to method
    injection—in numerous situations, we might be unable to utilize constructor injection,
    so we have to use method or property injection. The issue with method or property
    injection is that the dependent object might forget to set the dependency, so
    the object can exist in an incomplete state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性注入中，依赖项是通过属性设置的。通常，方法和属性注入可以互相替换。它与方法注入类似——在许多情况下，我们可能无法使用构造函数注入，因此我们必须使用方法或属性注入。方法或属性注入的问题在于，依赖对象可能会忘记设置依赖项，因此对象可能处于不完整的状态。
- en: This problem can be partially mitigated through the use of attributes or annotations
    in object-oriented languages, an approach we will explore later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在面向对象的语言中使用属性或注解，可以部分缓解这个问题，我们将在稍后探讨这种方法。
- en: In .NET MAUI, we can resolve the dependencies through `IServiceProvider`. Within
    a .NET MAUI application, the hosting environment generates an `IServiceProvider`
    interface for us, as demonstrated in *Figure 6.5*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，我们可以通过`IServiceProvider`解决依赖项。在一个.NET MAUI应用程序中，托管环境为我们生成一个`IServiceProvider`接口，如图6.5所示。
- en: 'To obtain the `IServiceProvider` interface, we can employ the `IPlatformApplication`
    interface defined in the platform-specific entry points, as depicted in *Listing
    6.1*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`IServiceProvider`接口，我们可以使用平台特定入口点中定义的`IPlatformApplication`接口，如图6.1所示：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6.1: `ServiceHelper.cs` ([https://epa.ms/ServiceHelper6-1](https://epa.ms/ServiceHelper6-1))'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '列表6.1: `ServiceHelper.cs` ([https://epa.ms/ServiceHelper6-1](https://epa.ms/ServiceHelper6-1))'
- en: '**(1)** In the `ServiceHelper` class, we define a static variable called `Current`,
    which maintains a reference to the `IServiceProvider`. We can obtain the `IServiceProvider`
    through the `Services` property of the `IPlatformApplication` interface.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在`ServiceHelper`类中，我们定义了一个名为`Current`的静态变量，它维护对`IServiceProvider`的引用。我们可以通过`IPlatformApplication`接口的`Services`属性来获取`IServiceProvider`。'
- en: '**(2)** A `GetService` static method is defined, which, in turn, invokes the
    `GetService` method of the `IServiceProvider` interface.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 定义了一个名为`GetService`的静态方法，该方法反过来调用`IServiceProvider`接口的`GetService`方法。'
- en: '**ServiceHelper**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**ServiceHelper**'
- en: For the **ServiceHelper** implementation, I referred to the **MauiApp-DI** GitHub
    project. Thanks to James Montemagno for the sample code on GitHub!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**ServiceHelper**的实现，我参考了**MauiApp-DI** GitHub项目。感谢James Montemagno在GitHub上提供的示例代码！
- en: ([https://github.com/jamesmontemagno/MauiApp-DI](https://github.com/jamesmontemagno/MauiApp-DI))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://github.com/jamesmontemagno/MauiApp-DI](https://github.com/jamesmontemagno/MauiApp-DI))
- en: 'By utilizing the `ServiceHelper` class, we can obtain an instance of `IDataStore`,
    as demonstrated below:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ServiceHelper`类，我们可以获取`IDataStore`的一个实例，如下所示：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might notice that the property injection code provided earlier appears less
    elegant when compared to constructor injection. We have to set the dependencies
    manually. In the worst case, the object can exist in an incomplete state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，之前提供的属性注入代码与构造函数注入相比显得不那么优雅。我们必须手动设置依赖项。在最坏的情况下，对象可能处于不完整的状态。
- en: 'As of now, I have not discovered a more efficient method for implementing this
    in .NET MAUI. Nonetheless, in the subsequent sections of this book, when we introduce
    the Blazor Hybrid app, we will be able to utilize C# attributes to address property
    injection more effectively. To resolve the `IDataStore` interface in Blazor, a
    more straightforward approach can be employed, which is demonstrated in the following
    example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我还没有发现一种更有效的方法来实现.NET MAUI中的这一功能。然而，在本书的后续章节中，当我们介绍Blazor混合应用时，我们将能够更有效地利用C#属性来处理属性注入。在Blazor中解析`IDataStore`接口时，可以采用更直接的方法，以下是一个示例：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can use the `Inject` C# attribute to implicitly resolve dependencies without
    explicitly invoking the `GetService` method from the `ServiceHelper`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Inject` C#属性来隐式解析依赖，而不需要显式调用`ServiceHelper`中的`GetService`方法。
- en: By employing DI, we can seamlessly substitute the mock implementation of the
    `IDataStore` interface with the actual one. This implementation can facilitate
    the CRUD operations of the password database. In the upcoming section, we will
    examine this new class in greater detail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用依赖注入（DI），我们可以无缝地将`IDataStore`接口的模拟实现替换为实际实现。这种实现可以简化密码数据库的CRUD操作。在下一节中，我们将更详细地探讨这个新类。
- en: Replacing the mock data store
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换模拟数据存储
- en: 'As explored in previous sections, we can register the implementation of data
    store services in `MauiProgram.cs` as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，我们可以在`MauiProgram.cs`中注册数据存储服务的实现，如下所示：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `DataStore` is the actual implementation of the `IDataStore` service,
    which we will fully implement in the remainder of this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DataStore`是`IDataStore`服务的实际实现，我们将在本章的剩余部分中完全实现它。
- en: The password database is a local database in the KeePass 2.x format. Within
    this database, password information is organized into groups and entries. The
    `KeePassLib` namespace contains a `PwDatabase` class, which is designed to manage
    database operations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 密码数据库是KeePass 2.x格式的本地数据库。在这个数据库中，密码信息被组织成组和条目。`KeePassLib`命名空间包含一个`PwDatabase`类，该类旨在管理数据库操作。
- en: 'To comprehend the relationship between `PwDatabase`, `PwGroup`, and `PwEntry`,
    we can refer to the class diagram in *Figure 6.6*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`PwDatabase`、`PwGroup`和`PwEntry`之间的关系，我们可以参考*图6.6*中的类图：
- en: '![Figure 6.6: Class diagram of KeePass database](img/B21554_06_06.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6：KeePass数据库的类图](img/B21554_06_06.png)'
- en: 'Figure 6.6: Class diagram of KeePass database'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：KeePass数据库的类图
- en: 'In **PwDatabase**, the **RootGroup** property of type **PwGroup** is defined,
    which contains all groups and entries stored in the database. The data structure
    of the KeePass database can be navigated from **RootGroup** to a specific entry.
    **PwEntry** defines a set of standard fields, as illustrated in *Figure 6.7*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在**PwDatabase**中，定义了类型为**PwGroup**的**RootGroup**属性，它包含数据库中存储的所有组和条目。可以从**RootGroup**导航到特定的条目，KeePass数据库的数据结构。**PwEntry**定义了一组标准字段，如图6.7所示：
- en: '![A screenshot of a phone  Description automatically generated](img/B21554_06_07.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述由系统自动生成](img/B21554_06_07.png)'
- en: 'Figure 6.7: Group, entry, and field'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：组、条目和字段
- en: If we possess a list of entries containing only standard fields, it will resemble
    a table. In *Figure 6.7*, the current group consists of five entries (**GitHub**,
    **Google**, **Facebook**, **Instagram**, and **Chase Bank**) along with a sub-group
    (**Cloud**). On the left, a screenshot of the `ItemsPage` displays the items within
    the current group. If the **Google** item is selected, it will appear as an entry
    in the screenshot on the right side. Users have the option to add extra fields
    to the entry, making the KeePass database dissimilar to a relational database;
    it is more akin to a key-value database. Each field consists of a key-value pair,
    such as a URL field.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个只包含标准字段的条目列表，它将类似于一个表格。在 *图 6.7* 中，当前组包含五个条目（**GitHub**、**Google**、**Facebook**、**Instagram**
    和 **Chase Bank**）以及一个子组（**Cloud**）。在左侧，`ItemsPage` 的截图显示了当前组中的项目。如果选择 **Google**
    项目，它将出现在右侧截图的条目中。用户可以选择向条目添加额外字段，这使得 KeePass 数据库不同于关系数据库；它更类似于键值数据库。每个字段都是一个键值对，例如
    URL 字段。
- en: In order to utilize `PwDatabase` in our application, we have defined a derived
    class called `PxDatabase`. This class introduces additional properties and methods,
    such as `CurrentGroup`, `DeleteGroup`, `DeleteEntry`, and more.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中利用 `PwDatabase`，我们定义了一个派生类，称为 `PxDatabase`。这个类引入了额外的属性和方法，例如 `CurrentGroup`、`DeleteGroup`、`DeleteEntry`
    等。
- en: To access a database, one can open the database file and perform CRUD operations
    on it. However, when building a cross-platform app, handling the database file
    directly may not be convenient for the end users. In **PassXYZ.Vault**, the concept
    of users is employed rather than using a data file. Within **PassXYZLib**, a `User`
    class has been defined to encapsulate the underlying file operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库，可以打开数据库文件并在其上执行 CRUD 操作。然而，在构建跨平台应用程序时，直接处理数据库文件可能对最终用户来说不方便。在 **PassXYZ.Vault**
    中，使用了用户的概念而不是使用数据文件。在 **PassXYZLib** 中，定义了一个 `User` 类来封装底层文件操作。
- en: In order to access the database, we have defined database initialization and
    CRUD operations within the `IDataStore` and `IUserService` interfaces. The `DataStore`
    and `UserService` concrete classes serve to implement these two interfaces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问数据库，我们在 `IDataStore` 和 `IUserService` 接口中定义了数据库初始化和 CRUD 操作。`DataStore`
    和 `UserService` 具体类用于实现这两个接口。
- en: Initializing the database
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数据库
- en: 'The database initialization is incorporated within the login process, so the
    subsequent login method is defined in the `IUserService` interface:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库初始化被包含在登录过程中，因此后续的登录方法定义在 `IUserService` 接口中：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `UserService` class serves as an implementation of the `IUserService` interface.
    Within the `UserService` class, the `LoginAsync` method is defined as an asynchronous
    method, as illustrated here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService` 类是 `IUserService` 接口的一个实现。在 `UserService` 类中，定义了 `LoginAsync`
    方法，如下所示：'
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `LoginAsync`, the `IDataStore` method `ConnectAsync` is invoked to perform
    the actual task. Let’s examine the `ConnectAsync` implementation below:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoginAsync` 方法中，调用 `IDataStore` 的 `ConnectAsync` 方法来执行实际任务。下面我们来查看 `ConnectAsync`
    的实现：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `ConnectAsync` function, **(1)**, a distinct task is employed to manage
    the opening process of the database. The `Open` method of `PxDatabase` is invoked,
    **(2)**, and an instance of the `User` class is provided as an argument to the
    `Open` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConnectAsync` 函数中，**（1**），使用一个独立任务来管理数据库的打开过程。调用 `PxDatabase` 的 `Open` 方法**（2**），并将
    `User` 类的实例作为参数传递给 `Open` 方法。
- en: After successfully establishing a connection and initializing the database,
    we need to implement the methods required for database operations. These can include
    tasks such as data retrieval, data insertion, data update, and data deletion,
    among others. These represent the fundamental operations to interact, manage,
    and maintain data within the database system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功建立连接并初始化数据库后，我们需要实现数据库操作所需的方法。这可以包括数据检索、数据插入、数据更新和数据删除等任务。这些代表在数据库系统中交互、管理和维护数据的基本操作。
- en: Performing CRUD operations
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 CRUD 操作
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the user navigates to another group, `SetCurrentGroup` is invoked with
    an argument to set the new location in the navigation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到另一个组时，`SetCurrentGroup` 方法被调用，并带有一个参数来设置导航中的新位置：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6.2: `IDataStore.cs` ([https://epa.ms/IDataStore6-2](https://epa.ms/IDataStore6-2))'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.2: `IDataStore.cs` ([https://epa.ms/IDataStore6-2](https://epa.ms/IDataStore6-2))'
- en: Adding an item
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加项目
- en: 'The initial operation in CRUD involves creating or adding an item. This item
    could be an entry or a group that is added to the current group. The user interface
    for performing this add operation can be found as a toolbar item in `ItemsPage`,
    as illustrated below:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 的初始操作涉及创建或添加项目。这个项目可以是添加到当前组中的条目或组。执行此添加操作的用户界面可以在 `ItemsPage` 中的工具栏项中找到，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see a toolbar item icon is shown in the top-right corner of `ItemsPage`
    in *Figure 6.8*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在 *图 6.8* 中的 `ItemsPage` 的右上角显示了工具栏项图标：
- en: '![Figure 6.8: Adding an item](img/B21554_06_08.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：添加项目](img/B21554_06_08.png)'
- en: 'Figure 6.8: Adding an item'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：添加项目
- en: When the **+** button is clicked, the `AddItemCommand` command in the `ItemsViewModel`
    is invoked through data binding.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 **+** 按钮时，通过数据绑定调用 `ItemsViewModel` 中的 `AddItemCommand` 命令。
- en: 'The `AddItemCommand` command invokes the following `AddItem` method in the
    view model:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItemCommand` 命令在视图中调用以下 `AddItem` 方法：'
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6.3: `ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel6-3](https://epa.ms/ItemsViewModel6-3))'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3：`ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel6-3](https://epa.ms/ItemsViewModel6-3))
- en: '**(1)** In the `AddItem` function, an `ActionSheet` is displayed, allowing
    the user to select an item type. The item type can either be a group or an entry.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在 `AddItem` 函数中，显示了一个 `ActionSheet`，允许用户选择项目类型。项目类型可以是组或条目。'
- en: '**(2)** Upon obtaining the item type, we can construct a dictionary that includes
    the item type and the query parameter’s name. Then, we store this dictionary object
    in a variable called `itemType`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 获取项目类型后，我们可以构建一个包含项目类型和查询参数名称的字典。然后，我们将这个字典对象存储在名为 `itemType` 的变量中。'
- en: '**(3)** This `itemType` variable can be passed to `NewItemPage` as a query
    parameter. In *Chapter 5*, *Navigation Using .NET MAUI Shell and NavigationPage*,
    we learned how to pass a string value as a query parameter to a page in Shell
    navigation. Here, we can pass an object as a query parameter to a page after we
    wrap it in a dictionary.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** 这个 `itemType` 变量可以作为查询参数传递给 `NewItemPage`。在 *第5章*，*使用 .NET MAUI Shell
    和 NavigationPage 进行导航* 中，我们学习了如何将字符串值作为查询参数传递给 Shell 导航中的页面。在这里，我们可以在将其包装在字典中之后，将对象作为查询参数传递给页面。'
- en: 'To add a new item, the user interface is defined in `NewItemPage`, while the
    logic is managed within the `NewItemViewModel`. Let’s examine the `NewItemViewModel`
    implementation as shown in *Listing 6.4*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新项目，用户界面在 `NewItemPage` 中定义，而逻辑在 `NewItemViewModel` 中管理。让我们查看 *列表 6.4* 中显示的
    `NewItemViewModel` 实现：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6.4: `NewItemViewModel.cs` ([https://epa.ms/NewItemViewModel6-4](https://epa.ms/NewItemViewModel6-4))'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4：`NewItemViewModel.cs` ([https://epa.ms/NewItemViewModel6-4](https://epa.ms/NewItemViewModel6-4))
- en: 'The design of the `NewItemPage` is quite straightforward, featuring two controls:
    **Entry** and **Editor**, which serve to edit the name and notes of an item, respectively.
    The **Entry** control is employed for entering or editing a single line of text,
    whereas the **Editor** control is utilized for modifying multiple lines of text.
    Within the `NewItemViewModel` view model, we can observe the process of adding
    a new item as demonstrated below:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewItemPage` 的设计非常直接，包含两个控件：**Entry** 和 **Editor**，分别用于编辑项目的名称和备注。**Entry**
    控件用于输入或编辑单行文本，而 **Editor** 控件用于修改多行文本。在 `NewItemViewModel` 视图模型中，我们可以观察到添加新项目的流程，如下所示：'
- en: '**(1)** The query parameter is defined using the `QueryPropertyAttribute`.
    **(2)** The `Type` property, declared as `ItemSubType`, is utilized to obtain
    the query parameter. The acquired item type is subsequently stored in the `_type`
    backing variable. Within the `NewItemPage`, two toolbar items are established,
    and their actions are associated with the **Save** and **Cancel** methods found
    in the view model.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 使用 `QueryPropertyAttribute` 定义了查询参数。**(2)** 声明为 `ItemSubType` 的 `Type`
    属性用于获取查询参数。随后，获取的项目类型存储在 `_type` 后备变量中。在 `NewItemPage` 中，创建了两个工具栏项，并将它们的行为关联到视图模型中找到的
    **Save** 和 **Cancel** 方法。'
- en: Upon entering a name and notes in the user interface and clicking the **Save**
    button, **(3)**, a new item instance is created using the `CreateNewItem` factory
    method, which is defined in the `IDataStore` interface. **(4)** Once the new item
    instance is populated with the user input, it can be added to the database by
    calling the `AddItemAsync` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中输入名称和备注并点击 **Save** 按钮**（3**），使用定义在 `IDataStore` 接口中的 `CreateNewItem`
    工厂方法创建一个新的项目实例。**（4**）一旦新项目实例填充了用户输入，就可以通过调用 `AddItemAsync` 方法将其添加到数据库中。
- en: We have now implemented the addition operation. In the following section, let’s
    proceed to implement the remaining data operations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了添加操作。在下一节中，让我们继续实现剩余的数据操作。
- en: Editing or deleting an item
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑或删除项目
- en: In CRUD operations, a create operation does not require an existing item. However,
    to perform update and delete operations, an instance of the existing item is necessary.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRUD操作中，创建操作不需要现有项目。但是，要执行更新和删除操作，需要现有项目的实例。
- en: In a read operation, when an item is a group, we implement it by transmitting
    an `ItemId` query parameter to the `ItemsPage` and, subsequently, identifying
    the group within the setter of `ItemId` in the `ItemsViewModel` view model. Conversely,
    if the item is an entry, we transmit an `ItemId` query parameter to `ItemDetailPage`
    and locate the entry within the setter of `ItemId` in the `ItemDetailViewModel`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取操作中，当项目是一个组时，我们通过向`ItemsPage`发送一个`ItemId`查询参数来实现它，并在`ItemsViewModel`视图模型的`ItemId`设置器中识别该组。相反，如果项目是一个条目，我们向`ItemDetailPage`发送一个`ItemId`查询参数，并在`ItemDetailViewModel`的`ItemId`设置器中定位该条目。
- en: 'For updating, editing, and deleting operations, we can utilize context actions.
    These actions allow us to manipulate items within a `ListView` effectively. It
    is important to note that context actions have a distinct appearance on various
    platforms, such as iOS, Android, and Windows, as depicted in *Figure 6.9*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新、编辑和删除操作，我们可以利用上下文操作。这些操作允许我们有效地在`ListView`中操作项目。需要注意的是，上下文操作在不同平台上具有独特的外观，如图*6.9*所示：
- en: '![Figure 6.9: Context actions](img/B21554_06_09.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：上下文操作](img/B21554_06_09.png)'
- en: 'Figure 6.9: Context actions'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：上下文操作
- en: On the iOS platform, you can perform an action on an item by swiping it to the
    left. In an Android system, you can access the contextual actions menu by long-pressing
    an item, which will then appear in the top-right corner of the screen. On Windows,
    you might be familiar with right-clicking your mouse to display the contextual
    actions menu.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，你可以通过向左滑动项目来执行对项目的操作。在Android系统中，你可以通过长按项目来访问上下文操作菜单，该菜单将出现在屏幕的右上角。在Windows上，你可能熟悉通过右击鼠标来显示上下文操作菜单。
- en: 'In our application, we introduce a context actions menu within the `ItemsPage`.
    We configure the context actions in the `ItemViewCell` inside `ItemsPage`, as
    demonstrated below:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们在`ItemsPage`中引入了一个上下文操作菜单。我们按照以下示例在`ItemsPage`内的`ItemViewCell`中配置上下文操作：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ItemViewCell` is a custom view that inherits from `KeyValueView`, which
    was introduced in *Chapter 4*, *Exploring MVVM and Data Binding*. Let’s examine
    the `ItemViewCell` code in *Listing 6.5*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemViewCell`是一个继承自`KeyValueView`的自定义视图，该视图在*第4章*，*探索MVVM和数据绑定*中引入。让我们查看*列表6.5*中的`ItemViewCell`代码：'
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6.5: `ItemViewCell.cs` ([https://epa.ms/ItemViewCell6-5](https://epa.ms/ItemViewCell6-5))'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5：`ItemViewCell.cs` ([https://epa.ms/ItemViewCell6-5](https://epa.ms/ItemViewCell6-5))
- en: In the `ItemViewCell`, we define two menu items for editing and deleting context
    actions. We assign two event handlers (**(1)** `OnEditAction` and **(2)** `OnDeleteAction`)
    to their corresponding context actions. Within the event handlers, we invoke the
    view model methods, `Update` and `Delete`, to execute the required operations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemViewCell`中，我们为编辑和删除上下文操作定义了两个菜单项。我们将两个事件处理器（**（1**）`OnEditAction`和**（2**）`OnDeleteAction`）分配给它们相应的上下文操作。在事件处理器中，我们调用视图模型方法`Update`和`Delete`来执行所需的操作。
- en: 'Let us examine the source code for the `Update` and `Delete` functions in the
    `ItemsViewModel`, as shown below:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看`ItemsViewModel`中`Update`和`Delete`函数的源代码，如下所示：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `ItemsViewModel`, to edit or update an item, **(1)**, we utilize a content
    page called `FieldEditPage` to carry out the editing process. Upon invoking the
    constructor of `FieldEditPage`, an anonymous function is passed as a parameter.
    This function is invoked when the user finishes editing within `FieldEditPage`.
    Within this function, **(2)**, the `UpdateItemAsync` method of the `IDataStore`
    interface is called to update the item.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemsViewModel`中，要编辑或更新项目，**（1**），我们使用一个名为`FieldEditPage`的内容页面来执行编辑过程。在调用`FieldEditPage`的构造函数时，一个匿名函数作为参数传递。当用户在`FieldEditPage`中完成编辑时，将调用此函数。在此函数中，**（2**），调用`IDataStore`接口的`UpdateItemAsync`方法来更新项目。
- en: The delete operation is fairly straightforward. We can simply invoke the `DeleteItemAsync`
    method, **(3)**, from the `IDataStore` interface to eliminate the item.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作相当直接。我们可以简单地从 `IDataStore` 接口调用 `DeleteItemAsync` 方法 **(3**) 来消除该条目。
- en: Once the CRUD operations are implemented, our application will possess the essential
    features required for a password manager app. We can establish a new database
    by registering a new user. Upon creating a new database, we can then log in to
    access our data. Additionally, after generating entries and groups, we have the
    ability to modify or remove them as needed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了 CRUD 操作，我们的应用程序将具备密码管理应用程序所需的必要功能。我们可以通过注册新用户来创建一个新的数据库。在创建新数据库后，我们可以登录以访问我们的数据。此外，在生成条目和组之后，我们有能力根据需要修改或删除它们。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began by introducing design principles. Following this,
    we delved into the SOLID design principles, and I shared insights gleaned from
    the development of our app. Among the most crucial SOLID principles is the **DIP**.
    **DI** is a technique that applies the DIP in practical implementation. In our
    app, we utilize the built-in DI service of .NET MAUI to decouple dependencies,
    enabling us to separate the implementation of the service from the interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了设计原则。随后，我们深入探讨了 SOLID 设计原则，并分享了从我们应用程序开发中获得的见解。其中最重要的 SOLID 原则是
    **DIP**。**DI** 是一种将 DIP 应用于实际实施的技术。在我们的应用程序中，我们利用 .NET MAUI 内置的 DI 服务来解耦依赖关系，使我们能够将服务的实现与接口分离。
- en: We accumulated extensive knowledge about .NET MAUI and successfully completed
    our app implementation by replacing `MockDataStore` with the actual implementation.
    We established CRUD operations on top of this new `IDataStore` service, resulting
    in a fully functional password manager app.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们积累了关于 .NET MAUI 的丰富知识，并通过用实际实现替换 `MockDataStore` 成功完成了我们的应用程序实现。我们在新的 `IDataStore`
    服务之上建立了 CRUD 操作，从而实现了一个功能齐全的密码管理应用程序。
- en: Although we have incorporated essential features in our app, users often expect
    additional desirable features in a password manager application, such as fingerprint
    scanning and one-time passwords. Some of these features are platform-specific,
    which requires knowledge of platform integration. In the next chapter, we will
    delve into various platform integration topics to further improve our app.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在应用程序中集成了基本功能，但用户通常期望密码管理应用程序中具有额外的期望功能，例如指纹扫描和一次性密码。其中一些功能是平台特定的，这需要了解平台集成。在下一章中，我们将深入探讨各种平台集成主题，以进一步提高我们的应用程序。
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Beginning SOLID Principles and Design Patterns for ASP.NET Developers*, by
    Bipin Joshi'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《面向 ASP.NET 开发者的 SOLID 原则与设计模式入门》，作者 Bipin Joshi*'
- en: '**Autofac** is an **inversion of control** (**IoC**) container for .NET Core,
    ASP.NET Core, .NET 4.5.1+, and more: [https://autofac.org/](https://autofac.org/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Autofac** 是一个用于 .NET Core、ASP.NET Core、.NET 4.5.1+ 以及更多环境的 **控制反转**（**IoC**）容器：[https://autofac.org/](https://autofac.org/)'
- en: '**Simple Injector** is a DI container that can support .NET 4.5 and .NET Standard:
    [https://simpleinjector.org/](https://simpleinjector.org/%20)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Injector** 是一个支持 .NET 4.5 和 .NET Standard 的 DI 容器：[https://simpleinjector.org/](https://simpleinjector.org/%20)'
- en: Learn more on Discord
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code166522361691420406.png)'
