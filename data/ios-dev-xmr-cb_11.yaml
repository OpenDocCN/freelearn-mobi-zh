- en: Chapter 11. Graphics and Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 图形和动画
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Animating views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画视图
- en: Transforming views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换视图
- en: Animating images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画图像
- en: Animating layers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画层
- en: Drawing lines and curves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制线条和曲线
- en: Drawing shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Drawing text
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制文本
- en: A simple drawing app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的绘图应用
- en: Creating an image context
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像上下文
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we are going to discuss custom drawing and animations. The
    iOS SDK contains two very useful frameworks for these tasks: Core Graphics and
    Core Animation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论自定义绘制和动画。iOS SDK 包含两个用于这些任务的非常有用的框架：Core Graphics 和 Core Animation。
- en: These two frameworks simplify the process of animating UI elements and drawing
    2D graphics on them. The effective usage of these two frameworks will make a difference
    between a dull and stunning app. After all, these two frameworks play a very important
    role in making the iOS platform unique in its kind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架简化了在 UI 元素上动画化和绘制 2D 图形的过程。有效使用这两个框架将在平淡无奇和令人惊叹的应用之间产生差异。毕竟，这两个框架在使 iOS
    平台在其类别中独一无二方面发挥着非常重要的作用。
- en: We will learn how to provide simple or even more complicated animations for
    controls to provide a unique user experience. We will also see how to custom draw
    lines, curves, shapes, and text on the screen. Finally, with all the examples
    provided, we will create two drawing apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何为控件提供简单甚至更复杂的动画，以提供独特的用户体验。我们还将看到如何在屏幕上自定义绘制线条、曲线、形状和文本。最后，通过所有提供的示例，我们将创建两个绘图应用。
- en: Animating views
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画视图
- en: In this recipe, we will learn how to take advantage of UIKit animations to move
    a `UILabel` on the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何利用 UIKit 动画在屏幕上移动 `UILabel`。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ViewAnimationApp`.
    Add a label and button on the view of the controller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **Single View Application** 并将其命名为 `ViewAnimationApp`。在控制器的视图中添加一个标签和按钮。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中输入以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the app on the simulator. Tap on the **Animate!** button and
    watch the label transitioning to the lower part of the view.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。点击 **Animate!** 按钮，观察标签过渡到视图的下半部分。
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIView` class contains a number of various static methods that provide
    animation functionality. In this example, we simply change the position of a label
    with an animation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView` 类包含许多提供动画功能的静态方法。在这个例子中，我们通过动画简单地改变标签的位置。'
- en: 'To animate the change of the view, we call the static `UIView.Animate` method
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化视图的变化，我们调用静态的 `UIView.Animate` 方法，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following list explains the parameters of the `UIView.Animate` method,
    individually:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表解释了 `UIView.Animate` 方法的参数，分别如下：
- en: '**Duration**: This specifies the duration of the animation in seconds.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**: 这指定了动画的持续时间（以秒为单位）。'
- en: '**Delay**: This indicates the number of seconds before the animation starts.
    Set it to zero for the animation to start immediately.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**: 这表示动画开始前的秒数。将其设置为零以使动画立即开始。'
- en: '**Options**: This includes the various options for animation. In this example,
    we pass `UIViewAnimationOptions.CurveEaseInOut`, which applies an easing curve
    to the animation.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**: 这包括动画的各种选项。在这个例子中，我们传递 `UIViewAnimationOptions.CurveEaseInOut`，这将对动画应用一个缓动曲线。'
- en: '**Animation**: This is an `NSAction` delegate with the changes that will be
    animated. In this example, we set the modified frame to the label as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**: 这是一个包含将要动画化更改的 `NSAction` 代理。在这个例子中，我们将修改后的框架设置为标签，如下所示：'
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Completion**: This is an `NSAction` delegate, which will be called after
    the animation is complete.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**: 这是一个 `NSAction` 代理，动画完成后将被调用。'
- en: We can combine multiple `UIViewAnimationOptions` values. For example, if we
    wanted the animation to repeat indefinitely, we would pass `UIViewAnimationOptions.CurveEaseInOut
    | UIViewAnimationOptions.Repeat`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以组合多个 `UIViewAnimationOptions` 值。例如，如果我们想使动画无限重复，我们将传递 `UIViewAnimationOptions.CurveEaseInOut
    | UIViewAnimationOptions.Repeat`。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Xamarin.iOS also offers an asynchronous method for `UIView` animations. This
    method is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 还为 `UIView` 动画提供了一个异步方法。该方法如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, there are no `delay` and `options` parameters with the asynchronous
    method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步方法中没有 `delay` 和 `options` 参数。
- en: Animatable properties
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可动画属性
- en: 'UIKit animations support a specific set of `UIView` properties. These properties
    are called **animatable** properties. Following is a list of `UIView` properties
    that can be animated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit 动画支持一组特定的 `UIView` 属性。这些属性被称为 **可动画属性**。以下是可以动画化的 `UIView` 属性列表：
- en: '`Frame`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frame`'
- en: '`Bounds`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bounds`'
- en: '`Center`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Center`'
- en: '`Transform`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform`'
- en: '`Alpha`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alpha`'
- en: '`BackgroundColor`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundColor`'
- en: '`ContentStretch`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentStretch`'
- en: Transforming views
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换视图
- en: In this recipe, we will rotate a `UILabel` by applying a transformation. Furthermore,
    the rotation will be animated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过应用转换来旋转 `UILabel`。此外，旋转将是动画化的。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `TransformViewApp`.
    Add a label and a button on the controller.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序**，并将其命名为 `TransformViewApp`。在控制器中添加一个标签和一个按钮。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the `MonoTouch.CoreGraphics` namespace in the `TransformViewAppViewController.cs`
    file as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TransformViewAppViewController.cs` 文件中添加 `MonoTouch.CoreGraphics` 命名空间如下：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Enter the following `ViewDidLoad` method in the `TransformViewAppViewController`
    class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TransformViewAppViewController` 类中输入以下 `ViewDidLoad` 方法：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compile and run the app on the simulator. Tap the button and watch the label
    rotate. The following screenshot displays that the label rotated 270 degrees:![How
    to do it...](img/8924OT_11_01.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击按钮并观察标签旋转。以下截图显示了标签旋转了 270 度：![如何实现...](img/8924OT_11_01.jpg)
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the `CoreGraphics`
    framework. This framework is the basic graphics framework of iOS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreGraphics` 命名空间是 `CoreGraphics` 框架的包装器。这个框架是 iOS 的基本图形框架。'
- en: 'To rotate a view, we need a transformation object that will be applied to the
    view through its `Transform` property as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转一个视图，我们需要一个转换对象，该对象将通过视图的 `Transform` 属性应用如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The transformation object is an instance of the `CGAffineTransform` class and
    is initialized through the `MakeRotation` static method. This method accepts a
    float value of the angle of rotation we want to be applied, in radians. The `DegreesToRadians`
    method can be used to convert degrees to radians. After creating the transformation
    object, we assign it to the label''s `Transform` property inside the animation
    handler as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 转换对象是 `CGAffineTransform` 类的实例，并通过 `MakeRotation` 静态方法初始化。此方法接受一个浮点值，表示要应用的旋转角度，以弧度为单位。可以使用
    `DegreesToRadians` 方法将度转换为弧度。创建转换对象后，我们将其分配给标签的 `Transform` 属性，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we need to increment the rotation angle each time the button is pressed,
    because the transformation we apply is not being autoincremented. If we apply
    another rotational transformation object with the same angle, there will be no
    effect since it is basically the same transformation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次按钮被按下时，我们需要增加旋转角度，因为我们应用的转换不会被自动增加。如果我们应用另一个具有相同角度的旋转转换对象，将没有效果，因为它基本上是相同的转换。
- en: 'When the label has been rotated to a full circle (360 degrees), we reset the
    `rotationAngle` value and the transformation object as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签被旋转到完整一圈（360度）时，我们重置 `rotationAngle` 值和转换对象如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `MakeIdentity` static method creates an identity transformation object,
    which is the default transformation of all views, before applying transformation
    objects to them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeIdentity` 静态方法在将转换对象应用于视图之前，创建一个身份转换对象，这是所有视图的默认转换。'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CGAffineTransform` class contains various static methods for creating
    transformation objects. These are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGAffineTransform` 类包含用于创建转换对象的多种静态方法。这些方法如下：'
- en: '`CGAffineTransformInvert`: This inverts a current transformation and returns
    the result'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CGAffineTransformInvert`: 这将反转当前转换并返回结果'
- en: '`MakeIdentity`: This creates an identity transformation'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeIdentity`: 这将创建一个身份转换'
- en: '`MakeRotation`: This creates a rotation transformation'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeRotation`: 这将创建一个旋转转换'
- en: '`MakeScale`: This creates a scaling transformation'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeScale`: 这将创建一个缩放转换'
- en: '`MakeTranslation`: This creates a translation transformation'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeTranslation`: 这将创建一个平移转换'
- en: '`Multiply`: This multiplies two transformations and returns the result'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Multiply`: 这将两个转换相乘并返回结果'
- en: Transformation and Frame
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换和框架
- en: After applying transformations on a view, its `Frame` property must not be taken
    into account, as its value will be undefined. If there is a need for altering
    the view's size or position after a transformation has been applied, use the `Bounds`
    and `Center` properties, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一个视图应用转换后，其 `Frame` 属性不应被考虑，因为其值将是未定义的。如果需要在应用转换后更改视图的大小或位置，请分别使用 `Bounds`
    和 `Center` 属性。
- en: See also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Animating views* and *Animating layers* recipes
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图* 和 *动画图层* 食谱'
- en: Animating images
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画图片
- en: In this recipe, we will create a simple slideshow of images using the built-in
    animation feature of `UIImageView`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 `UIImageView` 内置的动画功能创建一个简单的图片幻灯片。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ImageAnimationApp`.
    Add a `UIImageView` and two buttons on the controller. The sample project for
    this task contains three images. Add two or more images to the project and make
    sure that their **Build Action** is set to **Content**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序**，并将其命名为 `ImageAnimationApp`。在控制器上添加一个 `UIImageView`
    和两个按钮。此任务的示例项目包含三张图片。将两张或更多图片添加到项目中，并确保它们的 **构建操作** 设置为 **内容**。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中输入以下代码：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile and run the app on the simulator. Tap the **Start animating** button
    to start the animation.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并在模拟器上运行应用程序。点击 **开始动画** 按钮以开始动画。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIImageView` class can accept an array of `UIImage` objects and automatically
    display them in a sequence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 类可以接受一个 `UIImage` 对象数组，并自动按顺序显示它们。'
- en: 'To load the images that the view will animate, assign an array of the images
    to its `AnimationImages` property as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载视图将动画化的图片，按照以下方式将其图片数组分配给其 `AnimationImages` 属性：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The sequence in which the images will be displayed is defined by their order
    in the array. After setting the images that will be animated, we set the duration
    of the animation in seconds and the number of times it will occur as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将要显示的图片的顺序由它们在数组中的顺序定义。在设置将要动画化的图片后，我们设置动画的持续时间（以秒为单位）和它将发生的次数，如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To start or stop the animation, call the `StartAnimating` or `StopAnimating`
    methods, respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始或停止动画，分别调用 `StartAnimating` 或 `StopAnimating` 方法。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is no relation between the `AnimationImages` and `Image` properties of
    the `UIImageView` class. The image set to the `Image` property of the `UIImageView`
    class will not be displayed while the animation takes place.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 类的 `AnimationImages` 和 `Image` 属性之间没有关系。在动画进行时，设置到 `UIImageView`
    类的 `Image` 属性的图片将不会显示。'
- en: Checking for animation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查动画
- en: To determine if an animation is taking place, check the `IsAnimating` property
    of `UIImageView`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定是否正在进行动画，请检查 `UIImageView` 的 `IsAnimating` 属性。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Animating views* recipe
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图* 食谱'
- en: The *Displaying images* recipe in [Chapter 2](ch02.html "Chapter 2. User Interface
    – Views"), *User Interface – Views*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 章](ch02.html "第 2 章。用户界面 – 视图")中的 *显示图片* 食谱，*用户界面 – 视图*'
- en: Animating layers
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画图层
- en: In this recipe, we will learn how to use the Core Animation framework to copy
    a `UILabel` on the screen by animating its layer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 Core Animation 框架通过动画其图层来在屏幕上复制一个 `UILabel`。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `LayerAnimation`.
    Add two labels and a button on the controller. Set the text and background color
    for the first label and a different background color for the second label.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序**，并将其命名为 `LayerAnimation`。在控制器上添加两个标签和一个按钮。为第一个标签设置文本和背景颜色，并为第二个标签设置不同的背景颜色。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the `MonoTouch.CoreAnimation` namespace in the `LayerAnimationViewController.cs`
    file as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LayerAnimationViewController.cs` 文件中添加 `MonoTouch.CoreAnimation` 命名空间，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a field of the `CALayer` type in the class as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个 `CALayer` 类型的字段，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile and run the app on the simulator. Tap the **Copy label** button to copy
    the contents of the first label to the second label, with animation. The following
    screenshot was captured while the process of copying was taking place:![How to
    do it...](img/8924OT_11_02.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击**复制标签**按钮，以动画方式将第一个标签的内容复制到第二个标签。以下截图是在复制过程中捕获的：![如何操作...](img/8924OT_11_02.jpg)
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.CoreAnimation` namespace is a wrapper around the Core Animation
    framework.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreAnimation`命名空间是Core Animation框架的包装器。'
- en: Every view has a `Layer` property, which returns the view's `CALayer` object.
    In this task, we are creating an animation that graphically displays the contents
    of the label that are being copied from one label to another.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都有一个`Layer`属性，它返回视图的`CALayer`对象。在这个任务中，我们正在创建一个动画，该动画以图形方式显示从标签复制到另一个标签的内容。
- en: 'Instead of creating another label and moving it with a `UIView` animation,
    we will create a layer and move that instead. We create the layer by setting its
    `Frame` and `Contents` property; the latter is set from the source label''s layer.
    We then add the layer to the main view''s layer with the `AddSublayer` method.
    After this point, the main view contains a layer that displays the same contents
    and is on top of the source label. We will do all this with the help of the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建另一个标签并通过`UIView`动画移动它，我们将创建一个图层并移动该图层。我们通过设置其`Frame`和`Contents`属性来创建图层；后者是从源标签的图层设置的。然后我们使用`AddSublayer`方法将图层添加到主视图的图层中。在此之后，主视图包含一个显示相同内容且位于源标签之上的图层。我们将借助以下代码完成所有这些操作：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To animate the transition from the source label to the target label, we will
    use the `CABasicAnimation` class. The highlighted part of the code in step 3 shows
    how to initialize and set up the instances of the class. The `FromKeyPath` static
    method creates a new instance, accepting the name of the layer's property as a
    parameter; this name will be animated. The `To` property represents the value
    to which the property will be animated. The `Duration` property represents the
    duration of the animation in seconds, while the `RemovedOnCompletion` property
    declares that the animation object should be removed from the layer when the animation
    finishes. The `TimingFunction` property sets the behavior of the animation. The
    `AnimationStopped` event is triggered when the animation finishes. Inside the
    handler we assign to it, we set the contents of the source label to the target
    label, thus completing the copy. The `AutoReverses` property states that when
    the value of the `To` property has been reached, the animation should be reversed.
    It is this property that gives the effect of the label getting bigger and subsequently
    smaller when it reaches its final position.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从源标签到目标标签的过渡动画，我们将使用`CABasicAnimation`类。在步骤3中代码的高亮部分显示了如何初始化和设置类的实例。`FromKeyPath`静态方法创建一个新的实例，接受图层属性的名称作为参数；这个名称将被动画化。`To`属性表示属性将被动画化的值。`Duration`属性表示动画的持续时间（以秒为单位），而`RemovedOnCompletion`属性声明当动画完成后应从图层中移除动画对象。`TimingFunction`属性设置动画的行为。当动画完成后，将触发`AnimationStopped`事件。在分配给它的处理程序内部，我们将源标签的内容设置为目标标签，从而完成复制。`AutoReverses`属性表示当`To`属性的值达到时，动画应该反转。正是这个属性使得标签在达到最终位置时先变大然后变小。
- en: 'The animations start when they are added to the layer as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画被添加到图层时，动画开始：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A list of strings that the `FromKeyPath` method accepts can be found at [https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2)找到`FromKeyPath`方法接受的字符串列表。
- en: 'Apart from the `To` property, the `CABasicAnimation` class has two more properties
    for defining the animation: `From` and `By`. They are all of the `NSObject` type,
    but the actual values that should be assigned to them should be of the `NSValue`
    type. The `NSValue` class contains various static methods for creating instances
    of it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`To`属性外，`CABasicAnimation`类还有两个用于定义动画的属性：`From`和`By`。它们都是`NSObject`类型，但实际分配给它们的值应该是`NSValue`类型。`NSValue`类包含各种静态方法用于创建其实例。
- en: Layers
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层
- en: Layers are very powerful and efficient objects that can be used for both drawing
    and animations. Using layers to perform animations on views, instead of the actual
    views themselves, is strongly suggested.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 层是非常强大和高效的物体，可以用于绘制和动画。强烈建议使用层在视图中执行动画，而不是实际视图本身。
- en: See also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Animating views* recipe
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动画视图*菜谱'
- en: Drawing lines and curves
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条和曲线
- en: In this recipe, we will implement custom drawing to draw two lines on a `UIView`
    class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现自定义绘图，在`UIView`类上绘制两条线。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawLineApp`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，命名为`DrawLineApp`。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add a new class to the project and name it `DrawingView`. Derive it from `UIView`
    as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的类，命名为`DrawingView`，并从`UIView`派生，如下所示：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following `using` directives in the `DrawingView.cs` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawingView.cs`文件中添加以下`using`指令：
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following constructor to the class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下构造函数：
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Override the `Draw` method of `UIView` and implement it with the following
    code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`UIView`的`Draw`方法，并使用以下代码实现它：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `ViewDidLoad` override of `DrawLineAppViewController`, initialize and
    add the view as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawLineAppViewController`的`ViewDidLoad`重写中，初始化并添加视图，如下所示：
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_11_03.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应该类似于以下截图所示：![如何操作...](img/8924OT_11_03.jpg)
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the native Core Graphics
    framework. The Core Graphics framework contains the necessary objects for custom
    drawing on views.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.CoreGraphics`命名空间是围绕本地Core Graphics框架的包装器。Core Graphics框架包含在视图中进行自定义绘制所需的必要对象。'
- en: 'To draw on a view, we have to override its `Draw(RectangleF)` method as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中绘制，我们必须重写其`Draw(RectangleF)`方法，如下所示：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside the `Draw` method, we need an instance of the current graphics context
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Draw`方法内部，我们需要当前图形上下文的实例，如下所示：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A graphics context is represented by the `CGContext` class. The `UIGraphics.GetCurrentContext`
    static method returns an instance of the current context.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图形上下文由`CGContext`类表示。`UIGraphics.GetCurrentContext`静态方法返回当前上下文的实例。
- en: 'The `CGContext` class contains various methods that allow us to draw on the
    view. We need to set the line width, the color, and then add the type of drawing
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGContext`类包含各种方法，允许我们在视图中绘制。我们需要设置线宽、颜色，然后添加绘制类型，如下所示：'
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To add a line, we use the `AddLines` method that accepts an array of `PointF`
    structs, containing the start and end points of each line. Just adding the lines
    to the context is not enough. To present the drawing on the view, we call the
    `StrokePath` method as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加线条，我们使用接受`PointF`结构数组作为参数的`AddLines`方法，包含每条线的起点和终点。仅仅将线条添加到上下文中是不够的。为了在视图中呈现绘制，我们调用`StrokePath`方法，如下所示：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To add another item to the drawing, we repeat the steps accordingly. The `MoveTo`
    method moves the current point so that the additional item will have a starting
    point for the curve.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在绘制中添加另一个项目，我们相应地重复步骤。`MoveTo`方法将当前点移动，以便附加项目将有一个曲线的起点。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Draw` method is being called by the runtime when it needs to draw the contents
    of a view. We can only get the instance of the current graphics context inside
    the `Draw` method. We should not call it directly, since the `UIGraphics.GetCurrentContext`
    method will return `null` if we do. If we need to force the runtime to call the
    `Draw` method, we need to call `SetNeedsDisplay()`. Care should be taken when
    calling it, since drawing operations are expensive in terms of CPU usage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时需要绘制视图的内容时，会调用`Draw`方法。我们只能在`Draw`方法内部获取当前图形上下文的实例。我们不应直接调用它，因为如果这样做，`UIGraphics.GetCurrentContext`方法将返回`null`。如果我们需要强制运行时调用`Draw`方法，我们需要调用`SetNeedsDisplay()`。在调用时应小心，因为绘制操作在CPU使用方面代价高昂。
- en: When there is no need for causing the entire view area to be redrawn, we can
    call the `SetNeedsDisplayInRect` method, passing a `RectangleF` object in the
    coordinate system of the view area that we want to update.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要重新绘制整个视图区域时，我们可以调用`SetNeedsDisplayInRect`方法，传递一个在视图区域坐标系中的`RectangleF`对象，以更新我们想要更新的区域。
- en: Graphics context on a UIImageView class
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UIImageView`类上的图形上下文'
- en: The current graphics context of a `UIImageView` object is reserved for drawing
    the contents of the image. Calling `SetNeedsDisplay` on a custom view deriving
    from `UIImageView` has the same effect as calling the `Draw` method directly.
    If we need to draw on a custom image view, we have to either add another view
    on top of it and draw on that or draw on a custom layer and add it to the view's
    main layer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`对象的当前图形上下文保留用于绘制图像的内容。在继承自`UIImageView`的自定义视图中调用`SetNeedsDisplay`与直接调用`Draw`方法具有相同的效果。如果我们需要在自定义图像视图中绘制，我们必须要么在其上方添加另一个视图并在该视图上绘制，要么在自定义图层上绘制并将其添加到视图的主图层中。'
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考也
- en: The *Drawing text* recipe
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制文本*配方'
- en: The *Creating a custom view* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interfaces – Views*
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。用户界面 – 视图")的*创建自定义视图*配方中，*用户界面 – 视图*
- en: Drawing shapes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Following the example from the previous recipe, we will draw a circle and square
    on the screen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一个配方中的示例，我们将在屏幕上绘制一个圆和一个正方形。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawShapeApp`.
    Add a custom view to the project, like we did in the previous task, and name it
    `DrawingView`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`DrawShapeApp`。向项目中添加一个自定义视图，就像我们在上一个任务中所做的那样，并将其命名为`DrawingView`。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Override the `Draw` method of the `DrawingView` class and implement it with
    the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`DrawingView`类的`Draw`方法，并使用以下代码实现：
- en: '[PRE27]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `ViewDidLoad` method of the `DrawShapeAppViewController` class, initialize
    and display the view with the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawShapeAppViewController`类的`ViewDidLoad`方法中，使用以下代码初始化并显示视图：
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compile and run the app on the simulator. The result on the screen should be
    similar to the one shown in the following screenshot:![How to do it...](img/8924OT_11_04.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。屏幕上的结果应该类似于以下截图所示：![如何操作...](img/8924OT_11_04.jpg)
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To draw shapes on a view, we need to call the appropriate method. We first
    set the fill color of the `CGContext` instance as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中绘制形状，我们需要调用适当的方法。我们首先将`CGContext`实例的填充颜色设置为以下所示：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To draw a circle, we call the `AddEllipseInRect` method, passing a `RectangleF`
    object that contains the bounding rectangle of the circle as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个圆，我们调用`AddEllipseInRect`方法，传递一个包含圆的边界矩形的`RectangleF`对象，如下所示：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Whether the shape will be an ellipse or an absolute circle is defined through
    the bounding rectangle''s size. We then call the `FillPath` method as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 形状将是一个椭圆还是一个绝对圆，是通过边界矩形的尺寸定义的。然后我们按照以下方式调用`FillPath`方法：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The shadow effect is defined by the `SetShadow` method as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影效果由`SetShadow`方法定义如下：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first parameter, which is of the `SizeF` type, defines the offset of the
    shadow, while the second parameter defines the amount of blur, in points.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，其类型为`SizeF`，定义了阴影的偏移量，而第二个参数定义了模糊量，以点为单位。
- en: There's more...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When the `SetShadow` method is called, all objects that are added to the context
    are displayed with a shadow. To remove the shadow, call the `SetShadowWithColor`
    method, passing either a fully transparent color or null for the color parameter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`SetShadow`方法时，所有添加到上下文中的对象都会显示阴影。要移除阴影，调用`SetShadowWithColor`方法，传递一个完全透明的颜色或为颜色参数传递null。
- en: Transparent colors
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明颜色
- en: 'To fill a shape with a transparent color, create a `CGColor` instance with
    the appropriate values as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要用透明颜色填充形状，创建一个具有适当值的`CGColor`实例，如下所示：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will create a red color with its alpha value set to 50 percent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个红色，其alpha值设置为50%。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Drawing lines and curves* recipe
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*食谱'
- en: Drawing text
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: In this recipe, we will learn how to draw styled text with an outline on a view.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在视图中绘制带有轮廓的样式文本。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawTextApp`.
    Add a custom view to the project, similar to the one we created in the previous
    recipe, and name it `DrawingView`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`DrawTextApp`。向项目中添加一个自定义视图，类似于我们在前面的食谱中创建的，并将其命名为`DrawingView`。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Implement the following `Draw` method override in the `DrawingView` class:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawingView`类中实现以下`Draw`方法重写：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `ViewDidLoad` method of the controller, initialize and display the `DrawingView`
    method as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的`ViewDidLoad`方法中，初始化并显示`DrawingView`方法如下：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Compile and run the app on the simulator. The text will be displayed on the
    screen. The result should be similar to the following screenshot:![How to do it...](img/8924OT_11_05.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。文本将显示在屏幕上。结果应类似于以下截图：![如何实现...](img/8924OT_11_05.jpg)
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `NSString` class contains the very useful `DrawString` method, which draws
    the text it contains to the current context. To provide the outline effect, we
    call the `SetTextDrawingMode` method as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSString`类包含非常实用的`DrawString`方法，它将包含的文本绘制到当前上下文中。为了提供轮廓效果，我们调用`SetTextDrawingMode`方法如下：'
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We pass the `CGTextDrawingMode.Stroke` value. We then set the color and width
    of the outline to the graphics context and draw it text on the screen as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`CGTextDrawingMode.Stroke`值。然后我们将轮廓的颜色和宽度设置为图形上下文，并在屏幕上绘制文本，如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `SetStrokeColorWithColor` method sets the color of the stroke, and the `SetLineWidth`
    method sets the width of the stroke. Calling the `DrawString` method of `NSString`
    draws the text in the graphics context in the specified location and with the
    specified font.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetStrokeColorWithColor`方法设置描边的颜色，而`SetLineWidth`方法设置描边的宽度。调用`NSString`的`DrawString`方法可以在指定位置和指定字体下在图形上下文中绘制文本。'
- en: 'Similarly, to fill the text, we set the text drawing mode to `Fill` as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为了填充文本，我们将文本绘制模式设置为`Fill`，如下所示：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the fill, we are not concerned about the line''s width, so we just need
    to call the `DrawString` method once more as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于填充，我们不需要关心线的宽度，所以我们只需要再次调用`DrawString`方法，如下所示：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `DrawString` method is overloaded. The overload we use here accepts a `PointF`
    struct, which represents the location of the string in the view's coordinate system
    and a `UIFont` instance that represents the font by which the text will be rendered
    on the screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawString`方法有多个重载。我们在这里使用的是接受一个`PointF`结构，它表示字符串在视图坐标系中的位置，以及一个`UIFont`实例，该实例表示文本将在屏幕上通过该字体渲染。'
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Drawing text on the screen with the `DrawString` method is very simple and the
    quickest way to do it. For more complex functionality, such as customizing the
    layout of the text, its appearance, and many more, we need to use the **CoreText
    framework**. This is accessible in Xamarin.iOS through the `MonoTouch.CoreText`
    namespace.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DrawString`方法在屏幕上绘制文本非常简单，也是最快的方法。对于更复杂的功能，例如自定义文本布局、外观等，我们需要使用**CoreText框架**。这可以通过Xamarin.iOS中的`MonoTouch.CoreText`命名空间访问。
- en: Size of the drawn text
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制文本的大小
- en: 'The `DrawString` method of the `NSString` class returns the size of the bounding
    rectangle of the text. We can, however, get the size of the text before drawing
    it through the `StringSize` method as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSString`类的`DrawString`方法返回文本的边界矩形的大小。然而，我们可以通过`StringSize`方法在绘制文本之前获取文本的大小，如下所示：'
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See also
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Drawing lines and curves* and *Drawing shapes* recipes
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*和*绘制形状*食谱'
- en: A simple drawing app
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的绘图应用程序
- en: In this recipe, we will use the techniques we learned to create a drawing app.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用我们学到的技术来创建一个绘图应用程序。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `FingerDrawingApp`.
    Once again, we will need a custom view. Add a class deriving from `UIView` and
    name it `CanvasView`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序** 并将其命名为 `FingerDrawingApp`。再一次，我们需要一个自定义视图。添加一个从
    `UIView` 继承的类并命名为 `CanvasView`。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Implement the `CanvasView` class with the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现 `CanvasView` 类：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `ViewDidLoad` method of the `FingerDrawingAppViewController` class,
    initialize and show the canvas as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FingerDrawingAppViewController` 类的 `ViewDidLoad` 方法中，初始化并显示画布如下：
- en: '[PRE42]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Compile and run the app on the simulator or on the device. Touch-and-drag your
    finger (or click-and-drag with the cursor) and start drawing. The following screenshot
    displays a sketch drawn in this app:![How to do it...](img/8924OT_11_06.jpg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。触摸并拖动手指（或使用光标点击并拖动）开始绘图。以下截图显示了在此应用程序中绘制的草图：![如何做...](img/8924OT_11_06.jpg)
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this task, we are combining touch events and custom drawing to create a simple
    drawing app. When the user touches and moves the finger on the screen, we keep
    the information of the touch location points and use them in the `Draw` method
    to draw lines.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将触摸事件和自定义绘图结合起来创建一个简单的绘图应用程序。当用户触摸并移动屏幕上的手指时，我们保留触摸位置点的信息，并在 `Draw`
    方法中使用这些信息来绘制线条。
- en: After setting the touch locations to the class fields, we call `SetNeedsDisplay`
    to force the `Draw` method to be called. The `fingerDraw` variable is used to
    determine that the `Draw` method was called by a touch on the screen and not by
    the runtime when the view is first loaded.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在将触摸位置设置到类字段之后，我们调用 `SetNeedsDisplay` 以强制调用 `Draw` 方法。`fingerDraw` 变量用于确定 `Draw`
    方法是由屏幕上的触摸触发的，而不是在视图首次加载时由运行时触发的。
- en: Every time we call a method to draw something to a graphics context, the previous
    drawings in this context are cleared. To avoid this behavior, we use a `CGPath`
    object. We can add various drawing objects in `CGPath` and display these object
    on the screen by adding it to the graphics context. So, every time the user moves
    their finger on the screen, the new lines defined by the touch location points
    are added to the path, and the path is drawn on the current context.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用一个方法将某些内容绘制到图形上下文中时，该上下文中的先前绘图都会被清除。为了避免这种行为，我们使用一个 `CGPath` 对象。我们可以在
    `CGPath` 中添加各种绘图对象，并通过将其添加到图形上下文中来在屏幕上显示这些对象。因此，每当用户在屏幕上移动手指时，由触摸位置点定义的新线条就会被添加到路径中，并且路径会在当前上下文中绘制。
- en: Note that we need to hold information of both the current touch location and
    the previous one. This is because the `AddLineToPoint` method accepts one point,
    which defines the end point of the line, assuming that there already is a point
    in the path. The starting point of each line is defined by calling `MoveToPoint`,
    passing the previous touch location point.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要保留当前触摸位置和上一个位置的信息。这是因为 `AddLineToPoint` 方法接受一个点，该点定义了线的终点，假设路径中已经有一个点。每条线的起点是通过调用
    `MoveToPoint` 并传递上一个触摸位置点来定义的。
- en: The path that is drawn on the screen by sliding the finger on it is basically
    comprised of a series of consecutive straight lines. The result, however, is a
    smooth path that follows the finger movement, because the `TouchesMoved` method
    is triggered every time there is a single movement of the finger on the screen.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在屏幕上滑动手指绘制的路径基本上由一系列连续的直线组成。然而，结果是平滑的路径，它遵循手指的移动，因为每当屏幕上有单个手指移动时，`TouchesMoved`
    方法就会被触发。
- en: 'After adding the line to the path, we add it to the context and draw it in
    the graphics context, hence showing it on the screen as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在将线条添加到路径之后，我们将它添加到上下文中并在图形上下文中绘制它，因此如下所示显示在屏幕上：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Two new `CGContext` methods are introduced in this task: `SetLineJoin` and
    `SetLineCap`. The `SetLineJoin` method sets how each line will be joined to the
    previous one, while the `SetLineCap` method sets the appearance of the endpoint
    of a line.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中引入了两个新的 `CGContext` 方法：`SetLineJoin` 和 `SetLineCap`。`SetLineJoin` 方法设置每条线如何与前一条线连接，而
    `SetLineCap` 方法设置线条端点的外观。
- en: 'The values that they accept are explained in the following two tables:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 他们接受的值在以下两个表中解释：
- en: '| SetLineJoin | Description |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| SetLineJoin | 描述 |'
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CGLineJoin.Miter` | Joins two lines with an angled corner |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineJoin.Miter` | 使用角度角落连接两条线 |'
- en: '| `CGLineJoin.Round` | Joins two lines with a rounded end |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineJoin.Round` | 使用圆角连接两条线 |'
- en: '| `CGLineJoin.Bevel` | Joins two lines with a squared end |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineJoin.Bevel` | 使用方形端点连接两条线 |'
- en: '| SetLineCap | Description |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| SetLineCap | 描述 |'
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CGLineCap.Butt` | The line will end with a squared edge on the endpoint
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineCap.Butt` | 线条将以端点上的方形边缘结束 |'
- en: '| `CGLineCap.Round` | The line will end with a rounded edge that expands beyond
    the endpoint |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineCap.Round` | 线条将以一个扩展到端点的圆形边缘结束 |'
- en: '| `CGLineCap.Square` | The line will end with a squared edge that expands beyond
    the endpoint |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `CGLineCap.Square` | 线条将以一个扩展到端点的方形边缘结束 |'
- en: Clear the drawing
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除绘图
- en: To clear the drawing, we simply have to set the `fingerDraw` variable to `false`
    and call `SetNeedsDisplay`. This way, the `Draw` method will be called without
    our custom drawing code, clearing the current context.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除绘图，我们只需将`fingerDraw`变量设置为`false`并调用`SetNeedsDisplay`。这样，`Draw`方法将调用而不需要我们的自定义绘图代码，清除当前上下文。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Drawing lines and curves*, *Drawing shapes*, and *Drawing text* recipes
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*、*绘制形状*和*绘制文本*菜谱'
- en: Creating an image context
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像上下文
- en: In this recipe, we will extend the finger-drawing app we created earlier by
    providing a save functionality for the drawings that the user will create.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过提供用户创建的绘图保存功能来扩展我们之前创建的手指绘图应用程序。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ImageContextApp`.
    Add the `CanvasView` class we created in the earlier task to the project. Don't
    forget to change the namespace in the `CanvasView.cs` file to correspond to the
    namespace of the new project.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ImageContextApp`。将我们在早期任务中创建的`CanvasView`类添加到项目中。别忘了将`CanvasView.cs`文件中的命名空间更改为与新项目对应的命名空间。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the following methods in the `CanvasView` class:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CanvasView`类中添加以下方法：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Add two buttons on the view of the controller. One button will be used for saving
    the drawing and the other one for clearing the canvas.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加两个按钮。一个按钮将用于保存绘图，另一个按钮用于清除画布。
- en: 'Add the following code in the `ViewDidLoad` method of the `ImageContextAppViewController`
    class:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ImageContextAppViewController`类的`ViewDidLoad`方法中添加以下代码：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Compile and run the app on the simulator. Draw something on the canvas and tap
    the **Save drawing** button to save your drawing. Tap on the **Clear canvas**
    button to clear the canvas. You can then check the simulator's photo albums for
    your drawing.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在画布上绘制一些东西，然后点击**保存绘图**按钮来保存你的绘图。点击**清除画布**按钮来清除画布。然后你可以在模拟器的照片库中检查你的绘图。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `UIGraphics` class, we can create an image context through which we
    can retrieve our drawing in a `UIImage` object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UIGraphics`类，我们可以创建一个图像上下文，通过它可以检索我们的绘图，并将其存储在`UIImage`对象中。
- en: 'To create an image context, we call the `BeginImageContext` static method inside
    the `GetDrawingImage` method, passing the size that we want the image context
    to have, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图像上下文，我们在`GetDrawingImage`方法内部调用`BeginImageContext`静态方法，并传递我们想要图像上下文具有的大小，如下所示：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The current context is now the image context we created with the `BeginImageContext`
    call. We then repeat the code we have in the `Draw` method; only this time, there
    is no need to add new lines to the path. We simply add the path that we already
    have to the context and draw it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当前上下文现在是使用`BeginImageContext`调用创建的图像上下文。然后我们重复`Draw`方法中的代码；只是这次，我们不需要向路径中添加新线条。我们只需将我们已有的路径添加到上下文中并绘制它。
- en: 'After adding the path, we get the context image by calling the `GetImageFromCurrentContext`
    method as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路径后，我们可以通过调用以下`GetImageFromCurrentContext`方法来获取上下文图像：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we have to end the image context block and return the `UIImage` object
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须结束图像上下文块并返回`UIImage`对象，如下所示：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To clear the drawing from the screen, we simply have to set the `fingerDraw`
    variable to `false` and dispose and prepare our `CGPath` object for reuse inside
    the `ClearDrawing` method as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除屏幕上的绘图，我们只需将`fingerDraw`变量设置为`false`，并在`ClearDrawing`方法中处理并准备我们的`CGPath`对象以供重用，如下所示：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To reflect the clearing on the screen immediately, we call the `SetNeedsDisplay`
    method as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要立即反映屏幕上的清除，我们调用以下`SetNeedsDisplay`方法：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We cannot create an image context inside the `Draw` method. This is because
    when we call the `BeginImageContext` method, a context is actually created, but
    the view's default context remains as the current context. Hence, the `GetImageFromCurrentImageContext`
    method would return `null`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在`Draw`方法内部创建图像上下文。这是因为当我们调用`BeginImageContext`方法时，实际上会创建一个上下文，但视图的默认上下文仍然保持为当前上下文。因此，`GetImageFromCurrentImageContext`方法会返回`null`。
- en: Drawing on UIImageView
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`UIImageView`上绘图
- en: The technique discussed here can be used to draw on custom `UIImageView` objects.
    To display the drawing when the finger slides on the screen, we would simply have
    to set its `Image` property to the image we get from the image context.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的技术可以用来在自定义的`UIImageView`对象上绘图。为了在手指在屏幕上滑动时显示绘图，我们只需将其`Image`属性设置为从图像上下文获取的图像。
- en: Background on saved drawings
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存绘图的背景信息
- en: You will notice that although we are setting the `CanvasView` background to
    gray, the saved drawings are with a white background. This is because the view's
    background color is not included in the drawing. To include it, we would just
    have to draw a rectangle to the graphics context. This rectangle should be of
    the same color as the background color.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，尽管我们将`CanvasView`的背景设置为灰色，但保存的绘图却是白色的背景。这是因为视图的背景颜色不包括在绘图内。要包括它，我们只需在图形上下文中绘制一个矩形。这个矩形应该与背景颜色相同。
- en: See also
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Drawing lines and curves*, *Drawing shapes*, *Drawing text*, and *A simple
    drawing app* recipes
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和曲线*、*绘制形状*、*绘制文本*和*一个简单的绘图应用*的食谱'
