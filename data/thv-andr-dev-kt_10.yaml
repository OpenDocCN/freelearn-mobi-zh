- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Starting a Video Streaming App and Adding Authentication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始视频流应用程序并添加身份验证
- en: 'Having mastered how to create engaging social apps such as WhatsApp and Instagram,
    it’s now time to dive into the world of video streaming services. This chapter
    marks the beginning of our third project: a Netflix-like app. Let’s call it Packtflix.
    Here, we will explore a different aspect of Android development, focusing on multimedia
    content delivery and user authentication, while continuing to build captivating
    user interfaces.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了如何创建像WhatsApp和Instagram这样的引人入胜的社交应用程序之后，现在是时候进入视频流服务领域了。本章标志着我们第三个项目的开始：一个类似Netflix的应用程序。让我们称它为Packtflix。在这里，我们将探索Android开发的另一个方面，重点是多媒体内容交付和用户身份验证，同时继续构建吸引人的用户界面。
- en: Our journey will begin by laying the groundwork for our streaming app. We’ll
    start from scratch, setting up a new project and introducing you to the app’s
    structure and modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程将从为我们的流媒体应用程序打下基础开始。我们将从头开始，设置一个新的项目，并介绍应用程序的结构和模块。
- en: 'Following the setup, we’ll dive into one of the most critical aspects of any
    app: authenticating your users. In today’s digital age, security and privacy are
    more relevant than ever, so you’ll learn how to implement robust authentication
    mechanisms using OAuth2\. This will ensure that your app’s users can securely
    access their accounts and personal preferences.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完成后，我们将深入探讨任何应用程序最关键的一个方面：验证用户身份。在当今这个数字时代，安全和隐私比以往任何时候都更加重要，因此您将学习如何使用OAuth2实现强大的身份验证机制。这将确保您的应用程序用户可以安全地访问他们的账户和个人偏好。
- en: Once our users can log in, we’ll focus on presenting them with a rich selection
    of movies. We’ll employ Jetpack Compose to create dynamic and responsive lists,
    showcasing the available content.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的用户可以登录，我们将专注于向他们展示丰富的电影选择。我们将使用Jetpack Compose创建动态和响应式的列表，展示可用的内容。
- en: Finally, we’ll delve into the details. Each movie or series in your app deserves
    its spotlight, and you’ll create detailed screens for them using Jetpack Compose.
    This will provide users with all the information they need to decide what to watch
    next.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入了解细节。您应用程序中的每部电影或电视剧都应得到其应有的关注，您将使用Jetpack Compose为它们创建详细的界面。这将使用户能够获得他们决定观看下一部电影所需的所有信息。
- en: 'So, this chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: Creating the app’s structure and modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序的结构和模块
- en: Building the login screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建登录界面
- en: Authenticating the app’s users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证应用程序的用户身份
- en: Creating your movie list
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的电影列表
- en: Making the movie and series detail screen
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作电影和电视剧详情界面
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要安装Android Studio（或您偏好的其他编辑器）。
- en: We are going to start a new project in this chapter, so it is not necessary
    to download the changes made in the previous chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将开始一个新的项目，因此没有必要下载前一章所做的更改。
- en: 'You will find the complete code that we are going to build throughout this
    chapter in this repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章节中找到我们将要构建的完整代码，它位于这个仓库中：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7).
- en: Creating the app’s structure and modules
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的结构和模块
- en: In this section, we’ll lay the foundation for our Packtflix app by organizing
    it into feature modules. As we have seen before, by dividing the app into modules
    such as login, list, and playback, we can work on one feature at a time without
    affecting the others and speed up the build process for larger projects. Additionally,
    we’ll set up a version catalog for our dependencies as we did before to streamline
    the management of libraries such as Jetpack Compose, Dagger Hilt, and Kotlin.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将Packtflix应用程序组织成功能模块来为其打下基础。正如我们之前所看到的，通过将应用程序划分为登录、列表和播放等模块，我们可以一次专注于一个功能，而不会影响其他功能，从而加快大型项目的构建过程。此外，我们还将为我们的依赖项设置版本目录，就像我们之前所做的那样，以简化对Jetpack
    Compose、Dagger Hilt和Kotlin等库的管理。
- en: Let’s start creating the project. In Android Studio, select **File** | **New**
    | **New Project…**, and choose **Empty Compose Activity**. Then, in the **New
    Project** panel, fill out **Name**, **Package name**, and **Save location**. For
    the **Minimum SKD** option, we will choose **API 29** again as it guarantees the
    best percentage of compatibility at the time of writing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建项目。在 Android Studio 中，选择 **文件** | **新建** | **新建项目…**，然后选择 **空 Compose
    Activity**。然后，在 **新建项目** 面板中，填写 **名称**、**包名** 和 **保存位置**。对于 **最小 SDK** 选项，我们将再次选择
    **API 29**，因为它在撰写时保证了最佳的兼容性百分比。
- en: '![Figure 7.1: New project configuration for Packtflix](img/B19443_07_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：Packtflix 的新项目配置](img/B19443_07_001.jpg)'
- en: 'Figure 7.1: New project configuration for Packtflix'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：Packtflix 的新项目配置
- en: The options in *Figure 7**.1* are the ones we will see using Android Studio
    Iguana (version 2023.2.1), though it may have variations depending on the version.
    For example, in other previous versions of Android Studio, we could also select
    whether we were going to use the version catalog for our dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.1* 中的选项是我们将在 Android Studio Iguana（版本 2023.2.1）中看到的，尽管它可能因版本不同而有所变化。例如，在其他之前的
    Android Studio 版本中，我们还可以选择是否为依赖项使用版本目录。'
- en: 'Now, the version catalog is created by default, so we will already get a `libs.versions.toml`
    file in our project with the following content:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，版本目录默认创建，因此我们将在项目中获得一个 `libs.versions.toml` 文件，其内容如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code adds the basic dependencies to the version catalog to build an app
    with Kotlin, Android, and Jetpack Compose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码向版本目录添加了基本的依赖项，以使用 Kotlin、Android 和 Jetpack Compose 构建应用程序。
- en: 'The next step will be to create the modules needed. Here, we will create three
    feature modules:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是创建所需的模块。在这里，我们将创建三个功能模块：
- en: '**:feature:login**: We will use this module to include the login feature'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:feature:login**: 我们将使用此模块来包含登录功能'
- en: '**:feature:list**: In this module, we will include the list screen as well
    as the detail screen'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:feature:list**: 在此模块中，我们将包括列表界面以及详情界面'
- en: '**:feature:playback**: In this module, we will host all the playback functionality'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:feature:playback**: 在此模块中，我们将托管所有播放功能'
- en: 'We will also create the following common modules:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建以下通用模块：
- en: '**:app**: This module will contain the entry point for our application'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:app**: 此模块将包含我们应用程序的入口点'
- en: '**:common**: This module will contain common functionality needed in more than
    one module'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:common**: 此模块将包含在多个模块中需要的通用功能'
- en: 'To create these modules, use the **File** | **New** | **New Module…** option,
    as we have done in the previous projects. The final project structure should look
    like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些模块，使用 **文件** | **新建** | **新建模块…** 选项，就像我们在前面的项目中做的那样。最终的项目结构应该看起来像这样：
- en: '![Figure 7.2: Project module structure](img/B19443_07_002.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：项目模块结构](img/B19443_07_002.jpg)'
- en: 'Figure 7.2: Project module structure'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：项目模块结构
- en: Now that we have created our module structure, it is time to set up the dependency
    injection framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的模块结构，是时候设置依赖注入框架了。
- en: Setting up the dependency injection framework
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置依赖注入框架
- en: As we saw in the previous chapters, the need for scalability, performance optimization,
    and testability has made the use of a dependency injection framework practically
    a must in Android. In this case, we will use Hilt again (to learn more about it,
    please refer to [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015) where we did a
    complete review of the framework and exposed its main advantages).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，可扩展性、性能优化和可测试性的需求使得在 Android 中使用依赖注入框架几乎成为必须。在这种情况下，我们将再次使用 Hilt（想了解更多，请参阅[*第
    1 章*](B19443_01.xhtml#_idTextAnchor015)，在那里我们对框架进行了全面审查并揭示了其主要优势）。
- en: 'Let’s start adding the dependency to our version catalog. Open our `libs.versions.toml`
    file and add the Hilt dependencies in the `versions`, `libraries`, and `plugins`
    blocks, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的版本目录添加依赖项开始。打开我们的 `libs.versions.toml` 文件，并在 `versions`、`libraries`
    和 `plugins` 块中添加 Hilt 依赖项，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we will add the plugin to the project-level `build.gradle.kts`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将插件添加到项目级别的 `build.gradle.kts`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in the `build.gradle.kts` file of every module, we will have to apply
    the plugin and add the Hilt dependency:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在每一个模块的 `build.gradle.kts` 文件中，我们将必须应用插件并添加 Hilt 依赖项：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, in the `:app` module, we can create the `PacktflixApp` class, which will
    be the entry point for the Hilt configuration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `:app` 模块中，我们可以创建 `PacktflixApp` 类，它将是 Hilt 配置的入口点：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this annotation, we are enabling Hilt to generate the necessary components
    under the hood that will be used for dependency injection throughout our application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个注解，我们正在启用Hilt在底层生成必要的组件，这些组件将在我们的应用程序中用于依赖注入。
- en: 'Finally, we should include `PacktflixApp` in `AndroidManifest.xml`, so that
    our app uses it instead of the default `Application` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在 `AndroidManifest.xml` 中包含 `PacktflixApp`，这样我们的应用程序就会使用它而不是默认的 `Application`
    类：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we are all set to start building our new project. The first step will be
    to build the login screen as we want our users to authenticate themselves using
    their credentials. Let’s start working on it!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始构建我们的新项目了。第一步将是构建登录界面，因为我们希望用户使用他们的凭据进行身份验证。让我们开始工作吧！
- en: Building the login screen
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建登录界面
- en: To build the login screen, we will start creating a `LoginScreen` composable
    with Jetpack Compose. We will have to include the app’s logo, fields to introduce
    the email and password, and a **Login** button. We can also include a text to
    show whether there are any errors when the user tries to log in.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建登录界面，我们将开始创建一个 `LoginScreen` 可组合组件，使用Jetpack Compose。我们必须包括应用程序的标志、输入电子邮件和密码的字段以及一个
    **登录** 按钮。我们还可以包括一个文本来显示当用户尝试登录时是否有任何错误。
- en: 'This login screen is going to have four states (`Idle`, `Loading`, `Success`,
    and `Error`), so let’s start modeling the overall `ViewState`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个登录界面将有四种状态（`Idle`、`Loading`、`Success` 和 `Error`），所以让我们开始建模整体的 `ViewState`：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s create the `LoginScreen` composable:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `LoginScreen` 可组合组件：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We start the composable function by obtaining `LoginViewModel`, accessed via
    `hiltViewModel()`. This `ViewModel` component manages the login logic and exposes
    the current login state through a `StateFlow` stream. The `collectAsState().value`
    call converts the asynchronous stream of login states into a composable-friendly
    state that triggers recompositions when the login state changes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `hiltViewModel()` 获取 `LoginViewModel` 来开始可组合函数，这是通过 `hiltViewModel()` 访问的。这个
    `ViewModel` 组件管理登录逻辑并通过 `StateFlow` 流暴露当前的登录状态。`collectAsState().value` 调用将异步的登录状态流转换为可组合友好的状态，当登录状态改变时触发重新组合。
- en: The function uses `remember { mutableStateOf("") }` to maintain the state of
    user inputs for email and password within the composable’s lifecycle. This state
    is mutable and reactive, meaning any changes to the input fields (handled by `onValueChange`)
    automatically update the corresponding variables and thus the UI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用 `remember { mutableStateOf("") }` 来维护用户输入的电子邮件和密码在可组合组件的生命周期内的状态。这个状态是可变的和响应式的，意味着任何对输入字段（由
    `onValueChange` 处理）的更改都会自动更新相应的变量，从而更新UI。
- en: 'Let’s continue now with the next part of the composable, which will include
    the name of the app, the fields for `email` and `password`, and the **Login**
    button:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一部分的可组合组件，这将包括应用程序的名称、`email` 和 `password` 字段以及 **登录** 按钮：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The UI dynamically adjusts based on the current login state. For example, if
    the login state is `LoginState.Error`, the function renders a `Text` composable
    to display the error message. This conditional rendering is crucial for providing
    feedback to the user, such as indicating a login failure or showing a loading
    indicator (`CircularProgressIndicator`) when the login process is underway. This
    approach to UI development is declarative, with the UI’s structure and content
    directly mapping to the application’s state.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: UI会根据当前的登录状态动态调整。例如，如果登录状态是 `LoginState.Error`，函数将渲染一个 `Text` 可组合组件来显示错误信息。这种条件渲染对于向用户提供反馈至关重要，例如指示登录失败或显示加载指示器（`CircularProgressIndicator`），当登录过程正在进行时。这种UI开发方法声明式，UI的结构和内容直接映射到应用程序的状态。
- en: The `OutlinedTextField` composables for `email` and `password` capture user
    inputs, which are then used to initiate the login process (`loginViewModel.login(email,
    password)`) when the user clicks the `password` field (via `KeyboardActions`).
    This demonstrates how to handle user actions and input in a composable, triggering
    `ViewModel` actions that ultimately lead to state changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutlinedTextField` 可组合组件用于捕获 `email` 和 `password` 的用户输入，然后当用户点击 `password`
    字段（通过 `KeyboardActions`）时，这些输入被用来启动登录过程（`loginViewModel.login(email, password)`）。这展示了如何在可组合组件中处理用户动作和输入，触发
    `ViewModel` 动作，最终导致状态变化。'
- en: Finally, the `LaunchedEffect` block listens for changes in the login state to
    perform side effects, such as navigation upon successful login or updating the
    error message state. This pattern separates side effects from the UI logic, ensuring
    that effects such as navigation or showing toasts only occur in response to state
    changes, not as a direct result of user actions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LaunchedEffect`块监听登录状态的变化以执行副作用，例如在登录成功后进行导航或更新错误信息状态。这种模式将副作用与UI逻辑分离，确保导航或显示吐司等效果仅在响应状态变化时发生，而不是直接由用户操作的结果。
- en: 'Now, let’s start working on `LoginViewModel`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始工作在`LoginViewModel`上：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we start with the dependency injection stuff: the use of `@HiltViewModel`
    indicates that Hilt will be responsible for the instantiation and provision of
    `LoginViewModel`. The `@Inject` constructor signifies that Hilt will inject the
    necessary dependencies into this `ViewModel` instance, in this case, an implementation
    of a use case called `DoLoginUseCase` (we will implement this use case later).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始处理依赖注入相关的内容：使用`@HiltViewModel`表示Hilt将负责`LoginViewModel`的实例化和提供。`@Inject`构造函数表示Hilt将向这个`ViewModel`实例注入必要的依赖，在这种情况下，是一个名为`DoLoginUseCase`的使用案例的实现（我们将在后面实现这个使用案例）。
- en: The `ViewModel` instance manages the login state using `MutableStateFlow<LoginState>`.
    Here, `_loginState` is a private, mutable state flow that holds the current state
    of the login process, which can be one of `Idle`, `Loading`, `Success`, or `Error`.
    The immutable `loginState` property exposes this state to the UI layer as a read-only
    `StateFlow`, ensuring that state updates are safely and efficiently communicated
    to the UI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`实例使用`MutableStateFlow<LoginState>`来管理登录状态。在这里，`_loginState`是一个私有的、可变的state
    flow，它持有登录过程的当前状态，可以是`Idle`、`Loading`、`Success`或`Error`之一。不可变的`loginState`属性将这个状态以只读的`StateFlow`的形式暴露给UI层，确保状态更新能够安全且高效地传达给UI。'
- en: The login function embodies the core functionality of this `ViewModel` class.
    It initiates the login process by setting `_loginState` to `Loading`, indicating
    that the login operation has started. It then proceeds to call the `doLogin` method
    on the provided `loginUseCase` with the user’s email and password.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 登录函数体现了这个`ViewModel`类的核心功能。它通过将`_loginState`设置为`Loading`来启动登录过程，表示登录操作已经开始。然后，它继续调用提供的`loginUseCase`上的`doLogin`方法，并传递用户的电子邮件和密码。
- en: After attempting to log in, the function evaluates the result. If the login
    attempt fails (`result.isFailure`), `_loginState` is updated to `Error` with the
    exception message, providing feedback on why the login failed. If the login succeeds,
    `_loginState` is set to `Success`, indicating a successful login process. This
    conditional handling ensures that the UI can react appropriately to different
    outcomes of the login process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试登录后，函数评估结果。如果登录尝试失败（`result.isFailure`），`_loginState`会被更新为`Error`状态，并带有异常信息，提供登录失败的原因。如果登录成功，`_loginState`会被设置为`Success`，表示登录过程成功。这种条件处理确保UI能够适当地对登录过程的不同结果做出反应。
- en: The login process is launched within `viewModelScope`, a coroutine scope tied
    to the `ViewModel` lifecycle. This ensures that any ongoing login operation is
    automatically canceled if the `ViewModel` instance is cleared (typically, when
    the associated UI component is destroyed), preventing memory leaks and unnecessary
    work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 登录过程在`viewModelScope`中启动，这是一个与`ViewModel`生命周期绑定的协程作用域。这确保了如果`ViewModel`实例被清除（通常是在相关的UI组件被销毁时），任何正在进行的登录操作都会自动取消，从而防止内存泄漏和不必要的操作。
- en: 'With that, we have our login screen ready. The last step is to set up the Hilt
    modules and set the content of `MainActivity` to show the `LoginScreen` composable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的登录界面就准备好了。最后一步是设置Hilt模块并将`MainActivity`的内容设置为显示`LoginScreen`可组合界面：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we now execute the app, we should see the following screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用，我们应该看到以下屏幕：
- en: '![Figure 7.3: Packtflix login screen](img/B19443_07_003.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：Packtflix登录界面](img/B19443_07_003.jpg)'
- en: 'Figure 7.3: Packtflix login screen'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：Packtflix登录界面
- en: Now that we have finished our UI, the next step will be to authenticate the
    users. Let’s learn how to do it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的UI，下一步将是验证用户。让我们学习如何做到这一点。
- en: Authenticating the app’s users
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证应用的用户
- en: In mobile applications, authentication plays a critical role in protecting user
    data and personal information from unauthorized access. As mobile devices often
    serve as personal gateways to a wide array of services and store a significant
    amount of sensitive data, ensuring that this data is securely managed and accessed
    is more important than ever. One of the preferred methods for authenticating users
    is OAuth2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序中，身份验证在保护用户数据和个人信息免受未经授权的访问方面发挥着关键作用。由于移动设备通常作为通向各种服务的个人网关，并存储大量敏感数据，因此确保这些数据得到安全管理和访问比以往任何时候都更重要。验证用户的最受欢迎的方法之一是OAuth2。
- en: '**OAuth2** is an authorization framework that allows third-party services to
    exchange web resources on behalf of a user. It enables users to grant websites
    or applications access to their information on other websites without giving them
    their passwords. This is particularly useful for providing functionalities such
    as logging in with Google, Facebook, or other social media accounts.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth2**是一个授权框架，允许第三方服务代表用户交换网络资源。它使用户能够授予网站或应用程序访问其他网站上的其信息的权限，而无需提供他们的密码。这对于提供使用Google、Facebook或其他社交媒体账户登录等功能特别有用。'
- en: 'The following is a list of OAuth2’s most important features:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了OAuth2最重要的功能：
- en: '**Security**: It allows the user to authorize an application to access their
    resources on a different server without sharing their credentials, typically by
    using access tokens granted through a process involving user consent and secure
    token exchanges.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：它允许用户授权应用程序在不共享其凭据的情况下访问不同服务器上的资源，通常是通过使用涉及用户同意和安全令牌交换的过程授予的访问令牌。'
- en: An OAuth **token** is a credential that represents the authorization granted
    to the application, allowing it to access specific resources on behalf of the
    user. These tokens can come in various formats, such as opaque tokens or **JSON
    Web Tokens** (**JWTs**). Opaque tokens are simple strings without any specific
    structure, while JWTs are structured tokens that consist of three parts – a header,
    a payload, and a signature – all encoded in Base64.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个OAuth **令牌**是代表授予应用程序的授权的凭证，允许它代表用户访问特定资源。这些令牌可以采用各种格式，如不透明令牌或**JSON Web Tokens**（**JWTs**）。不透明令牌是没有任何特定结构的简单字符串，而JWTs是由三个部分组成的结构化令牌——一个头部、一个负载和一个签名——所有这些都在Base64中进行编码。
- en: '**Scalability**: It allows for the delegation of user authentication to the
    service that hosts the user account, by offloading the technical complexities
    of secure authentication and infrastructure scalability to dedicated services.
    These services are usually managed by specific teams in charge of the complex
    and resource-intensive tasks of securing and scaling authentication processes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：它允许将用户身份验证委托给托管用户账户的服务，通过将安全身份验证和基础设施可扩展性的技术复杂性卸载到专用服务中。这些服务通常由负责确保和扩展身份验证过程的复杂且资源密集型任务的特定团队管理。'
- en: '**Flexibility**: It supports multiple flows (based on grant types, which will
    determine the flow the authentication process has to follow) for different types
    of clients, including mobile apps, websites, and server-side applications.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：它支持多种流程（基于授权类型，这将确定身份验证过程必须遵循的流程），适用于不同类型的客户端，包括移动应用、网站和服务器端应用程序。'
- en: '**User Experience**: It enables a smoother login experience for users, as users
    can use existing accounts to sign in to new services without creating new credentials.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**：它使用户的登录体验更加顺畅，因为用户可以使用现有的账户登录到新的服务，而无需创建新的凭据。'
- en: In essence, OAuth2 provides a secure and efficient way to implement authentication
    in mobile applications. It leverages existing user accounts, which simplifies
    the login process for users, and offloads the complexity of managing user credentials
    and sessions to a third-party service, enhancing both security and user experience.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，OAuth2为在移动应用程序中实现身份验证提供了一种安全且高效的方法。它利用现有的用户账户，简化了用户的登录过程，并将管理用户凭据和会话的复杂性卸载到第三方服务中，从而提高了安全性和用户体验。
- en: Let’s add this feature to our app, starting by adding the models that are needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用中添加这个功能，首先添加所需的模型。
- en: Creating the user model
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: 'First, we will define a simple user model that will hold the user information
    we will receive upon successful authentication:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个简单的用户模型，它将保存我们在成功身份验证后收到的用户信息：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code, we are defining the basic fields needed to hold the user information
    (depending on the requirements of your app, these fields will be different).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们定义了存储用户信息所需的基本字段（根据您应用程序的要求，这些字段可能会有所不同）。
- en: 'Then, to build the login request that we are going to send to the backend to
    obtain the authentication token, we will need another data class to hold the credentials:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了构建我们将发送到后端以获取认证令牌的登录请求，我们需要另一个数据类来存储凭证：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are including the `email` and `password` fields, which will be mandatory
    to be able to log users in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包括了`email`和`password`字段，这些字段是登录用户所必需的。
- en: 'Once this request reaches the backend, if the credentials are correct, the
    backend will return an authorization token, which our app will store in a secure
    place and will use to authenticate the following API calls to the backend. We
    will need another model to hold this token information:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个请求到达后端，如果凭证正确，后端将返回一个授权令牌，我们的应用程序将将其存储在安全的地方，并用于验证后续对后端的API调用。我们需要另一个模型来存储这个令牌信息：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let’s set Retrofit to get this authorization token.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置Retrofit来获取这个授权令牌。
- en: Using Retrofit to get the authorization token
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Retrofit获取授权令牌
- en: 'To obtain the authorization token, we need our app to request it when the user
    provides their credentials. In order to send this request to the backend, we are
    going to use Retrofit. We already used Retrofit in [*Chapter 4*](B19443_04_split_000.xhtml#_idTextAnchor089),
    so let’s skip the introductions and start with the setup of an interface that
    Retrofit will use to make the HTTP requests:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取授权令牌，我们需要我们的应用程序在用户提供他们的凭证时请求它。为了将这个请求发送到后端，我们将使用Retrofit。我们已经在[*第4章*](B19443_04_split_000.xhtml#_idTextAnchor089)中使用了Retrofit，所以让我们跳过介绍，直接从设置Retrofit将用于发送HTTP请求的接口开始：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code defines an interface called `AuthService` with a unique login function.
    We will pass a `LoginRequest` object with the data needed for the request and
    then will obtain an `AuthToken` response.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`AuthService`的接口，具有一个独特的登录功能。我们将传递一个包含请求所需数据的`LoginRequest`对象，然后获取一个`AuthToken`响应。
- en: 'Let’s build those models. First, we’ll build the `LoginRequest` model:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这些模型。首先，我们将构建`LoginRequest`模型：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this model, we will send the user’s credentials – their email and password
    – to the backend.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们将用户的凭证——他们的电子邮件和密码——发送到后端。
- en: 'Then, if the login has been successful, the backend should answer with a response
    including an authorization token. We will structure this response as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果登录成功，后端应该返回一个包含授权令牌的响应。我们将按照以下结构来构建这个响应：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `AuthToken` model will include the aforementioned authorization token.
    Note that, usually, these tokens have a time window and so have to be renewed
    before they have expired. For simplicity, we are going to assume this token will
    not expire.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AuthToken`模型将包括上述授权令牌。请注意，通常这些令牌有一个时间窗口，因此必须在它们过期之前更新。为了简单起见，我们将假设这个令牌不会过期。
- en: 'Now, let’s create our remote data source to retrieve the authorization token:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的远程数据源以检索授权令牌：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we define the `LoginRemoteDataSource` class, which will act as a data
    source layer for handling login functionality by interacting with the remote authentication
    service. This class will have a single dependency, `authService`, which is an
    interface (presumably Retrofit or a similar networking library) responsible for
    making network requests related to authentication. The primary function within
    this class, `login`, is a suspended function that takes two parameters, `email`
    and `password`, which are used to construct a `LoginRequest` object. This object
    is then passed to the `authService.login` method, initiating a network request
    to log the user in.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`LoginRemoteDataSource`类，该类将作为数据源层，通过交互远程认证服务来处理登录功能。这个类将有一个单一的依赖项，即`authService`，它是一个接口（可能是Retrofit或类似的网络库），负责处理与认证相关的网络请求。在这个类中的主要功能`login`是一个挂起函数，它接受两个参数，`email`和`password`，这些参数用于构建一个`LoginRequest`对象。然后，这个对象被传递给`authService.login`方法，启动一个网络请求以登录用户。
- en: Upon receiving the response from `authService.login`, the `run` block is executed
    to handle the response. Inside this block, the response is checked to determine
    whether the request was successful (`isSuccessful`) and whether the response body
    contains a non-`null` token. If both conditions are met, `Result.success(token)`
    is returned, encapsulating the token in a successful result. This indicates that
    the login was successful and provides the caller with the token. Conversely, if
    either condition is not satisfied – meaning the request failed or the token was
    null – a failure result is returned by calling `Result.failure(getError(this))`.
    The `getError` function will analyze the `Response<AuthToken>` object to determine
    the nature of the failure and return an appropriate `Throwable` object that describes
    the error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到 `authService.login` 的响应后，执行 `run` 块来处理响应。在这个块内部，检查响应以确定请求是否成功（`isSuccessful`）以及响应体是否包含非
    `null` 令牌。如果这两个条件都满足，则返回 `Result.success(token)`，将令牌封装在成功的结果中。这表明登录成功，并向调用者提供令牌。相反，如果任一条件不满足——即请求失败或令牌为空——则通过调用
    `Result.failure(getError(this))` 返回失败结果。`getError` 函数将分析 `Response<AuthToken>`
    对象以确定失败的性质，并返回一个描述错误的适当 `Throwable` 对象。
- en: 'At this point, let’s build the `getError()` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们构建 `getError()` 函数：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this `getError` function, we map the possible values of the status code from
    the response to different errors. If we wanted to, we could later process those
    errors and show messages to the user accordingly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `getError` 函数中，我们将响应的状态码的可能值映射到不同的错误。如果我们愿意，我们可以在以后处理这些错误，并相应地向用户显示消息。
- en: 'Let’s also define those errors, in which we will map the server response. We
    will define them as part of a `LoginException` sealed class, which is a special
    type of class in Kotlin that restricts the inheritance hierarchy to a specific
    set of subclasses, providing exhaustive `when` expressions and ensuring that every
    possible type of error is handled:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也定义那些错误，我们将它们定义为 `LoginException` 密封类的一部分，这是 Kotlin 中的一种特殊类型类，它将继承层次结构限制为特定的一组子类，提供详尽的
    `when` 表达式，并确保处理了所有可能的错误类型：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have our `LoginRemoteDataSource` component, it is time to define
    how to store the token.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的 `LoginRemoteDataSource` 组件，是时候定义如何存储令牌了。
- en: Using DataStore to store the token
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DataStore 存储令牌
- en: Introduced by Google, **DataStore** is a data storage solution that provides
    an efficient, secure, and asynchronous way of persisting small pieces of data.
    It uses Kotlin coroutines and flow streams to store data asynchronously, ensuring
    UI thread safety and smoother performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由谷歌推出，**DataStore** 是一种数据存储解决方案，它提供了一种高效、安全且异步的方式来持久化小块数据。它使用 Kotlin 协程和流式传输来异步存储数据，确保
    UI 线程安全并提高性能。
- en: 'DataStore comes with several features that make it a preferable data storage
    option in Android applications:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: DataStore 提供了几个功能，使其成为 Android 应用程序中首选的数据存储选项：
- en: '**Asynchronous by default**: DataStore operations are performed asynchronously
    using Kotlin coroutines, preventing blocking the main thread and improving app
    performance.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认异步**：DataStore 操作默认使用 Kotlin 协程异步执行，防止阻塞主线程并提高应用性能。'
- en: '**Safe and consistent**: With built-in transactional data APIs, DataStore ensures
    data consistency and integrity, even if an app process is killed during a write
    operation.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和一致**：使用内置的事务性数据 API，DataStore 确保数据一致性和完整性，即使在写入操作期间应用程序进程被杀死也是如此。'
- en: '**Type safety**: DataStore offers two implementations: Preferences DataStore,
    which stores and retrieves key-value pairs, and Proto DataStore, which allows
    for storing type-safe objects using Protocol Buffers.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：DataStore 提供了两种实现：偏好 DataStore，它存储和检索键值对，以及 Proto DataStore，它允许使用
    Protocol Buffers 存储类型安全的对象。'
- en: '**Security**: DataStore can be integrated with encryption mechanisms to securely
    store sensitive information. DataStore can be combined with encryption libraries
    such as Tink to encrypt the data before saving, making it a more secure option
    for handling user credentials, tokens, and other sensitive information.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：DataStore 可以与加密机制集成，以安全地存储敏感信息。DataStore 可以与加密库（如 Tink）结合使用，在保存之前加密数据，使其成为处理用户凭据、令牌和其他敏感信息的更安全选项。'
- en: 'Why will we use DataStore and not Room (which we used previously for our WhatsPackt
    messenger project)? While both are robust data persistence libraries, they serve
    different purposes and have distinct use cases:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会使用 DataStore 而不是 Room（我们之前用于我们的 WhatsPackt 消息传递项目）？虽然两者都是健壮的数据持久化库，但它们服务于不同的目的，并且具有不同的用例：
- en: '**Use case suitability**: DataStore is designed for storing small collections
    of data, such as settings, preferences, or application state. It excels in handling
    lightweight tasks where the data structure is simple. **RoomDatabase** is a SQLite
    abstraction that significantly reduces the amount of boilerplate code needed to
    use SQLite. It’s intended for more complex data storage requirements, such as
    storing large datasets, relational data, or when we need to perform complex queries.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用用例**：DataStore 设计用于存储小型数据集合，例如设置、偏好或应用程序状态。它在处理结构简单的轻量级任务方面表现出色。**RoomDatabase**
    是一个 SQLite 抽象，可以显著减少使用 SQLite 所需的样板代码量。它旨在满足更复杂的数据存储需求，例如存储大型数据集、关系数据或当我们需要执行复杂查询时。'
- en: '**Performance and complexity**: DataStore provides a simpler API for data storage
    with minimal setup, making it ideal for straightforward tasks. Its performance
    is optimized for small datasets and simple data structures. **RoomDatabase**,
    being a database, is more suited for complex queries and large datasets. It involves
    more setup and is heavier than DataStore but offers more features and capabilities
    for comprehensive data management.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和复杂性**：DataStore 提供了一个更简单的 API 用于数据存储，设置最少，使其非常适合简单的任务。其性能针对小型数据集和简单的数据结构进行了优化。**RoomDatabase**
    作为数据库，更适合复杂查询和大型数据集。它涉及更多的设置，比 DataStore 更重，但提供了更多功能和能力，用于全面的数据管理。'
- en: '**Data security**: DataStore, especially with Proto DataStore, can easily be
    integrated with encryption mechanisms to store data securely, making it a more
    secure option for sensitive information. **RoomDatabase** supports SQLite encryption,
    but integrating encryption requires additional setup and possibly third-party
    libraries.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全**：DataStore，尤其是与 Proto DataStore 结合使用时，可以轻松集成加密机制以安全地存储数据，使其成为敏感信息的更安全选项。**RoomDatabase**
    支持SQLite加密，但集成加密需要额外的设置，可能还需要第三方库。'
- en: As we just need to store a small value (the token) and given its security features,
    DataStore is the best option.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要存储一个小的值（令牌）并且考虑到其安全特性，DataStore 是最佳选择。
- en: 'So, to start using it, first, we need to set up the DataStore dependency and
    its version in our version catalog:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要开始使用它，首先，我们需要在我们的版本目录中设置 DataStore 依赖项及其版本：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, need to add it to our modules’ `gradle.build.kts` files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要将其添加到我们的模块的 `gradle.build.kts` 文件中：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this code, we are only adding it to the modules where we would need to
    use the dependency – initially, this will just be in the `:feature:login` module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们只将其添加到需要使用依赖项的模块中 - 初始情况下，这将是 `:feature:login` 模块。
- en: 'Now, we can start using the DataStore library. We are going to build a `LoginLocalDataSource`
    component, which will be responsible for storing and retrieving the token in and
    from the DataStore:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用 DataStore 库了。我们将构建一个 `LoginLocalDataSource` 组件，该组件将负责在 DataStore
    中存储和检索令牌：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `LoginLocalDataSource`, first, we leverage Kotlin’s property delegation
    feature to initialize the DataStore. By defining `val Context.dataStore` with
    `preferencesDataStore(name: "user_preferences")`, we ensure a single instance
    of the DataStore is lazily initialized and tied to the application’s context.
    This method optimizes resource use and simplifies subsequent data operations.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `LoginLocalDataSource` 中，首先，我们利用 Kotlin 的属性委托功能来初始化 DataStore。通过定义 `val Context.dataStore`
    为 `preferencesDataStore(name: "user_preferences")`，我们确保 DataStore 的单例实例是懒加载的，并且与应用程序的上下文相关联。这种方法优化了资源使用并简化了后续的数据操作。'
- en: Within `LoginLocalDataSource`, we define a companion object to hold `TOKEN_KEY`,
    a key used to store and retrieve the authentication token from the DataStore.
    This key is defined using `stringPreferencesKey("auth_token")`, indicating the
    data type we intend to store – in this case, a `String` type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoginLocalDataSource` 中，我们定义一个伴生对象来持有 `TOKEN_KEY`，这是一个用于从 DataStore 存储和检索认证令牌的键。此键使用
    `stringPreferencesKey("auth_token")` 定义，表示我们打算存储的数据类型 - 在这种情况下，是一个 `String` 类型。
- en: In the `saveAuthToken` function, we perform a write operation on the DataStore
    by calling `edit` and passing a lambda that assigns the provided token to `TOKEN_KEY`.
    This operation is atomic and thread-safe, ensuring the integrity of our data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`saveAuthToken`函数中，我们通过调用`edit`并传递一个lambda表达式，将提供的令牌赋值给`TOKEN_KEY`，在DataStore上执行写操作。这个操作是原子的且线程安全的，确保了数据的一致性。
- en: To retrieve the authentication token, `getAuthToken` also employs suspending
    semantics to facilitate asynchronous execution. It accesses the DataStore’s data
    as a flow, immediately fetching the first emitted value with `.data.first()`.
    This operation suspends the coroutine, effectively making the data retrieval feel
    synchronous while maintaining the benefits of asynchronous execution. The function
    then checks whether the token exists and returns it wrapped in `Result<String>`,
    providing a straightforward way to handle success and failure. In the absence
    of a token, it returns `Result.failure` with a custom `TokenNotFoundError`, offering
    precise error handling.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索认证令牌，`getAuthToken`还采用了挂起语义以促进异步执行。它将DataStore的数据作为流访问，立即使用`.data.first()`获取第一个发出的值。此操作挂起协程，有效地使数据检索感觉是同步的，同时保持异步执行的好处。然后函数检查令牌是否存在，并将其包装在`Result<String>`中返回，提供了一种简单处理成功和失败的方式。如果没有令牌，它返回带有自定义`TokenNotFoundError`的`Result.failure`，提供精确的错误处理。
- en: 'Now, it is time to implement `LoginRepository`, which is responsible for coordinating
    between the remote and local data sources. We will build it, as always, by creating
    an interface in the domain layer and the implementation in the data layer. This
    is because the domain shouldn’t have any explicit dependency from the data layer,
    to respect the clean architecture. So, we define the interface like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现`LoginRepository`了，它负责协调远程和本地数据源。我们将像往常一样，在领域层创建一个接口，在数据层创建实现。这是因为领域层不应该有任何来自数据层的显式依赖，以尊重整洁架构。因此，我们定义接口如下：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the interface will have two functions: one to obtain the token so it
    can be used elsewhere (for example, for the backend requests to authenticate the
    user once it has been obtained) and another to perform the login and store the
    newly obtained authentication token.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，该接口将有两个功能：一个用于获取令牌以便在其他地方使用（例如，对于获取后用于验证用户的后端请求）以及另一个用于执行登录并存储新获得的认证令牌。
- en: 'Now, let’s implement the repository:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现仓库：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `LoginRepositoryImpl` class serves as an implementation of the `LoginRepository`
    interface, acting as a mediator between the application’s data sources and its
    use cases or view models. This class abstracts the details of data retrieval and
    storage, providing a cohesive API for authentication processes. It relies on two
    primary data sources: `localDataSource` for local data storage and retrieval,
    and `remoteDataSource` for handling network requests related to user authentication.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginRepositoryImpl`类是`LoginRepository`接口的实现，它作为应用程序数据源和其用例或视图模型之间的中介。这个类抽象了数据检索和存储的细节，为认证过程提供了一个统一的API。它依赖于两个主要的数据源：`localDataSource`用于本地数据存储和检索，以及`remoteDataSource`用于处理与用户认证相关的网络请求。'
- en: In the `getToken` function, the repository directly delegates the call to `localDataSource.getAuthToken()`,
    which fetches the authentication token from local storage. This method returns
    a `Result<String>` object, encapsulating the outcome of the operation in a type-safe
    manner. The token retrieval is critical for checking the user’s authentication
    status or for subsequent authenticated API calls that require a token.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getToken`函数中，仓库直接委托调用`localDataSource.getAuthToken()`，从本地存储中获取认证令牌。此方法返回一个`Result<String>`对象，以类型安全的方式封装操作的结果。令牌检索对于检查用户的认证状态或进行需要令牌的后续认证API调用至关重要。
- en: The `loginWithCredentials` function implements the process of authenticating
    a user with their email and password. It first attempts to log in through the
    `remoteDataSource.login(email, password)` method. Upon a successful login, indicated
    by the `onSuccess` branch of the fold, it saves the received authorization token
    using `localDataSource.saveAuthToken(it)` and then signals the completion of the
    login process with `Result.success(Unit)`. Conversely, if the remote login attempt
    fails (`onFailure`), it propagates the failure as `Result.failure(it)`, allowing
    the calling code to handle the error appropriately. This design effectively separates
    concerns between local and remote data handling, ensuring that the repository
    remains the single source of truth for all authentication-related data flows within
    the application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`loginWithCredentials` 函数实现了使用电子邮件和密码验证用户的流程。它首先尝试通过 `remoteDataSource.login(email,
    password)` 方法进行登录。在折叠的 `onSuccess` 分支指示登录成功后，它使用 `localDataSource.saveAuthToken(it)`
    保存收到的授权令牌，然后通过 `Result.success(Unit)` 信号表示登录过程的完成。相反，如果远程登录尝试失败（`onFailure`），它将错误传播为
    `Result.failure(it)`，允许调用代码适当地处理错误。这种设计有效地在本地和远程数据处理之间分离了关注点，确保仓库是应用程序中所有与认证相关的数据流唯一真相的来源。'
- en: 'Now, we can build a use case to perform the login, consuming this `LoginRepository`
    component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个用例来执行登录，消耗这个 `LoginRepository` 组件：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DoLogin` class implements the `DoLoginUseCase` interface, encapsulating
    the logic required to authenticate a user by their email and password. By delegating
    the authentication process to `loginRepository`, it invokes `loginRepository.loginWithCredentials(email,
    password)` to perform the actual login operation. The `DoLogin` use case simplifies
    the process of user authentication into a single method call, ensuring that the
    details of how the login is performed are encapsulated within the repository,
    thereby promoting the separation of concerns and making the code easier to maintain
    and test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoLogin` 类实现了 `DoLoginUseCase` 接口，封装了通过电子邮件和密码验证用户所需的逻辑。通过将认证过程委托给 `loginRepository`，它调用
    `loginRepository.loginWithCredentials(email, password)` 来执行实际的登录操作。`DoLogin` 用例将用户认证过程简化为单个方法调用，确保登录执行的细节封装在仓库中，从而促进关注点的分离，使代码更容易维护和测试。'
- en: Now, we are all set to use the login functionality. Next, let’s use those tokens
    to validate the app requests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用登录功能。接下来，让我们使用这些令牌来验证应用请求。
- en: Sending the authorization token in requests
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在请求中发送授权令牌
- en: To finish the users authentication:authorization token, sending in requests”
    authentication tasks, there is still one thing we have to do. The reason we were
    obtaining this authentication token was to be used in the requests the app is
    going to send to the backend, so it will guarantee the authenticity of the user
    that has generated the request. To include the token in every request, we are
    going to take advantage of Retrofit interceptors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成用户认证：在请求中发送授权令牌，还有一件事我们必须做。我们获取这个认证令牌的原因是将其用于应用将要发送到后端的请求中，这样将保证请求是由哪个用户生成的真实性。为了在每次请求中包含令牌，我们将利用
    Retrofit 拦截器。
- en: A Retrofit **interceptor** is a powerful mechanism provided by OkHttp (the underlying
    HTTP client used by Retrofit) that allows you to intercept and manipulate the
    request and response chain. Interceptors can modify requests and responses or
    perform actions such as logging, adding headers, handling authentication, and
    much more, before the request is sent to the server or after the response is received
    by the client.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 的 **拦截器** 是 OkHttp（Retrofit 所使用的底层 HTTP 客户端）提供的一种强大机制，允许您拦截和操作请求和响应链。拦截器可以修改请求和响应，或在请求发送到服务器之前或响应被客户端接收之后执行诸如记录、添加头、处理认证等操作。
- en: 'Interceptors can be broadly categorized into two types:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器可以大致分为两种类型：
- en: '**Application interceptors**: These interceptors are called once for any single
    call to the server. They don’t need to worry about network specifics such as retries
    and redirects. Application interceptors are perfect for tasks such as adding a
    common header to all requests, logging the request and response body for debugging
    purposes, or managing application-level caching.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序拦截器**：这些拦截器在调用服务器时仅被调用一次。它们不需要担心网络特定的细节，如重试和重定向。应用程序拦截器非常适合添加公共头到所有请求、记录请求和响应体以供调试目的或管理应用程序级缓存等任务。'
- en: '**Network interceptors**: These interceptors can monitor the data at the network
    level. They can observe and manipulate requests and responses that come from and
    go to the server, including any retries and redirects that occur as part of the
    network call process.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络拦截器**：这些拦截器可以在网络级别监控数据。它们可以观察和操作来自和发送到服务器的请求和响应，包括作为网络调用过程一部分发生的任何重试和重定向。'
- en: To add an authentication token to all outgoing requests, we will choose an application
    interceptor. We will choose an application interceptor in this scenario because
    they are designed to operate at the application layer, directly modifying requests
    before they are sent out and processing responses once they are received. This
    makes them well suited for tasks such as adding headers that should be included
    in every request to the server, such as authentication tokens.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将认证令牌添加到所有发出的请求中，我们将选择一个应用程序拦截器。在这个场景中，我们将选择应用程序拦截器，因为它们设计在应用层操作，直接在请求发送之前修改请求，并在收到响应后处理响应。这使得它们非常适合添加应包含在每个请求中的头信息，例如认证令牌。
- en: 'So, let’s write our interceptor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写我们的拦截器：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This class plays a critical role in enriching outgoing HTTP requests with authentication
    details. It achieves this by integrating with `LoginRepository`, from which it
    retrieves the current user’s authorization token. Upon intercepting a request,
    the interceptor fetches theusers authentication:authorization token, sending in
    requests” token synchronously using `runBlocking` (a mechanism that allows for
    the seamless integration of coroutine-based asynchronous token retrieval into
    the synchronous flow expected by interceptors).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在丰富发出的 HTTP 请求的认证细节方面发挥着关键作用。它通过集成 `LoginRepository` 来实现这一点，从中检索当前用户的授权令牌。在拦截请求时，拦截器获取用户的认证：授权令牌，通过使用
    `runBlocking`（一种允许将基于协程的异步令牌检索无缝集成到拦截器期望的同步流程中的机制）同步发送请求中的令牌。
- en: If a token is present, it’s appended to the request as an `Authorization` header,
    adhering to the widely accepted bearer token format (the bearer token format is
    a security scheme where a client sends a token in the header of the requests to
    authenticate access, prefixed with the word `Bearer` followed by a space and the
    token itself), thereby ensuring that the request carries the necessary credentials
    for authentication by the server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在令牌，它将作为 `Authorization` 头附加到请求中，遵循广泛接受的载体令牌格式（载体令牌格式是一种安全方案，其中客户端在请求头中发送令牌以进行身份验证，前缀为单词
    `Bearer` 后跟一个空格和令牌本身），从而确保请求携带服务器进行认证所需的所有凭证。
- en: Using `runBlocking` within the interceptor is a pragmatic approach to accommodate
    the synchronous nature of the `intercept()` method, allowing for the immediate
    availability of the token. However, it’s crucial to ensure that the token retrieval
    operation is efficient and non-blocking to avoid performance bottlenecks – ideally,
    by fetching the token from a local cache or storage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在拦截器中使用 `runBlocking` 是一种实用方法，以适应 `intercept()` 方法的同步性质，允许令牌立即可用。然而，确保令牌检索操作高效且非阻塞至关重要，以避免性能瓶颈——理想情况下，通过从本地缓存或存储中获取令牌。
- en: Finally, at the end of the function, we return `chain.proceed(requestwithToken)`,
    which will allow Retrofit to continue processing the request, including the interceptor
    changes (in this case, adding the authentication header).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在函数的末尾，我们返回 `chain.proceed(requestwithToken)`，这将允许 Retrofit 继续处理请求，包括拦截器更改（在这种情况下，添加认证头）。
- en: 'Now, we should include `AuthInterceptor` as an interceptor when we are building
    the Retrofit client:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建 Retrofit 客户端时，应将 `AuthInterceptor` 作为拦截器包含在内：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we can see how we can integrate the interceptor we’ve created into our
    network layer setup, specifically within a Retrofit configuration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如何将我们创建的拦截器集成到我们的网络层设置中，具体是在 Retrofit 配置中。
- en: Within the function, an `OkHttpClient` instance is created and configured to
    include the `authInterceptor` instance via the `addInterceptor` method. This setup
    ensures that every HTTP request made by this client will first pass through the
    `authInterceptor`, allowing it to modify the request as needed before it is sent
    out.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，创建并配置了一个 `OkHttpClient` 实例，通过 `addInterceptor` 方法包含 `authInterceptor`
    实例。这种设置确保了该客户端发出的每个 HTTP 请求都将首先通过 `authInterceptor`，允许它在请求发送之前按需修改请求。
- en: Following the configuration of the `OkHttpClient` instance, the Retrofit instance
    is built. The configured `OkHttpClient` instance is set as the client for Retrofit,
    linking the HTTP client, with its interceptor, to the Retrofit instance. Now,
    all the requests using this Retrofit instance will include the authentication
    token in the header, if it exists.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`OkHttpClient`实例之后，构建Retrofit实例。配置的`OkHttpClient`实例被设置为Retrofit的客户端，将HTTP客户端及其拦截器链接到Retrofit实例。现在，使用此Retrofit实例的所有请求都将包含头部的身份验证令牌（如果存在）。
- en: 'After that, weusers authentication:authorization token, sending in requests”
    handled the app authentication, from obtaining the token and storing it to providing
    this token in every request. Now, it’s time to build the main screen: the list
    of movies and series.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们处理了应用的身份验证：从获取令牌到存储令牌，并在每个请求中提供此令牌。”现在，是时候构建主屏幕了：电影和电视剧列表。
- en: Creating your movie list
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的电影列表
- en: One of the goals of our Packtflix app is for users to have the freedom to explore
    and enjoy an extensive range of movies (or TV series), ensuring they stay engaged
    with our app. To achieve this, we must present our movie catalog in the most appealing
    manner possible. For that reason, in this section, we will focus on building a
    movie (or series!) catalog screen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Packtflix应用的一个目标是为用户提供自由探索和享受广泛的电影（或电视剧）范围，确保他们保持对我们应用的兴趣。为了实现这一点，我们必须以最吸引人的方式展示我们的电影目录。因此，在本节中，我们将专注于构建一个电影（或系列！）目录屏幕。
- en: To start building the classical main screen of our streaming app, we first need
    to create the models we will use to represent the information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建我们流媒体应用的经典主屏幕，我们首先需要创建我们将用来表示信息的模型。
- en: Building the models
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型
- en: 'Start by building the `Movie` model:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建`Movie`模型：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the model that will represent a movie – it includes the movie identification
    (`id`), its title, and a URL to an image of the movie.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将表示电影的模型 – 它包括电影标识（`id`）、标题以及电影图片的URL。
- en: 'Generally, movies in a streaming app are arranged by genres, so let’s create
    a `Genre` model too:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，流媒体应用中的电影是按类型排列的，所以让我们也创建一个`Genre`模型：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we defined the name of the genre (needed to render it on the screen) and
    a list of the movies included in that genre.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了类型的名称（需要将其渲染到屏幕上）以及包含在该类型中的电影列表。
- en: 'Finally, we need a `MoviesViewState` class to represent the movie list screen
    state:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`MoviesViewState`类来表示电影列表屏幕状态：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this `MoviesViewState` class, we are including just one property, `genres`,
    which will store the list of genres we want to show in the list of our streaming
    app.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`MoviesViewState`类中，我们只包含一个属性`genres`，它将存储我们希望在流媒体应用列表中显示的类型列表。
- en: Now, we are ready to start creating the `MoviesScreen` composable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好开始创建`MoviesScreen`可组合组件。
- en: Building the MoviesScreen composable
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建MoviesScreen可组合组件
- en: 'To build the `MoviesScreen` composable, enter the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建`MoviesScreen`可组合组件，请输入以下代码：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, we have created our `MoviesScreen` composable and a `Scaffold`
    inside of it. As a `topBar` component of the `Scaffold`, we are including a new
    composable called `PackflixTopBar`, then as a `bottomBar` component, we are including
    another new composable called `PacktflixBottomBar`. Finally, in the content of
    the Scaffold, we are showing a `GenreList` composable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经创建了我们的`MoviesScreen`可组合组件以及其内部的`Scaffold`。作为`Scaffold`的`topBar`组件，我们包括了一个新的可组合组件`PackflixTopBar`，然后作为`bottomBar`组件，我们包括另一个新的可组合组件`PacktflixBottomBar`。最后，在`Scaffold`的内容中，我们显示了一个`GenreList`可组合组件。
- en: 'Now, let’s build these three composables: `PacktflixTopBar`, `PacktflixBottomBar`,
    and `GenreList`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建这三个可组合组件：`PacktflixTopBar`、`PacktflixBottomBar`和`GenreList`。
- en: PacktflixTopBar
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PacktflixTopBar
- en: 'Here is how we create the `PacktflixTopBar` composable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何创建`PacktflixTopBar`可组合组件的：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside `TopAppBar`, there’s a title that displays the text **PACKTFLIX** on
    the screen – the text will be colored in red, with a large font size and some
    padding to create some space.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TopAppBar`内部，有一个显示屏幕上**PACKTFLIX**文本的标题 – 文本将以红色显示，具有大字体和一些填充以创建一些空间。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is how `TopAppBar` will look:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`TopAppBar`的外观：
- en: '![Figure 7.4: Top bar in MoviesScreen](img/B19443_07_004.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：MoviesScreen中的顶部栏](img/B19443_07_004.jpg)'
- en: 'Figure 7.4: Top bar in MoviesScreen'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：MoviesScreen中的顶部栏
- en: Let’s continue with the bottom bar.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建底栏。
- en: PacktflixBottomBar
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PacktflixBottomBar
- en: 'Now, let’s build the `PacktflixBottomBar` composable:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建`PacktflixBottomBar`可组合组件：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This navigation bar sports a sleek black background with icons illuminated in
    white, offering a stark and stylish contrast. We’re also introducing four navigation
    items, each symbolized by a distinct icon. We’ve opted for icons from the Material
    Icons collection, assigning specific and intuitive symbols to signify **Home**,
    **Search**, **Downloads**, and **More** functionalities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导航栏采用光滑的黑色背景，白色图标照亮，提供了鲜明而时尚的对比。我们还引入了四个导航项，每个项都由一个独特的图标表示。我们选择了来自 Material
    Icons 收集的图标，为 **主页**、**搜索**、**下载** 和 **更多** 功能分配了具体且直观的符号。
- en: For each navigation item within `NavigationBarItem`, we have set up an icon
    along with an `onClick` listener. Initially, all these items are not selected
    (`selected = false`) to indicate that their selection state will be managed dynamically
    through user interactions or specific logic to be implemented in the future. The
    implementation of these sections is beyond the scope of this book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `NavigationBarItem` 内的每个导航项，我们都设置了一个图标以及一个 `onClick` 监听器。最初，所有这些项都没有被选中（`selected
    = false`），以表明它们的选中状态将通过用户交互或未来要实现的具体逻辑动态管理。这些部分的实现超出了本书的范围。
- en: We are also pairing each icon with `contentDescription`. This approach enhances
    app accessibility by offering screen readers a concise explanation of each button’s
    function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将每个图标与 `contentDescription` 配对。这种方法通过为屏幕阅读器提供每个按钮功能的简洁说明，增强了应用程序的无障碍性。
- en: 'Once it is finished, this is how `PacktflixBottomBar` will look:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，`PacktflixBottomBar` 将看起来是这样的：
- en: '![Figure 7.5: Bottom bar in MoviesScreen](img/B19443_07_005.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：MoviesScreen 中的底部栏](img/B19443_07_005.jpg)'
- en: 'Figure 7.5: Bottom bar in MoviesScreen'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：MoviesScreen 中的底部栏
- en: Now, let’s continue with the next step and complete this screen by implementing
    the list of movies.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步，通过实现电影列表来完成这个屏幕。
- en: GenreList
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GenreList
- en: 'Now, let’s start building the `GenreList` composable. Generally, the content
    of a movie screen in a streaming app is composed of a list of genres, where each
    one contains a list of movies. Let’s use the `Genre` model we defined previously
    and create this list of lists. We will start creating a vertical list composed
    of rows where every row will show the content of every `Genre` instance:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建 `GenreList` 组合器。通常，流媒体应用程序中电影屏幕的内容由一系列类别组成，其中每个类别包含一系列电影。让我们使用我们之前定义的
    `Genre` 模型，并创建这个列表的列表。我们将开始创建一个由行组成的垂直列表，其中每行将显示每个 `Genre` 实例的内容：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To efficiently display the `GenreList` composable, we employed `LazyColumn`,
    chosen for its ability to render items lazily – this means it only draws the items
    visible on the screen, enhancing performance, especially for long lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地显示 `GenreList` 组合器，我们使用了 `LazyColumn`，这是因为它能够懒加载渲染项目——这意味着它只绘制屏幕上可见的项目，从而提高了性能，尤其是在长列表中。
- en: Inside `LazyColumn`, we iterate over the genre list. For each genre, we call
    items, specifying the size of our genre list to determine the number of items
    it should prepare to display.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LazyColumn` 内部，我们遍历类别列表。对于每个类别，我们调用 `items`，指定我们的类别列表的大小以确定它应该准备显示的项目数量。
- en: Then, for every item (or genre, in our context), we invoke `GenreRow`, a custom
    composable function that we will define in a moment. This function is responsible
    for rendering a single row in our list, which represents a genre. We pass each
    genre to `GenreRow` by indexing it into our genres list with `genres[index]`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个项目（或在我们的上下文中，每个类别），我们调用 `GenreRow`，这是一个我们将稍后定义的自定义组合器函数。这个函数负责渲染列表中的单行，它代表一个类别。我们通过将
    `genres[index]` 索引到我们的类别列表中，将每个类别传递给 `GenreRow`。
- en: 'Now, let’s build the `GenreRow` composable that we just mentioned:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们刚才提到的 `GenreRow` 组合器：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start with a vertical container, `Column`, that stretches across the full
    width of the screen. At the top of this container, we place the genre’s name in
    large, readable text. This makes it clear to the user which genre they’re looking
    at.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个垂直容器 `Column` 开始，该容器跨越整个屏幕的宽度。在这个容器的顶部，我们放置了该类别的名称，使用大号、易读的文本。这使得用户清楚地知道他们正在查看哪个类别。
- en: Right below the genre’s name, we set up a horizontal scroll area, `LazyRow`,
    filled with movie cards. Each card represents a movie in the genre, and users
    can scroll through them horizontally.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在类别名称下方，我们设置了一个水平滚动区域，`LazyRow`，其中填充了电影卡片。每张卡片代表该类别的电影，用户可以水平滚动浏览它们。
- en: 'For each movie in the genre, we will create a `MovieCard` composable that will
    show the movie thumbnail image and the name:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该类别的每部电影，我们将创建一个 `MovieCard` 组合器，它将显示电影的缩略图和名称：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by using a `Card` composable that provides a Material Design card layout.
    This card is given specific dimensions and padding to ensure that it looks neat
    and uniform across the app. Specifically, we set each card to be `120dp` wide
    and `180dp` tall, with an `8dp` padding around it. This size is ideal for displaying
    movie posters without taking up too much screen space or looking too cramped.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个提供Material Design卡片布局的`Card`可组合组件。这个卡片被赋予了特定的尺寸和填充，以确保它在整个应用中看起来整洁且统一。具体来说，我们将每个卡片设置为`120dp`宽和`180dp`高，周围填充`8dp`。这个尺寸对于显示电影海报来说非常理想，既不会占用太多屏幕空间，也不会显得过于拥挤。
- en: Inside the card, we place an `Image` composable to show the movie’s poster.
    To load the image (the movie’s poster in this case) from a URL, we use `rememberAsyncImagePainter`,
    a handy function that handles asynchronous image loading and caching. This means
    our app can fetch movie posters from the internet efficiently and display them
    as they become available, without blocking the UI thread.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡片内部，我们放置一个`Image`可组合组件来显示电影的海报。为了从URL加载图片（在这个案例中是电影的海报），我们使用`rememberAsyncImagePainter`，这是一个处理异步图像加载和缓存的便捷函数。这意味着我们的应用可以高效地从互联网上获取电影海报，并在它们可用时显示，而不会阻塞UI线程。
- en: The image is set to crop to fit the card’s dimensions, ensuring that the most
    visually important part of the poster remains visible, even if the original image’s
    aspect ratio doesn’t exactly match the card’s dimensions. This cropping also maintains
    a consistent appearance across all movie cards.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图片被设置为裁剪以适应卡片尺寸，确保即使原始图片的宽高比与卡片尺寸不完全匹配，海报的最重要视觉部分仍然可见。这种裁剪也保持了所有电影卡片的一致外观。
- en: Finally, we include `contentDescription` for the image, using the movie’s title,
    to make our list as accessible as possible.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为图片添加`contentDescription`，使用电影标题，以使我们的列表尽可能易于访问。
- en: 'With this component, we have finished our movie screen (or series screen –
    you just have to change the title and the content!). We can now test it using
    the `@Preview` annotation and providing a list of genres:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个组件，我们已经完成了我们的电影屏幕（或剧集屏幕——您只需更改标题和内容即可！）现在我们可以使用`@Preview`注解和提供流派列表来测试它。
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we are using the preview feature of Jetpack Compose to see what our list
    will look like. We would need to create some sample content, and that’s what the
    `sampleMoviesScreen()` function will do for us. For example, we could create this
    fake list of movies:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Jetpack Compose的预览功能来查看我们的列表将呈现什么样子。我们需要创建一些示例内容，这正是`sampleMoviesScreen()`函数为我们所做的事情。例如，我们可以创建以下假的电影列表：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are creating fake data to make the testing of `MoviesScreen` easier.
    Note that the URLs provided are not the actual image URLs, so you would have to
    replace them for actual movie posters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建假数据以使`MoviesScreen`的测试更容易。请注意，提供的URL不是实际的图片URL，因此您需要将它们替换为实际的电影海报。
- en: 'Once finished, our list screen should look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的列表屏幕应该看起来像这样：
- en: '![Figure 7.6: Movies list screen](img/B19443_07_006.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：电影列表屏幕](img/B19443_07_006.jpg)'
- en: 'Figure 7.6: Movies list screen'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：电影列表屏幕
- en: Now that we have our list of genres and movies, let’s build the movie (or series)
    details page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的流派和电影列表，让我们构建电影（或剧集）详情页面。
- en: Making the movie and series detail screen
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作电影和剧集详细屏幕
- en: In this section, we will create the detail screen, which is the screen that
    will be shown when the user clicks a movie or series from the list. This screen
    will include information such as the plot summary, cast, year of release, and
    so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建详细屏幕，这是当用户从列表中点击电影或剧集时将显示的屏幕。该屏幕将包括剧情简介、演员阵容、上映年份等信息。
- en: Before building the necessary composables, we need to think about the models
    we need. Let’s start creating them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建必要的可组合组件之前，我们需要考虑我们需要哪些模型。让我们开始创建它们。
- en: Creating the detail models
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建详细模型
- en: 'To define the models, we need to take into account the data we want to show
    in the detail screen. As we would like to create the same model for both movies
    and series, we will build an `ItemDetail` model as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义模型，我们需要考虑在详细屏幕中想要展示的数据。由于我们希望为电影和剧集创建相同的模型，我们将构建一个`ItemDetail`模型，如下所示：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the case that `ItemDetail` represents a streaming series item, we also should
    define the `Episode` model:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ItemDetail`代表一个流媒体剧集项目，我们也应该定义`Episode`模型：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now that we have our models ready, we can start building the `DetailScreen`
    composable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了模型，我们可以开始构建`DetailScreen`可组合组件。
- en: Building the DetailScreen
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建详细屏幕
- en: 'As we have done on other occasions, we will first build the structure we want
    the screen to have:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他场合所做的那样，我们首先构建我们想要的屏幕结构：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In `ItemDetailScreen`, all the composables included are shown in a vertical
    `Column`, which allows us to build the UI progressively as we add new composables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ItemDetailScreen` 中，所有包含的可组合组件都显示在一个垂直的 `Column` 中，这使得我们可以在添加新的可组合组件时逐步构建
    UI。
- en: 'Now, let’s start building all those composables, starting with `ItemBannerImage`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建所有这些可组合组件，从 `ItemBannerImage` 开始：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This composable displays a banner image at the top of the screen, stretching
    it to fill the screen’s width. It uses a `Box` composable with a `Modifier` parameter
    that will make sure it takes up the full width of the screen, and an `Image` composable
    that loads an image from a given URL with the `rememberAsyncImagePainter` function.
    The image is set to be 200 dp tall and automatically adjusts its width to fit
    the screen, ensuring that it’s properly cropped to the allocated space.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可组合组件在屏幕顶部显示横幅图片，将其拉伸以填充屏幕宽度。它使用一个带有 `Modifier` 参数的 `Box` 可组合组件，确保它占据屏幕的全宽，并使用
    `Image` 可组合组件通过 `rememberAsyncImagePainter` 函数从给定的 URL 加载图片。图片设置为 200 dp 高，并自动调整其宽度以适应屏幕，确保它被正确裁剪到分配的空间中。
- en: On top of the image, there’s an `IconButton` composable that’s meant to act
    as a **Back** button. We place this button in the top-left corner with some padding.
    Inside this button, there’s an icon shaped like an arrow pointing back, suggesting
    that pressing it should take you back to the previous screen. The icon is white
    to make sure it’s visible on top of the banner image.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片上方，有一个 `IconButton` 可组合组件，它旨在充当 **返回** 按钮。我们将这个按钮放置在左上角并添加一些填充。在这个按钮内部，有一个形状像箭头指向回的图标，暗示按下它应该带您回到上一个屏幕。这个图标是白色的，以确保它在横幅图片上可见。
- en: 'Now, let’s build the `ItemTitleAndMetadata` composable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建 `ItemTitleAndMetadata` 可组合组件：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We start by creating a `Column` layout because we want the details to stack
    vertically.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `Column` 布局，因为我们希望细节垂直堆叠。
- en: In this column, we will display the title of the item. The style we choose here
    is `bodyMedium` from the Material Theme, ensuring it fits nicely with the overall
    design of the app.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列中，我们将显示项目的标题。我们在这里选择 `bodyMedium` 从 Material 主题，确保它与应用程序的整体设计很好地匹配。
- en: Next, we align our HD indicator and the year of release in a row, centering
    them vertically to ensure that they line up perfectly. We include a conditional
    check – only if `isHD` is `true` do we display an **HD** badge. We give this badge
    a white border and a bit of padding to make it pop against any background.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的 HD 指示符和发布年份对齐在一行中，垂直居中以确保它们完美对齐。我们包含一个条件检查 - 只有当 `isHD` 为 `true`
    时，我们才显示 **HD** 徽章。我们给这个徽章一个白色边框和一些填充，使其在背景上更加突出。
- en: Following a small spacer, which adds some breathing room between our **HD**
    badge and the year, we place the text for the year. It’s styled to be less prominent
    than the title, using a medium gray color.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个小间隔之后，这个间隔在 **HD** 徽章和年份之间增加了一些空间，我们放置年份的文本。它的样式设计得比标题不那么突出，使用中等灰色颜色。
- en: Finally, below the row, we will show the duration of the item. It’s also in
    medium gray, matching the year, and using the same `bodyMedium` style for consistency.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在行下方，我们将显示项目的持续时间。它也是中等灰色，与年份匹配，并使用相同的 `bodyMedium` 风格以保持一致性。
- en: 'The next step is to create the `ItemActions` composable:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `ItemActions` 可组合组件：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We start by laying this function in a column format so that our action buttons
    stack vertically – this column will take up the full width available and will
    have padding all around for some space from the screen edges.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以列格式排列这个函数，以便我们的操作按钮垂直堆叠 - 这个列将占据可用宽度，并且周围都有填充，以从屏幕边缘留出一些空间。
- en: 'Inside this column, we’re placing two action buttons: one for playing the item
    and another for adding the item to a user’s personal list. To create these buttons,
    we are using the `ActionButton` composable function, which neatly bundles an icon
    and a label together into a clickable area. For the **Play** action, we are using
    a play arrow icon, and for adding to the list, we are using an **Add** icon.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列内部，我们放置两个操作按钮：一个用于播放项目，另一个用于将项目添加到用户的个人列表中。为了创建这些按钮，我们使用 `ActionButton`
    可组合函数，它将图标和标签整齐地捆绑在一起，形成一个可点击的区域。对于 **播放** 操作，我们使用播放箭头图标，对于添加到列表，我们使用 **添加** 图标。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have left placeholders in the code where the play and add-to-list actions
    can be written. In the next chapter, we will implement the **Play** button; however,
    I will leave you to add the add-to-list feature yourself. To do this, one solution
    could be to call an endpoint when the **Add To List** button is pressed, so the
    backend can store it in the user list (of course, imagining that we have a backend
    that handles this feature). You can refer to [*Chapter 4*](B19443_04_split_000.xhtml#_idTextAnchor089)
    where we connected Packtagram with **NewsFeed** to understand how this can be
    done.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中留下了占位符，以便可以编写播放和添加到列表的动作。在下一章中，我们将实现**播放**按钮；然而，我将留给你自己添加添加到列表的功能。为此，一个解决方案是在按下**添加到列表**按钮时调用一个端点，以便后端可以将其存储在用户列表中（当然，假设我们有一个处理此功能的后端）。你可以参考[*第4章*](B19443_04_split_000.xhtml#_idTextAnchor089)，了解我们如何将Packtagram与**新闻动态**连接起来。
- en: 'Now, let’s continue with the next composable, `CastAndCreatorsList`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个可组合组件，`CastAndCreatorsList`：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We start with `Column`, which is going to stack our elements vertically. We
    want this to take up the full width available, so we use `Modifier.fillMaxWidth()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Column`开始，它将垂直堆叠我们的元素。我们希望它占据可用的全部宽度，所以我们使用`Modifier.fillMaxWidth()`。
- en: Then, we put a header labeled `Cast` at the top. We style this text to make
    it stand out using `MaterialTheme.typography.titleSmall` and set the color to
    white. To give it some breathing room, we add padding around it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在顶部放置一个标记为`Cast`的标题。我们使用`MaterialTheme.typography.titleSmall`来使这个文本突出，并将其颜色设置为白色。为了给它留出一些空间，我们在其周围添加填充。
- en: Next, we introduce a `LazyRow` composable to display each actor’s name from
    the cast list using a `Text` composable. We style the names to stand out against
    the background by applying `MaterialTheme.typography.bodyMedium` and setting the
    text color to white. To further distinguish each name, we give them a tag-like
    appearance with a dark gray background and rounded corners using `RoundedCornerShape(4.dp)`.
    Additionally, we add padding around the text to ensure that it doesn’t touch the
    edges of its gray backdrop, enhancing readability and visual appeal.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入一个`LazyRow`可组合组件来显示演员列表中的每个演员的名字，使用一个`Text`可组合组件。我们通过应用`MaterialTheme.typography.bodyMedium`并将文字颜色设置为白色来使名字在背景上突出。为了进一步区分每个名字，我们使用`RoundedCornerShape(4.dp)`给它们一个类似标签的外观，背景为深灰色，边缘为圆角。此外，我们在文字周围添加填充，以确保它不触及其灰色背景的边缘，从而增强可读性和视觉吸引力。
- en: Then, we separate the cast from the creators with a `Spacer` composable. This
    just adds a bit of vertical space between the two sections, so they don’t run
    into each other.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个`Spacer`可组合组件将演员与创作者分开。这只是在两个部分之间添加一点垂直空间，这样它们就不会相互碰撞。
- en: For the creators, the setup is pretty much the same. We have a header labeled
    `"Created by"`, styled similarly to the `Cast` header but a bit larger using `titleMedium`.
    Then, we list out the creators in another `LazyRow`, giving them the same styled
    text tags as the cast.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创作者，设置几乎相同。我们有一个标记为`"Created by"`的标题，其样式与`Cast`标题类似，但使用`titleMedium`稍大一些。然后，我们在另一个`LazyRow`中列出创作者，给他们与演员相同的样式文本标签。
- en: 'Now, it’s time to work on the last composable of the screen, `AdditionalMovieDetails`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理屏幕上的最后一个可组合组件，`AdditionalMovieDetails`：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In `AdditionalMovieDetails`, we’re setting up a column that expands to the maximum
    width of its parent container. Inside this column, we’re going through each episode
    in the `item.episodes` list and, for each one, we’re calling the `EpisodeItem`
    composable to render the details of that episode.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AdditionalMovieDetails`中，我们设置了一个列，它扩展到其父容器最大宽度。在这个列中，我们遍历`item.episodes`列表中的每个剧集，并为每个剧集调用`EpisodeItem`可组合组件来渲染该剧集的详细信息。
- en: Now, moving on to the `EpisodeItem` composable function, this is where we lay
    out each episode’s information. We create a row that stretches across the full
    width, which can be tapped – this is where we will want to add the code for what
    happens when someone clicks to play the episode. We are also adding some padding
    for spacing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向`EpisodeItem`可组合函数，这是放置每个剧集信息的地方。我们创建了一行，它横跨整个宽度，可以点击——这就是我们想要添加点击播放剧集代码的地方。我们还添加了一些填充来增加间距。
- en: Within this row, the first thing is the episode image. We use `rememberAsyncImagePainter`
    to load the image from the episode URL, and we make sure it’s nicely rounded and
    cropped to fit a specific size. This image will act as a thumbnail for the episode.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，首先是剧集的图片。我们使用`rememberAsyncImagePainter`从剧集URL加载图片，并确保它被很好地圆角裁剪以适应特定的大小。这张图片将作为剧集的缩略图。
- en: 'Next to the image, we add a spacer to give some breathing room before the text
    details of the episode. This is followed by a column that holds two pieces of
    text: the episode’s title, which stands out more, and below it, the duration of
    the episode in a smaller and less prominent color.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片旁边，我们添加了一个空白区域，为剧集的文字细节提供一些呼吸空间。随后是一个包含两段文字的列：剧集的标题，它更加突出，以及在其下方，剧集的时长，以较小的颜色和不太突出的方式呈现。
- en: Lastly, after each episode item, we draw a thin gray line, a divider, to visually
    separate the episodes from one another. It’s a common design pattern that helps
    users distinguish between different pieces of content.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每个剧集项目之后，我们画一条细灰线，作为分隔符，以在视觉上区分各个剧集。这是一种常见的布局模式，有助于用户区分不同的内容。
- en: 'And with this composable, we have finished the detail screen and this chapter.
    Our detail screen should look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个组合组件，我们已经完成了详情屏幕和这一章。我们的详情屏幕应该看起来像这样：
- en: '![Figure 7.7: Detail screen](img/B19443_07_007.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：详情屏幕](img/B19443_07_007.jpg)'
- en: 'Figure 7.7: Detail screen'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：详情屏幕
- en: In the next chapter, we will bring those movies and series to life by implementing
    the playback.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现播放功能，让那些电影和电视剧变得生动起来。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we close this chapter, we have laid a solid foundation for Packtflix, our
    video streaming app. We began by conceptualizing the project’s structure and modules,
    setting the stage for an organized and scalable app. This structure is pivotal
    for our journey ahead, where complexity will grow as we add more features.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们为Packtflix，我们的视频流应用，奠定了坚实的基础。我们首先构思了项目的结构和模块，为有序和可扩展的应用程序奠定了基础。这种结构对我们未来的旅程至关重要，随着我们添加更多功能，复杂性将会增长。
- en: We then created the login screen, before venturing into the world of user authentication.
    Through the integration of OAuth2, we’ve equipped Packtflix with a secure authentication
    system that respects user privacy and guards against unauthorized access, ensuring
    a trustworthy environment for our users to enjoy their favorite content.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建了登录屏幕，然后进入了用户认证的世界。通过整合OAuth2，我们为Packtflix配备了一个安全的认证系统，尊重用户隐私，防止未经授权的访问，确保用户能够在一个值得信赖的环境中享受他们喜爱的内容。
- en: Our progress continued as we crafted a UI to display a curated list of movies,
    leveraging the power of Jetpack Compose to create a dynamic and engaging experience.
    This attention to detail in presenting content is what will turn first-time users
    into loyal fans of Packtflix.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进展继续，我们制作了一个用户界面来显示精心挑选的电影列表，利用Jetpack Compose的力量创建了一个动态和吸引人的体验。这种在呈现内容时的细致入微将把新用户转变为Packtflix的忠实粉丝。
- en: In the next chapter, we will learn more about how to implement the playback,
    so our users can not only see the movies and series information but also play
    their videos.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何实现播放功能，这样我们的用户不仅能看到电影和电视剧信息，还能播放他们的视频。
