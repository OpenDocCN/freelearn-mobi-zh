- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Design Patterns to Solve Complex Questions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决复杂问题的设计模式
- en: In previous chapters, we discussed different aspects of iOS development. We
    covered UIKit, Swift, reactive programming, SwiftUI, Core Data, and many more.
    These building blocks help us achieve our next level – design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了 iOS 开发的不同方面。我们涵盖了 UIKit、Swift、响应式编程、SwiftUI、Core Data 以及更多。这些构建块帮助我们达到下一个层次——设计模式。
- en: 'Design patterns are like tools. Each one of them solves a different problem
    or a different need, such as the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式就像工具。每一个都解决不同的问题或不同的需求，例如以下内容：
- en: Do we need to change the behavior of a particular instance? We can use **dependency**
    **injection** (**DI**).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要改变特定实例的行为吗？我们可以使用 **依赖** **注入**（**DI**）。
- en: Do we have a complex state to manage? We can use **Model-View-ViewModel** (**MVVM**).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要管理复杂的状态吗？我们可以使用 **模型-视图-视图模型**（**MVVM**）。
- en: Do we need to define communication between objects? We can use delegation.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要定义对象之间的通信吗？我们可以使用代理。
- en: The more we expand our toolbox with design patterns, the more problems we can
    solve. We should remember that design patterns alone are not our goal – they are
    tools to accomplish our tasks. We should remember that we’ll have to pick a particular
    design pattern or talk about it in our interviews.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计模式工具箱越丰富，我们能解决的问题就越多。我们应该记住，设计模式本身并不是我们的目标——它们是完成我们任务的工具。我们应该记住，在面试中，我们可能需要选择一个特定的设计模式或讨论它。
- en: 'In this chapter, we’ll cover some commonly used design patterns in iOS development.
    We’ll do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 iOS 开发中常用的一些设计模式。我们将做以下几件事：
- en: Discuss **Model-View-Controller** (**MVC**) and MVVM, including some interview
    questions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论 **模型-视图-控制器**（**MVC**）和 MVVM，包括一些面试问题
- en: Decouple our code using DI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖注入解耦我们的代码
- en: Improve communication with delegation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代理改进通信
- en: Share a state with Singletons
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例共享状态
- en: Improve performance using Concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发改进性能
- en: One of the most commonly asked topics in interviews is the first on the list
    – MVC and MVVM. So, let’s dive right into it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面试中最常问的话题之一是列表中的第一个——MVC 和 MVVM。所以，让我们直接进入正题。
- en: Building a UI with MVC/MVVM
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MVC/MVVM 构建用户界面
- en: Several known design patterns can help us build stable and complex screens,
    but MVC and MVVM are the most common and famous patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几种已知的设计模式可以帮助我们构建稳定且复杂的界面，但 MVC 和 MVVM 是最常见和最著名的设计模式。
- en: Like many development areas, the topic of MVC and MVVM can be subject to personal
    preferences and opinions and may not always align with practical considerations.
    We always need to be careful with that, especially when interviewing for a job.
    Let me explain what I mean.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多开发领域一样，MVC 和 MVVM 的主题可能会受到个人偏好和观点的影响，并且可能并不总是与实际考虑相符。我们始终需要小心这一点，尤其是在求职面试时。让我解释一下我的意思。
- en: Solving different problems with MVC and MVVM
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MVC 和 MVVM 解决不同的问题
- en: 'I want to go over several sentences I suggest avoiding when having a professional
    discussion with an interviewer or even colleagues:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我想讨论一下在与面试官或同事进行专业讨论时建议避免的几个句子：
- en: “My app is built with MVVM architecture.”
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我的应用程序是使用 MVVM 架构构建的。”
- en: “MVC is antique and a horrible architecture. I never use it.”
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “MVC 是过时的，是一种糟糕的架构。我从不使用它。”
- en: “This is not how MVVM works. Let me show you.”
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “这不是 MVVM 的工作方式。让我给你演示一下。”
- en: Remember what I’ve said multiple times throughout the book – we should avoid
    dichotomous thinking as developers. MVC and MVVM solve different problems, and
    we should think of both patterns as different solutions to various issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我在书中多次提到的一点——作为开发者，我们应该避免二分法思考。MVC 和 MVVM 解决不同的问题，我们应该将这两种模式视为解决各种问题的不同方案。
- en: In fact, we can use different design patterns in the same app, in the same feature,
    or even on the same screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以在同一个应用程序、同一个功能或同一个界面上使用不同的设计模式。
- en: Additionally, there is more than one way to implement MVC and MVVM. What’s more
    important is to follow the different principles and explain them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实现 MVC 和 MVVM 的方法不止一种。更重要的是遵循不同的原则并解释它们。
- en: Let’s start with the more straightforward pattern – MVC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更直接的模式——MVC 开始。
- en: Learning MVC
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 MVC
- en: MVC stands for Model-View-Controller. When the iOS development era started,
    Apple used MVC to demonstrate best practices for building UI screens, and it was
    the primary design pattern for building apps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 代表模型-视图-控制器。当 iOS 开发时代开始时，苹果公司使用 MVC 来展示构建 UI 界面的最佳实践，并且它是构建应用程序的主要设计模式。
- en: The basic principle of MVC is a separation between the *View,* which is what
    the user sees and interacts with, and the *Model,* which represents the business
    logic and the data layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MVC的基本原则是在*视图*和*模型*之间进行分离，*视图*是用户所见并与之交互的部分，而*模型*则代表业务逻辑和数据层。
- en: In MVC, there’s no direct connection between the View and the Model, and all
    the data flow is done using the *Controller*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC中，视图和模型之间没有直接连接，所有数据流都是通过*控制器*完成的。
- en: 'Let’s have a look at a classic MVC pattern (*Figure 11**.1*):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个经典的MVC模式（*图11.1*）：
- en: '![Figure 11.1 – MVC design pattern](img/Figure_11.01_B18653.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – MVC设计模式](img/Figure_11.01_B18653.jpg)'
- en: Figure 11.1 – MVC design pattern
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – MVC设计模式
- en: In *Figure 11**.1*, we can see that the View and the Model communicate with
    each other using the controller. This separation allows us to reuse each component
    in different use cases across our project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.1*中，我们可以看到视图和模型通过控制器相互通信。这种分离使我们能够在项目的不同用例中重用每个组件。
- en: 'How can we implement MVC in the iOS world? Let’s see:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在iOS世界中实现MVC？让我们看看：
- en: '**View**: The View represents the UI displayed on the screen. Therefore, we
    typically implement it with one of the UIKit view elements, such as buttons, labels,
    and text fields (we’ll talk about SwiftUI in a second).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图代表屏幕上显示的UI。因此，我们通常使用UIKit视图元素之一来实现它，例如按钮、标签和文本字段（我们将在下一节中讨论SwiftUI）。'
- en: '**Model**: The Model is our data and business logic. We implement it using
    data structures, persistent storage, different algorithms, and network requests.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型是我们的数据和业务逻辑。我们使用数据结构、持久存储、不同的算法和网络请求来实现它。'
- en: '**Controller**: The controller in iOS development is mostly **UIViewController**
    and its different subclasses, such as **UITableViewController** and **UIAlertController**.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：在iOS开发中，控制器主要是**UIViewController**及其不同的子类，如**UITableViewController**和**UIAlertController**。'
- en: One thing to notice is how Apple implements the MVC pattern in iOS. `UIViewController`
    is not really a pure controller like we saw in *Figure 11**.1*. It has a view
    of its own and is responsible for user interaction. In a way, `UIViewController`
    is part of the UI, not just a controller.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意苹果如何在iOS中实现MVC模式。`UIViewController`并不像我们在*图11.1*中看到的那样是一个纯粹的控制器。它有自己的视图，并负责用户交互。从某种意义上说，`UIViewController`是UI的一部分，而不仅仅是控制器。
- en: Things are a little different with SwiftUI – the SwiftUI pattern resembles MVVM
    rather than MVC. We'll examine this more closely when we get to MVVM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在SwiftUI中，情况略有不同——SwiftUI的模式更类似于MVVM而不是MVC。当我们讨论到MVVM时，我们会更详细地考察这一点。
- en: 'Let’s see how to implement MVC in iOS. Here is the Model part:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在iOS中实现MVC。以下是模型部分：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Person` represents the data structure and has a logic function (`canVote()`).
    It doesn’t have any reference to the view or even to the controller.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`代表数据结构，并有一个逻辑函数（`canVote()`）。它没有任何对视图或控制器的引用。'
- en: 'And here’s the View:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是视图：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that the `PersonView` class has nothing to do with logic and focuses
    purely on UI presentation. This allows it to be reusable with other logic and
    models.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`PersonView`类与逻辑无关，纯粹关注UI展示。这使得它可以与其他逻辑和模型一起重用。
- en: Notice that `PersonView` has a `configure(with person:Person)` function. This
    common practice helps us load the view with a specific model. We can move this
    code to an extension and increase the code separation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`PersonView`有一个`configure(with person:Person)`函数。这种常见的做法有助于我们使用特定的模型来加载视图。我们可以将此代码移动到扩展中，以增加代码的分离。
- en: 'Now, let’s move on to the controller:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向控制器：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`PersonViewController` has a reference to both `Person` and `PersonView` and
    is responsible for linking between them and loading the view with data from `Person`.
    Notice that `PersonView` and `Person` don’t have a reference to each other – `PersonViewController`
    acts as the controller and sets up what is needed in the `viewDidLoad` function.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonViewController`对`Person`和`PersonView`都有引用，并负责在它们之间建立联系，并使用来自`Person`的数据加载视图。注意`PersonView`和`Person`之间没有引用——`PersonViewController`充当控制器，并在`viewDidLoad`函数中设置所需的内容。'
- en: Earlier, we discussed how MVC improves our code to make it reusable, as we can
    reuse the Model and View components. In iOS development, we should also consider
    MVC as a self-contained unit we can reuse.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了MVC如何改进我们的代码，使其可重用，因为我们可以在项目中重用模型和视图组件。在iOS开发中，我们还应该将MVC视为一个可以重用的自包含单元。
- en: 'For example, we can have a screen that is built upon two embedded view controllers,
    each one of which is an MVC unit. Look at *Figure 11**.2*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个基于两个嵌入式视图控制器（每个都是一个MVC单元）的屏幕。看看**图11.2**：
- en: '![Figure 11.2 – Two embedded MVC units](img/Figure_11.02_B18653.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 两个嵌入式MVC单元](img/Figure_11.02_B18653.jpg)'
- en: Figure 11.2 – Two embedded MVC units
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 两个嵌入式MVC单元
- en: An MVC unit doesn’t have to be a whole screen – this approach can help us reuse
    part of the screen and extend our project’s flexibility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MVC单元不一定要是一个完整的屏幕——这种方法可以帮助我们重用屏幕的一部分并扩展我们项目的灵活性。
- en: The MVC pattern is excellent for simple screens that don’t require complex state
    and data manipulation. In this case, we must move to a more complex pattern –
    MVVM.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式对于不需要复杂状态和数据操作的简单屏幕非常出色。在这种情况下，我们必须转向更复杂的模式——MVVM。
- en: Exploring MVVM
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索MVVM
- en: I believe this is a critical checkpoint in the chapter (and maybe even in the
    whole book). Developers tend to be attached to a specific pattern, especially
    related to the UI. MVVM is not “better” than “MVC” and vice versa. They are both
    patterns for different use cases, which is crucial to explain in an interview.
    We should never be tied to a specific technology or pattern, especially not in
    interviews.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是本章（也许甚至是整本书）的一个关键检查点。开发者往往对特定的模式有很强的依赖性，尤其是与UI相关的。MVVM并不比“MVC”更好，反之亦然。它们都是针对不同用例的模式，这在面试中至关重要。我们永远不应该被特定的技术或模式所束缚，尤其是在面试中。
- en: We said that MVC is not the best pattern for complex state and data management.
    But why?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过MVC不是复杂状态和数据管理的最佳模式。但为什么呢？
- en: Complex screens require state management – to show/hide certain UI elements,
    update text, change colors, and present dynamic information on the screen. All
    of this can make our view controller bloated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的屏幕需要状态管理——显示/隐藏某些UI元素、更新文本、更改颜色，并在屏幕上呈现动态信息。所有这些都可以使我们的视图控制器变得臃肿。
- en: That’s why iOS developers used to rely on MVC in the first era of the App Store
    but quickly moved on to a more suitable pattern – MVVM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么iOS开发者曾在App Store的第一个时代依赖MVC，但很快转向了更合适的模式——MVVM。
- en: MVVM stands for Model-View-ViewModel. The idea is that the View is connected
    to the Model using a **ViewModel** – another component that can help us manage
    the state and manipulate data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM代表模型-视图-视图模型。其理念是视图通过**视图模型**连接到模型——另一个可以帮助我们管理状态和操作数据的组件。
- en: 'Look at *Figure 11**.3*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**图11.3**：
- en: '![Figure 11.3 – The MVVM design pattern](img/Figure_11.03_B18653.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – MVVM设计模式](img/Figure_11.03_B18653.jpg)'
- en: Figure 11.3 – The MVVM design pattern
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – MVVM设计模式
- en: In *Figure 11**.3*, we can see that the ViewModel stands between the View and
    Model like the controller in the MVC pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图11.3**中，我们可以看到视图模型像MVC模式中的控制器一样位于视图和模型之间。
- en: But in MVVM, the responsibilities of the different components are much more
    transparent and intuiitive.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但在MVVM中，不同组件的责任更加透明和直观。
- en: 'Let’s go over the different components now:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下不同的组件：
- en: '**View**: The View is responsible for presenting the information and responding
    to user interaction. It’s the only component with access to the UIKit framework
    (we’ll talk about SwiftUI shortly), which is a significant difference from the
    MVC pattern we discussed earlier.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图负责展示信息和响应用户交互。它是唯一可以访问UIKit框架（我们很快会谈到SwiftUI）的组件，这与我们之前讨论的MVC模式有显著的不同。'
- en: '**ViewModel**: The ViewModel handles the state and prepares data for presentation.
    Also, the ViewModel decides on user interaction and moves the requests forward
    to the Model layer.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：视图模型处理状态并为展示准备数据。此外，视图模型决定用户交互并将请求向前推进到模型层。'
- en: '**Model**: The Model layer is the actual business logic and is responsible
    for accessing the persistent store and performing network requests.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型层是实际的业务逻辑，负责访问持久存储和执行网络请求。'
- en: Notice that the View and the ViewModel communicate using **data binding**, which
    connects the input field to the corresponding data model. In fact, the ViewModel
    doesn’t even have a reference to the view – the view observes changes in the ViewModel
    and refreshes itself accordingly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到视图（View）和视图模型（ViewModel）是通过**数据绑定**进行通信的，这连接了输入字段到对应的数据模型。实际上，视图模型甚至没有视图的引用——视图观察视图模型的变化并相应地刷新自己。
- en: That’s where SwiftUI and Combine come in handy. In SwiftUI, for example, the
    ViewModel is usually derived from the `@ObservableObject` class with `@``Published`
    properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SwiftUI和Combine派上用场的地方。例如，在SwiftUI中，ViewModel通常是从`@ObservableObject`类派生出来的，具有`@Published`属性。
- en: Forgot about SwiftUI and Combine?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记了SwiftUI和Combine？
- en: Now is a good time to return to [*Chapter 8*](B18653_08.xhtml#_idTextAnchor249)
    and refresh your memory regarding SwiftUI and Combine. It looks like Apple took
    a close look at how developers develop screens and built a dedicated framework
    for MVVM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回到[*第8章*](B18653_08.xhtml#_idTextAnchor249)并刷新一下关于SwiftUI和Combine的记忆。看起来苹果仔细研究了开发者如何开发屏幕，并为MVVM构建了一个专门的框架。
- en: Now, let’s see MVVM in practice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看MVVM的实际应用。
- en: Going over some code examples
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看一些代码示例
- en: Let’s see a code example of the MVVM design pattern. In our example, we have
    a screen with a label that shows the status of a loading request (**Loading…**,
    **Ready**, or **Error**). The label is bound to a specific ViewModel that communicates
    with the Model and updates its View.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看MVVM设计模式的代码示例。在我们的例子中，我们有一个带有标签的屏幕，该标签显示加载请求的状态（**加载中…**，**就绪**或**错误**）。标签绑定到一个特定的ViewModel，该ViewModel与Model通信并更新其视图。
- en: 'Let’s start with the ViewModel:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从ViewModel开始：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now, let’s observe the status change:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们观察状态变化：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code example is a bit long, yet simple to understand. The ViewModel observes
    a network request-response and updates its values using a Combine pattern. The
    combine stream starts with the network service and forwards the results to the
    `status` property, which can be observed by the view. Notice that the ViewModel
    doesn’t deal with any UI elements – that’s the View’s job.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例有点长，但很容易理解。ViewModel通过Combine模式观察网络请求-响应并更新其值。Combine流从网络服务开始，并将结果转发到`status`属性，该属性可以被视图观察。请注意，ViewModel不处理任何UI元素——那是视图的工作。
- en: 'Now, let’s see the View:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看视图：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `StatusLabel` class has a direct reference to the ViewModel, and it observes
    changes to refresh itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusLabel`类有一个对ViewModel的直接引用，并观察变化以刷新自己。'
- en: 'The only thing left to do is to connect the view with the ViewModel, and that’s
    the only job of the view controller in this case:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是将视图与ViewModel连接起来，这就是在这个情况下视图控制器唯一的工作：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ViewController` injects the ViewModel into the view and `NetworkService` into
    the ViewModel. Imagine doing that with MVC, with several components and complex
    data manipulation; you’d get 3,000 lines of code with a view controller.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewController`将ViewModel注入到视图中，将`NetworkService`注入到ViewModel中。想象一下在MVC中这样做，有多个组件和复杂的数据操作；你会得到一个包含3,000行代码的视图控制器。'
- en: MVVM is a modern design pattern compared to MVC and can help us separate our
    concerns more efficiently and handle much more complex state management and data
    manipulation. We can create a ViewModel for each view that we think needs one
    and organize our presentation logic however we want.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与MVC相比，MVVM是一种现代的设计模式，可以帮助我们更有效地分离关注点，并处理更复杂的状态管理和数据操作。我们可以为每个我们认为需要ViewModel的视图创建一个ViewModel，并按我们的意愿组织我们的展示逻辑。
- en: Now let’s move on to some questions about MVC/MVVM design patterns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论一些关于MVC/MVVM设计模式的问题。
- en: “How would you implement navigation in an MVVM architecture, considering that
    the ViewModel should not have knowledge of the View?”
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在MVVM架构中实现导航，考虑到ViewModel不应该了解视图？”
- en: '*Why is this* *question important?*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Learning MVVM is easy in theory. Binding ViewModel properties to UI elements
    is simple, but applying it to *real-world problems is the real challenge*. One
    of the most common real-world problems in iOS and mobile is navigation combined
    with state and logic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上学习MVVM很容易。将ViewModel属性绑定到UI元素是简单的，但将其应用于*现实世界问题才是真正的挑战*。iOS和移动开发中最常见的现实世界问题之一是导航与状态和逻辑的结合。
- en: What is the solution to the navigation problem when the ViewModel lacks a direct
    reference to the View and the View cannot handle navigation on its own?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当ViewModel缺乏对视图的直接引用，而视图又不能独立处理导航时，导航问题的解决方案是什么？
- en: '*What is* *the answer?*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'When discussing navigation, we need to decide on three things:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论导航时，我们需要决定三件事：
- en: How to *trigger* the navigation action
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何*触发*导航操作
- en: How to *choose* where to navigate
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何*选择*导航位置
- en: How to *navigate*
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何*导航*
- en: These are three different responsibilities that can be separated into various
    components. For example, we can decide that the ViewModel can trigger the navigation
    action and also choose where to go, while the View can handle the navigation action
    itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三种可以分离到各种组件中的不同责任。例如，我们可以决定ViewModel可以触发导航操作，并选择去哪里，而视图可以处理导航操作本身。
- en: Another option is to decide that the ViewModel triggers the navigation. Still,
    where to go can be part of the View or another object explicitly dedicated to
    that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是决定ViewModel触发导航。然而，去哪里可以是视图的一部分或另一个专门为此目的而明确创建的对象。
- en: 'Let’s look at *Figure 11**.4*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图11.4*：
- en: '![Figure 11.4 – Simple navigation pattern using MVVM](img/Figure_11.04_B18653.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 使用MVVM的简单导航模式](img/Figure_11.04_B18653.jpg)'
- en: Figure 11.4 – Simple navigation pattern using MVVM
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 使用MVVM的简单导航模式
- en: In *Figure 11**.4*, the ViewModel triggers the navigations and notifies the
    View using a delegate pattern or **Combine**. The View then asks the navigation
    controller to navigate to a specific destination, which is part of the reason
    view controllers have a reference to the navigation controller. This simple navigation
    pattern puts the navigation responsibility on the View.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.4*中，ViewModel通过委托模式或**Combine**触发导航并通知视图。然后视图请求导航控制器导航到特定的目的地，这也是视图控制器有导航控制器引用的部分原因。这种简单的导航模式将导航责任放在了视图上。
- en: 'Here’s how to implement that in code. This is what the ViewModel looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在代码中实现这一点。这是ViewModel的样子：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that the ViewModel has a `didTapButton()` method and decides to send
    a message using `navigationSubject`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到ViewModel有一个`didTapButton()`方法，并决定使用`navigationSubject`发送消息。
- en: 'Now, let’s go over the view controller:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下视图控制器：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The ViewModel navigation subject triggers the navigation according to its own
    logic, which in this case is tapping the button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel的导航主题根据其自己的逻辑触发导航，在这个例子中是点击按钮。
- en: '`ViewController` observes the ViewModel navigation publishers and pushes `detailsViewcontroller`
    using the navigation controller.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewController`观察ViewModel的导航发布者，并使用导航控制器推送`detailsViewcontroller`。'
- en: 'As mentioned, this pattern is simple and puts a lot of responsibility on the
    view controller. If we want to separate our code, we can delegate the navigation
    responsibility to another class (**Coordinator**). See *Figure 11**.5*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个模式很简单，将很多责任放在了视图控制器上。如果我们想分离我们的代码，我们可以将导航责任委托给另一个类（**Coordinator**）。参见*图11.5*：
- en: '![Figure 11.5 – MVVM and coordinator pattern](img/Figure_11.05_B18653.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – MVVM和协调器模式](img/Figure_11.05_B18653.jpg)'
- en: Figure 11.5 – MVVM and coordinator pattern
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – MVVM和协调器模式
- en: 'In the coordinator pattern, the ViewModel notifies the coordinator about a
    navigation intent, which pushes a new screen. See how the ViewModel looks now:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调器模式中，ViewModel通知协调器关于一个导航意图，从而推送一个新的屏幕。看看ViewModel现在是什么样子：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The ViewModel sends a message with the button tap, and the coordinator can
    subscribe to it and respond. This is what the coordinator looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel发送一个带有按钮点击的消息，协调器可以订阅它并做出响应。这是协调器的样子：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that the coordinator creates the ViewModel and the view, then wires
    everything together. In the previous example, the view controller observed the
    ViewModel events and pushed a new view controller. Similarly, in this case, the
    coordinator observes `didTapButtonPublisher` and decides to push a new view controller
    – `DetailsViewController`. The view and ViewModel are unaware of this transition
    as it is managed entirely by the coordinator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到协调器创建了ViewModel和视图，然后将一切连接起来。在前面的例子中，视图控制器观察ViewModel事件并推送一个新的视图控制器。同样，在这种情况下，协调器观察`didTapButtonPublisher`并决定推送一个新的视图控制器
    – `DetailsViewController`。视图和ViewModel对这个过渡一无所知，因为它完全由协调器管理。
- en: In general, both ways have their pros and cons. Using a coordinator is a powerful
    and complex pattern. Still, there is little overhead for simpler cases, where
    we can connect the navigation controller to the view controller. What’s important
    is to understand the navigation principles and balance the responsibilities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，两种方式都有其优缺点。使用协调器是一个强大且复杂的模式。然而，对于更简单的情况，我们可以将导航控制器连接到视图控制器，这样开销很小。重要的是要理解导航原则并平衡责任。
- en: “Why is the MVVM architecture considered good for testability in iOS app development?”
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “为什么MVVM架构被认为在iOS应用开发中具有良好的可测试性？”
- en: '*Why is this* *question important?*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: When designing code, tests have become increasingly important in recent years.
    It’s not just about being able to test the code but also about writing high-quality
    code that is well structured and easy to maintain. With this in mind, the interviewer
    wants us to consider the importance of writing testable code in our response.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在近年来设计代码时，测试变得越来越重要。这不仅仅是能够测试代码，还关于编写高质量、结构良好且易于维护的代码。考虑到这一点，面试官希望我们在回答中考虑编写可测试代码的重要性。
- en: '*What is* *the answer?*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The MVVM design pattern is suitable for testing because it separates the concerns
    in an easy way. The state and the data manipulation code, which is the most important
    part we want to test, is part of the ViewModel. We can set up the ViewModel easily
    without handling the UI and simply test it by mocking the View.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 设计模式适合测试，因为它以简单的方式分离了关注点。状态和数据操作代码，这是我们想要测试的最重要部分，是 ViewModel 的一部分。我们可以轻松设置
    ViewModel，无需处理 UI，只需通过模拟 View 进行测试。
- en: We can also test an MVC unit, but since the state management is part of the
    View Controller or the View, it is more complex than testing an MVVM pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试 MVC 单元，但由于状态管理是 View Controller 或 View 的一部分，所以它比测试 MVVM 模式更复杂。
- en: 'Here’s a code example of how to test a ViewModel. Let’s start with defining
    a standard ViewModel:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何测试 ViewModel 的代码示例。让我们从定义一个标准的 ViewModel 开始：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We created a ViewModel that handles a tap button and updates a label. Notice
    that there is no UIKit-related code here, so it should be reasonably easy to test.
    Now, let’s see the test itself:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个处理点击按钮并更新标签的 ViewModel。注意，这里没有 UIKit 相关的代码，所以它应该相对容易测试。现在，让我们看看测试本身：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `testLabelValue()` function observes the ViewModel’s `labelValue` to see
    whether it equals `"Ready"` when tapping the button. We did all that without setting
    up the View, which only handles UI logic in this case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`testLabelValue()` 函数观察 ViewModel 的 `labelValue`，以查看在点击按钮时它是否等于 `"Ready"`。我们没有设置
    View 就完成了所有这些，在这种情况下，View 只处理 UI 逻辑。'
- en: Decoupling with Dependency Injection
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入解耦
- en: DI is a powerful pattern that helps us to create modular and testable code.
    It’s another tool in our toolbox that can help us make our code flexible and decoupled.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是一种强大的模式，帮助我们创建模块化和可测试的代码。它是我们工具箱中的另一个工具，可以帮助我们使代码灵活且解耦。
- en: There are several ways to implement DI in iOS, which are discussed next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中实现依赖注入（DI）有几种方法，接下来将进行讨论。
- en: Using constructor injection
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数注入
- en: This is the most common form of DI in iOS. In constructor injection, dependencies
    are passed into an object through its initializer. For example, if we have a view
    controller that depends on a data manager, we can inject the data manager into
    the view controller’s initializer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 iOS 中最常用的 DI 形式。在构造函数注入中，依赖项通过初始化器传递给对象。例如，如果我们有一个依赖于数据管理器的视图控制器，我们可以在视图控制器的初始化器中注入数据管理器。
- en: 'In the following code example, we created a custom `init()` function and a
    private variable to hold the injected data manager:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们创建了一个自定义的 `init()` 函数和一个私有变量来保存注入的数据管理器：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main advantage of constructor DI is that we have a clear interface with
    the required dependencies for the class, as we must pass them in our `init()`
    method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数 DI 的主要优势是我们有一个清晰的接口，用于类所需的依赖项，因为我们必须在 `init()` 方法中传递它们。
- en: Simplifying things with setter injection
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设置器注入简化事情
- en: In setter injection, setter methods pass dependencies into the object. The object
    declares its dependencies as public properties, and the DI framework sets those
    properties with the appropriate dependencies. Setter injection is less common
    than constructor injection but can be helpful when changing the object’s dependencies
    at runtime.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置器注入中，设置器方法将依赖项传递给对象。对象将其依赖项声明为公共属性，DI 框架使用适当的依赖项设置这些属性。设置器注入不如构造函数注入常见，但在运行时更改对象的依赖项时可能很有帮助。
- en: 'Here’s a code example of setter injection:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个设置器注入的代码示例：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we haven’t changed the `init` function of the view controller.
    After we created the view controller, we passed `dataManager` using the built-in
    setter property method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有更改视图控制器的 `init` 函数。在创建视图控制器后，我们使用内置的设置器属性方法传递了 `dataManager`。
- en: The primary advantage of using setter injection is simplicity; we don’t have
    to modify the `init` function and decoupling. On the other hand, this approach
    is not suitable for the required dependencies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设置器注入的主要优点是简单性；我们不需要修改 `init` 函数和解耦。另一方面，这种方法不适合所需的依赖项。
- en: Using pure functions with method injection
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法注入的纯函数
- en: In method injection, dependencies are passed into an object’s methods as parameters.
    This is similar to constructor injection but allows for more fine-grained control
    over when and how dependencies are injected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法注入中，依赖项作为参数传递给对象的函数。这与构造函数注入类似，但允许对何时以及如何注入依赖项有更精细的控制。
- en: 'The `fetchData()` method is an example of a pure function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchData()` 方法是一个纯函数的例子：'
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code example, we have the same view controller and data manager, but
    this time we don’t have an instance variable for the data manager. We pass the
    data manager as part of the `fetchData` method and make the function pure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们拥有相同的视图控制器和数据管理器，但这次我们没有为数据管理器创建实例变量。我们将数据管理器作为 `fetchData` 方法的部分传入，从而使函数成为纯函数。
- en: What is a pure function?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是纯函数？
- en: A pure function is a function that does not rely on instance variables or any
    state outside of its scope and only operates on its input parameters. It produces
    the same output for the same input and has no side effects on the program or environment.
    A pure function can rely on method injection to use external dependencies, where
    dependencies are passed in as parameters rather than depending on global or instance
    variables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个不依赖于实例变量或其作用域之外的任何状态，并且只操作其输入参数的函数。它对相同的输入产生相同的输出，并且对程序或环境没有副作用。纯函数可以依赖方法注入来使用外部依赖，其中依赖项作为参数传入，而不是依赖于全局或实例变量。
- en: Method injection is excellent for testability as it increases the decoupling
    of the class from the dependency. It also decouples the class from the method
    (that’s part of the “pure” definition we discussed), but it also requires our
    method signatures to be more complex and manage states outside the class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方法注入对于可测试性非常好，因为它增加了类与依赖项的解耦。它还使类与方法（这是我们讨论的“纯”定义的一部分）解耦，但它也要求我们的方法签名更复杂，并管理类外部的状态。
- en: These three ways of DI are great to improve decoupling and testability. But
    we can make all these ways much more decoupled. How? Easily, using protocols.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种依赖注入（DI）的方式都非常有助于提高解耦和可测试性。但我们可以使所有这些方式更加解耦。如何？简单，使用协议。
- en: Decoupling our code using protocols
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用协议解耦我们的代码
- en: We discussed protocols in [*Chapter 5*](B18653_05.xhtml#_idTextAnchor163) when
    we talked about the Swift language features. Protocols play a significant role
    in design patterns, especially in DI.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 Swift 语言特性时，我们在 [*第5章*](B18653_05.xhtml#_idTextAnchor163) 中讨论了协议。协议在设计模式中扮演着重要的角色，尤其是在依赖注入（DI）中。
- en: We can inject different objects with different behavior using protocols as long
    as they conform to the protocol interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它们符合协议接口，我们可以使用协议注入具有不同行为的不同对象。
- en: 'Here’s an example of using a protocol to inject a different object with a different
    implementation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用协议注入具有不同实现的不同对象的例子：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we have two instances of `MyViewController`. We inject `concreteDataManager`,
    an instance of the `DataManager` protocol, into the first instance, and we inject
    `otherDataManager`, another instance of the `DataManager` protocol, into the second
    `MyViewController` instance. They both have the same interface but different implementations.
    In this case, they return other elements in their `fetchData()` method. This technique
    allows us to inject whatever implementation we want with any object. It is especially
    powerful with testing and helps us to use mocks in our code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有 `MyViewController` 的两个实例。我们将 `concreteDataManager`，`DataManager`
    协议的一个实例，注入到第一个实例中，并将 `otherDataManager`，另一个 `DataManager` 协议的实例，注入到第二个 `MyViewController`
    实例中。它们具有相同的接口但不同的实现。在这种情况下，它们在 `fetchData()` 方法中返回不同的元素。这种技术使我们能够通过任何对象注入我们想要的任何实现。这对于测试特别强大，它帮助我们使用代码中的模拟。
- en: To summarize DI, we can pick any pattern we want out of the three I mentioned
    – constructor, setter, or method – and expand its capabilities with a protocol.
    It all depends on the level of simplicity and coupling we want.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总结依赖注入（DI），我们可以从提到的三种模式中选择任何一种——构造函数、设置器或方法——并使用协议扩展其功能。这完全取决于我们想要的简单性和耦合程度。
- en: Communicating using delegation
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理进行通信
- en: Delegation is a simple pattern that allows objects to communicate with each
    other in a loosely coupled interface. Delegation is also based on a protocol that
    allows classes to communicate with different types of objects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是一种简单的模式，它允许对象通过松散耦合的接口相互通信。委托还基于一种协议，允许类与不同类型的对象进行通信。
- en: 'Let’s see a small example of delegation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个关于委托的小例子：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `MyViewController` class has a view named `MyView` and conforms to a protocol
    named `MyViewDelegate`. This protocol has a method called `didTapButton()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyViewController` 类有一个名为 `MyView` 的视图，并遵循一个名为 `MyViewDelegate` 的协议。这个协议有一个名为
    `didTapButton()` 的方法。'
- en: '`MyView` needs to communicate with `MyViewController` but doesn’t have a direct
    reference. Instead, it has a delegate property of the `MyViewDelegate` type. This
    delegate property creates a loosely coupled interface between the view and its
    view controller (its “delegate”).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyView` 需要与 `MyViewController` 进行通信，但它没有直接的引用。相反，它有一个 `MyViewDelegate` 类型的委托属性。这个委托属性在视图和它的视图控制器（它的“委托”）之间创建了一个松散耦合的接口。'
- en: 'Here are two takeaways from this code sample:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码示例中，我们可以得到以下两点体会：
- en: '*We need to create a delegate property*: The object that communicates with
    the delegate needs to have a delegate property, and the delegate property is obtained
    from the type of the protocol we just declared. This ensures a loosely coupled
    relationship; every object can conform to that protocol, even mocks for testing
    purposes.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们需要创建一个委托属性*：与委托进行通信的对象需要有一个委托属性，而这个委托属性是从我们刚才声明的协议类型中获得的。这确保了一个松散耦合的关系；每个对象都可以遵循那个协议，即使是用于测试的模拟对象。'
- en: '*We must mark the delegate as weak*: This is a critical point. Based on our
    code, the view controller has a strong reference to the view, and the view has
    a reference to the view controller through the delegate property. This means that
    the delegate property must be weak, and that’s a common mistake many developers
    make. In fact, the weak reference to the delegate property is a common topic in
    interviews, and we should remember that when asked about it.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们必须将委托标记为弱引用*：这是一个关键点。根据我们的代码，视图控制器对视图有一个强引用，而视图通过委托属性对视图控制器有一个引用。这意味着委托属性必须是弱引用，这是许多开发者常见的错误。事实上，对委托属性的弱引用是面试中的常见话题，我们应该记住这一点。'
- en: Even though delegation is a widely used pattern, it has some drawbacks compared
    to modern patterns such as Combine, and many developers consider it a little bit
    outdated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管委托是一个广泛使用的模式，但与Combine等现代模式相比，它有一些缺点，许多开发者认为它有点过时。
- en: To begin with, when using delegation to pass a message between multiple objects,
    the code can become cumbersome and difficult to read. This is especially true
    when each object must act as the delegate of the previous object, as it requires
    the creation of multiple protocols and delegates properties. As a result, the
    code can become boilerplate and challenging to follow and maintain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当使用委托在多个对象之间传递消息时，代码可能会变得繁琐且难以阅读。这尤其适用于每个对象都必须作为前一个对象的委托，因为它需要创建多个协议和委托属性。结果，代码可能会变得像样板代码一样，难以跟随和维护。
- en: Creating protocols can decrease our coupling, but our delegate must conform
    to a specific interface. With reactive programming, the subscriber observes updates
    without being tied to a particular interface, making the communication even more
    loosely coupled.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建协议可以减少我们的耦合度，但我们的委托必须遵循一个特定的接口。在响应式编程中，订阅者观察更新而不被绑定到特定的接口，这使得通信更加松散耦合。
- en: So, what can be a reason to choose delegation over Combine? With delegation,
    we can define a clear interface and even a complex one, which is not always true
    with Combine. But more than that – delegation clearly separates concerns and helps
    us keep our code modular and easy to maintain.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，选择委托而不是Combine的原因可能是什么？使用委托，我们可以定义一个清晰的接口，甚至是一个复杂的接口，这在Combine中并不总是成立。但不仅如此——委托明确地分离了关注点，帮助我们保持代码模块化和易于维护。
- en: Let’s go over a common interview question about the delegate design pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个关于委托设计模式的常见面试问题。
- en: “How does the delegation pattern differ from other communication patterns, such
    as notifications or closures, in Swift?”
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “在Swift中，委托模式与其他通信模式，如通知或闭包，有何不同？”
- en: '*Why is this* *question important?*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: A delegate design pattern is just one way for an object to communicate with
    another object. Over the years, new ways of communication have been added – notifications,
    closures, and, of course, reactive approaches such as Combine and RxSwift.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 委托设计模式只是对象之间通信的一种方式。多年来，已经添加了新的通信方式——通知、闭包，当然还有 Combine 和 RxSwift 这样的响应式方法。
- en: Each of these options has its pros and cons and we should match the pattern
    to the problem we are trying to solve. Therefore, it is important to understand
    the practical differences between these options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有其优缺点，我们应该将模式与我们要解决的问题相匹配。因此，了解这些选项之间的实际差异非常重要。
- en: '*What is* *the answer?*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'The delegate design pattern is different from notifications, closures, and
    Combine in several key ways:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个关键方面，委托设计模式与通知、闭包和 Combine 不同：
- en: '*One-to-one communication relationship*: While the notifications pattern and
    a Combine publisher can send a message to an unlimited number of instances, the
    delegate pattern typically communicates with a single object. This might initially
    seem like a disadvantage, but it also simplifies complex situations where we need
    more control over our code coupling.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一对一通信关系*：虽然通知模式和 Combine 发布者可以向无限数量的实例发送消息，但委托模式通常与单个对象进行通信。这最初可能看起来像是一个缺点，但它也简化了需要更多控制代码耦合的复杂情况。'
- en: '*Formalized protocol*: In a delegate pattern, there’s a clear interface to
    work with the delegate, thanks to the use of protocols. The protocol formalizes
    the communication and provides clear expectations for both the delegate and the
    owner. This is extremely important when the communication becomes complex – for
    example, several functions to implement with multiple parameters.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*形式化协议*：在委托模式中，由于使用了协议，与委托一起工作的接口是清晰的。协议形式化了通信，并为委托和所有者提供了明确的期望。当通信变得复杂时，这一点尤为重要——例如，需要实现多个参数的多个函数。'
- en: '*More complex to set up*: Using the delegate pattern becomes more complex to
    set up when we want to pass a value or an event between different layers and components
    of our app. But it’s not just the setup – following the data flow becomes cumbersome,
    as you have to jump between one protocol implementation and another. It’s another
    example of a flexibility versus simplicity use case.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更复杂设置*：当我们想在应用程序的不同层和组件之间传递值或事件时，使用委托模式变得更复杂。但这不仅仅是设置——跟踪数据流变得繁琐，因为你必须在不同协议实现之间跳转。这是灵活性与简单性用例的另一个例子。'
- en: Overall, the delegate pattern is great for certain use cases and choosing the
    right communication option depends on the specific requirements of our problem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，委托模式对于某些用例来说非常好，选择正确的通信选项取决于我们问题的具体要求。
- en: As for interview questions, especially related to design patterns, we must remember
    that “better” relies on the context.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 至于面试问题，特别是与设计模式相关的问题，我们必须记住，“更好”取决于上下文。
- en: I think the next topic describes that perfectly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为下一个主题完美地描述了这一点。
- en: Sharing a state using Singleton
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Singleton 共享状态
- en: 'There are two questions that interviewers love to ask:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官喜欢问的两个问题是：
- en: “How do we create a Singleton?”
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我们如何创建一个 Singleton？”
- en: “Is it good to have singletons in our app?”
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在我们的应用程序中拥有单例是否好？”
- en: The first question is technical, but the second one is tricky.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题很技术性，但第二个问题很棘手。
- en: Let’s start with the definition of a Singleton.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Singleton 的定义开始。
- en: What is a Singleton?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Singleton？
- en: In the Singleton design pattern, there is only one instance of a class that
    can be globally accessed through a **static** property. It is often used to manage
    shared resources or states in a program where multiple instances could cause issues
    with synchronization or consistency. To implement a Singleton, a class typically
    has a private constructor and a static method or property that returns the single
    instance of the class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Singleton 设计模式中，只有一个类的实例可以被全局访问，通过一个 **静态** 属性。它通常用于管理程序中的共享资源或状态，其中多个实例可能导致同步或一致性方面的问题。为了实现
    Singleton，一个类通常有一个私有的构造函数和一个静态方法或属性，它返回类的单个实例。
- en: 'In Swift, it is simple to create a Singleton. We use a static property for
    that task:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，创建 Singleton 很简单。我们使用静态属性来完成这项任务：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the Singleton is defined with one line only:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Singleton 只用一行定义：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The critical thing is to always access the Singleton using the `shared` property,
    as seen in the preceding code example. To prevent creating another instance of
    the `MySingleton` class, we can mark the `init()` method as private and ensure
    there is only one instance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要始终使用`shared`属性来访问单例，正如前一个代码示例中所示。为了防止创建`MySingleton`类的另一个实例，我们可以将`init()`方法标记为私有，并确保只有一个实例。
- en: But that was the easy question. The real question is – should we use a Singleton
    in our projects? Is it considered a legit pattern or an anti-pattern?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但那只是一个简单的问题。真正的问题是——我们应该在我们的项目中使用单例吗？它被认为是合法的模式还是反模式？
- en: 'There are a couple of reasons why a Singleton can be an anti-pattern for many
    developers. Let’s discuss some of them:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明为什么单例对于许多开发者来说可能是一个反模式。让我们讨论其中的一些：
- en: '*Having a global state*: Singletons provide a global state for the app, and
    multiple app components can manipulate this global state. As a result, it can
    be hard to track down where and when these changes are made. In a way, the main
    problem of having a global state that can be accessed from everywhere in the code,
    is when the app gets more extensive.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拥有全局状态*：单例为应用提供了一个全局状态，多个应用组件可以操作这个全局状态。结果，很难追踪到这些更改是在哪里和什么时候进行的。从某种意义上说，当应用变得更大时，可以从代码的任何地方访问的全局状态的主要问题。'
- en: '*Coupling increasing*: We build a modular app with great code separations.
    But once our different app components access a shared instance (aka Singleton),
    the coupling between these components increases. Tight coupling becomes more of
    a concern as the number of Singletons in a program increases.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*耦合增加*：我们构建了一个模块化应用，代码分离做得很好。但一旦我们的不同应用组件访问共享实例（即单例），这些组件之间的耦合就会增加。随着程序中单例数量的增加，紧密耦合成为一个更大的问题。'
- en: '*Challenge multithreading*: Because the Singleton can be accessed from everywhere,
    it also means that we can modify and read values from a shared instance from different
    threads. This can lead to race conditions and other synchronization issues.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多线程挑战*：因为单例可以从任何地方访问，这也意味着我们可以从不同的线程修改和读取共享实例的值。这可能导致竞态条件和其他同步问题。'
- en: So, what is the answer? Well, there are cases where having a Singleton is perfectly
    legit. For example, there should be only one instance of a particular object in
    the app – a configuration manager or database connection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，答案是什么呢？嗯，有些情况下拥有一个单例（Singleton）是完全合法的。例如，在应用中应该只有一个特定对象的实例——比如配置管理器或数据库连接。
- en: But we should try to avoid using a Singleton whenever possible. How? Let’s answer
    that with an interview question.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们应该尽可能避免使用单例。怎么做？让我们用一个面试问题来回答。
- en: “How would you avoid using a Singleton in your code? Can you describe some of
    the alternative approaches you might consider?”
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你将如何在代码中避免使用单例？你能描述一些你可能考虑的替代方法吗？”
- en: '*Why is this* *question important?*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: At this point, we should already be familiar with the different design patterns
    and can come up with a suitable alternative. And that’s the goal of the question
    – to test the ability to take your experience and knowledge and provide a good,
    acceptable solution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，我们应该已经熟悉了不同的设计模式，并且可以提出一个合适的替代方案。这正是问题的目标——测试你将经验和知识转化为良好、可接受解决方案的能力。
- en: If finding an alternative is possible, the general guideline regarding Singletons
    is to avoid them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到替代方案是可能的，关于单例的一般性指导原则是避免使用它们。
- en: '*What is* *the answer?*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The most common way to avoid a Singleton is using DI to inject services used
    within the class or the function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 避免单例最常见的方法是使用依赖注入（DI）来注入类或函数内部使用的服务。
- en: 'Instead of creating a static constant (Singleton), we can approach the `Service`
    instance from the `Client` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不创建一个静态常量（单例），而是从`Client`类来处理`Service`实例：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can create an instance and inject it into the `Client` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个实例并将其注入到`Client`类中：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If a global state is not required, injecting a new instance (or passing an existing
    instance) instead of using a Singleton is better.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要全局状态，注入一个新的实例（或传递现有的实例）而不是使用单例会更好。
- en: 'We can improve that example by converting `Service` into a protocol:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Service`转换为协议来改进这个例子：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that `Service` is a protocol, it makes our coupling even looser. That’s
    a nice code modification we can make.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`Service`是一个协议，这使得我们的耦合更加松散。这是一个很好的代码修改，我们可以进行。
- en: “Can you describe the potential issues with using Singletons in a multithreaded
    environment, and how can these be addressed?”
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能描述一下在多线程环境中使用单例可能遇到的问题，以及如何解决这些问题吗？”
- en: '*Why is this* *question important?*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: We briefly mentioned multi-threading issues when we discussed Singleton’s disadvantages
    earlier in this section. A Singleton is a shared resource, and as such, we must
    understand how it fits in a multithreaded environment.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前在本节中讨论单例的缺点时，我们简要提到了多线程问题。单例是一个共享资源，因此我们必须了解它在多线程环境中的位置。
- en: '*What is* *the answer?*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Here are some of the potential issues we can encounter with Singleton in a
    multithreaded environment:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，我们可能会遇到与单例相关的以下潜在问题：
- en: '*Having race conditions*: If multiple threads try to access and modify the
    same Singleton instance simultaneously, it can result in race conditions that
    can cause unpredictable behavior and data corruption'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*出现竞态条件*：如果有多个线程同时尝试访问和修改同一个单例实例，可能会导致竞态条件，这可能导致不可预测的行为和数据损坏'
- en: '*Encountering deadlocks*: If multiple threads try to access a Singleton instance
    in a different order, it can lead to deadlocks where one thread waits for another
    to release a lock on the Singleton'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遇到死锁*：如果有多个线程以不同的顺序尝试访问单例实例，可能会导致死锁，其中一个线程等待另一个线程释放对单例的锁'
- en: '*Having an inconsistent state*: If a Singleton instance is modified by one
    thread while another thread is reading or using it, it can result in an unstable
    state and unexpected behavior'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态不一致*：如果一个单例实例被一个线程修改，而另一个线程正在读取或使用它，可能会导致不稳定的状态和意外的行为'
- en: As developers, unpredictable behavior is one of the most challenging things
    to encounter, making debugging and investigation more difficult.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，不可预测的行为是我们遇到的最具挑战性的问题之一，这使得调试和调查变得更加困难。
- en: 'The simplest solution is to assume the Singleton is not a thread-safe object
    and can be accessed only from the same thread. Take the following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是假设单例不是一个线程安全的对象，并且只能从同一个线程访问。以下是一个示例：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we assume the Singleton can only be accessed from the main
    thread. We’re using the **Grand Central Dispatch** (**GCD**) API to move to the
    main thread to ensure the Singleton is always accessed from the main thread.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设单例只能从主线程访问。我们使用**Grand Central Dispatch**（**GCD**）API 转移到主线程，以确保单例总是从主线程访问。
- en: 'Another option is to make the Singleton a thread-safe object by locking access
    using **NSLock**:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将单例变成线程安全的对象，通过使用**NSLock**来锁定访问：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we make the shared instance a private property and add a static
    method that ensures locking and unlocking before returning the Singleton instance.
    This is a common practice to lock an object and make it thread-safe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将共享实例作为一个私有属性，并添加一个静态方法，确保在返回单例实例之前进行锁定和解锁。这是一种常见的做法，用于锁定对象并使其线程安全。
- en: To summarize the topic – there is an ongoing debate and discussion in the iOS
    developer community. Some developers find Singleton a helpful tool that simplifies
    sharing states and resources, while others see Singleton as an anti-pattern that
    has the potential to cause problems. The truth, as always, is somewhere in the
    middle.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这个话题——在 iOS 开发者社区中有一个持续的辩论和讨论。一些开发者认为单例是一个有用的工具，可以简化状态和资源的共享，而另一些开发者则认为单例是一个可能导致问题的反模式。事实，就像往常一样，介于两者之间。
- en: Improving performance with Concurrency
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发提高性能
- en: Concurrency is a complex computer science topic, not only in iOS development.
    A bad design can lead to crashes, race conditions, deadlocks, and lags.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个复杂的计算机科学话题，不仅在 iOS 开发中。糟糕的设计可能导致崩溃、竞态条件、死锁和延迟。
- en: But don’t worry – do you remember what we said about design patterns in this
    chapter’s introduction? They are here to solve our problems. So, let’s review
    some of the design patterns and best practices for concurrency to see what tools
    we can add to our toolbox.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心——你还记得我们在本章引言中提到的设计模式吗？它们就是为了解决我们的问题而存在的。所以，让我们回顾一些关于并发的设计模式和最佳实践，看看我们可以添加哪些工具到我们的工具箱中。
- en: Working with GCD
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GCD
- en: GCD is a powerful concurrency framework that enables the efficient and scalable
    execution of tasks. GCD provides a simple way to create queues of tasks and schedule
    them for execution without managing threads manually. This makes it easy to write
    efficient and responsive code that takes full advantage of the available system
    resources.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 是一个强大的并发框架，它能够高效且可扩展地执行任务。GCD 提供了一种简单的方法来创建任务队列并安排它们执行，而无需手动管理线程。这使得编写高效且响应迅速的代码变得容易，可以充分利用系统资源。
- en: 'Here is an example of how to use GCD to download an image asynchronously in
    the background:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何使用 GCD 在后台异步下载图像的例子：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we define a function, `downloadImage`, which takes a URL and
    a completion handler as parameters. The function creates a global background queue
    using the `DispatchQueue.global` method and then calls the async method to add
    a task to the queue. The task downloads the image data from the URL, converts
    it into a an image, and then calls the completion handler with the result. Because
    the task is executed asynchronously in the background, it does not block the main
    thread and allows the app to remain responsive.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个函数 `downloadImage`，它接受一个 URL 和一个完成处理程序作为参数。该函数使用 `DispatchQueue.global`
    方法创建一个全局后台队列，然后调用异步方法将任务添加到队列中。任务从 URL 下载图像数据，将其转换为图像，然后使用结果调用完成处理程序。因为任务在后台异步执行，所以它不会阻塞主线程，并允许应用程序保持响应。
- en: Creating advanced queues with OperationQueue
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OperationQueue 创建高级队列
- en: An operation queue is a higher-level concurrency mechanism that manages tasks
    and executes them concurrently, like the GCD API we just discussed. **OperationQueue**
    provides advanced features and a simple interface for managing queues.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 操作队列是一个高级并发机制，它管理任务并发执行，就像我们刚才讨论的 GCD API 一样。**OperationQueue** 提供了高级功能和简单的接口来管理队列。
- en: The basic unit of `OperationQueue` is `Operation`, which can perform a specific
    task. The operation queue’s job is to take an operation and perform it simultaneously
    or one after the other.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationQueue` 的基本单位是 `Operation`，它可以执行特定的任务。操作队列的任务是取一个操作并执行它，可以同时执行或依次执行。'
- en: We simply subclass the `Operation` class and implement the `main()` function
    to create an operation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需继承 `Operation` 类并实现 `main()` 函数来创建一个操作。
- en: 'Here’s an example of how to download multiple images using Operation Queue:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 Operation Queue 下载多个图像的例子：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we subclassed `Operation` by creating the `ImageDownloadOperation`
    class, which has a `url` property and performs a download operation in its main
    method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过创建 `ImageDownloadOperation` 类来继承 `Operation`，该类有一个 `url` 属性并在其主方法中执行下载操作。
- en: Right after that, we create an operation queue called `queue` and an array of
    download operations. We add the operations array to our created queue and collect
    them by calling the `result` property.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们创建了一个名为 `queue` 的操作队列和一个下载操作数组。我们将操作数组添加到我们创建的队列中，并通过调用 `result` 属性来收集它们。
- en: 'One of Operation Queue’s best features is the ability to configure how it works.
    If we want the queue to perform a maximum of three operations at the same time,
    we can set its `maxConcurrentOperationCount` value:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Operation Queue 的最佳特性之一是能够配置其工作方式。如果我们想使队列同时执行最多三个操作，我们可以设置其 `maxConcurrentOperationCount`
    的值：
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we set that property to `1`, our queue will perform the operations one after
    the other.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将该属性设置为 `1`，我们的队列将依次执行操作。
- en: Another exciting option is *adding dependencies between the queue operations*
    – we can define that a specific operation cannot start before another operation
    ends.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人兴奋的选项是 *在队列操作之间添加依赖关系* - 我们可以定义一个特定的操作在另一个操作结束之前不能开始。
- en: 'Here’s an example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, `downloadOp2` cannot start before `downloadOp1` ends.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`downloadOp2` 在 `downloadOp1` 结束之前无法开始。
- en: Operation Queue generally provides advanced capabilities and patterns to perform
    complex background operations with more control.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Operation Queue 通常提供高级功能和模式，以更精细地执行复杂的后台操作。
- en: Blocking threads with NSLock
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NSLock 阻塞线程
- en: '`NSLock` is a synchronization mechanism for managing access to shared resources
    in a multi-threaded environment. `NSLock` provides a simple way to block threads
    that attempt to access a locked resource, allowing only one thread to access the
    resource at a time.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSLock` 是一个用于在多线程环境中管理对共享资源访问的同步机制。`NSLock` 提供了一种简单的方法来阻塞尝试访问已锁定资源的线程，允许一次只有一个线程访问资源。'
- en: 'Here’s an example of how to use `NSLock` to protect a shared resource:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何使用 `NSLock` 来保护共享资源的示例：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s assume that `SharedResource` can be used in different threads. This can
    cause race conditions and deadlocks in trying to access and modify the `count`
    variable simultaneously.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `SharedResource` 可以在不同的线程中使用。这可能导致在尝试同时访问和修改 `count` 变量时出现竞态条件和死锁。
- en: To handle that, we “lock” the read and write access with `NSLock` – we call
    `lock()` before the read/write operation and release it by calling `unlock()`
    afterward.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们使用 `NSLock` “锁定”读取和写入访问权限——我们在读取/写入操作之前调用 `lock()`，并在之后通过调用 `unlock()`
    释放它。
- en: Using the Combine Future publisher to implement async operations
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Combine `Future` 发布者实现异步操作
- en: We already discussed Combine earlier in [*Chapter 8*](B18653_08.xhtml#_idTextAnchor249),
    but now let’s discuss integrating async operations into the Combine stream.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论了 Combine [*第 8 章*](B18653_08.xhtml#_idTextAnchor249)，但现在让我们讨论如何将异步操作集成到
    Combine 流中。
- en: The `Future` publisher for any action whose value is not received immediately.
    For example, the `Future` type can include opening a modal, selecting an item,
    and dismissing it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何值不会立即接收的动作的 `Future` 发布者。例如，`Future` 类型可以包括打开模态、选择项目以及关闭它。
- en: But let’s see how we can use `Future` for async operations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看我们如何使用 `Future` 来进行异步操作。
- en: The `Future` publisher has a closure with a `promise` parameter with either
    success or failure depending on the operation result.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 发布者有一个带有 `promise` 参数的闭包，该参数根据操作结果具有成功或失败。'
- en: 'Let’s see an example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the `loadJSONFile` function returns a `Future` publisher. Inside,
    it creates a background queue and loads a big JSON file. It calls the promise
    type with success and data if everything works fine. If not, it sends a failure
    and an error.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`loadJSONFile` 函数返回一个 `Future` 发布者。在内部，它创建一个后台队列并加载一个大的 JSON 文件。如果一切顺利，它会调用带有成功和数据的结果。如果不顺利，它会发送失败和错误。
- en: 'Now let’s see how to use that function in a Combine stream:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 Combine 流中使用该函数：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we can integrate the JSON loading operation in one line, decode its data,
    and map and filter it, as part of a Combine stream.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 JSON 加载操作整合到一行中，解码其数据，并将其映射和过滤，作为 Combine 流的一部分。
- en: We can see how the `Future` publisher makes it very easy to integrate async
    operations in the Combine stream. We can also include more complex async operations
    in Combine by combining `OperationQueue` and `Future`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `Future` 发布者如何使将异步操作整合到 Combine 流中变得非常容易。我们还可以通过结合 `OperationQueue` 和
    `Future` 来在 Combine 中包含更复杂的异步操作。
- en: Going over concurrency development best practices
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探讨并发开发最佳实践
- en: Regardless of the different techniques we just learned, there are some best
    practices we should follow to keep our code safe from race conditions and deadlocks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们刚刚学到的不同技术如何，都有一些最佳实践我们应该遵循，以使我们的代码免受竞态条件和死锁的影响。
- en: 'Some of them are derived from what we’ve learned till now. Also, these best
    practices are excellent for interview discussions about concurrency:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些是从我们至今所学的内容中派生出来的。此外，这些最佳实践对于关于并发的面试讨论也非常出色：
- en: '*Avoid blocking the main thread*: The main thread handles UI updates, so blocking
    it can cause the app to become unresponsive. To avoid blocking the main thread,
    use background threads or operation queues to perform long-running or CPU-intensive
    tasks.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*避免阻塞主线程*：主线程处理 UI 更新，因此阻塞它可能会导致应用无响应。为了避免阻塞主线程，请使用后台线程或操作队列来执行长时间运行或 CPU 密集型任务。'
- en: '*Use structs for safety*: Structs are value types, which means they’re thread-safe
    by default. If we need to pass data between threads or queues, using structs can
    help prevent race conditions and other concurrency issues.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用结构体以确保安全*：结构体是值类型，这意味着它们默认是线程安全的。如果我们需要在线程或队列之间传递数据，使用结构体可以帮助防止竞态条件和其他并发问题。'
- en: '*Avoid shared state*: Shared state between threads or queues can lead to race
    conditions and other concurrency issues. Instead, try to keep the state local
    to each thread or queue and use message passing or other communication mechanisms
    to share data between them.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*避免共享状态*：线程或队列之间的共享状态可能导致竞态条件和其他并发问题。相反，尝试将状态保持在每个线程或队列的本地，并使用消息传递或其他通信机制在它们之间共享数据。'
- en: '*Use Combine*: Combine is a robust framework for reactive programming in iOS
    and can help simplify concurrency by allowing you to define data streams and transformations
    that operate on those streams. By using Combine, you can avoid complex thread
    management and synchronization issues.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Combine*：Combine是iOS中响应式编程的一个强大框架，它可以通过允许你定义数据流及其操作来简化并发。通过使用Combine，你可以避免复杂的线程管理和同步问题。'
- en: '*Always return a closure in the same thread*: When performing asynchronous
    operations, it’s essential to ensure that any closures or callbacks are executed
    in the same thread or queue where they were initially created. This helps avoid
    race conditions and other concurrency issues when executing code across multiple
    threads.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*始终在相同的线程中返回闭包*：在进行异步操作时，确保任何闭包或回调都在它们最初创建的相同线程或队列中执行是至关重要的。这有助于避免在跨多个线程执行代码时出现竞争条件和其他并发问题。'
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was long, and this topic could be a book of its own. In fact, many
    books focus solely on design patterns, and it’s obvious why – design patterns
    are our toolbox for everything we do in iOS development.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容很长，这个主题本身就可以写成一本书。实际上，许多书籍只专注于设计模式，原因很明显——设计模式是我们进行iOS开发时所有工作的工具箱。
- en: This chapter taught us about MVC/MVVM, DI, delegation, singletons, and concurrency
    patterns and tools. By now, we should have a great understanding of the primary
    design patterns in iOS.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了MVC/MVVM、依赖注入（DI）、代理、单例以及并发模式和工具。到目前为止，我们应该对iOS中的主要设计模式有了很好的理解。
- en: This knowledge of design patterns is a great foundation to prepare us for the
    next chapter, which will focus on app architecture and development.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对设计模式的知识是构建我们为下一章做准备的一个很好的基础，下一章将专注于应用程序架构和开发。
