- en: Enabling Wi-Fi on the Android Emulator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android模拟器上启用Wi-Fi
- en: 'In the last three chapters, we have explored ways to customize and extend the
    Android emulator. In this chapter, we will pursue this topic to add Wi-Fi support
    in the Android emulator. If you are a developer using the Android emulator, you
    may notice that there is only data connection in the Android emulator. Some applications
    may be aware of the connection type and exhibit different behaviors according
    to the connection type. In this case, you cannot use an emulator to test your
    applications. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章中，我们探讨了自定义和扩展Android模拟器的方法。在本章中，我们将继续探讨这个主题，以在Android模拟器中添加Wi-Fi支持。如果你是使用Android模拟器的开发者，你可能注意到Android模拟器中只有数据连接。一些应用程序可能知道连接类型，并根据连接类型表现出不同的行为。在这种情况下，你不能使用模拟器来测试你的应用程序。在本章中，我们将涵盖以下主题：
- en: Introducing Wi-Fi architecture in Android
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Android中的Wi-Fi架构
- en: Extending the x86emu device to support Wi-Fi connections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展x86emu设备以支持Wi-Fi连接
- en: Testing a Wi-Fi connection on the x86emu device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在x86emu设备上测试Wi-Fi连接
- en: The topics in this chapter are at an advanced level. We will analyze the Wi-Fi
    source code at the beginning of the chapter to help understand the Wi-Fi architecture.
    I recommend that you open a source code editor and locate the functions under
    discussion. This is a very efficient way to understand the source code analysis
    part in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题处于高级水平。我们将在本章的开始分析Wi-Fi源代码，以帮助理解Wi-Fi架构。我建议你打开源代码编辑器并定位讨论中的函数。这是理解本章源代码分析部分的一种非常有效的方法。
- en: Wi-Fi on Android
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android上的Wi-Fi
- en: In [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml), *Discovering Kernel,
    HAL, and Virtual Hardware*, we discussed the porting layers related to the Android
    system, we used goldfish lights as an example to depict the calling sequence from
    an application to HAL to access the hardware. We will use a similar approach in
    this chapter to explore the Wi-Fi architecture of Android. Based on what we understand
    about Wi-Fi architecture, we will add Wi-Fi to the emulator later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)“发现内核、HAL和虚拟硬件”中，我们讨论了与Android系统相关的端口层，我们以goldfish
    lights为例来描述从应用程序到HAL访问硬件的调用序列。在本章中，我们将采用类似的方法来探索Android的Wi-Fi架构。基于我们对Wi-Fi架构的理解，我们将在本章的后面部分将Wi-Fi添加到模拟器中。
- en: The Wi-Fi architecture
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wi-Fi架构
- en: As we know from previous chapters, Android applications use managers to access
    system services. The managers will use various system services to access **Hardware
    Abstraction Layer** (**HAL**). The Wi-Fi architecture also follows the same approach
    for applications to access Wi-Fi hardware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的章节所知，Android应用程序使用管理器来访问系统服务。管理器将使用各种系统服务来访问**硬件抽象层**（**HAL**）。Wi-Fi架构也遵循相同的方法，让应用程序访问Wi-Fi硬件。
- en: '![](img/image_07_001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_001.png)'
- en: Android Wi-Fi architecture
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wi-Fi架构
- en: As we can see from the preceding diagram showing Wi-Fi layers in the Android
    system, **WifiSettings** is the application in the default AOSP build used to
    control Wi-Fi connections. **WifiSettings** uses **WifiManager** to get access
    to Wi-Fi services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面显示Android系统中Wi-Fi层的图所示，**WifiSettings**是默认AOSP构建中用于控制Wi-Fi连接的应用程序。**WifiSettings**使用**WifiManager**来获取访问Wi-Fi服务。
- en: '**WifiManager** provides the following functionalities:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**WifiManager**提供以下功能：'
- en: Providing a list of configured networks--the attributes of individual entries
    can be modified.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供配置网络的列表--可以修改单个条目的属性。
- en: Monitoring the current active Wi-Fi network, if any. Connectivity can be established
    or torn down, and dynamic information about the state of the network can be queried.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控当前活动的Wi-Fi网络（如果有）。可以建立或断开连接，并查询网络状态的动态信息。
- en: Providing the results of access point scans, containing enough information to
    make decisions about what access point to connect to.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供接入点扫描的结果，包含足够的信息来决定连接哪个接入点。
- en: Defining the names of various intent actions that are broadcast upon any sort
    of change in the Wi-Fi state.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在Wi-Fi状态发生任何变化时广播的各种intent动作的名称。
- en: 'When `WifiManager` is created, it gets an interface of `IWifiManager`, as shown
    in the following code snippet. This interface is implemented by `WifiService`
    through the binder mechanism:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WifiManager`被创建时，它获得`IWifiManager`的接口，如下面的代码片段所示。该接口通过binder机制由`WifiService`实现：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`WifiManager` is defined in the `$AOSP/frameworks/base/wifi/java/android/net/wifi/WifiManager.java`
    file.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`WifiManager` 定义在 `$AOSP/frameworks/base/wifi/java/android/net/wifi/WifiManager.java`
    文件中。'
- en: 'In the `WifiService` implementation, it uses `WifiStateMachine` to manage Wi-Fi
    states:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WifiService` 的实现中，它使用 `WifiStateMachine` 来管理 Wi-Fi 状态：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`WifiServiceImpl` is defined in the `$AOSP/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java`
    file.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`WifiServiceImpl` 定义在 `$AOSP/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java`
    文件中。'
- en: 'We can see how the Wi-Fi HAL is initialized through `WifiStateMachine` in the
    following sequence diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下序列图查看 Wi-Fi HAL 的初始化过程：
- en: There is a very good Android source code cross-reference tool at [http://xref.opersys.com/](http://xref.opersys.com/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://xref.opersys.com/](http://xref.opersys.com/) 有一个非常好的 Android 源代码交叉引用工具。
- en: You can search the definition of functions and locate the location of source
    code using this cross reference tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这个交叉引用工具搜索函数定义并定位源代码位置。
- en: '![](img/image_07_002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_002.png)'
- en: Sequence diagram of Android Wi-Fi initialization
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wi-Fi 初始化的序列图
- en: '`WifiStateMachine` processes requests from `WifiManager`. When the system initializes
    Wi-Fi by sending a `CMD_START_SUPPLICANT` command, `WifiStateMachine` will call
    its `processMessage` method to handle this request as shown in the following code
    snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`WifiStateMachine` 处理来自 `WifiManager` 的请求。当系统通过发送 `CMD_START_SUPPLICANT` 命令初始化
    Wi-Fi 时，`WifiStateMachine` 将调用其 `processMessage` 方法来处理此请求，如下所示：'
- en: '![](img/image_07_003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_003.png)'
- en: The `processMessage` method calls to native methods through `WifiNative` to
    load the Wi-Fi driver (`loadDriver`) and start the Wi-Fi HAL (`startHAL`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`processMessage` 方法通过 `WifiNative` 调用原生方法来加载 Wi-Fi 驱动程序（`loadDriver`）并启动 Wi-Fi
    HAL（`startHAL`）。'
- en: 'Pay attention to the function calls `mWifiNative.loadDriver`, and `WifiNative.startHal`,
    as shown in the following flow diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意函数调用 `mWifiNative.loadDriver` 和 `WifiNative.startHal`，如下所示的流程图所示：
- en: '![](img/image_07_004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_004.png)'
- en: The **WifiNative** implementation includes the Java part and the native part.
    The Java implementation can be found at `$AOSP/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**WifiNative** 的实现包括 Java 部分 和 原生部分。Java 实现可以在 `$AOSP/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java`
    文件中找到。'
- en: The native implementation can be found at `$AOSP/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原生实现可以在 `$AOSP/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp`
    文件中找到。
- en: 'When the instance of the `WifiNative` class is created, it loads the Wi-Fi
    service shared library first and calls to a `registerNatives` function to register
    all native functions as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `WifiNative` 类的实例时，它首先加载 Wi-Fi 服务共享库，并调用 `registerNatives` 函数来注册所有原生函数，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The native implementation of `registerNatives` is shown in the following snippet.
    It registers the native functions through a `gWifiMethods` global variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerNatives` 的原生实现如下所示。它通过一个 `gWifiMethods` 全局变量来注册原生函数：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this function, it calls to another framework function, `registerNativeMethods`,
    to register native methods at the Java layer so that the Java layer can call the
    functions implemented in `WifiNative`. You might know the function `registerNativeMethods`,
    if you have worked on Android NDK programming. We can look at the `gWifiMethods`
    global variable in the following snippet. The `gWifiMethods` global variable includes
    a list of native functions that are implemented in `WifiNative`, which should
    be exported as Java native methods of the `WifiNative` class. We can see that
    `loadDriver` and `startHalNative` are in the list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，它调用另一个框架函数 `registerNativeMethods` 来在 Java 层注册原生方法，以便 Java 层可以调用 `WifiNative`
    中实现的功能。如果您在 Android NDK 编程方面工作过，您可能知道 `registerNativeMethods` 函数。我们可以在以下片段中查看
    `gWifiMethods` 全局变量。`gWifiMethods` 全局变量包含在 `WifiNative` 中实现的原生函数列表，这些函数应作为 `WifiNative`
    类的 Java 原生方法导出。我们可以看到 `loadDriver` 和 `startHalNative` 在列表中：
- en: '![](img/image_07_005.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_005.png)'
- en: 'The `loadDriver` method is implemented in the `android_net_wifi_loadDriver`
    function as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadDriver` 方法在 `android_net_wifi_loadDriver` 函数中实现，如下所示：'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It calls to a `wifi_load_driver` function, which is a part of Wi-Fi HAL at `$AOSP/hardware/libhardware_legacy/wifi/wifi.c`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用一个 `wifi_load_driver` 函数，这是 Wi-Fi HAL 的一部分，位于 `$AOSP/hardware/libhardware_legacy/wifi/wifi.c`。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `WIFI_DRIVER_MODULE_PATH` macro needs to be defined to specify the path
    of the driver module, if there is a specific Wi-Fi driver that needs to be used.
    After the driver has loaded successfully, a `wlan.driver.status` property is set
    to the value `ok`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用特定的Wi-Fi驱动程序，需要定义`WIFI_DRIVER_MODULE_PATH`宏来指定驱动模块的路径。驱动程序加载成功后，会设置`wlan.driver.status`属性为`ok`。
- en: 'Now we will look at another method, `startHalNative`. It is implemented in
    the `android_net_wifi_startHal` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨另一种方法，`startHalNative`。它在`android_net_wifi_startHal`函数中实现：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Wi-Fi chip vendors usually provide two components the Wi-Fi implementations.
    The first one is a kernel driver as we discussed in the `loadDriver` and the second
    one is a vendor HAL library. The `startHalNative` function is used to hook vendor-implemented
    functions to a pre-defined list of functions. As we can see in the preceding code
    snippet, the `init_wifi_hal_func_table` function is called to initialize the list
    of functions in `hal_fn`. After that, the `init_wifi_vendor_hal_func_table` function
    is called to initialize the function pointers in `hal_fn`. If this operation is
    successful, it will call to the vendor initialization function, `hal_fn.wifi_initialize`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi芯片供应商通常提供两个组件：Wi-Fi实现。第一个是我们讨论过的内核驱动程序，第二个是供应商HAL库。`startHalNative`函数用于将供应商实现的函数钩接到预定义的函数列表中。正如我们可以在前面的代码片段中看到的那样，调用`init_wifi_hal_func_table`函数来初始化`hal_fn`中的函数列表。之后，调用`init_wifi_vendor_hal_func_table`函数来初始化`hal_fn`中的函数指针。如果此操作成功，它将调用供应商初始化函数`hal_fn.wifi_initialize`。
- en: QEMU networking and wpa_supplicant in Android
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QEMU网络和Android中的wpa_supplicant
- en: At HAL, `wpa_supplicant` is used to support the authentication between the device
    and access point. It starts as a native daemon in the Android system. Control
    requests from the upper layer are sent to `wpa_supplicant` and `wpa_supplicant`
    deals with device drivers and kernel networking systems to provide the network
    connections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在HAL中，使用`wpa_supplicant`来支持设备与接入点之间的认证。它作为Android系统中的本地守护进程启动。上层控制请求被发送到`wpa_supplicant`，`wpa_supplicant`处理设备驱动程序和内核网络系统以提供网络连接。
- en: 'Since the Android emulator uses QEMU, the networking system is provided by
    the QEMU networking system. QEMU provides multiple network backends including
    TAP, VDE, socket, and SLIRP. The Android emulator uses user networking (SLIRP),
    which is the default networking backend of QEMU. Since SLIRP is a software implementation
    of TCP/IP networking stacks, it does not require root privileges to support networking
    functionalities. As a software implementation, it has the following limitations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android模拟器使用QEMU，网络系统由QEMU网络系统提供。QEMU提供多个网络后端，包括TAP、VDE、套接字和SLIRP。Android模拟器使用用户网络（SLIRP），这是QEMU的默认网络后端。由于SLIRP是TCP/IP网络堆栈的软件实现，它不需要root权限来支持网络功能。作为一个软件实现，它有以下限制：
- en: Lot of overhead so the performance is poor
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有很多开销，因此性能较差
- en: In general, ICMP traffic does not work so you cannot use ping within a guest
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，ICMP流量无法正常工作，因此您无法在虚拟机内部使用ping命令。
- en: On Linux hosts, ping can work within the guest if the initial setup is done
    by root
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux主机上，如果初始设置是由root完成的，则ping命令可以在虚拟机内部工作。
- en: The guest is not directly accessible from the host or the external network
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机无法直接从主机或外部网络访问。
- en: 'The following is a typical diagram of what SLIRP networking looks like in the
    Android emulator:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是Android模拟器中SLIRP网络的一个典型示例：
- en: '![](img/image_07_006.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_006.png)'
- en: A QEMU SLIRP network
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU SLIRP网络
- en: 'In the preceding diagram, the client has an IP address of **10.0.2.15** and
    the gateway has an IP address of **10.0.2.2**. The default DNS IP address is **10.0.2.3**.
    It may support SMB, which is optional. If you start an Android emulator, the default
    network interface is `eth0` with an IP address of **10.0.2.15**. This is usually
    used to simulate a cellular data connection. To simulate a Wi-Fi connection, we
    can add one more network interface, `eth1`, using the following QEMU options:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，客户端的IP地址为**10.0.2.15**，网关的IP地址为**10.0.2.2**。默认DNS IP地址为**10.0.2.3**。它可能支持SMB，这是可选的。如果您启动Android模拟器，默认网络接口为`eth0`，IP地址为**10.0.2.15**。这通常用于模拟蜂窝数据连接。要模拟Wi-Fi连接，我们可以使用以下QEMU选项添加一个额外的网络接口`eth1`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the `-device` QEMU option, we add a new network device, `mynet1`, which
    uses virtio network hardware. QEMU can simulate many existing network hardware
    types and we choose virtio network hardware in this chapter. You may choose others
    if you like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-device` QEMU 选项，我们添加了一个新的网络设备 `mynet1`，它使用 virtio 网络硬件。QEMU 可以模拟许多现有的网络硬件类型，我们在这章中选择
    virtio 网络硬件。如果您喜欢，您也可以选择其他选项。
- en: With the `-netdev` QEMU option, we specify the attributes of this network device
    by providing an IP address range and the starting address for DHCP protocol.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-netdev` QEMU 选项，我们通过提供 IP 地址范围和 DHCP 协议的起始地址来指定此网络设备的属性。
- en: 'Be aware that the previous option can only work with ranchu not goldfish. To
    start the Android emulator with the preceding QEMU option, we can run the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的选项只能与 ranchu 一起使用，而不能与 goldfish 一起使用。要使用前面的 QEMU 选项启动 Android 模拟器，我们可以运行以下命令：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding Wi-Fi to the emulator
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模拟器中添加Wi-Fi
- en: With the introduction of Wi-Fi architecture in Android, we can now extend the
    emulator to support Wi-Fi. To add Wi-Fi in the emulator, we need to build `wpa_supplicant`
    for the emulator and choose the right device driver for the `eth1` network interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android中Wi-Fi架构的引入，我们现在可以扩展模拟器以支持Wi-Fi。要在模拟器中添加Wi-Fi，我们需要为模拟器构建 `wpa_supplicant`
    并为 `eth1` 网络接口选择正确的设备驱动程序。
- en: Enabling wpa_supplicant in BoardConfig.mk
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 BoardConfig.mk 中启用 wpa_supplicant
- en: 'In the default emulator build, `wpa_supplicant` is not built. To enable building
    `wpa_supplicant` for the emulator, we can add the following lines in our `BoardConfig.mk`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的模拟器构建中，`wpa_supplicant` 不会被构建。要为模拟器启用 `wpa_supplicant` 的构建，我们可以在我们的 `BoardConfig.mk`
    中添加以下行：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When `BOARD_WPA_SUPPLICANT_DRIVER` is defined, the following configuration
    in `external/wpa_supplicant_8/wpa_supplicant/Android.mk` will be changed to true:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `BOARD_WPA_SUPPLICANT_DRIVER` 被定义时，`external/wpa_supplicant_8/wpa_supplicant/Android.mk`
    中的以下配置将被更改为 true：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value of `BOARD_WPA_SUPPLICANT_DRIVER` tells which driver should be built.
    Since we use a wired Ethernet connection to simulate Wi-Fi, we will choose the
    *wired* driver, which can be found at `external/wpa_supplicant_8/src/drivers/driver_wired.c`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOARD_WPA_SUPPLICANT_DRIVER` 的值表示应该构建哪个驱动程序。由于我们使用有线以太网连接来模拟 Wi-Fi，我们将选择 *有线*
    驱动程序，它可以在 `external/wpa_supplicant_8/src/drivers/driver_wired.c` 中找到。'
- en: We also define the `wpa_supplicant` version to use and the wired Ethernet interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了要使用的 `wpa_supplicant` 版本和有线以太网接口。
- en: Providing a proper wpa_supplicant configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供适当的 wpa_supplicant 配置
- en: To make `wpa_supplicant` work correctly, we need to prepare a `wpa_supplicant.conf`
    configuration file with the right permission. Wi-Fi-related configuration files
    are stored in the `/data/misc/wifi/` directory. This directory is owned by the
    `wifi` user, which is also the user that the `wpa_supplicant` runs as.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `wpa_supplicant` 正确工作，我们需要准备一个具有正确权限的 `wpa_supplicant.conf` 配置文件。Wi-Fi 相关的配置文件存储在
    `/data/misc/wifi/` 目录中。此目录属于 `wifi` 用户，也是 `wpa_supplicant` 运行的用户。
- en: 'The `wpa_supplicant.conf` configuration file for the `eth1` wired connection
    can be found in the following snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`eth1` 有线连接的 `wpa_supplicant.conf` 配置文件可以在以下片段中找到：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this configuration file, we defined the network SSID to be used and the authentication
    method to establish the connection. Since this is a predefined wired connection,
    we set the authentication method as `key_mgmt=NONE`, which means we don't need
    to use any authentication method for this case.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置文件中，我们定义了要使用的网络 SSID 和建立连接的认证方法。由于这是一个预定义的有线连接，我们将认证方法设置为 `key_mgmt=NONE`，这意味着在这种情况下我们不需要使用任何认证方法。
- en: 'To copy `wpa_supplicant.conf` to the `/data/misc/wifi/` directory with the
    right permission, we need to change `device.mk` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `wpa_supplicant.conf` 以正确的权限复制到 `/data/misc/wifi/` 目录，我们需要按以下方式更改 `device.mk`：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `device.mk`, we define the `wifi.interface` to `eth1` as we discussed previously.
    After that, we add all Wi-Fi-related modules to `PRODUCT_PACKAGES` so that they
    can be added to the system image. We copy the `wpa_supplicant.conf` configuration
    file to the `/data/misc/wifi` directory so that it can be accessed with read and
    write permissions by `wpa_supplicant`. This file is owned by the `wifi` user with
    permission `0555`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `device.mk` 中，我们定义 `wifi.interface` 为 `eth1`，正如我们之前讨论的那样。之后，我们将所有 Wi-Fi 相关模块添加到
    `PRODUCT_PACKAGES` 中，以便它们可以被添加到系统镜像中。我们将 `wpa_supplicant.conf` 配置文件复制到 `/data/misc/wifi`
    目录，以便 `wpa_supplicant` 可以以读写权限访问它。此文件属于 `wifi` 用户，权限为 `0555`。
- en: 'From the Android 6 release, the system permission for files from the vendor
    is defined in an `android_filesystem_config.h` file under the `device` folder.
    `PRODUCT_PACKAGES` must include `fs_config_dirs` and/or `fs_config_files` in order
    to install them to `/system/etc/fs_config_dirs` and `/system/etc/fs_config_files`,
    respectively. The generated `fs_config_dirs` and `fs_config_files` files are used
    to set the runtime permission. We can see the owner and permission defined in
    `android_filesystem_config.h` in the following snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 6 版本开始，系统对供应商文件的权限定义在 `device` 文件夹下的 `android_filesystem_config.h`
    文件中。`PRODUCT_PACKAGES` 必须包含 `fs_config_dirs` 和/或 `fs_config_files`，以便将它们分别安装到
    `/system/etc/fs_config_dirs` 和 `/system/etc/fs_config_files`。生成的 `fs_config_dirs`
    和 `fs_config_files` 文件用于设置运行时权限。我们可以在以下代码片段中看到定义在 `android_filesystem_config.h`
    中的所有者和权限：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last change in `device.mk` is related to the settings user interface. The
    Wi-Fi settings user interface is not available in the emulator build. To enable
    the Wi-Fi settings, we need to add `android.hardware.wifi.xml` to the `system/etc/permissions`
    folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`device.mk` 的最后一个更改与设置用户界面有关。在模拟器构建中，Wi-Fi 设置用户界面不可用。要启用 Wi-Fi 设置，我们需要将 `android.hardware.wifi.xml`
    添加到 `system/etc/permissions` 文件夹。'
- en: Creating services in init scripts
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在初始化脚本中创建服务
- en: To initialize network interface `eth1` and start `wpa_supplicant`, we need to
    define related services in init scripts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化网络接口 `eth1` 并启动 `wpa_supplicant`，我们需要在初始化脚本中定义相关服务。
- en: Initializing network interface eth1
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化网络接口 eth1
- en: 'To initialize `eth1`, we can refer to the initialization of `eth0` in the emulator.
    The network interface `eth0` is initialized in the `system/etc/init.goldfish.sh`
    shell script as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 `eth1`，我们可以参考模拟器中 `eth0` 的初始化过程。网络接口 `eth0` 在 `system/etc/init.goldfish.sh`
    脚本中初始化，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we can see, a fixed IP address `10.0.2.15` is assigned to the `eth0` interface.
    We can add the following commands to initialize the interface `eth1`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，固定 IP 地址 `10.0.2.15` 被分配给了 `eth0` 接口。我们可以添加以下命令来初始化接口 `eth1`：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding commands, we enable the interface `eth1` first using the `ifconfig`
    command. Then, instead of using a fixed IP address, we use the DHCP client to
    get the IP address for `eth1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们首先使用 `ifconfig` 命令启用接口 `eth1`。然后，我们不是使用固定 IP 地址，而是使用 DHCP 客户端为 `eth1`
    获取 IP 地址。
- en: As we discussed when covering the init process of Android in [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml),
    *Debugging the Boot Up Process Using a Customized ramdisk*, the init process will
    process the `init.rc` script during the system startup. The `init.rc` script will
    include a hardware-specific init script, `init.${ro.hardware}.rc`. In our case,
    the `ro.hardware` is `ranchu`, so the hardware-specific init script is `init.ranchu.rc`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第 6 章[使用自定义 ramdisk 调试启动过程](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)中讨论的那样，init
    进程将在系统启动时处理 `init.rc` 脚本。`init.rc` 脚本将包括一个特定于硬件的 init 脚本，`init.${ro.hardware}.rc`。在我们的案例中，`ro.hardware`
    是 `ranchu`，因此特定于硬件的 init 脚本是 `init.ranchu.rc`。
- en: 'In the `init.ranchu.rc` init script, a service, as shown in the following snippet,
    is defined to run the `init.goldfish.sh` shell script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init.ranchu.rc` 初始化脚本中，定义了一个服务，如下面的代码片段所示，用于运行 `init.goldfish.sh` 脚本：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's how the goldfish- or ranchu- related setup process is done in an emulator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在模拟器中完成 goldfish- 或 ranchu- 相关设置过程的方式。
- en: Starting up wpa_supplicant
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 wpa_supplicant
- en: 'We can add a service in the `init.ranchu.rc` script to start `wpa_supplicant`.
    The following are the services that we added to the `init.ranchu.rc` script:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `init.ranchu.rc` 脚本中添加一个服务来启动 `wpa_supplicant`。以下是我们添加到 `init.ranchu.rc`
    脚本中的服务：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This service is used to start or restart the `eth1` interface using the DHCP
    client. For the service of `wpa_supplicant`, we start it with the following options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务用于使用 DHCP 客户端启动或重启 `eth1` 接口。对于 `wpa_supplicant` 服务，我们使用以下选项启动它：
- en: '`-i`: Use the network interface `eth1` for Wi-Fi'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`: 使用网络接口 `eth1` 进行 Wi-Fi'
- en: '`-D`: Use the wired driver for Wi-Fi on the interface `eth1`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D`: 在接口 `eth1` 上使用有线驱动程序进行 Wi-Fi'
- en: '`-c`: Use the configuration file at `/data/misc/wifi/wpa_supplicant.conf`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`: 使用位于 `/data/misc/wifi/wpa_supplicant.conf` 的配置文件'
- en: '`-e`: Define the path of the entropy file'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`: 定义熵文件的路径'
- en: '`-g`: Define the global `ctrl_interface` as `@android:wpa_eth1`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g`: 将全局 `ctrl_interface` 定义为 `@android:wpa_eth1`'
- en: 'If we refer to the sequence diagram of Wi-Fi initialization earlier in this
    chapter, the `wpa_supplicant` start sequence can be explained using the following
    steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考本章前面提到的 Wi-Fi 初始化的时序图，可以使用以下步骤解释 `wpa_supplicant` 的启动序列：
- en: '`WifiStateMachine` processes the `CMD_START_SUPPLICANT` command.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WifiStateMachine` 处理 `CMD_START_SUPPLICANT` 命令。'
- en: '`WifiStateMachine` calls the `startSupplicant` method of `WifiNative`.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WifiStateMachine` 调用 `WifiNative` 的 `startSupplicant` 方法。'
- en: The `startSupplicant` method is a native method implemented as the `android_net_wifi_startSupplicant`
    native function. This native function calls the `wifi_start_supplicant` function
    defined in Wi-Fi HAL `wifi.c`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`startSupplicant` 方法是一个作为 `android_net_wifi_startSupplicant` 原生函数实现的本地方法。这个原生函数调用在
    Wi-Fi HAL `wifi.c` 中定义的 `wifi_start_supplicant` 函数。'
- en: 'The `wifi_start_supplicant` function starts the `wpa_supplicant` through setting
    the `ctl.start` system property. `ctl.start` and `ctl.stop` are two system properties
    implemented by the property service that can be used to start or stop a service
    defined in the init scripts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`wifi_start_supplicant` 函数通过设置 `ctl.start` 系统属性来启动 `wpa_supplicant`。`ctl.start`
    和 `ctl.stop` 是由属性服务实现的两个系统属性，可以用来启动或停止在 init 脚本中定义的服务：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Building the source code
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建源代码
- en: We have made all the changes required to support Wi-Fi in emulators now. Let's
    build the AOSP source code for this chapter so that we can test the Wi-Fi connection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了所有支持在模拟器中运行 Wi-Fi 所需的更改。让我们构建这一章的 AOSP 源代码，以便我们可以测试 Wi-Fi 连接。
- en: Getting the source code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'As we have done in previous chapters, we will have a look at the projects that
    we have changed in this chapter. We can check this from the manifest file for
    this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所做的那样，我们将查看这一章中我们更改的项目。我们可以从这一章的清单文件中检查：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is the `default.xml` file at `https://github.com/shugaoye/manifests/blob/android-7.1.1_r4_ch07_aosp/default.xml`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是位于 `https://github.com/shugaoye/manifests/blob/android-7.1.1_r4_ch07_aosp/default.xml`
    的 `default.xml` 文件。
- en: 'We can see that we have an `android-7.1.1_r4_x86emu_ch07_r2` tag for this chapter.
    In this chapter, we have our own projects, `kernel`, `x86emu`, `newinstaller`,
    and `goldfish`. We will use this manifest to download or update the source code
    for this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们为这一章有一个 `android-7.1.1_r4_x86emu_ch07_r2` 标签。在这一章中，我们有我们自己的项目，`kernel`、`x86emu`、`newinstaller`
    和 `goldfish`。我们将使用此清单来下载或更新这一章的源代码：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After we have the source code for this chapter, we can set the environment
    and build the system as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得这一章的源代码后，我们可以设置环境和构建系统，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enabling boot with initrd.img
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用使用 initrd.img 的启动
- en: 'As we learnt in [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging
    the Boot Up Process Using a Customized ramdisk*, we can boot the emulator in two
    stages. This is very helpful to debug the init process and troubleshoot issues
    at system level. in [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging
    the Boot Up Process Using a Customized ramdisk*, we create a separate disk image,
    `x86emu_x86.img`, to store all the necessary file images to support a first-stage
    boot up similar to Android-x86\. The `x86emu_x86.img` image appears in the system
    as `/dev/sda` and includes all images: `system.img`, `install.img`, `initrd.img`,
    `ramdisk.img`, `kernel`, and so on.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 6 章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml) 中所学的，*使用自定义 ramdisk
    调试启动过程*，我们可以分两个阶段启动模拟器。这对于调试 init 进程和解决系统级别的问题非常有帮助。在 [第 6 章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)
    中，*使用自定义 ramdisk 调试启动过程*，我们创建了一个单独的磁盘镜像 `x86emu_x86.img`，以存储所有必要的文件镜像以支持类似于 Android-x86
    的第一阶段启动。`x86emu_x86.img` 镜像在系统中显示为 `/dev/sda`，并包含所有镜像：`system.img`、`install.img`、`initrd.img`、`ramdisk.img`、`kernel`
    等。
- en: In this chapter, we will change the Android-x86 `newinstaller` further to support
    two-stages boot up just using `system.img` instead of creating a separate image.
    We will use the first stage boot to help our debugging of Wi-Fi initialization
    later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将进一步修改 Android-x86 的 `newinstaller` 以支持两阶段启动，仅使用 `system.img` 而不是创建单独的镜像。我们将使用第一阶段启动来帮助我们在本章后面调试
    Wi-Fi 初始化。
- en: 'In the first stage of boot-up, the init script in `initrd.img` will mount the
    system image and extract `ramdisk.img` to a filesystem in memory. Since we will
    use `system.img` directly, we need to put `ramdisk.img` inside the `system.img`.
    We do this using the `Makefile` in the x86emu device instead of changing the AOSP
    source code. The following is the build target that we add to `device/generic/x86emu/Makefile`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动的第一阶段，`initrd.img` 中的 init 脚本将挂载系统镜像并将 `ramdisk.img` 提取到内存中的文件系统。由于我们将直接使用
    `system.img`，我们需要将 `ramdisk.img` 放入 `system.img` 中。我们使用 x86emu 设备中的 `Makefile`
    来完成这项工作，而不是更改 AOSP 源代码。以下是我们添加到 `device/generic/x86emu/Makefile` 中的构建目标：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `qcow2_img` build target, we create an `x86emu_ch07` folder in the system
    image and we copy `ramdisk.img` to this folder. After that, we build a system
    image in QCOW2 format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `qcow2_img` 构建目标中，我们在系统镜像中创建一个 `x86emu_ch07` 文件夹，并将 `ramdisk.img` 复制到该文件夹。之后，我们以
    QCOW2 格式构建系统镜像。
- en: 'To build the system image in QCOW2 format, we need to change `Android.mk` in
    the `bootable/newinstaller` folder:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 QCOW2 格式下构建系统镜像，我们需要更改 `bootable/newinstaller` 文件夹中的 `Android.mk`：
- en: '![](img/image_07_007.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_007.png)'
- en: diff in bootable/newinstaller/Android.mk
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bootable/newinstaller/Android.mk` 中的 diff
- en: From the preceding diff tool output, we can see that we changed the `VER` variable
    to `x86emu_ch07`. The init script of `initrd.img` uses this variable to find the
    folder of images. The second change is to add a build target to generate the `QCOW2`
    image using the `qemu-img` tool.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 diff 工具输出中，我们可以看到我们将 `VER` 变量更改为 `x86emu_ch07`。`initrd.img` 的 init 脚本使用此变量来查找镜像文件夹。第二次更改是添加一个构建目标，使用
    `qemu-img` 工具生成 `QCOW2` 镜像。
- en: 'Finally, we need to change the init script in `initrd.img` as follows to extract
    `ramdisk.img` inside `system.img`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `initrd.img` 中的 init 脚本更改为以下内容，以从 `system.img` 内提取 `ramdisk.img`：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The original script will try to find the system image in `SQUASH` format (`system.sfs`)
    or a plain image (`system.img`). If none of the system images can be found, it
    will try to find a `system/` folder as the system image. After that, it will mount
    the image file or the folder to `/android/system`. In our case, the system image
    is already mounted at `/mnt`, so we just move the mount point from `/mnt` to `/android/system`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 原始脚本将尝试在 `SQUASH` 格式（`system.sfs`）或普通镜像（`system.img`）中查找系统镜像。如果找不到任何系统镜像，它将尝试将
    `system/` 文件夹作为系统镜像。之后，它将挂载镜像文件或文件夹到 `/android/system`。在我们的情况下，系统镜像已经挂载在 `/mnt`，所以我们只需将挂载点从
    `/mnt` 移动到 `/android/system`。
- en: The second change to the init script is to define the `DEBUG` and `SRC` environment
    variables. These two variables are passed from the kernel command line in [Chapter
    6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging the Boot Up Process
    Using a Customized ramdisk*. Here, we define them inside the script, so we don't
    need to worry about the kernel command line in our test script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对 init 脚本的第二次更改是定义 `DEBUG` 和 `SRC` 环境变量。这两个变量是从 [第 6 章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)
    的内核命令行传递的，*使用自定义 ramdisk 调试启动过程*。在这里，我们在脚本内部定义它们，所以我们不需要担心测试脚本中的内核命令行。
- en: 'Once we have done all these changes, we can build the `initrd.img` and system
    image as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成所有这些更改，我们可以按照以下方式构建 `initrd.img` 和系统镜像：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see from the preceding output that `initrd.img` is created and `system-qcow2.img`
    is generated from `system.img`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的输出中看到，`initrd.img` 已创建，`system-qcow2.img` 是从 `system.img` 生成的。
- en: Testing Wi-Fi on an emulator
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模拟器上测试 Wi-Fi
- en: 'We have now prepared all the images that we need for the testing process. The
    prebuilt test images for this chapter can be downloaded from the following URL:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了测试过程中所需的全部镜像。本章的预构建测试镜像可以从以下 URL 下载：
- en: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch07/ch07.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch07/ch07.zip/download)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch07/ch07.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch07/ch07.zip/download)'
- en: Booting an Android emulator using initrd.img
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 initrd.img 启动 Android 模拟器
- en: 'We can execute the following command to boot the system using `initrd.img`
    first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下命令，首先使用 `initrd.img` 启动系统：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding command, we use QCOW2-format images for both system and user
    data, since they are much smaller than the plain file images. We use `initrd.img`
    as the ramdisk so that we can debug the configuration in the first stage of boot
    up. We can also change this script to use `ramdisk.img` directly. In this case,
    it is the normal start up process of the emulator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用 QCOW2 格式的镜像来存储系统和用户数据，因为它们比普通文件镜像小得多。我们使用 `initrd.img` 作为 ramdisk，这样我们就可以在启动的第一阶段调试配置。我们也可以将此脚本更改为直接使用
    `ramdisk.img`。在这种情况下，这是模拟器的正常启动过程。
- en: Once we start the emulator using `initrd.img`, we can enter the debug console,
    in which we can check the configuration and make necessary changes before we move
    forward.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `initrd.img` 启动模拟器，我们就可以进入调试控制台，在那里我们可以在继续前进之前检查配置并做出必要的更改。
- en: '![](img/image_07_008.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_008.png)'
- en: From the output, we can see that the system image on the device, `/dev/block/vda`,
    is mounted to `/android/system`. At this point, we have an opportunity to check
    and change any start up scripts before we launch them. For example, we can edit
    `init.ranchu.rc` to increase the debug level of `wpa_supplicant` with the `-dd`
    option before we start the Android system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到设备上的系统镜像 `/dev/block/vda` 已挂载到 `/android/system`。此时，我们有机会在启动它们之前检查和更改任何启动脚本。例如，我们可以在启动
    Android 系统之前，通过 `-dd` 选项编辑 `init.ranchu.rc` 来提高 `wpa_supplicant` 的调试级别。
- en: Booting an Android emulator using ramdisk.img
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ramdisk.img 启动 Android 模拟器
- en: 'To boot the system using `ramdisk.img`, we can execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ramdisk.img` 启动系统，我们可以执行以下命令：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Debugging Wi-Fi start up processes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Wi-Fi 启动过程
- en: 'Once the system starts, we can check the `wpa_supplicant` debug message using
    logcat as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动后，我们可以使用 logcat 检查 `wpa_supplicant` 的调试信息，如下所示：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/image_07_009.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-9](img/image_07_009.png)'
- en: 'We can see that `wpa_supplicant` started successfully using Ethernet `eth1`
    and global control socket `wpa_eth1`. This global control socket is specified
    in `init.ranchu.rc` as part of the `wpa_supplicant` service as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `wpa_supplicant` 成功启动，使用以太网 `eth1` 和全局控制套接字 `wpa_eth1`。此全局控制套接字在 `init.ranchu.rc`
    中指定，作为 `wpa_supplicant` 服务的一部分，如下所示：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also check the network status using the `ifconfig` command in the following
    snippet. We can see that `eth0` is assigned a fixed IP address, `10.0.2.15`, and
    `eth1` is assigned the IP address `10.0.2.50` through DHCP:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下片段中的 `ifconfig` 命令检查网络状态。我们可以看到 `eth0` 被分配了一个固定的 IP 地址，`10.0.2.15`，而
    `eth1` 通过 DHCP 被分配了 IP 地址 `10.0.2.50`：
- en: '![](img/image_07_010.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-10](img/image_07_010.png)'
- en: 'Once the system starts up, we can go to Settings | Wi-Fi and we will see the
    following screen. The access point SSID is WiredSSID and we can turn Wi-Fi on
    or off as we expect:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动后，我们可以进入设置 | Wi-Fi，我们会看到以下屏幕。接入点 SSID 是 WiredSSID，我们可以像预期的那样打开或关闭 Wi-Fi：
- en: '![](img/image_07_011.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-11](img/image_07_011.png)'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Wi-Fi architecture in Android and we also
    did an analysis of the Wi-Fi initialization process. Based on that, we modified
    our x86emu device to support simulated Wi-Fi through a wired Ethernet interface
    `eth1`. We used the advanced features in QEMU to add the second network interface
    to the ranchu emulator. With all these changes to x86emu, we built and tested
    the image. In order to help with debugging, we reused the technique that we learnt
    from [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging the Boot
    Up Process Using a Customized ramdisk*, to boot the system using `initrd.img`
    so that we can get a debug console before the Android system is started.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Android 中的 Wi-Fi 架构，并对 Wi-Fi 初始化过程进行了分析。基于此，我们修改了我们的 x86emu 设备，通过有线以太网接口
    `eth1` 支持模拟 Wi-Fi。我们利用 QEMU 的高级功能为 ranchu 模拟器添加了第二个网络接口。在所有这些对 x86emu 的修改完成后，我们构建并测试了镜像。为了帮助调试，我们重新使用了从[第
    6 章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)，“使用自定义 ramdisk 调试启动过程”中学到的技术，使用
    `initrd.img` 启动系统，以便在 Android 系统启动之前获得调试控制台。
- en: With all the knowledge from [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml),
    *Customizing the Android Emulator* to [Chapter 7](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml),
    *Enabling Wi-Fi on the Android Emulator*, we learnt how to create a new device
    based on an existing one. We also learnt how to customize and extend the device
    to support new features. From the next chapter to [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces*, we will take on a new challenge
    to support a new platform that is not supported by AOSP. We will create and build
    a new x86vbox device to explore more advanced topics in the Android system programming
    world.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从[第 4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)，“自定义 Android 模拟器”到[第
    7 章](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml)，“在 Android 模拟器上启用 Wi-Fi”的知识，我们学习了如何基于现有设备创建新设备。我们还学习了如何自定义和扩展设备以支持新功能。从下一章到[第
    11 章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)，“启用 VirtualBox 特定硬件接口”，我们将接受一个新的挑战，支持
    AOSP 不支持的新的平台。我们将创建并构建一个新的 x86vbox 设备，以探索 Android 系统编程领域的更多高级主题。
