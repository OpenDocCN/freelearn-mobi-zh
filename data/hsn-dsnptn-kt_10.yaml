- en: Idioms and Anti-Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 习语和反模式
- en: This chapter discusses the best and worst practices in Kotlin. You'll learn
    what idiomatic Kotlin code should look like and which patterns to avoid.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Kotlin的最佳和最坏实践。你将了解惯用的Kotlin代码应该是什么样子，以及哪些模式应该避免。
- en: After completing this chapter, you should be able to write more readable and
    maintainable Kotlin code, as well as avoid some common pitfalls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你应该能够编写更易读、更易于维护的Kotlin代码，并避免一些常见的陷阱。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Let
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let
- en: Apply
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apply
- en: Also
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Also
- en: Run
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Run
- en: With
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: With
- en: Instance checks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例检查
- en: Try-with-resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用资源
- en: Inline functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数
- en: Reified
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新声明
- en: Constants
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Constructor overload
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: Dealing with nulls
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理空值
- en: Explicit async
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式异步
- en: Validation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Sealed, not enumerated
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封，而不是枚举
- en: More companions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多同伴
- en: Scala function
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala函数
- en: Let
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let
- en: 'Usually, we use `let()` to do something only if the object is `not null`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`let()`只在对象`not null`时执行某些操作：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One common gotcha here is that `let()` by itself also works on nulls:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个常见的陷阱是`let()`本身也可以用于空值：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't forget the question mark, `?`, when you use `let()` for null checks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let()`进行空值检查时，不要忘记问号`?`。
- en: 'The return value of `let()` is not related to the type it operates on:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()`的返回值与其操作的类型无关：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code will print `"string"` and return `Int 6` as its length.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印`"string"`并返回其长度为`Int 6`。
- en: Apply
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apply
- en: We have already discussed `apply()` in previous chapters. It returns the same
    object it operates on and sets the context to `this`. The most useful case for
    this function is setting the fields of a mutable object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中讨论了`apply()`。它返回它操作的对象，并将上下文设置为`this`。这个函数最有用的用例是设置可变对象的字段。
- en: 'Think of how many times you had to create a class with an empty constructor,
    then call a lot of setters, one after another:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你有多少次不得不创建一个空构造函数的类，然后依次调用很多setter：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can set only `name` and `movie`, but leave `alsoStarring` blank, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能设置`name`和`movie`，但`alsoStarring`留空，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the context is set to this, we can simplify it to the following nice
    syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文设置为`this`，我们可以将其简化为以下漂亮的语法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is especially good when you work with Java classes that usually
    have a lot of setters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在你处理通常有很多setter的Java类时特别有用。
- en: Also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Also
- en: 'Single-expression functions are very nice and concise:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单表达式函数非常简洁和优雅：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But often, you have a single-statement function, that also needs to write to
    a log, for example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常，你有一个单语句函数，它还需要写入日志，例如。
- en: 'You could write it the following way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写成以下方式：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But then it's not a single statement function anymore, right?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样它就不再是单语句函数了，对吧？
- en: 'And we also introduced another variable. To the rescue, `also()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了另一个变量。来拯救，`also()`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function will set results of the expression to `it` and return the result
    of the expression.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将表达式的结果设置到`it`，并返回表达式的结果。
- en: 'This is also useful when you want to have a side effect on a chain of calls:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于你想要在一系列调用中产生副作用的情况：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Run
- en: 'Not related to threads in any way, `run()` is much like `let()`, but it sets
    the context to `this` instead of using `it`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程无关，`run()`与`let()`类似，但它将上下文设置为`this`而不是使用`it`：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Usually, `this` could be omitted:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`this`可以省略：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is mostly useful when you plan to call a number of methods on the same object,
    much like `apply()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计划在同一个对象上调用多个方法时，这非常有用，就像`apply()`一样。
- en: 'The return result, unlike `apply()`, may be of a totally different type, though:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与`apply()`不同，返回结果可能完全不同：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: With
- en: Unlike the other four scoping functions, `with()` is not an extension function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他四个作用域函数不同，`with()`不是一个扩展函数。
- en: 'This means you cannot do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不能这样做：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead, `with()` receives the object you want to scope as an argument:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`with()`接收一个作为参数的对象，你想要作用域的对象：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And as usual, we can omit `this`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以省略`this`：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like `run()` and `let()`, you can return any result from `with()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`run()`和`let()`一样，你可以从`with()`返回任何结果。
- en: Instance checks
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例检查
- en: 'Coming from Java, you may be inclined to check what type your object is using, `is`,
    and cast it using `as`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Java，你可能倾向于检查你的对象类型，使用`is`，然后使用`as`进行转换：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But as you may know, Kotlin has smart casts, so implicit casting, in this case,
    is not needed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你可能知道的，Kotlin有智能转换，所以在这种情况下，隐式转换不是必需的：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Moreover, in most cases, using `when()` while smart-casting produces cleaner
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数情况下，使用`when()`进行智能转换会产生更干净的代码：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a rule of thumb, you should avoid using casts and rely on smart casts most
    of the time:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你应该避免使用类型转换，并尽可能多地依赖智能转换：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But if you absolutely must, there''s also a safe cast operator:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你绝对必须，还有一个安全的类型转换操作符：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Try-with-resources
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 try-with-resources
- en: Java7 added the notion of `AutoCloseable` and the try-with-resources statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java7 引入了 `AutoCloseable` 的概念和 try-with-resources 语句。
- en: This statement allows us to provide a set of resources that would be automatically
    closed after the code is done with them. No more risk (or at least less risk)
    of forgetting to close a file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明允许我们提供一组资源，这些资源在代码使用完毕后会自动关闭。不再有忘记关闭文件的风险（或者至少风险更小）。
- en: 'Before Java7, that was a total mess:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java7 之前，那是一个完全的混乱：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After Java7:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java7 之后：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Kotlin, the `this` statement is replaced with the `use()` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`this` 语句被 `use()` 函数替换：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inline functions
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数
- en: You can think of inline functions as a copy/paste instruction for the compiler.
    Each time the compiler sees a call to a function marked with inline, it will replace
    the call with the `concrete` function body.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将内联函数视为编译器的复制/粘贴指令。每次编译器看到标记为内联的函数调用时，它都会用具体的函数体替换调用。
- en: 'It makes sense to use the inline function only if it''s a higher-order function
    that receives a lambda as one of its arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当它是一个高阶函数，并且其中一个参数是 lambda 表达式时，才使用内联函数：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the most common use case where you would like to use `inline`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的使用场景，你希望使用 `inline`：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You call it as usual, with the block body:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像往常一样调用它，使用代码块体：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But if you view the bytecode, you''ll see it''s actually translated to the
    lines produces and not to a function call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你查看字节码，你会发现它实际上被转换成了生成的行，而不是函数调用：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the actual code, you''ll see the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，你会看到以下内容：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice there's absolutely no difference between the two blocks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个代码块之间没有任何区别。
- en: Since the inline function is copy/paste, you shouldn't use it if you have more
    than a few lines of code. It would be more efficient to have it as a regular function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内联函数是复制/粘贴的，所以如果你有超过几行代码，就不应该使用它。将其作为常规函数会更有效率。
- en: Reified
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reified
- en: Since the inline function is copied, we can get rid of one of the major JVM
    limitations–type erasure. After all, inside the function, we know exactly what
    type we're getting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内联函数是复制的，我们可以消除 JVM 的一项主要限制——类型擦除。毕竟，在函数内部，我们知道我们得到的确切类型。
- en: Let's look at the following example. You would like to create a generic function,
    which will receive a number but will print it only if it's of the same type as
    the function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。你希望创建一个泛型函数，该函数将接收一个数字，但只有在它与函数类型相同时才会打印它。
- en: 'You can try writing something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试编写如下内容：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But this code won''t compile with an error as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码会因为以下错误而无法编译：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What we usually do in Java, in this case, is pass the class as an argument:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通常在 Java 中这样做，即传递类作为参数：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can check this code by running the following two lines:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下两行来检查这段代码：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code has a few downsides:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个缺点：
- en: 'We had to use reflection, and for that, we had to include the `kotlin-reflect`
    library:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不使用反射，为此，我们必须包含 `kotlin-reflect` 库：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We cannot use the `is` operator and must use the `isInstance()` function instead.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能使用 `is` 操作符，而必须使用 `isInstance()` 函数。
- en: 'We must pass the correct class:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须传递正确的类：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead, we canuse a `reified` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一个 `reified` 函数：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can test that our code still works as expected:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试我们的代码是否仍然按预期工作：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We get all the benefits of the language this way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就能获得该语言的所有好处：
- en: No need for another dependency
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要使用另一个依赖项
- en: Clear method signature
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的方法签名
- en: Ability to use the `is` construct
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `is` 构造的能力
- en: Of course, the same rules as regular inline functions apply. This code would
    be replicated, so it shouldn't be too large.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与常规内联函数相同的规则适用。这段代码将被复制，所以它不应该太大。
- en: 'Consider another case regarding function overloading:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个关于函数重载的例子：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This won''t compile because there''s a platform declaration clash. Both have
    the same signature in terms of JVM: `printList(list: List)`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '这将无法编译，因为存在平台声明冲突。在 JVM 方面，两者具有相同的签名：`printList(list: List)`。'
- en: 'But with `reified`, we can achieve this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用 `reified`，我们可以实现这一点：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Constants
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: Since everything in Java is an object (unless you're a primitive type), we're
    used to putting all the constants inside our objects as static members.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 中的所有内容都是对象（除非你是原始类型），我们习惯于将所有常量作为静态成员放入我们的对象中。
- en: 'And since Kotlin has companion objects, we usually try putting them there:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kotlin 有伴随对象，我们通常尝试将它们放在那里：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will work, but you should remember that companion object is an object,
    after all.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但你应该记住，毕竟伴随对象是一个对象。
- en: 'So, this will be translated to the following code, more or less:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这将被翻译成以下代码，或多或少：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And the call to our constant looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常量的调用看起来像这样：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, we have our class, `Spock`, inside of which we have another class. But what
    we wanted was only `static final String`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `Spock` 类中有一个类，但我们想要的只是 `static final String`。
- en: 'Let''s now mark this value as constant:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这个值标记为常量：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here are the bytecode changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是字节码的变化：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here is the call:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调用：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that there's no call to this constant at all since the compiler already
    inlined its value for us. After all, it's constant.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根本就没有调用这个常量，因为编译器已经为我们内联了它的值。毕竟，它是常量。
- en: 'If all you need is a constant, you can also set it up outside of any class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个常量，你也可以在任何类外部设置它：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And if you need namespacing, you can wrap it in an object:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要命名空间，你可以将其包裹在一个对象中：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Constructor overload
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: 'In Java, we''re used to having overloaded constructors:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们习惯于有重载的构造函数：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can simulate the same behavior in Kotlin:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Kotlin 中模拟相同的行为：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But it''s usually better to have default parameter values and named arguments
    instead:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常更好的做法是使用默认参数值和命名参数：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Dealing with nulls
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空值
- en: Nulls are unavoidable, especially if you work with Java libraries or get data
    from a database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 空值是不可避免的，尤其是在你使用 Java 库或从数据库获取数据时。
- en: 'But you can check for null the Java way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以用 Java 的方式检查空值：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Or in a shorter form, with the `Elvis` operator. If the length is not null,
    this operator will return its value. Otherwise, it will return the default value
    we supplied, zero in this case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者用更短的形式，使用 `Elvis` 操作符。如果长度不为空，这个操作符将返回其值。否则，它将返回我们提供的默认值，在这个例子中是零：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you have a nested object, you can chain those checks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个嵌套对象，你可以链式调用这些检查：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, you can use the `let()` block for those checks:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `let()` 块来进行这些检查：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want to get rid of the `it()` everywhere, you can use run:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要消除所有地方的 `it()`，你可以使用 run：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'By all means, do try to avoid the unsafe `!!` null operator:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免不安全的 `!!` 空值操作符：
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will result in `KotlinNullPointerException`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `KotlinNullPointerException`。
- en: Explicit async
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式异步
- en: 'As you saw in the previous chapter, in Kotlin it is very easy to introduce
    concurrency:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，在 Kotlin 中引入并发非常容易：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But that concurrency may be unexpected behavior to the user of the function,
    as they may expect a simple value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种并发可能对函数的用户来说是不预期的行为，因为他们可能期望一个简单的值：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It prints:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印：
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Of course, what''s missing here is `await()`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里缺少的是 `await()`：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But it would have been a lot more obvious if we''d named our function accordingly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们相应地命名我们的函数，这会显得更加明显：
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As a rule, you should establish some kind of convention to distinguish async
    functions from regular ones.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该建立某种约定来区分异步函数和常规函数。
- en: Validation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'How many times did you have to write code like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次不得不编写如下代码：
- en: '[PRE61]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Instead, you can check arguments with `require()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 `require()` 来检查参数：
- en: '[PRE62]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This makes the code a lot more fluent.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加流畅。
- en: 'You can use `require()` to check for nested nulls:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `require()` 来检查嵌套的空值：
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But there''s also `requireNotNull()` for that:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有 `requireNotNull()` 来处理这种情况：
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use `check()` to validate the state of your object. This is useful when you
    provide some object that the user may not have set up correctly:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `check()` 来验证你对象的状态。这在你提供用户可能没有正确设置的对象时很有用：
- en: '[PRE65]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And again, there''s a shortcut for `null`: `checkNotNull()`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于 `null` 有一个快捷方式：`checkNotNull()`。
- en: Sealed, not enumerated
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封，而不是枚举
- en: 'Coming from Java, you may be tempted to overload your `enum` with functionality:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Java，你可能想给你的 `enum` 赋予功能：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead, you can use the `sealed` class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 `sealed` 类：
- en: '[PRE67]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The benefit of this approach is that we can now pass data around along with
    the status:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，我们现在可以传递数据以及状态：
- en: '[PRE68]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In general, sealed classes are good if you want to have data associated with
    a state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你想要将数据与状态关联起来，密封类是很好的选择。
- en: More companions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多伴随对象
- en: 'You are limited to having only one companion object in your class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能有一个伴随对象在你的类中：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But you can have as many objects in your class as you want:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以在你的类中拥有任意多的对象：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is sometimes used to produce namespacing. Namespacing is important because
    it provides you with better naming conventions. Think about having cases when
    you created classes such as `SimpleJsonParser`, which inherits from `JsonParser`,
    which inherits from `Parser`. You could convert this structure to `Json.Parser`,
    for example, which is much more concise and practical, as Kotlin code should be.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时用于产生命名空间。命名空间很重要，因为它为你提供了更好的命名约定。想想看，当你创建了像 `SimpleJsonParser` 这样的类，它继承自
    `JsonParser`，而 `JsonParser` 又继承自 `Parser` 时的情况。你可以将这个结构转换为 `Json.Parser`，例如，这要简洁得多，也更实用，因为
    Kotlin 代码应该是这样的。
- en: Scala functions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 函数
- en: 'Developers coming into Kotlin from Scala may sometimes define their function
    this way:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Scala 转向 Kotlin 的开发者有时可能会这样定义他们的函数：
- en: '[PRE71]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Calling this function won''t print what you expect:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数不会打印你期望的内容：
- en: '[PRE72]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It prints the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印以下内容：
- en: '[PRE73]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'What we''re missing is the second set of parentheses:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少的是第二组括号：
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It prints the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印以下内容：
- en: '[PRE75]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'That''s because the single-expression definition could be translated into:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为单表达式定义可以翻译成：
- en: '[PRE76]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It could be further translated into:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以进一步翻译成：
- en: '[PRE77]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now you can see where that function came from, at least.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你至少可以看到那个函数的来源了。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed best practices in Kotlin, as well as some of the
    caveats of the language. Now you should be able to write more idiomatic code that
    is also performant and maintainable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 Kotlin 中的最佳实践以及语言的一些注意事项。现在你应该能够编写更符合语言习惯、性能良好且易于维护的代码。
- en: You should make use of scoping functions, but make sure not to overuse them,
    as they may make the code confusing, especially for those newer to the language.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该利用作用域函数，但确保不要过度使用它们，因为它们可能会使代码变得混乱，尤其是对于那些刚开始学习这门语言的人来说。
- en: Be sure to handle nulls and type casts correctly, with `let()`, the `Elvis`
    operator, and smart casts that the language provides.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保正确处理空值和类型转换，使用 `let()`、`Elvis` 操作符以及语言提供的智能转换。
- en: In the next and final chapter, we'll put those skills to use by writing a real-life
    microservice using everything we've learned.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将通过编写一个真实生活中的微服务来应用这些技能，使用我们所学的一切。
