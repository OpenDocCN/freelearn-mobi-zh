- en: 'Chapter 6: Putting Pieces Together'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：整合各个部分
- en: The previous chapters explored various aspects of Jetpack Compose. For example,
    [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding the Declarative
    Paradigm*, compared the traditional View system to composable functions and explained
    the benefits of the declarative approach. [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076),*Laying
    Out UI Elements*, gave you a solid understanding of some built-in layout composables
    such as `Box()`, `Row()`, and `Column()`. In [*Chapter 5*](B17505_05_ePub.xhtml#_idTextAnchor089),
    *Managing the State of Your Composable Functions*, we looked at state and learned
    about the important role it plays in a Compose app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章探讨了Jetpack Compose的各个方面。例如，[*第2章*](B17505_02_ePub.xhtml#_idTextAnchor040)，*理解声明式范式*，将传统的视图系统与组合函数进行了比较，并解释了声明式方法的好处。[*第4章*](B17505_04_ePub.xhtml#_idTextAnchor076)，*布局UI元素*，使你对一些内置布局组合器，如`Box()`、`Row()`和`Column()`，有了扎实的理解。在[*第5章*](B17505_05_ePub.xhtml#_idTextAnchor089)，*管理组合函数的状态*中，我们探讨了状态及其在Compose应用中的重要作用。
- en: Now, it's time to see how these key elements work together in a real-world app.
    In this chapter, you will learn how Compose apps can be themed. We will also look
    at `Scaffold()`, an integrational UI element that picks up quite a few concepts
    that were originally related to activities, such as toolbars and menus, and we
    will learn how to add screen-based navigation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看这些关键元素如何在现实世界的应用中协同工作了。在本章中，您将学习如何为主题化Compose应用。我们还将查看`Scaffold()`，这是一个集成UI元素，它收集了与活动最初相关的一些概念，如工具栏和菜单，我们将学习如何添加基于屏幕的导航。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Styling a Compose app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Compose应用添加样式
- en: Integrating toolbars and menus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成工具栏和菜单
- en: Adding navigation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加导航
- en: We will start by setting up a custom theme for a Compose app. You can define
    quite a few colors, shapes, and text styles that the built-in Material composables
    will use when drawing themselves. I will also show you what to keep in mind when
    you're adding additional Jetpack components that rely on app themes, such as *Jetpack
    Core Splashscreen*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为Compose应用设置一个自定义主题。您可以定义很多颜色、形状和文本样式，内置的Material组合器在绘制自身时将使用这些样式。我还会向您展示在添加依赖于应用主题的额外Jetpack组件时需要注意的事项，例如*Jetpack
    Core Splashscreen*。
- en: The following section, *Integrating toolbars and menus*, will introduce you
    to app bars and the options menu. You will also learn how to create snack bars.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，*集成工具栏和菜单*中，我们将向您介绍应用栏和选项菜单。您还将学习如何创建snack bars。
- en: In the final main section, *Adding navigation*, I will show you how to structure
    your app into screens. We will use the Compose version of *Jetpack Navigation*
    to navigate between them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的主体部分，*添加导航*，我将向您展示如何将您的应用结构化为屏幕。我们将使用*Jetpack Navigation*的Compose版本在它们之间进行导航。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes one sample app, `ComposeUnitConverter`, as shown in the
    following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一个示例应用，`ComposeUnitConverter`，如下截图所示：
- en: '![Figure 6.1 – The ComposeUnitConverter app'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – ComposeUnitConverter应用'
- en: '](img/B17505_06_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_06_1.jpg)'
- en: Figure 6.1 – The ComposeUnitConverter app
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – ComposeUnitConverter应用
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio, as well as how to get the repository that accompanies this
    book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第1章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个Compose应用*中的*技术要求*部分，了解如何安装和设置Android
    Studio，以及如何获取本书的配套仓库。
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06)。
- en: Styling a Compose app
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Compose应用添加样式
- en: Most of your Compose UI will likely use the built-in composable functions from
    the `androidx.compose.material` package. They implement the design language known
    as **Material Design** and its successor, **Material You** (which was introduced
    with Android 12). Material You is the native design language on Android, though
    it will also be available on other platforms. It expands on the ideas of a pen,
    paper, and cards, and makes heavy use of grid-based layouts, responsive animations,
    and transitions, as well as padding and depth effects. Material You advocates
    larger buttons and rounded corners. Custom color themes can be generated from
    the user's wallpaper.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分Compose UI可能都会使用来自`androidx.compose.material`包的内置可组合函数。它们实现了被称为**Material
    Design**的设计语言及其继任者**Material You**（随着Android 12的推出而引入）。Material You是Android的原生设计语言，尽管它也将在其他平台上可用。它扩展了笔、纸和卡片的概念，并大量使用基于网格的布局、响应式动画和过渡，以及填充和深度效果。Material
    You提倡更大的按钮和圆角。可以从用户的壁纸生成自定义颜色主题。
- en: Defining colors, shapes, and text styles
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义颜色、形状和文本样式
- en: While apps should certainly honor both system and user preferences regarding
    visual appearance, you may want to add colors, shapes, or text styles that reflect
    your brand or corporate identity. So, how can you modify the look of the built-in
    Material composable functions?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用应该当然尊重系统和使用者对视觉外观的偏好，但你可能希望添加反映你的品牌或企业身份的颜色、形状或文本样式。那么，你如何修改内置的Material可组合函数的外观？
- en: 'The main entry point to Material Theming is `MaterialTheme()`. This composable
    may receive custom colors, shapes, and text styles. If a value is not set, a corresponding
    default (`MaterialTheme.colors`, `MaterialTheme.typography`, or `MaterialTheme.shapes`)
    is used. The following theme sets custom colors but leaves the text styles and
    shapes as their defaults:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 材料主题化的主要入口点是`MaterialTheme()`。这个可组合函数可以接收自定义颜色、形状和文本样式。如果没有设置值，则使用相应的默认值（`MaterialTheme.colors`、`MaterialTheme.typography`或`MaterialTheme.shapes`）。以下主题设置了自定义颜色，但将文本样式和形状保留为默认值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `isSystemInDarkTheme()` composable detects if the device is currently using
    a dark theme. Your app should use colors that suit this configuration. My example
    has two palettes, `DarkColorPalette` and `LightColorPalette`. Here''s how the
    latter one is defined:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSystemInDarkTheme()`可组合函数检测设备当前是否正在使用深色主题。你的应用应该使用适合这种配置的颜色。我的例子有两个调色板，`DarkColorPalette`和`LightColorPalette`。以下是后者的定义方式：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`lightColors()` is a top-level function inside the `androidx.compose.material`
    package. It provides a complete color definition for the Material color specification.
    You can     find more information about this at [https://material.io/design/color/the-color-system.html#color-theme-creation](https://material.io/design/color/the-color-system.html#color-theme-creation).
    `LightColorPalette` overrides the default values for primary, `primaryVariant`,
    secondary, and `secondaryVariant`. All the others (there are, for example, `background`,
    `surface`, and `onPrimary`) remain unchanged.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`lightColors()`是`androidx.compose.material`包中的一个顶级函数。它为Material颜色规范提供了完整的颜色定义。你可以在[https://material.io/design/color/the-color-system.html#color-theme-creation](https://material.io/design/color/the-color-system.html#color-theme-creation)找到更多关于此的信息。`LightColorPalette`覆盖了默认的primary、`primaryVariant`、secondary和`secondaryVariant`值。所有其他（例如，`background`、`surface`和`onPrimary`）保持不变。'
- en: '`primary` will be displayed most frequently across your app''s screens and
    components. With `secondary`, you can accent and distinguish your app. It is,
    for example, used for radio buttons. The checked thumb color of switches is `secondaryVariant`,
    whereas the unchecked thumb color is taken from `surface`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`primary`将在你的应用屏幕和组件中显示得最频繁。使用`secondary`，你可以突出和区分你的应用。例如，它用于单选按钮。开关的选中拇指颜色是`secondaryVariant`，而未选中拇指颜色则来自`surface`。'
- en: Tip
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Material composables typically receive their default colors from composable
    functions called `colors()`, which belong to their accompanying `…Defaults` objects.
    For example, `Switch()` invokes `SwitchDefaults.colors()` if no color parameter
    is passed to `Switch()`. By looking at these `colors()` functions, you can find
    out which color attribute you should set in your theme.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 材料可组合函数通常从名为`colors()`的可组合函数接收默认颜色，这些函数属于它们的伴随`…Defaults`对象。例如，如果没有传递颜色参数给`Switch()`，则`Switch()`会调用`SwitchDefaults.colors()`。通过查看这些`colors()`函数，你可以找出在你的主题中应该设置哪个颜色属性。
- en: 'You may be wondering how I defined, for example, `AndroidGreen`. The simplest
    way to achieve this is like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我是如何定义例如`AndroidGreen`的。实现这一点的最简单方法是这样的：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works great if your app does not require other libraries or components
    that rely on the traditional Android theming system. We will turn to such scenarios
    in the *Using resource-based themes* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用不需要其他库或组件，这些库或组件依赖于传统的Android主题系统，这将非常有效。我们将在*使用基于资源的主题*部分转向这些场景。
- en: 'Besides colors, `MaterialTheme()` allows you to provide alternative shapes.
    Shapes direct attention and communicate state. Material composables are grouped
    into shape categories based on their size:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色之外，`MaterialTheme()`还允许你提供替代形状。形状引导注意力并传达状态。基于大小，Material可组合项被分组到形状类别中：
- en: Small (buttons, snack bars, tooltips, and more)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型（按钮、snack bars、工具提示等）
- en: Medium (cards, dialog, menus, and more)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中型（卡片、对话框、菜单等）
- en: Large (sheets and drawers, and more)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型（纸张和抽屉等）
- en: To pass an alternative set of shapes to `MaterialTheme()`, you must instantiate
    `androidx.compose.material.Shapes` and provide implementations of the `androidx.compose.foundation.shape.CornerBasedShape`
    abstract class for the categories you want to modify (`small`, `medium`, and `large`).
    `AbsoluteCutCornerShape`, `CutCornerShape`, `AbsoluteRoundedCornerShape`, and
    `RoundedCornerShape` are direct subclasses of `CornerBasedShape`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递给`MaterialTheme()`的替代形状集，你必须实例化`androidx.compose.material.Shapes`，并为你想要修改的类别（`small`、`medium`和`large`）提供`androidx.compose.foundation.shape.CornerBasedShape`抽象类的实现。`AbsoluteCutCornerShape`、`CutCornerShape`、`AbsoluteRoundedCornerShape`和`RoundedCornerShape`是`CornerBasedShape`的直接子类。
- en: 'The following screenshot shows a button with cut corners. While this makes
    the button look less familiar, it gives your app a distinctive look. You should,
    however, ensure that you want to add this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个带有切角的按钮。虽然这使按钮看起来不那么熟悉，但它给你的应用带来了一种独特的风格。然而，你应该确保你想要添加这个：
- en: '![Figure 6.2 – A button with cut corners'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.2 – A button with cut corners'
- en: '](img/B17505_06_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_06_2.jpg](img/B17505_06_2.jpg)'
- en: Figure 6.2 – A button with cut corners
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 带有切角的按钮
- en: 'To achieve this, just add the following line when invoking `MaterialTheme()`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，只需在调用`MaterialTheme()`时添加以下行：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can find more information about applying shapes to UIs at [https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme](https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme](https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme)找到有关将形状应用于UI的更多信息。
- en: To alter the text styles that are used by Material composable functions, you
    need to pass an instance of `androidx.compose.material.Typography` to `MaterialTheme()`.
    `Typography` receives quite a few parameters, such as `h1`, `subtitle1`, `body1`,
    `button`, and `caption`. All of these are instances of `androidx.compose.ui.text.TextStyle`.
    If you do not pass a value for a parameter, a default is used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改Material可组合函数使用的文本样式，你需要将`androidx.compose.material.Typography`的实例传递给`MaterialTheme()`。`Typography`接收许多参数，例如`h1`、`subtitle1`、`body1`、`button`和`caption`。所有这些都是`androidx.compose.ui.text.TextStyle`的实例。如果你没有为参数传递值，则使用默认值。
- en: 'The following code block increases the text size of buttons:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块增加了按钮的文本大小：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you add this line to the invocation of `MaterialTheme()`, the text of all
    the buttons using your theme will be 24 scale-independent pixels tall. But how
    do you set the theme? To make sure that your complete Compose UI uses it, you
    should invoke your theme as early as possible:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此行添加到`MaterialTheme()`的调用中，使用你的主题的所有按钮的文本将高24个缩放无关像素。但如何设置主题？为了确保你的完整Compose
    UI使用它，你应该尽早调用你的主题：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In my example, `ComposeUnitConverter()` is the root of the app''s composable
    UI hierarchy since it is invoked inside `setContent {}`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，`ComposeUnitConverter()`是应用的可组合UI层次结构的根，因为它在`setContent {}`内部被调用：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ComposeUnitConverter()` immediately delegates to `ComposeUnitConverterTheme
    {}`, which receives the remaining UI as its content. `Scaffold()` is a skeleton
    for real-world Compose UIs. We will be taking a closer look at this in the *Integrating
    toolbars and menus* section.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComposeUnitConverter()`立即委托给`ComposeUnitConverterTheme {}`，它接收剩余的UI作为其内容。`Scaffold()`是现实世界Compose
    UI的骨架。我们将在*集成工具栏和菜单*部分更详细地探讨这一点。'
- en: 'If you need to style parts of your app differently, you can nest themes by
    overriding your parent theme (*Figure 6.3*). Let''s see how this works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要以不同的方式样式化应用的部分，你可以通过覆盖父主题（*图6.3*）来嵌套主题。让我们看看这是如何工作的：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code snippet, the base theme configures any text that is styled
    as `h1` so that it appears in red. The second `Text()` uses a nested theme that
    styles `h1` to appear in blue. So, it overrides the parent theme:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，基本主题配置了任何被样式化为`h1`的文本，使其显示为红色。第二个`Text()`使用嵌套主题将`h1`样式化为蓝色。因此，它覆盖了父主题：
- en: '![Figure 6.3 – Nesting themes'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 嵌套主题'
- en: '](img/B17505_06_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17505_06_3.jpg](img/B17505_06_3.jpg)'
- en: Figure 6.3 – Nesting themes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 嵌套主题
- en: Please Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: All the parts of your app must have a consistent look. Consequently, you should
    use nested themes carefully.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您应用的所有部分都必须具有一致的外观。因此，您应谨慎使用嵌套主题。
- en: In the next section, we will continue exploring styles and themes. We will look
    at how themes are set in the manifest file, as well as how libraries may influence
    the way you define your Compose theme.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续探讨样式和主题。我们将查看如何在清单文件中设置主题，以及库如何影响您定义Compose主题的方式。
- en: Using resource-based themes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于资源的主题
- en: App styling or theming has been present on Android since API level 1\. It is
    based on resource files. Conceptually, there is a distinction between styles and
    themes. A **style** is a collection of attributes that specify the appearance
    (for example, font color, font size, or background color) of a single View. Consequently,
    styles do not matter for composable functions. A **theme** is also a collection
    of attributes, but'it's applied to an entire app, activity, or View hierarchy.
    Many elements of a Compose app are provided by Material composables; for them,
    a resource-based theme does not matter either. However, themes can apply styles
    to non-View elements, such as the status bar and window background. This may be
    relevant for a Compose app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自API级别1以来，Android上就存在应用样式或主题。它基于资源文件。从概念上讲，样式和主题之间有一个区别。**样式**是一组属性，用于指定单个视图的外观（例如，字体颜色、字体大小或背景颜色）。因此，样式对可组合函数不重要。**主题**也是一组属性，但它应用于整个应用、活动或视图层次结构。Compose应用中的许多元素由Material可组合元素提供；对于它们，基于资源的主题也不重要。然而，主题可以将样式应用于非视图元素，如状态栏和窗口背景。这可能对Compose应用相关。
- en: 'Styles and themes are declared in XML files inside the `res/values` directory
    and are typically named `styles.xml` and `themes.xml`, depending on the content.
    A theme is applied to the application or activity inside the manifest file with
    the `android:theme` attribute of the `<application />` or `<activity />` tag.
    If none of them receives a theme, `ComposeUnitConverter` will look as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 样式和主题在`res/values`目录内的XML文件中声明，通常根据内容命名为`styles.xml`和`themes.xml`。主题通过清单文件中`<application
    />`或`<activity />`标签的`android:theme`属性应用于应用或活动。如果没有它们接收主题，`ComposeUnitConverter`将如下所示：
- en: '![Figure 6.4 – Compose Unit Converter showing an additional title bar'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 组合单元转换器显示了一个额外的标题栏'
- en: '](img/B17505_06_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17505_06_4.jpg](img/B17505_06_4.jpg)'
- en: Figure 6.4 – Compose Unit Converter showing an additional title bar
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 组合单元转换器显示了一个额外的标题栏
- en: To avoid the unwanted additional title bar, Compose apps must configure a theme
    without action bars, such as `Theme.AppCompat.DayNight.NoActionBar`, using `android:the"e="@styl"/…"`
    for `<application />` or `<activity />`. This way, `ComposeUnitConverter` looks
    like *Figure 6.1*. Have you noticed that the status bar has a dark gray background?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不想要的额外标题栏，Compose应用必须配置一个没有操作栏的主题，例如`Theme.AppCompat.DayNight.NoActionBar`，使用`android:theme="@style/..."`为`<application
    />`或`<activity />`。这样，`ComposeUnitConverter`看起来就像图6.1。您注意到状态栏有深灰色背景吗？
- en: 'When `Theme.AppCompat.DayNight` is used, the status bar receives its background
    color from the `colorPrimaryDark` theme attribute (or `android:statusBarColor`
    since API level 21). If no value is specified, a default is used. Therefore, to
    make sure that the status bar is shown in a color that fits the remaining UI elements,
    you must add a file named `themes.xml` to `res/values`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Theme.AppCompat.DayNight`时，状态栏从`colorPrimaryDark`主题属性（或自API级别21以来的`android:statusBarColor`）接收其背景颜色。如果没有指定值，则使用默认值。因此，为了确保状态栏以适合剩余UI元素的颜色显示，您必须在`res/values`中添加一个名为`themes.xml`的文件：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the manifest file, the value of `android:theme` must then be changed to
    `@style/Theme.ComposeUnitConverter`. `@color/android_green_dark` represents the
    color. Instead of this expression, you could also pass the value directly; for
    example, `#FF20B261`. It is, however, best practice to store it in a file named
    `colors.xml` inside `res/values`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中，`android:theme`的值必须更改为`@style/Theme.ComposeUnitConverter`。`@color/android_green_dark`代表颜色。除了这个表达式，你也可以直接传递值；例如，`#FF20B261`。然而，将它们存储在`res/values`目录下的名为`colors.xml`的文件中是最佳实践：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This way, you can assign a different value for the Dark theme. The following
    version of `themes.xml` should be put in `res/values-night`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以为深色主题分配不同的值。以下版本的`themes.xml`应该放在`res/values-night`中：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The status bar now has a background color that fits the remaining UI elements.
    However, we need to define colors in two places: `colors.xml` and the Compose
    theme. Fortunately, this is rather easy to fix. Usually, we pass a literal, like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态栏的背景颜色与剩余的UI元素相匹配。但是，我们需要在两个地方定义颜色：`colors.xml`和Compose主题。幸运的是，这很容易解决。通常，我们传递一个字面量，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of doing this, we should obtain the value from the resources. The `colorResource()`
    composable function belongs to the `androidx.compose.ui.res` package. It returns
    the color associated with a resource that's identified by an ID.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样做，我们应该从资源中获取值。`colorResource()`可组合函数属于`androidx.compose.ui.res`包。它返回与ID标识的资源相关联的颜色。
- en: 'The following palette does not specify a `secondary` color:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调色板未指定一个`二级`颜色：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding a color using `colorResource()` works as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`colorResource()`添加颜色的工作方式如下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You saw most of this in the *Defining colors, shapes, and text styles* section.
    The important difference is that I created a modified version of `LightColorPalette`
    (with a secondary     color) using `copy()`, which is then passed to `MaterialTheme()`. If you store
    all the colors inside `colors.xml`, you should create your palettes completely
    inside your theme composable.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*定义颜色、形状和文本样式*部分看到了大部分内容。重要的区别在于我使用`copy()`创建了一个修改版的`LightColorPalette`（带有二级颜色），然后将其传递给`MaterialTheme()`。如果你将所有颜色存储在`colors.xml`中，你应该完全在你的主题可组合中创建你的调色板。
- en: 'As you have seen, you may need to provide some values for resource-based themes,
    depending on how heavily you want to brand your app. Additionally, certain non-Compose
    Jetpack libraries use themes too, such as *Jetpack Core Splashscreen*. This component
    makes the advanced splash screen features of Android 12 available on older platforms.
    The images and colors of the splash screen are configured through theme attributes.
    The library requires that the theme of the starting activity has `Theme.SplashScreen`     as its parent. Additionally, the theme must provide the `postSplashScreenTheme`     attribute, which refers to the theme to use once the splash screen has been dismissed.You
    can find more information about splash screens on Android at [https://developer.android.com/guide/topics/ui/splash-screen](https://developer.android.com/guide/topics/ui/splash-screen).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可能需要为基于资源的主题提供一些值，这取决于你想要如何强烈地品牌你的应用。此外，某些非Compose Jetpack库也使用主题，例如*Jetpack
    Core Splashscreen*。这个组件使得Android 12的高级启动屏幕功能在旧平台上可用。启动屏幕的图像和颜色通过主题属性进行配置。库要求启动活动的主题具有`Theme.SplashScreen`作为其父主题。此外，主题必须提供`postSplashScreenTheme`属性，该属性指向启动屏幕关闭后要使用的主题。你可以在Android开发者文档中找到有关启动屏幕的更多信息：[https://developer.android.com/guide/topics/ui/splash-screen](https://developer.android.com/guide/topics/ui/splash-screen)。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To ensure consistent use of colors, the `colors.xml` file should be the single
    point of truth in your app, if more than one component relies on resource-based
    themes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保颜色的一致使用，如果多个组件依赖于基于资源的主题，`colors.xml`文件应该是你应用中的单一真相来源。
- en: This concludes our look at Compose themes. In the next section, we will turn
    to an important integrational UI element called `Scaffold()` acts as a frame for
    your content, providing support for top and bottom bars, navigation, and actions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Compose主题的探讨。在下一节中，我们将转向一个重要的集成UI元素，称为`Scaffold()`，它充当内容的框架，提供顶部和底部栏、导航和操作的支持。
- en: Integrating toolbars and menus
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成工具栏和菜单
- en: Early Android versions did not know about action or app bars. They were introduced
    with API level 11 (Honeycomb). The options menu, on the other hand, has been around
    since the beginning but was opened by pressing a dedicated hardware button and
    shown at the bottom of the screen. With Android 3, it moved to the top and became
    a vertical list. Some elements could be made available permanently as actions.
    In a way, the options menu and the action bar merged. While originally, all the
    aspects of the action bar were handled by the hosting activity, the `AppCompat`
    support library introduced an alternative implementation (`getSupportActionBar()`).
    It is still widely used today as part of Jetpack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 早期安卓版本并不知道动作或应用栏的存在。它们是在API级别11（蜂巢）中引入的。另一方面，选项菜单从一开始就存在，但需要通过按下专用硬件按钮来打开，并显示在屏幕底部。在安卓3中，它移动到了顶部，并变成了一个垂直列表。一些元素可以作为动作永久显示。从某种意义上说，选项菜单和动作栏合并了。最初，动作栏的所有方面都由宿主活动处理，但`AppCompat`支持库引入了另一种实现（`getSupportActionBar()`）。它至今仍作为Jetpack的一部分被广泛使用。
- en: Using Scaffold() to structure your screen
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scaffold()来结构化你的屏幕
- en: 'Jetpack Compose includes several app bar implementations that closely follow
    Material Design or Material You specifications. They can be added to a Compose
    UI through `Scaffold()`, a composable function that acts as an app frame or skeleton.
    The following code snippet is the root of the `ComposeUnitConverter` UI. It sets
    up the theme and then delegates it to `Scaffold()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose包含几个与Material Design或Material You规范紧密相关的应用栏实现。它们可以通过`Scaffold()`添加到Compose
    UI中，这是一个充当应用框架或骨骼的可组合函数。以下代码片段是`ComposeUnitConverter` UI的根。它设置主题，然后委托给`Scaffold()`：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Scaffold()` implements the basic Material Design visual layout structure.
    You can add several other Material composables, such as `TopAppBar()` or `BottomNavigation()`.
    Google calls this a `Scaffold()` may need to remember different states. You can
    pass a `ScaffoldState`, which can be created with `rememberScaffoldState()`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scaffold()`实现了基本的Material Design视觉布局结构。你可以添加其他几个Material可组合函数，如`TopAppBar()`或`BottomNavigation()`。谷歌称这为`Scaffold()`可能需要记住不同的状态。你可以传递一个`ScaffoldState`，它可以通过`rememberScaffoldState()`创建。'
- en: My example uses `ScaffoldState` to show a snack bar, a brief temporary message
    that appears toward the bottom of the screen. As `showSnackbar()` is a suspending
    function, it must be called from a coroutine or another suspending function. Therefore,
    we must create and remember a `CoroutineScope` using `rememberCoroutineScope()`
    and invoke its `launch {}` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例使用`ScaffoldState`来显示一个snackbar，这是一个出现在屏幕底部的简短临时消息。由于`showSnackbar()`是一个挂起函数，它必须从协程或另一个挂起函数中调用。因此，我们必须使用`rememberCoroutineScope()`创建和记住一个`CoroutineScope`，并调用其`launch
    {}`函数。
- en: In the next section, I will show you how to create a top app bar with an options
    menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向你展示如何创建一个带有选项菜单的顶部应用栏。
- en: Creating a top app bar
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建顶部应用栏
- en: 'App bars at the top of the screen are implemented using `TopAppBar()`. You
    can provide a navigation icon, a title, and a list of actions here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕顶部的应用栏是通过`TopAppBar()`实现的。你可以在这里提供一个导航图标、标题和动作列表：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`TopAppBar()` has no specific API for an options menu. Instead, the menu is
    treated as an ordinary action. Actions are typically `IconButton()` composables.
    They are displayed at the end of the app bar in a horizontal row. An `IconButton()`
    receives an `onClick` callback and an optional `enabled` parameter, which controls
    if the user can interact with the UI element.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopAppBar()`没有针对选项菜单的特定API。相反，菜单被当作普通动作处理。动作通常是`IconButton()`可组合函数。它们以水平行的形式显示在应用栏的末尾。一个`IconButton()`接收一个`onClick`回调和一个可选的`enabled`参数，该参数控制用户是否可以与UI元素交互。'
- en: In my example, the callback only sets a `Boolean` mutable state (`menuOpened`)
    to `false`. As you will see shortly, this closes the menu. `content` (usually
    an icon) is drawn inside the button. The `Icon()` composable receives an instance
    of `ImageVector` and a content description. You can get icon data from the resources,
    but you should use predefined graphics if possible – in my example, `Icons.Default.MoreVert`.
    Next, let's learn how to display a menu.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，回调仅将一个`Boolean`可变状态（`menuOpened`）设置为`false`。正如你很快就会看到的，这将关闭菜单。`content`（通常是一个图标）被绘制在按钮内部。`Icon()`可组合函数接收一个`ImageVector`实例和一个内容描述。你可以从资源中获取图标数据，但如果可能的话，应使用预定义的图形
    – 在我的示例中，`Icons.Default.MoreVert`。接下来，让我们学习如何显示菜单。
- en: A Material Design drop-down menu (`DropdownMenu()`) allows you to display multiple
    choices compactly. It usually appears when you interact with another element,
    such as a button. My example places `DropdownMenu()` in a `Box()` with an `IconButton()`,
    which determines the location on-screen. The expanded parameter makes the menu
    visible (open) or invisible (closed). `onDismissRequest` is called when the user
    requests to dismiss the menu, such as by tapping outside the menu's bounds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design 下拉菜单 (`DropdownMenu()`) 允许您紧凑地显示多个选择。它通常在您与另一个元素（如按钮）交互时出现。我的例子将
    `DropdownMenu()` 放置在 `Box()` 中，并使用 `IconButton()` 确定屏幕上的位置。展开参数使菜单可见（打开）或不可见（关闭）。当用户请求关闭菜单，例如通过在菜单边界外轻触时，会调用
    `onDismissRequest`。
- en: The content should consist of `DropdownMenuItem()` composables. `onClick` is
    called when the corresponding menu item is clicked. Your code must make sure that
    the menu is closed. If possible, you should pass the domain logic to be executed
    as a parameter to make your code reusable and stateless. In my example, a snack
    bar is shown.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内容应包含 `DropdownMenuItem()` 组合器。当点击相应的菜单项时，会调用 `onClick`。您的代码必须确保菜单被关闭。如果可能，您应该将执行的域逻辑作为参数传递，以便使您的代码可重用且无状态。在我的例子中，显示了一个
    snack bar。
- en: This concludes our look at top app bars. In the next section, I will show you
    how to use `BottomNavigation()` to navigate to different screens using the Compose
    version of Jetpack Navigation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对顶级应用栏的探讨。在下一节中，我将向您展示如何使用 `BottomNavigation()` 通过 Jetpack Navigation
    的 Compose 版本在不同的屏幕间进行导航。
- en: Please Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: To use the Compose version of Jetpack Navigation in your app, you must add an
    implementation dependency of `androidx.navigation:navigation-compose` to your
    module-level `build.gradle` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用中使用 Jetpack Navigation 的 Compose 版本，您必须将 `androidx.navigation:navigation-compose`
    的实现依赖项添加到您的模块级 `build.gradle` 文件中。
- en: Adding navigation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加导航
- en: '`Scaffold()` allows you to put content in a slot at the bottom of the screen
    using its `bottomBar` parameter. This can, for example, be a `BottomAppBar()`.
    Material Design bottom app bars provide access to a bottom navigation drawer and
    up to four actions, including a floating action button. `ComposeUnitConverter`
    adds `BottomNavigation()` instead. Material Design bottom navigation bars allow
    movement between primary destinations in an app.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scaffold()` 允许您使用其 `bottomBar` 参数在屏幕底部放置内容。例如，这可以是一个 `BottomAppBar()`。Material
    Design 底部应用栏提供访问底部导航抽屉以及最多四个操作，包括一个浮动操作按钮。`ComposeUnitConverter` 则添加了 `BottomNavigation()`。Material
    Design 底部导航栏允许在应用中的主要目的地之间进行切换。'
- en: Defining screens
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义屏幕
- en: 'Conceptually, primary destinations are *screens*, something that, before Jetpack
    Compose, may have been displayed in separate activities. Here''s how screens are
    defined in `ComposeUnitConverter`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，主要目的地是 *屏幕*，在 Jetpack Compose 之前，这可能是显示在单独的活动中的。以下是 `ComposeUnitConverter`
    中定义屏幕的方式：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ComposeUnitConverter` consists of two screens – `Temperature` and `Distances`.
    `route` uniquely identifies a screen. `label` and `icon` are shown to the user.
    Let''s see how this is done:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComposeUnitConverter` 由两个屏幕组成——`Temperature` 和 `Distances`。`route` 唯一标识一个屏幕。`label`
    和 `icon` 将显示给用户。让我们看看这是如何实现的：'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The content of `BottomNavigation()` consists of `BottomNavigationItem()` items.
    Each item represents a *destination*. We can add them with a simple loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`BottomNavigation()` 的内容由 `BottomNavigationItem()` 项目组成。每个项目代表一个 *目的地*。我们可以通过简单的循环来添加它们：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the `label` and `icon` properties of a `ComposeUnitConverterScreen`
    instance are used during the invocation of `BottomNavigationItem()`. `alwaysShowLabel`
    controls if the label is visible when an item is selected. An item will be selected
    if the corresponding screen is currently displayed. When a `BottomNavigationItem()`
    is clicked, its `onClick` callback is invoked. My implementation calls `navigate()`
    on the provided `NavHostController` instance, passing `route` from the corresponding
    `ComposeUnitConverterScreen` object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ComposeUnitConverterScreen` 实例的 `label` 和 `icon` 属性在调用 `BottomNavigationItem()`
    时被使用。`alwaysShowLabel` 控制当项目被选中时标签是否可见。如果相应的屏幕当前正在显示，则项目将被选中。当点击 `BottomNavigationItem()`
    时，会调用其 `onClick` 回调。我的实现调用提供的 `NavHostController` 实例上的 `navigate()`，传递来自相应的 `ComposeUnitConverterScreen`
    对象的 `route`。
- en: So far, we have defined screens and mapped them to `BottomNavigationItem()`
    items. When an item is clicked, the app navigates to a given route. But how do
    routes relate to composable functions? I will show you in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了屏幕并将它们映射到 `BottomNavigationItem()` 项目上。当点击一个项目时，应用程序会导航到指定的路由。但是，路由是如何与可组合函数相关的呢？我将在下一节中向你展示。
- en: Using NavHostController and NavHost()
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NavHostController 和 NavHost()
- en: 'An instance of `NavHostController` allows us to navigate to different screens
    by calling its `navigate()` function. We can obtain a reference to it inside `ComposeUnitConverter()`
    by invoking `rememberNavController()`, and then passing it to `ComposeUnitConverterBottomBar()`.
    The mapping between a route and a composable function is established through `NavHost()`.
    It belongs to the `androidx.navigation.compose` package. Here''s how this composable
    is invoked:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `NavHostController` 的实例允许我们通过调用其 `navigate()` 函数来导航到不同的屏幕。我们可以在 `ComposeUnitConverter()`
    内部通过调用 `rememberNavController()` 获取其引用，然后将其传递给 `ComposeUnitConverterBottomBar()`。路由与可组合函数之间的映射是通过
    `NavHost()` 建立的。它属于 `androidx.navigation.compose` 包。以下是这个可组合函数的调用方式：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`NavHost()` receives three parameters:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavHost()` 接收三个参数：'
- en: A reference to our `NavHostController`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们 `NavHostController` 的引用
- en: The route for the start destination
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始目的地的路由
- en: The builder that was used to construct the navigation graph
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建导航图的构建器
- en: Before Jetpack Compose, the navigation graph was usually defined through an
    XML file. `NavGraphBuilder` provides access to a simple domain-specific language.
    `composable()` adds a composable function as a destination. Besides the route,
    you can pass a list of arguments and a list of deep links.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 之前，导航图通常通过一个 XML 文件定义。`NavGraphBuilder` 提供了对简单领域特定语言的访问。`composable()`
    添加一个可组合函数作为目的地。除了路由之外，你还可以传递一个参数列表和一个深度链接列表。
- en: Tip
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A detailed description of Jetpack Navigation is beyond the scope of this book.
    You can find more information at [https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Navigation 的详细描述超出了本书的范围。你可以在[https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation)找到更多信息。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showcased how key elements of Jetpack Compose work together in
    a real-world app. You learned how to theme Compose apps and how to keep your Compose
    theme in sync with resource-based themes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了 Jetpack Compose 的关键元素如何在真实世界的应用程序中协同工作。你学习了如何为主题 Compose 应用程序以及如何保持 Compose
    主题与基于资源的主题同步。
- en: I also showed you how `Scaffold()` acts as an app frame or skeleton. We used
    its slot API to plug in a top app bar with a menu, as well as a bottom bar to
    navigate between screens using the Compose version of Jetpack Navigation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向你展示了 `Scaffold()` 如何充当应用程序框架或骨架。我们使用其槽 API 插入了一个带有菜单的顶部应用程序栏，以及一个底部栏，用于使用
    Jetpack Navigation 的 Compose 版本在屏幕之间导航。
- en: In the next chapter, *Tips, Tricks, and Best Practices*, we will discuss how
    to separate UI and business logic. We will revisit `ComposeUnitConverter`, this
    time focusing on its use of ViewModels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，“技巧、窍门和最佳实践”中，我们将讨论如何分离 UI 和业务逻辑。我们将重新访问 `ComposeUnitConverter`，这次将重点介绍其使用
    ViewModel 的方式。
