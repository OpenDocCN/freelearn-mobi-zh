- en: Chapter 4. Fling App – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Fling应用 – 第2部分
- en: 'In [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, you learned to use the MIT App Inventor Designer and Blocks Editor
    by creating your first fully functional mobile app! In this chapter, we will show
    you how you can take the basic Fling app and build it out by adding more complex
    features. We will demonstrate how to enable:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc "第3章。导航App
    Inventor平台")，“导航App Inventor平台”，你通过创建你的第一个完全功能性的移动应用学习了如何使用MIT App Inventor设计器和块编辑器！在本章中，我们将向你展示如何通过添加更多复杂的功能来扩展基本的Fling应用。我们将演示如何启用：
- en: A scoring mechanism that will display when the ball touches the top edge
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当球触碰到顶部边缘时显示的得分机制
- en: Code, so the ball can only be flung from the lower half of the screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码，因此球只能从屏幕的下半部分抛出
- en: The increasing levels of difficulty by increasing ball speed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加球速来增加难度级别
- en: We will also begin debugging. Debugging is a standard practice in app development
    and should be viewed as part of the process, not as something negative.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开始调试。调试是应用开发中的标准实践，应将其视为流程的一部分，而不是消极的东西。
- en: 'Each time you add new components to your app, we encourage you to share your
    app with others to get feedback. Not only will the feedback give you ideas about
    the design, but it will also help you learn what users want from an app game.
    Such information will prove invaluable once you begin designing apps from scratch.
    This chapter will not only help you discover new ways to enhance a game app, it
    will also trigger new paths of creativity! By the end of this chapter, your Fling
    app will resemble the following image:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你向你的应用添加新组件时，我们鼓励你与他人分享你的应用以获取反馈。这不仅会给你的设计提供想法，而且还会帮助你了解用户对应用游戏的需求。一旦你开始从头设计应用，此类信息将非常有价值。本章不仅将帮助你发现增强游戏应用的新方法，还会激发新的创意路径！到本章结束时，你的Fling应用将类似于以下图像：
- en: '![Fling App – Part 2](img/00109.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Fling应用 – 第2部分](img/00109.jpeg)'
- en: Adding a scoring feature
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加得分功能
- en: Since most game apps include some sort of scoring feature, we will add this
    code to our Fling app. The score will display in the same label that will also
    display the **Game Over** text.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数游戏应用都包含某种得分功能，因此我们将此代码添加到我们的Fling应用中。得分将显示在同一个标签上，该标签也会显示**游戏结束**文本。
- en: Coding scoring blocks
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码得分块
- en: 'We left off in the last chapter with the ball bouncing off all the edges except
    the bottom edge. Now, we want to program the app to increase the score by one
    point every time the ball reaches the top edge. We will use another **if**/**then**
    block and add it into the **else** portion of the existing **if/then/else** block
    within the **when** **Ball1.EdgeReached** event, as shown in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上章中留下了球从所有边缘弹回，除了底部边缘。现在，我们想要编程应用，以便每次球达到顶部边缘时增加一分。我们将使用另一个**if**/**then**块，并将其添加到**when**
    **Ball1.EdgeReached**事件中现有的**if/then/else**块的**else**部分，如图所示：
- en: '![Coding scoring blocks](img/00110.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00110.jpeg)'
- en: Can you guess what block will fit in the **if** opening? If the ball hits the
    top edge, then the app will increase the score by **1**. In [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, you learned that the bottom edge is represented by **-1** (and the
    top edge is represented by 1). Since we've already created an if/then scenario
    for the ball hitting the bottom edge, we can copy this set of blocks and adjust
    it for the ball hitting the top edge.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到哪个块可以放入**if**的开口吗？如果球击中顶部边缘，则应用将增加**1**分。在[第3章](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "第3章。导航App Inventor平台")，“导航App Inventor平台”，你学习了底部边缘由**-1**（顶部边缘由1表示）。由于我们已经为球击中底部边缘创建了一个if/then场景，因此我们可以复制这一组块，并调整它以适应球击中顶部边缘。
- en: 'Copy the blue block from the existing **if** block (note that by copying the
    blue block, you will also automatically copy the embedded orange **get edge**
    block and the blue **-1** math block). Snap these pasted blocks into the new **if**
    block and change **-1** to **1**, as shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有的**if**块中复制蓝色块（注意，通过复制蓝色块，你也将自动复制嵌入的橙色**获取边缘**块和蓝色**-1**数学块）。将这些粘贴的块放入新的**if**块中，并将**-1**更改为**1**，如图所示：
- en: '![Coding scoring blocks](img/00111.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00111.jpeg)'
- en: 'We have coded: if the top edge is reached, then what will happen? We want the
    app to record a point. To code the score feature, we will first create a **global
    variable**. A global variable is a value that can be used by any block, whereas
    a **local variable** is one that can only be used by the specific block for which
    it was intended. Go to the **Variables** block drawer and select the orange, **initialize
    global name to** block.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了代码：如果触及顶部边缘，会发生什么？我们希望应用记录一个分数。要编写得分功能，我们首先创建一个**全局变量**。全局变量是任何块都可以使用的值，而局部变量是只能由为其设计的特定块使用的值。转到**变量**块抽屉并选择橙色，**初始化全局名称到**块。
- en: '![Coding scoring blocks](img/00112.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00112.jpeg)'
- en: Click on **name** and change the text to **score**. Next, in the **Math** drawer,
    select the **0** blue Math block. Connect it to the **initialize global score
    to** block. Your blocks will now look like the following screenshot. Note that
    this **initialize global name** block does not fit into any other block; it stands
    alone with the attached Math **0** block.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**名称**并更改文本为**分数**。接下来，在**数学**抽屉中，选择**0**蓝色数学块。将其连接到**初始化全局分数为**块。你的块现在将如下面的截图所示。请注意，这个**初始化全局名称**块不适用于任何其他块；它独立存在，并附有数学**0**块。
- en: '![Coding scoring blocks](img/00113.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00113.jpeg)'
- en: 'By setting the global variable equal to **0**, essentially, we have established
    the initial score to be set to `0`. Now, we can program the app to add **1** to
    this score. Go back into the **Variables** block drawer and select the **set to**
    block. Click on the little arrow in the middle of the block and select **global
    score** from the drop-down menu (this is now available for us to select because
    we created the global variable). Insert the block into the empty **then** slot,
    as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将全局变量设置为**0**，实际上，我们已经建立了要设置的初始分数为`0`。现在，我们可以编程应用将**1**加到这个分数上。返回到**变量**块抽屉并选择**设置为**块。点击块中间的小箭头并从下拉菜单中选择**全局分数**（现在我们可以选择，因为我们创建了全局变量）。将块插入到如以下截图所示的空**然后**槽中：
- en: '![Coding scoring blocks](img/00114.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00114.jpeg)'
- en: 'You will insert a Math block into the **set global score to** block because,
    every time the top edge is reached, we will want to get the current score (in
    this case, **0**) and add **1** to it. Therefore, we will need the blue Math addition
    block, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把一个数学块插入到**设置全局分数为**块中，因为每次顶部边缘被触及时，我们都会想要获取当前的分数（在这种情况下，**0**）并将其加1。因此，我们需要如以下截图所示的蓝色数学加法块：
- en: '![Coding scoring blocks](img/00115.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00115.jpeg)'
- en: 'The first blank will be filled with an orange **get global score** block, in
    the second block after the plus sign, there will be a number block filled with
    **1**, as shown in the following screenshot. There are two ways to find the get
    global score block. One is in the Variables drawer. Click on the get to block
    and then click on the downward arrow to select global score from the drop down
    menu. Or, you can hover (not click) over the initialize global score block and
    both a set and get global score block will appear. Select the get global score
    block. The reason we are using the get global score block and not the 0 block
    is because we want to add 1 to the most recent score. At the beginning of the
    game, the score is 0, but as soon as the ball hits the top edge, the new global
    score will be 0+1, then 1+1 (and so on):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个空格将填入一个橙色**获取全局分数**块，在加号后的第二个块中，将有一个填入**1**的数字块，如下面的截图所示。有两种方法可以找到获取全局分数块。一种是在变量抽屉中。点击“获取到”块，然后点击向下箭头从下拉菜单中选择全局分数。或者，你可以悬停（不点击）在初始化全局分数块上，将同时出现一个设置和获取全局分数块。选择获取全局分数块。我们之所以使用获取全局分数块而不是0块，是因为我们想要将1加到最新的分数上。游戏开始时，分数是0，但一旦球击中顶部边缘，新的全局分数将是0+1，然后1+1（以此类推）：
- en: '![Coding scoring blocks](img/00116.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![编码得分块](img/00116.jpeg)'
- en: So now, we have created the code to update the score each time the top edge
    is reached. But we haven't yet created the code to display the score. Let's do
    this next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经创建了每次顶部边缘被触及时更新分数的代码。但我们还没有创建显示分数的代码。让我们接下来做这件事。
- en: Updating the score label
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新分数标签
- en: Take a look at the blocks in the first **then** section in the following screenshot
    and notice the name change of our Score Label. Since the Score Label will be displaying
    both the score and the level, we decided to make that clear in our label name.
    In the Designer, we renamed the Label from Score to Score_Level_Label. This change
    updates in the Blocks Editor as well. The block name initially was, set Score.Text
    to is now, set Score_Level_Label.Text to. The blocks drawer is also updated. We
    show you this edit in the middle of development because sometimes, no matter how
    well thought out your app is, you may discover ways to improve it as you begin
    coding. Changing the Label name is not necessarily integral to the functioning
    of our app, but it helps us to be more clear in our design
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图中的第一个**然后**部分中的方块，并注意我们的分数标签名称的变化。由于分数标签将显示分数和等级，我们决定在标签名称中明确这一点。在设计师中，我们将标签从分数重命名为Score_Level_Label。这个更改也在方块编辑器中更新。方块名称最初是，将分数的文本设置为现在是，将Score_Level_Label.Text设置为。方块抽屉也进行了更新。我们在开发过程中展示这个编辑，因为有时候，无论你的应用构思多么周全，你可能在开始编码时发现改进它的方法。更改标签名称并不一定是我们应用功能的核心，但它有助于我们在设计中更加清晰。
- en: '![Updating the score label](img/00117.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签](img/00117.jpeg)'
- en: 'Since the Label will now display both the score and the level, we need to code
    that. Copy the green **set Score_Level_Label.Text to** block, from the if/then/else
    block. Since it will also copy the pink **"Game Over"** text block, you can merely
    delete this block as we won''t need it. Instead, go into the pink **Text** blocks
    and choose the **join** block, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签现在将显示分数和等级，我们需要编写相应的代码。从if/then/else块中复制绿色的**设置Score_Level_Label.Text为**方块。因为它还会复制粉色的**“游戏结束”**文本方块，你可以简单地删除这个方块，因为我们不需要它。相反，进入粉色的**文本**方块并选择**连接**方块，如下面的截图所示：
- en: '![Updating the score label](img/00118.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签](img/00118.jpeg)'
- en: 'We need this block to set the Label text to display pieces of information:
    the score and the level. If you think about it, we can''t just display two numbers
    because the user won''t know what they mean. We have to display: the word **Score**
    and the actual score (whatever number it is) and the word "Level" and the actual
    level (whatever number that is). To begin, we will just add two things, the word
    Score and the actual score. You probably can guess that the first block to attach
    to the join block is another blank **Text** block will. Type the word **Score:**
    with a space after the colon (so there will be a space between the word and the
    score number). The second block is the orange **get global score** block.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个方块来设置标签文本以显示信息：分数和等级。如果你这么想，我们不能只显示两个数字，因为用户不知道它们代表什么。我们必须显示：单词**分数**和实际的分数（无论是什么数字）以及单词“等级”和实际的等级（无论是什么数字）。首先，我们将只添加两个东西，单词分数和实际的分数。你可能可以猜到，第一个连接到连接块的方块是另一个空白**文本**方块。输入单词**分数**：冒号后面有一个空格（因此单词和分数数字之间会有一个空格）。第二个方块是橙色**获取全局分数**方块。
- en: '![Updating the score label](img/00119.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签](img/00119.jpeg)'
- en: Increasing difficulty
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加难度
- en: If you stop and think about our app as it stands, it would be very easy to cheat!
    A user could just keep the ball very near the top edge and fling it a short distance
    to amass tons of points! If you'd like to make it harder for the user to score
    points, we will show you one way to increase the difficulty. If, on the other
    hand, you are making this app for a young user and want it to be easy for them
    to score points, then you can skip this section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你停下来思考我们目前的应用，作弊会非常容易！用户只需将球保持在顶部边缘附近，轻轻一扔就能获得大量分数！如果你想让用户得分更难，我们将向你展示一种增加难度的方式。另一方面，如果你是为年轻用户制作这个应用，并希望他们容易得分，那么你可以跳过这一部分。
- en: Changing the game's dynamic
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变游戏动态
- en: As the game stands, the ball is moving downward and whenever your finger touches
    it, it will get flung in another direction (to be exact, 360 degrees minus the
    direction it was heading). We can program the app so the ball only responds to
    a fling when it is below the middle of the screen. Can you guess how we might
    program this? If you guessed using an **if**/**then** block, you're on the right
    track! If the ball is below the middle of the screen, then it can be flung.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前游戏而言，球正在向下移动，并且每当您的手指触摸它时，它将向另一个方向（确切地说，是360度减去它原来的方向）被抛出。我们可以编程应用程序，使球仅在它位于屏幕中间下方时响应抛出。你能猜到我们可能会如何编程吗？如果你猜到使用**if**/**then**块，你就对了！如果球位于屏幕中间下方，那么它可以被抛出。
- en: 'Currently, our blocks look like the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的块看起来如下所示：
- en: '![Changing the game''s dynamic](img/00120.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![改变游戏动态](img/00120.jpeg)'
- en: We want to tell the app to first check and see whether the ball is below the
    middle of the screen. We've coded something similar if you recall when we used
    the **Screen1.Width** block. Since we won't know the screen size of every user,
    we cannot just input a specific number and divide it by 2\. But we can get the
    user's screen size with the **Screen1.Height** block and divide this by 2\. In
    [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc "Chapter 3. Navigating
    the App Inventor Platform"), *Navigating the App Inventor Platform*, you also
    learned that **x** is used to represent the width and **y** is used to represent
    the height. The values of **x** and **y** start with `0`, `0` in the top left
    corner of the screen. So, we will use the **y** variable, which represents the
    height. We know that **y** gets bigger from top to bottom. Thus, we want to enable
    the ball to be flung if **y** is bigger than the screen size divided by `2`. For
    example, suppose that the height of the screen is `100` (with the value of `0`
    at the top and the value of `100` at the bottom). If the ball is at *y = 51*,
    it will be just below the halfway mark. Thus, it will be enabled to be flung.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望告诉应用程序首先检查并查看球是否位于屏幕中间下方。如果您记得，当我们使用**Screen1.Width**块时，我们已经编写了类似的内容。由于我们不知道每个用户的屏幕尺寸，所以我们不能直接输入一个特定的数字并将其除以2。但我们可以使用**Screen1.Height**块来获取用户的屏幕尺寸，并将其除以2。在[第3章](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "第3章。导航App Inventor平台")中，*导航App Inventor平台*，您也学习了**x**用于表示宽度，**y**用于表示高度。**x**和**y**的值从屏幕左上角的`0`开始。因此，我们将使用表示高度的**y**变量。我们知道**y**从上到下逐渐增大。因此，我们希望使球在**y**大于屏幕尺寸除以`2`时可以被抛出。例如，假设屏幕的高度为`100`（顶部值为`0`，底部值为`100`）。如果球在**y
    = 51**的位置，它将正好在中间下方。因此，它将被启用以被抛出。
- en: 'To begin coding this scenario temporarily, remove **set Ball1.Heading** and
    its accompanying blocks from the when Ball1.Flung event block. Add an **if**/**then**
    block and a **greater than Math** block (select the equals Math block and then
    chose the greater than symbol from the drop down menu by clicking on the downward
    arrow in the center of the block) to the **if** opening, as shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始临时编写此场景的代码，请从**当Ball1.Flung事件**块中移除**set Ball1.Heading**及其相关块。向**if**开孔添加一个**if**/**then**块和一个**大于Math**块（选择等于Math块，然后通过点击块中央的向下箭头从下拉菜单中选择大于符号），如图所示：
- en: '![Changing the game''s dynamic](img/00121.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![改变游戏动态](img/00121.jpeg)'
- en: 'Next, hover over (don''t click on) the light orange box with the variable **y**
    in the **when Ball1.Flung** event block. This will produce a pop-up window. Select
    the top choice, **get y**, as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将鼠标悬停在带有变量**y**的浅橙色框上（不要点击），该框位于**当Ball1.Flung事件**块中。这将弹出一个窗口。选择顶部的选项，**获取y**，如图所示：
- en: '![Changing the game''s dynamic](img/00122.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![改变游戏动态](img/00122.jpeg)'
- en: Insert the **get y** block into the first opening before the greater than sign.
    Remember we won't be adding a number into the second opening, but rather an equation
    of the screen height divided by 2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将**获取y**块插入大于符号之前的第一空位。请记住，我们不会在第二个空位中添加一个数字，而是一个屏幕高度除以2的等式。
- en: '![Changing the game''s dynamic](img/00123.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![改变游戏动态](img/00123.jpeg)'
- en: In the second opening, insert another **Math** block—this time, a division **Math**
    block because we want the **y** to be greater than the screen height divided by
    **2**. Get the **Screen1.Height** block from the **Screen1** block drawer and
    the **number** block from the **Math** drawer, and change the value to **2**.
    Insert the **Screen1.Height** block into the first opening of the **Math** division
    block and insert the number 2 block into the opening after the division sign.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个开口处，插入另一个**Math**块——这次是一个除法**Math**块，因为我们希望**y**值大于屏幕高度除以**2**。从**Screen1**块抽屉中获取**Screen1.Height**块，从**Math**抽屉中获取**number**块，并将值改为**2**。将**Screen1.Height**块插入到**Math**除法块的第一个开口中，将数字2块插入到除号之后的开口中。
- en: 'Reinsert the set **Ball1.Heading** blocks you removed earlier into the **then**
    opening of the **if**/**then** block, as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将你之前移除的**Ball1.Heading**块重新插入到**if**/**then**块的**then**开头，如图所示：
- en: '![Changing the game''s dynamic](img/00124.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![改变游戏动态](img/00124.jpeg)'
- en: Now, our app checks to see *if* the ball's **y** height value is below the halfway
    point on the screen. If it is, *then* the ball will be flung in a direction indicated
    by our formula, **360 - Ball1.Heading**. If it is not, nothing will happen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用会检查球的高度值是否低于屏幕中间点。如果是，则球会按照我们的公式**360 - Ball1.Heading**指示的方向被弹射出去。如果不是，则不会发生任何事。
- en: Creating levels
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建级别
- en: Computer games typically have multiple levels where the difficulty of playing
    the game progressively increases. This is what makes a game fun, challenging,
    and even somewhat addictive. We want to incorporate levels in our game as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机游戏通常包含多个级别，游戏的难度会随着玩家得分的增加而逐渐提升。这就是游戏之所以有趣、具有挑战性，甚至有些上瘾的原因。我们希望在游戏中也加入级别系统。
- en: 'One simple way to make the game play harder and harder is to increase the speed
    of the ball as the player continues to score points. You can create whatever tiers
    you like, but for the purpose of this tutorial, we will create a simple tier system:
    whenever a player scores 5 points, the player has completed a level. Again, to
    keep it simple, we will not pause game play (as is common in most computer games)
    when a level is completed. The player will automatically move on to the next level,
    which will also increase the speed of the ball.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让游戏难度逐渐增加的一个简单方法是在玩家继续得分时增加球的速度。你可以创建任何你喜欢的层级，但为了本教程的目的，我们将创建一个简单的层级系统：每当玩家得分5分，玩家就完成了一个级别。再次强调，为了保持简单，当完成一个级别时，我们不会暂停游戏（这在大多数计算机游戏中很常见）。玩家将自动进入下一个级别，球的速度也会相应增加。
- en: To figure out whether a level change is needed or not, we will code the app
    to constantly check the value of score. Each time the score is incremented, the
    app will check to see whether it is a multiple of 5 (for example, *score = 5,
    10, 15, 20, and so on*). If the score is indeed a multiple of 5, it will mean
    that the player has scored another 5 points and a level change should occur. To
    change the level, we will simply increase the speed a little bit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定是否需要更改级别，我们将编写代码让应用不断检查得分的值。每次得分增加时，应用都会检查它是否是5的倍数（例如，*得分=5、10、15、20等等*）。如果得分确实是5的倍数，这意味着玩家又得了5分，应该发生级别更改。为了更改级别，我们只需稍微增加速度即可。
- en: 'As explained earlier in this chapter, the event, **Ball1.EdgeReached**, contains
    the code that increments the score: the **set global score to** block. Whenever
    the score increases, the label will update to display the new score (the previous
    score plus 1). As you can see in the blocks shown in the following screenshot,
    the block immediately after the score-increment block is the **set Score_Level_Label.text
    to** block to update the score displayed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，事件**Ball1.EdgeReached**包含增加得分的代码：**set global score to**块。每当得分增加时，标签会更新以显示新的得分（之前的得分加1）。正如你在下面的屏幕截图中所看到的，得分增加块之后的块是**set
    Score_Level_Label.text to**块，用于更新显示的得分。
- en: Now, we will add an **if**/**then** block right after the **set Score_Level_Label.text**
    block. Do you remember where to find the **if**/**then** block?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在**set Score_Level_Label.text**块之后立即添加一个**if**/**then**块。你还记得在哪里可以找到**if**/**then**块吗？
- en: '![Creating levels](img/00125.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![创建级别](img/00125.jpeg)'
- en: 'Now, let''s think about the condition that we want to insert in the empty socket
    next to **if**. We want to check and see whether the score is a multiple of 5
    (if it is a multiple of 5, then the remainder will be 0). In order to do so, we
    need to complete the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下我们想在**if**旁边的空槽中插入的条件。我们想检查并查看分数是否是5的倍数（如果是5的倍数，则余数将为0）。为了做到这一点，我们需要完成以下步骤：
- en: Get the current value of the score.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取分数的当前值。
- en: Divide its value by 5 and calculate the remainder.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其值除以5并计算余数。
- en: See whether the remainder is equal to 0.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查余数是否等于0。
- en: To achieve these three subtasks, we will first get the **get global score**
    block just like we did when we used this block to increment the score. This block
    can be select from the **Variables** blocks or can be copied from your current
    set of blocks. This completes task 1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这三个子任务，我们首先获取**get global score**块，就像我们使用这个块来增加分数时做的那样。这个块可以从**Variables**块中选择，也可以从你当前的块集中复制。这完成了任务1。
- en: 'Next, we will get the remainder of the block from under the **Math** blocks.
    This step is not as obvious. When you go to the Math blocks, you will not see
    any remainder block. Instead, select the **modulo of** block, as shown in the
    following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从**Math**块下面获取块的余数。这一步并不明显。当你进入Math块时，你不会看到任何余数块。相反，选择**modulo of**块，如下面的截图所示：
- en: '![Creating levels](img/00126.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![创建等级](img/00126.jpeg)'
- en: Click on the downward-facing triangle to the right of **modulo of** and select
    **remainder of** from the drop-down list. Modulo, remainder, and quotient are
    different mathematical operations related to division. Hence, they all belong
    to the same block. Place the **get global score** block within the first slot
    of the **remainder of** block. Since we want to calculate the remainder of the
    score when divided by 5, place number **5** in the second slot of the **remainder
    of** block (that is, insert a Math number block and change the value from 0 to
    5). This completes step 2.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**modulo of**右侧的向下箭头，从下拉列表中选择**remainder of**。模数、余数和商是与除法相关的不同数学运算。因此，它们都属于同一个块。将**get
    global score**块放入**remainder of**块的第一个插槽中。由于我们想计算分数除以5的余数，将数字**5**放入**remainder
    of**块的第二个插槽中（即插入一个Math数字块并将值从0改为5）。这完成了第二步。
- en: 'Finally, we want to check whether this remainder is equal to 0\. If it is equal
    to 0, then it is time to increase the level (speed). If it is not, the level (speed)
    will remain the same. To check for the equality of numbers, we will need an **equal
    to** block from the **Math** blocks. Plug the **remainder of** block (and its
    accompanying **get global score / 5** blocks) that we created in step 2 into the
    left side of the **equal to** block and the number **0** into the right side.
    The following screenshot shows the completed steps plugged to the **if** statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想检查这个余数是否等于0。如果它等于0，那么是时候增加等级（速度）了。如果不等于，等级（速度）将保持不变。为了检查数字的相等性，我们需要从**Math**块中获取一个**equal
    to**块。将我们在第二步中创建的**remainder of**块（及其伴随的**get global score / 5**块）插入到**equal to**块的左侧，并将数字**0**插入到右侧。以下截图显示了连接到**if**语句的完成步骤：
- en: '![Creating levels](img/00127.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建等级](img/00127.jpeg)'
- en: Blocks placed within the **then** part of an **if**/**then** statement are executed
    only when the condition plugged to the **if** statement is true. In this case,
    when the score is a multiple of 5 (that is, the whole remainder equals 0 and the
    if block evaluates to be true), we would want to increase the speed. We need two
    blocks from the Ball1 drawer. The first block, **Ball1.Speed**, gives us the current
    value of **Ball1**'s speed property. The second one, **set Ball1.Speed**, lets
    us change the speed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 放在**if**/**then**语句的**then**部分中的块仅在将条件连接到**if**语句时执行。在这种情况下，当分数是5的倍数时（即整个余数等于0且if块评估为真），我们希望增加速度。我们需要从Ball1抽屉中获取两个块。第一个块，**Ball1.Speed**，给出了**Ball1**的速度属性的当前值。第二个块，**set
    Ball1.Speed**，让我们改变速度。
- en: '![Creating levels](img/00128.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![创建等级](img/00128.jpeg)'
- en: 'Since we want to increase the speed relative to the current speed, we will
    use both these blocks by:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想相对于当前速度增加速度，我们将使用这两个块：
- en: Using **Ball1.Speed** to get the current speed.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Ball1.Speed**来获取当前速度。
- en: Increasing the **Ball1.Speed** value by a small amount.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过增加**Ball1.Speed**值来增加一小部分。
- en: Using the result to set the new speed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用结果来设置新的速度。
- en: 'To complete these steps, drag an **add** block from the **Math** blocks and
    attach it to the **set Ball1.Speed** block. Insert the **Ball1.Speed** block into
    the opening on the left-hand side of the plus sign and a **number** Math block
    set to 2 (the small amount that we are increasing the speed by) in the opening
    on the right-hand side of the plus sign. This completes tasks 1, 2, and 3\. Finally,
    we will place the block within the **then** block, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这些步骤，需要从**Math**块拖动一个**add**块并将其连接到**set Ball1.Speed**块。将**Ball1.Speed**块插入加号左侧的开口，并在加号右侧的开口插入一个设置为2（我们增加速度的小量）的**number**
    Math块。这完成了任务1、2和3。最后，我们将块放入如下截图所示的**then**块中：
- en: '![Creating levels](img/00129.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建等级](img/00129.jpeg)'
- en: To summarize, whenever the user scores a point, the new score will be calculated.
    Then, the app will check to see whether the new score is a multiple of 5 or not.
    If it is indeed a multiple of 5, the app will increase the speed by a little bit
    to make the game harder. If the score is not a multiple of 5, nothing will change;
    the speed will remain the same.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，每当用户得一分时，新的分数将被计算。然后，应用将检查新的分数是否是5的倍数。如果是5的倍数，应用将略微增加速度以使游戏更难。如果分数不是5的倍数，则没有任何变化；速度将保持不变。
- en: We have completed coding the leveling part of our app! Can you think of what
    is still missing? We need to display the new level in the label!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了应用等级部分的编码！你能想到还缺少什么吗？我们需要在标签中显示新的等级！
- en: Updating the score label to display the level
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新分数标签以显示等级
- en: In our game, we have a label that displays the score or the words **"Game Over"**.
    Now that we have implemented levels as well, we also want to display the level
    within that label.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们有一个标签显示分数或单词**"Game Over"**。现在我们已经实现了等级，我们还想在标签中显示等级。
- en: 'As shown in the following screenshot, we used the **join** block to join two
    pieces of information and display it in the label—the word **Score:** (there is
    a blank space after the colon) and the value of the score. Now that we want to
    display the level, we will add three more pieces of information to this **join**
    block. There is another blank space after the score (value), followed by the word
    **"Level: "** (there is also a blank space after the colon here), and finally
    the value of level.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如以下截图所示，我们使用了**join**块将两块信息连接起来并在标签中显示——单词**Score:**（冒号后有空白）和分数的值。现在我们想要显示等级，我们将向这个**join**块添加三个更多信息。在分数（值）之后还有一个空白，然后是单词**"Level:
    "**（这里也有一个空白），最后是等级的值。'
- en: To make room for these three new pieces of information, we need to add strings
    to the existing **join** block. Click on the blue square in the top left corner
    of the **join** block. This will open a pop-up window. Inside this popup, drag
    the **string** block from the top left corner into the **join** block on the right-hand
    side. Do this three times. Each time you add another **string**, you will see
    a new space appear in the **join** block below the **get global score** block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为这三个新信息腾出空间，我们需要向现有的**join**块添加字符串。点击**join**块左上角的蓝色方块。这将打开一个弹出窗口。在这个弹出窗口中，从左上角拖动**string**块到右侧的**join**块中。这样做三次。每次添加另一个**string**，你将在**get
    global score**块下方看到**join**块中出现一个新的空白。
- en: '![Updating the score label to display the level](img/00130.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签以显示等级](img/00130.jpeg)'
- en: If you have done this correctly, there will be three empty slots, as shown in
    the following screenshot. Now, click anywhere outside the popup to close the pop-up
    menu.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确完成了这些操作，将会有三个空槽，如下面的截图所示。现在，点击弹出菜单外的任何地方以关闭弹出菜单。
- en: '![Updating the score label to display the level](img/00131.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签以显示等级](img/00131.jpeg)'
- en: Now, we are ready to plug in the three new pieces of information related to
    the levels. Plug in a blank text box in the first open slot (the blank text block
    is the first block in **Text** block's drawer). Even though it seems like this
    contains a blank space, we must make one. Click inside the blank text and press
    your keyboard's spacebar to create a space. In the next empty slot, plug in another
    blank text block, and click and type in the word **Level:** with a space after
    the colon.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好插入与等级相关的三个新信息。在第一个开放的插槽（空白文本块是**文本**块抽屉中的第一个块）中插入一个空白文本框。尽管这看起来像包含一个空白空间，但我们必须创建一个。在空白文本中点击并按下键盘的空格键以创建一个空格。在下一个空槽中，插入另一个空白文本块，并点击并输入单词**等级**：并在冒号后留一个空格。
- en: As you might have correctly guessed, the last piece of text we will plug into
    the **join** block is the level value. You might be wondering where this level
    value is going to come from. We will actually calculate this from the current
    score value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能正确猜到的，我们将插入到**连接**块的最后一部分文本是等级值。你可能想知道这个等级值从哪里来。实际上，我们将从当前的分数值中计算出这个等级值。
- en: When we implemented the levels, we assumed that an increase in score by 5 will
    trigger a level change. Hence, scores 0 to 4 correspond to level 0, scores 5 to
    9 correspond to level 1, scores 10 to 14 correspond to level 2, and so on. We
    can use some math to calculate the level from the score. As you might have guessed,
    the math that we are going to use here is the quotient operation. More specifically,
    we will divide the score by 5 and use the quotient part to determine our levels.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现等级时，我们假设分数增加5将触发等级变化。因此，分数0到4对应等级0，分数5到9对应等级1，分数10到14对应等级2，依此类推。我们可以使用一些数学来计算从分数中得出的等级。正如你可能猜到的，我们在这里将要使用的数学是商操作。更具体地说，我们将分数除以5，并使用商部分来确定我们的等级。
- en: 'To use the quotient block, go back to **Math** Blocks drawer and drag a **modulo**
    block. Then, click on the downward pointing triangle to change it to **quotient**.
    Copy a **get global score** block and plug it into the first open socket of the
    **quotient** block. Insert a Math **number** block into the second opening and
    change it to `5`. The completed blocks are shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用商块，请返回到**数学**块抽屉，并拖动一个**取模**块。然后，点击向下指向的三角形将其更改为**商**。复制一个**获取全局分数**块并将其插入到**商**块的第一个开放插槽中。将一个数学**数字**块插入第二个开口，并将其更改为`5`。完成的块在以下屏幕截图中显示：
- en: '![Updating the score label to display the level](img/00132.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签以显示等级](img/00132.jpeg)'
- en: 'This is an ideal time to reconnect your mobile device to your Fling app. Your
    Label will now display both the score and the level, as shown in the following
    screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是重新连接您的移动设备到Fling应用的最佳时机。您的标签现在将显示分数和等级，如下面的屏幕截图所示：
- en: '![Updating the score label to display the level](img/00133.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![更新分数标签以显示等级](img/00133.jpeg)'
- en: Updating the Reset button
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新重置按钮
- en: 'Don''t think that we have forgotten about our bug! Have you figured out what
    the bug is?" In the last chapter, we programmed the Reset button to move the ball
    to the top of the screen (y=2) and to a random x value. But, before the Play button
    starts the ball moving, it also moves the ball to a random x location. And the
    problem is, it isn''t the same location that the Reset button previously set.
    So the ball moves once upon Reset and again on Play. We can fix this problem!"
    START A NEW PARAGRAPH Start it with "In addition to fixing the bug, we have some
    other updates to the Reset and Play buttons. Now that we have added scoring and
    leveling to our game, we need to edit the Reset button. There are several tasks
    related to resetting the game. They are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要以为我们已经忘记了我们的错误！你弄清楚错误是什么了吗？”在上一章中，我们编程了重置按钮，将球移动到屏幕顶部（y=2）和随机的x值。但是，在播放按钮开始移动球之前，它也会将球移动到随机的x位置。问题是，这并不是重置按钮之前设置的位置。所以球在重置时移动一次，在播放时再次移动。我们可以修复这个问题！”开始新段落。从“除了修复错误之外，我们对重置和播放按钮还有一些其他更新。现在我们已经将计分和等级添加到我们的游戏中，我们需要编辑重置按钮。与重置游戏相关的有几个任务。如下所示：
- en: Stopping the ball's motion and resetting the position of the ball.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止球的运动并重置球的位置。
- en: Resetting the score variable.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置分数变量。
- en: Updating the label used to display the score.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新用于显示分数的标签。
- en: Another point to note is that we can't assume that the only reason a user presses
    Reset is because the ball hit the bottom edge and the game ended. We also have
    to think of the scenario of the user pressing the Reset button to stop the game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，我们不能假设用户按下重置按钮的唯一原因是球击中底部边缘并结束游戏。我们还得考虑用户按下重置按钮来停止游戏的情况。
- en: To reset the position of the ball, we will reuse the **Ball1.MoveTo** block
    that we already coded in [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, when we created the **Play_Button.Click** event. When the user presses
    **Play** button, the ball will move to a random **x** coordinate between the value
    of **1** and the screen width.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重置球的位置，我们将重用我们在 [第 3 章](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "第 3 章。导航 App Inventor 平台") 中编写的 **Ball1.MoveTo** 块，*导航 App Inventor 平台*，当时我们创建了
    **Play_Button.Click** 事件。当用户按下 **播放** 按钮时，球将移动到介于 **1** 和屏幕宽度之间的随机 **x** 坐标。
- en: '![Updating the Reset button](img/00134.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00134.jpeg)'
- en: 'You may also recall in [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, that we programmed the **Reset** button to move the ball to a random
    integer between **1** and the screen width, as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在 [第 3 章](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "第 3 章。导航 App Inventor 平台") 中，*导航 App Inventor 平台*，我们编程了 **重置** 按钮将球移动到介于 **1**
    和屏幕宽度之间的随机整数，如图所示：
- en: '![Updating the Reset button](img/00135.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00135.jpeg)'
- en: As the app is currently programmed, the Reset button moves the ball to a random
    *x* position at the top of the screen and the Play button also moves the ball
    to a random *x* position at the top of the screen, but these two random positions
    are not the same. Imagine a scenario in which the ball hits the bottom edge and
    ends the game. A user presses Reset to move the ball back up to the top of the
    screen. It goes to a random *x* location. Then, when the user presses Play, the
    ball is again reset to a new random *x* location before it starts moving downward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前应用程序的编程，重置按钮将球移动到屏幕顶部的随机 *x* 位置，播放按钮也将球移动到屏幕顶部的随机 *x* 位置，但这两个随机位置并不相同。想象一下这样的场景：球击中底部边缘并结束游戏。用户按下重置按钮将球移回屏幕顶部。它到达一个随机的
    *x* 位置。然后，当用户按下播放按钮时，球再次重置到一个新的随机 *x* 位置，然后开始向下移动。
- en: We first programmed the Play button to position the ball at the top of the screen,
    because the first time the game is played, the user wouldn't press the Reset button,
    but rather the Play button. However, after the game is played once, the user would
    press Reset and thus the Play button would no longer need to reposition the ball,
    since the Reset button will perform this function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编程播放按钮将球定位在屏幕顶部，因为第一次玩游戏时，用户不会按下重置按钮，而是按下播放按钮。然而，一旦游戏玩了一次，用户就会按下重置按钮，因此播放按钮就不再需要重新定位球，因为重置按钮将执行这个功能。
- en: We want the Play button to let the ball start moving from the same location
    that the Reset button previously randomly selected. To do this, we need to program
    our app so that the Play button gets the ball's x location from the **Reset**
    button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望播放按钮能够让球从重置按钮之前随机选择的位置开始移动。为此，我们需要编程我们的应用程序，以便播放按钮从 **重置** 按钮获取球的 x 位置。
- en: 'To make this Reset_Button and Play_Button communication happen, we will first
    create a variable called **randomX**. This variable will initially be set to **0**.
    Initializing a variable to some value (even if that value is not used later on)
    is important. Select the **initialize global name to** block from the **Variables**
    blocks drawer. Change the name to **randomX**. Select a number **Math** block
    and attach it, as shown in the following screenshot (note that this set of blocks
    stands on its own; it does not fit into the other event blocks):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个重置按钮和播放按钮进行通信，我们首先创建一个名为 **randomX** 的变量。这个变量最初将被设置为 **0**。初始化一个变量到某个值（即使这个值后来没有使用）也是非常重要的。从
    **变量** 块抽屉中选择 **初始化全局名称为** 块。将名称更改为 **randomX**。选择一个数字 **Math** 块并将其连接，如图所示（注意，这组块独立存在；它不适用于其他事件块）：
- en: '![Updating the Reset button](img/00136.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00136.jpeg)'
- en: 'After initializing the global variable, randomX, we can now use it for both
    our Reset and Play buttons. If you recall, when we programmed the Play_Button.Click
    event, we enabled the ball to start moving. We set the value of the set Ball1.Enabled
    block to true, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化全局变量 randomX 之后，我们现在可以使用它来更新重置和播放按钮。如果您还记得，当我们编程 Play_Button.Click 事件时，我们启用了球开始移动。我们将设置
    Ball1.Enabled 块的值设置为 true，如下截图所示：
- en: '![Updating the Reset button](img/00137.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00137.jpeg)'
- en: So, for the **Reset** button, we want to disable the ball. And we do this by
    making the value **false**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于**重置**按钮，我们希望禁用球。我们通过将其值设置为**false**来实现这一点。
- en: First, copy and paste the **set Ball1.Enabled** block; it will also copy and
    paste the attached **true** block. Simply click on the arrow to the right of the
    word **true** and you will be able to select **false**. This block disables the
    ball's movement. This was one of our goals, since the user will expect the game
    to stop when the Reset button is pressed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制并粘贴**设置 Ball1.Enabled** 块；它也会复制并粘贴附加的**true**块。只需单击“true”一词右侧的箭头，您就可以选择**false**。这个块禁用了球的移动。这是我们目标之一，因为用户会期望在按下重置按钮时游戏停止。
- en: Next, select the **set global randomX** block from the **Variables** block (it
    will be available as a choice in the blocks drawer, since we initialized the global
    variable, **randomX**). We will generate a random integer for the x coordinate
    and store it in this **randomX** variable. You know how to do this because we
    have already created the blocks to move the ball to a random x integer. Copy and
    paste the **random integer from to** blocks and add them to the **set global randomX
    to** block, as shown in the following screenshot. Once we set the global randomX
    variable to a random integer, we will use this variable in the **Call Ball1.MoveTo**
    block. The following screenshot shows how to generate a random number, store it
    in the variable (set **global randomX**), and then use this variable (get **global
    randomX**). This completes *Task 1*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 **变量** 块中选择**设置全局 randomX** 块（它将在块抽屉中作为选项可用，因为我们初始化了全局变量 **randomX**）。我们将为
    x 坐标生成一个随机整数并将其存储在这个 **randomX** 变量中。您知道如何做，因为我们已经创建了将球移动到随机 x 整数的块。复制并粘贴**从...到随机整数**块，并将它们添加到**设置全局
    randomX 到**块中，如下截图所示。一旦我们将全局 randomX 变量设置为随机整数，我们将在**调用 Ball1.MoveTo**块中使用这个变量。以下截图显示了如何生成随机数，将其存储在变量中（设置**全局
    randomX**），然后使用这个变量（获取**全局 randomX**）。这完成了 *任务 1*。
- en: '![Updating the Reset button](img/00138.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00138.jpeg)'
- en: '*Tasks 2* and *Task 3* are relatively easy. Since the Reset button also resets
    the score to equal zero, we will also set the score variable to zero. To do this,
    we will copy and paste the **set global score** block from the **Ball1.EdgeReached**
    event and modify the right-hand side to simply be a Math number block of the value
    0\. For *Task 3*, we will simply copy and paste the **Score_Level_Label.Text**
    block that we created previously in this chapter. This block always updates the
    label using the latest value of the score and the level. Since we are resetting
    the score to **0** right before we execute this block, this block will correctly
    reset the label to show **0** for the score and the level. (Note: blocks execute
    from top to bottom.)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务 2* 和 *任务 3* 相对简单。由于重置按钮也会将分数重置为零，因此我们还将分数变量设置为零。为此，我们将从 **Ball1.EdgeReached**
    事件复制并粘贴**设置全局分数**块，并将右侧修改为仅是值为 0 的 Math 数字块。对于 *任务 3*，我们将简单地复制并粘贴我们在本章中之前创建的 **Score_Level_Label.Text**
    块。此块始终使用最新的分数和级别更新标签。由于我们在执行此块之前将分数重置为 **0**，因此此块将正确地将标签重置为显示分数和级别为 **0**。（注意：块从上到下执行。）'
- en: '![Updating the Reset button](img/00139.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![更新重置按钮](img/00139.jpeg)'
- en: Updating the Play button
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新播放按钮
- en: 'When we built the Play button, the blocks resembled the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建播放按钮时，块看起来像以下截图：
- en: '![Updating the Play button](img/00140.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![更新播放按钮](img/00140.jpeg)'
- en: But now, we want to redo the Play button blocks because we no longer want the
    Play button to set the ball's x random location. Instead, we want the Play button
    to get the location of the ball from the Reset button. This way, when the Play
    button is pressed, the ball will just begin moving from where it already is, having
    just been reset to the top of the screen by the Reset button between the very
    first time a user plays the game, the Play button will set the random location
    of the ball using the blocks we already programmed. Then the first time (and ensuing
    times) that the Reset button is pressed and sets the location of the ball at the
    top of the screen, we want the ball to start moving from that location when the
    Play button is pressed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们想要重新做播放按钮的块，因为我们不再想让播放按钮设置球的x随机位置。相反，我们想让播放按钮从重置按钮获取球的位置。这样，当按下播放按钮时，球将从它已经被重置到屏幕顶部的位置开始移动，这是在用户第一次玩游戏时，播放按钮将使用我们已编程的块设置球的随机位置。然后，当第一次（以及随后的时间）按下重置按钮并将球的位置设置在屏幕顶部时，我们希望球在按下播放按钮时从该位置开始移动。
- en: At this point, it might be obvious that we will use an **if**/**then**/**else**
    event block. The reasoning, however, is a little counter-intuitive. The only time
    the Play button determines the ball's x location is the very first time that the
    user plays the app. This is when the global variable, randomX, has the value of
    0\. Instead of saying if the global randomX is equal to 0, then do something,
    we are going to say if the **global randomX** is not equal to 0, then do something.
    We are going to program the blocks this way because there is only one time this
    won't happen. Every other time the app checks this information, the global randomX
    will indeed be a value between 1 and the screen width (as we coded in the Reset
    button). If the **global randomX** *is not equal to* 0, *then* move the ball to
    the global randomX location set by the Reset button. Otherwise (else), we will
    move the ball to a random integer between 1 and the screen width (this code will
    only occur once—the first time the user plays the Fling app).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可能很明显我们会使用一个**if**/**then**/**else**事件块。然而，推理过程却有点反直觉。唯一一次播放按钮决定球x位置的情况是用户第一次玩这个应用的时候。这时，全局变量randomX的值为0。我们不是要说如果全局变量randomX等于0，那么就做某事，而是要说如果**全局randomX**不等于0，那么就做某事。我们将以这种方式编程这些块，因为只有一次这种情况不会发生。每次应用检查这个信息时，全局randomX确实会是一个介于1和屏幕宽度之间的值（正如我们在重置按钮中编码的那样）。如果**全局randomX***不等于*0，*那么*将球移动到重置按钮设置的global
    randomX位置。否则（else），我们将球移动到1和屏幕宽度之间的一个随机整数位置（此代码只会发生一次——即用户第一次玩Fling应用时）。
- en: '![Updating the Play button](img/00141.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![更新播放按钮](img/00141.jpeg)'
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We hope you found this chapter to be challenging yet rewarding. You have learned
    how to take a simple app and make it more intermediate by adding more complex
    features and code. Each feature, scoring, fling capability, and level requires
    a lot of thought on how each would work and interact with each other. As you experienced,
    enabling scoring and leveling mechanisms required us to alter code in a variety
    of block locations. Similarly, we had to reexamine how our buttons functioned
    and reprogram the buttons. You will discover that this is a typical process in
    coding. Changing or adding one thing requires reevaluating how other things would
    work and interact. Also, this chapter demonstrates how much thought needs to go
    into planning an app. Earlier in this chapter we decided to update our Label from
    Score to Score_Level_label to reflect that it would be displaying the Score, Level
    and Game Over. If you don't take sufficient time to map out your app design on
    paper initially, then you will most likely end up having to do more re-working
    than you may have anticipated. Most programming efforts require coders to do some
    troubleshooting along the way, so don't be discouraged if you find that your app
    building includes many rewrites. But, you can avoid grand overhauls by really
    thinking through each aspect of your app's features ahead of time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你觉得这一章节既有挑战性又有所收获。你已经学会了如何通过添加更多复杂的功能和代码，将一个简单的应用提升到中级水平。每个功能、评分、抛掷能力以及等级都需要大量思考，以确定它们如何运作以及如何相互交互。正如你所体验到的，启用评分和等级机制需要我们在多个代码块位置进行代码修改。同样，我们也必须重新审视我们的按钮功能，并重新编程按钮。你会发现，这通常是编码过程中的一个典型步骤。改变或添加一个东西需要重新评估其他事物的工作方式和交互方式。此外，这一章节还展示了在规划应用时需要投入多少思考。在本章的早期，我们决定将标签从“Score”更新为“Score_Level_label”，以反映它将显示评分、等级和游戏结束。如果你最初没有足够的时间在纸上规划你的应用设计，那么你很可能会发现自己需要做比预期更多的重做工作。大多数编程工作都需要程序员在过程中进行一些故障排除，所以如果你发现你的应用构建包括许多重写，不要气馁。但是，通过提前真正思考你应用功能的每个方面，你可以避免大规模的改造。
- en: In the next chapter, we will begin working on an intermediate app, an event
    app to plan events, parties, or meetings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手制作一个中级应用，一个用于策划活动、派对或会议的事件应用。
