- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building for Large Screens
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为大屏幕构建
- en: We can all agree now that we live in a world with foldable phones, a technology
    we never anticipated, due to their growing demand and popularity. Ten years ago,
    if you had told a developer we would have foldable phones, no one would have believed
    it due to the ambiguity of screen complexity and the transfer of information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在都可以同意，我们生活在一个拥有可折叠手机的世界，这是一个我们从未预料到的技术，因为它们的需求和普及度在增长。十年前，如果你告诉一个开发者我们会有可折叠手机，没有人会相信它，因为屏幕复杂性和信息传输的不确定性。
- en: However, now the devices are here with us. And since some of these devices run
    on the Android operating system, it’s vital to know how we developers will build
    our applications to cater to foldability, along with the number of Android tablets
    we’re now seeing on the market. The support for large screens seems now mandatory,
    and in this chapter, we will look at supporting large screens in the new Modern
    Android Development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在这些设备已经在我们身边了。由于其中一些设备运行在Android操作系统上，了解我们开发者将如何构建我们的应用程序以适应可折叠性，以及我们现在在市场上看到的Android平板电脑的数量至关重要。对大屏幕的支持现在似乎是强制性的，在本章中，我们将探讨在新的现代安卓开发中支持大屏幕。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Building adaptive layouts in Modern Android Development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代安卓开发中构建自适应布局
- en: Building adaptive layouts using `ConstraintLayouts`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConstraintLayouts`构建自适应布局
- en: Handling large-screen configuration changes and continuity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大屏幕配置更改和连续性
- en: Understanding activity embedding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解活动嵌入
- en: Material Theming in Compose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Compose中使用材质主题
- en: Testing your applications on a foldable device
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可折叠设备上测试你的应用程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine)找到。
- en: Building adaptive layouts in Modern Android Development
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现代安卓开发中构建自适应布局
- en: When building the UI for your application in Modern Android Development, it
    is fair to say that you should consider ensuring the application is responsive
    to different screen sizes, orientations, and form factors. Finally, developers
    can now remove the lock in portrait mode. In this recipe, we will utilize ideas
    we learned from previous recipes and build an adaptive app for different screen
    sizes and orientations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在现代安卓开发中构建应用程序的UI时，可以说你应该考虑确保应用程序能够响应不同的屏幕尺寸、方向和形态。最后，开发者现在可以移除横屏模式下的锁定。在这个菜谱中，我们将利用从前面的菜谱中学到的想法，为不同的屏幕尺寸和方向构建一个自适应的应用程序。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the cities application to create a traveler profile, and our
    screen should be able to change based on different screen sizes and support foldable
    devices and tablets. To get the entire code, check out the *Technical* *requirements*
    section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用城市应用程序来创建旅行者档案，并且我们的屏幕应该能够根据不同的屏幕尺寸变化，并支持可折叠设备和平板电脑。要获取完整代码，请查看 *技术要求*
    部分。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For this recipe, we will create a new project, and this time, instead of picking
    the empty Compose Activity template, we will pick empty Compose Activity (`Material
    3`). `Material 3` seeks to improve our application’s look and feel in Android.
    It includes updated theming, components, and great features, such as Material
    You personalization using dynamic color:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个新的项目，这次，我们不会选择空的Compose Activity模板，而是选择空的Compose Activity (`Material
    3`)。`Material 3`旨在改善我们的应用程序在Android中的外观和感觉。它包括更新的主题、组件和出色的功能，例如使用动态颜色进行Material
    You个性化：
- en: Let’s start by creating an Empty Compose Activity (`Material3`) project and
    calling it `Traveller`; note that you can call your project anything you wish.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个空的Compose Activity (`Material3`) 项目并命名为 `Traveller` 开始；请注意，你可以将你的项目命名为任何你想要的。
- en: '![Figure 9.1 – Creating a new Empty Compose Activity (Material3) project](img/Figure_9.1_B18827.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 创建一个新的Empty Compose Activity (Material3) 项目](img/Figure_9.1_B18827.jpg)'
- en: Figure 9.1 – Creating a new Empty Compose Activity (Material3) project
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 创建一个新的Empty Compose Activity (Material3) 项目
- en: Complex applications utilize responsive UI, and in most cases, ensuring you
    choose the right navigation type for your application comes in handy. The Material
    library offers navigation components to developers, such as the bottom navigation,
    navigation drawer, and navigation rail. You can get the starter code for these
    in the *Technical* *requirements* section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序使用响应式 UI，在大多数情况下，确保你为你的应用程序选择正确的导航类型很有用。Material 库为开发者提供了导航组件，例如底部导航、导航抽屉和导航轨道。你可以在
    *技术* *要求* 部分获取这些组件的起始代码。
- en: 'Add the following dependency, and check the project for the correct version
    number, `1.1.0`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下依赖项，并检查项目的正确版本号，`1.1.0`：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When ensuring our code caters to adaptability, we have to remember a responsive
    UI retains data when a phone is rotated, folded, or unfolded. The most crucial
    part is ensuring we handle the posture. We will create a function, `cityPosture`,
    that takes `FoldingFeature` as input and returns a Boolean:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当确保我们的代码具有适应性时，我们必须记住，响应式 UI 在手机旋转、折叠或展开时保留数据。最重要的是确保我们处理了姿势。我们将创建一个函数，`cityPosture`，它接受
    `FoldingFeature` 作为输入并返回一个布尔值：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We handle the state based on the three provided states. We also annotate it
    with the experimental class because this API is still experimental, which means
    it can change in the future and is not very stable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据提供的三个状态处理状态。我们还用实验性类注释它，因为这个 API 仍然是实验性的，这意味着它将来可能会改变，并且不是很稳定。
- en: 'Next, we need to cover `isSeparating`, which listens to the `FLAT` *fully open*
    and the `isSeparating` Boolean, which calculates whether `FoldingFeature` should
    be considered, splitting the window into multiple physical areas that users can
    see as logically separate:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要涵盖 `isSeparating`，它监听 `FLAT` *完全打开* 和 `isSeparating` 布尔值，这计算了是否应该考虑
    `FoldingFeature`，将窗口分割成多个用户可以视为逻辑上独立的物理区域：
- en: '[PRE10]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will also create a sealed interface, `DevicePosture`. This is a Jetpack
    Compose UI component that allows you to detect a device’s posture or orientation,
    such as whether the device is in portrait or landscape mode:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个密封的接口，`DevicePosture`。这是一个 Jetpack Compose UI 组件，允许你检测设备的姿势或方向，例如设备是处于纵向还是横向模式：
- en: '[PRE18]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our `MainActivity`, we now need to ensure we calculate the window size:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `MainActivity` 中，我们现在需要确保我们计算窗口大小：
- en: '[PRE28]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will ensure we handle all sizes well by creating `postureStateFlow`,
    which will listen to our `DevicePosture` and act when `cityPosture` is either
    folded, unfolded, or normal:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过创建 `postureStateFlow` 来确保我们处理所有尺寸，它将监听我们的 `DevicePosture`，并在 `cityPosture`
    是折叠、展开或正常时采取行动：
- en: '[PRE29]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We now need to get set up with a foldable testing virtual device. You can repeat
    the steps from the first chapter on how to create a virtual device if you need
    a refresher; otherwise, you should go ahead and create a foldable device. The
    arrow in *Figure 9**.2* shows how you will control the foldable screens.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置一个可折叠测试虚拟设备。如果你需要复习如何创建虚拟设备的第一章步骤，可以重复执行；否则，你应该继续创建一个可折叠设备。*图 9**.2*
    中的箭头显示了如何控制可折叠屏幕。
- en: '![Figure 9.2 – The foldable controls](img/Figure_9.2_B18827.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 可折叠控制](img/Figure_9.2_B18827.jpg)'
- en: Figure 9.2 – The foldable controls
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 可折叠控制
- en: Then, finally, when you run the app, you will see that it changes based on folded
    and unfolded states, working well. *Figure 9**.3* shows when the state is folded.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，当你运行应用程序时，你会看到它根据折叠和展开状态而变化，工作得很好。*图 9**.3* 显示了折叠状态。
- en: '![Figure 9.3 – The folded state](img/Figure_9.3_B18827.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 折叠状态](img/Figure_9.3_B18827.jpg)'
- en: Figure 9.3 – The folded state
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 折叠状态
- en: In *Figure 9**.4*, you can see that we changed the bottom navigation and now
    have our navigation drawer set to the side for more straightforward navigation.
    It should be acknowledged that this project is extensive, so we cannot cover all
    parts of the code. Make sure to utilize the Compose concepts learned in the previous
    chapter for this section.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *图 9**.4* 中，你可以看到我们更改了底部导航，现在将导航抽屉设置为侧面以实现更直接的导航。应该承认，这个项目很庞大，所以我们不能涵盖代码的所有部分。确保利用上一章学到的
    Compose 概念来处理这一部分。
- en: '![Figure 9.4 – The full-screen state (not folded)](img/Figure_9.4_B18827.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 全屏状态（未折叠）](img/Figure_9.4_B18827.jpg)'
- en: Figure 9.4 – The full-screen state (not folded)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 全屏状态（未折叠）
- en: Note that when you expand the navigation drawer, you can see all items, and
    you should be able to navigate easily.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你展开导航抽屉时，你可以看到所有项目，并且你应该能够轻松导航。
- en: '![Figure 9.5 – The navigation drawer open](img/Figure_9.5_B18827.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 导航抽屉打开](img/Figure_9.5_B18827.jpg)'
- en: Figure 9.5 – The navigation drawer open
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 导航抽屉打开
- en: You can also see on the side panel a more descriptive view of your UI, which
    helps debug issues.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在侧面板上看到一个更详细的UI视图，这有助于调试问题。
- en: '![Figure 9.6 – The device pose](img/Figure_9.6_B18827.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 设备姿态](img/Figure_9.6_B18827.jpg)'
- en: Figure 9.6 – The device pose
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 设备姿态
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code base for this project is vast and hence, cannot be covered in just
    one recipe; you can find the full code in the *Technical* *requirements* section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码库非常庞大，因此不能仅在一个菜谱中涵盖；你可以在*技术要求*部分找到完整的代码。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We covered the bottom navigation in [*Chapter 4*](B18827_04.xhtml#_idTextAnchor190),
    *Navigation in Modern Android Development*. In this chapter, however, we use it
    to showcase how your application can change as the screen changes if your application
    is installed on a foldable device, which is very important in Modern Android Development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B18827_04.xhtml#_idTextAnchor190)中介绍了底部导航，*现代Android开发中的导航*。然而，在这一章中，我们使用它来展示如果你的应用安装在可折叠设备上，应用如何随着屏幕的变化而变化，这在现代Android开发中非常重要。
- en: The navigation rail is used for medium-screen sizes, whereas the navigation
    drawer, just like in the old way of writing applications, is used as a side drawer
    and is suitable for large-screen devices. `FoldFeature` is a built-in Jetpack
    Compose UI component that allows you to create a folding animation effect when
    you click on it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏用于中等屏幕尺寸，而导航抽屉，就像在旧的应用程序编写方式中一样，用作侧抽屉，适用于大屏幕设备。`FoldFeature`是Jetpack Compose的一个内置UI组件，允许你在点击时创建折叠动画效果。
- en: 'Here are the steps to use `FoldFeature` in your Android app. You can also customize
    `FoldFeature` by providing the necessary parameters:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`FoldFeature`在您的Android应用程序中的步骤。您还可以通过提供必要的参数来自定义`FoldFeature`：
- en: '`foldableState`: This state controls the folding and unfolding of `FoldFeature`.
    You can create a `FoldState` instance using the `rememberFoldState()` function.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foldableState`：此状态控制`FoldFeature`的折叠和展开。你可以使用`rememberFoldState()`函数创建一个`FoldState`实例。'
- en: '`foldedConten`t: Content will be displayed when `FoldFeature` is folded.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foldedContent`：当`FoldFeature`折叠时，将显示内容。'
- en: '`expandedContent`: This is the content that will be displayed when `FoldFeature`
    is in its expanded state.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expandedContent`：当`FoldFeature`处于展开状态时，将显示此内容。'
- en: '`foldingIcon`: This is the icon that will be displayed to indicate the folding
    state of `FoldFeature`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foldingIcon`：这是将显示以指示`FoldFeature`折叠状态的图标。'
- en: A foldable device has the ability to be in various states and postures. The
    Jetpack `WindowManager` library’s `WindowLayoutInfo` class, which is what we use
    in our example, provides us with the following details. `state` helps describe
    the folded state the device is in. When the phone is fully opened, then the state
    is either `FLAT` or `HALF_OPENED`. We also get to play around with `orientation`,
    which is the orientation of the hinge.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可折叠设备能够处于各种状态和姿态。我们示例中使用的Jetpack `WindowManager`库的`WindowLayoutInfo`类提供了以下详细信息。`state`有助于描述设备所处的折叠状态。当手机完全打开时，状态为`FLAT`或`HALF_OPENED`。我们还可以玩转`orientation`，这是铰链的朝向。
- en: The hinge can be either `HORIZONTAL` or `VERTICAL`. We have `occlusionType`,
    and this is the value that is `FULL` when the hinge hides part of the display.
    Otherwise, the value is `NONE`. Finally, we have `isSeparating`, which becomes
    valid when the hinge creates two logical displays.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 铰链可以是`HORIZONTAL`或`VERTICAL`。我们有`occlusionType`，当铰链隐藏部分显示屏时，此值为`FULL`。否则，值为`NONE`。最后，我们有`isSeparating`，当铰链创建两个逻辑显示时，该值有效。
- en: Building adaptive layouts using ConstraintLayouts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConstraintLayout构建自适应布局
- en: Jetpack Compose, a declarative UI toolkit to build great UIs, is ideal to implement
    and design screen layouts that adjust automatically by themselves and render content
    well across different screen sizes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose，一个用于构建优秀UI的声明式UI工具包，非常适合实现和设计能够自动调整并适应不同屏幕尺寸的屏幕布局。
- en: This can be useful to consider when building your application, since the chance
    of it being installed in a foldable device is high. Furthermore, this can range
    from simple layout adjustments to filling up a foldable space that looks like
    a tablet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建你的应用程序时可以考虑，因为你的应用程序被安装在可折叠设备上的可能性很高。此外，这可以从简单的布局调整到填充类似平板电脑的可折叠空间。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have read the previous chapters to follow along with this recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读前面的章节才能跟随这个菜谱。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, we will build a separate composable function to show you how
    to use `ConstraintLayout` in the same project instead of creating a new one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将构建一个单独的可组合函数来向您展示如何在同一项目中使用`ConstraintLayout`，而不是创建一个新的：
- en: 'Let’s go ahead and open `Traveller`. Add a new package and call it `constraintllayoutexample`.
    Inside the package, create a Kotlin file, called `ConstraintLayoutExample`, and
    then add the following dependency to the project:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续打开`Traveller`。添加一个新的包，命名为`constraintllayoutexample`。在包内部，创建一个名为`ConstraintLayoutExample`的Kotlin文件，然后向项目中添加以下依赖项：
- en: '[PRE42]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In our example, we will create a fun `AndroidCommunity()` and use `ConstraintLayout`
    to create `title`, `aboutCommunity`, and `AndroidImage` references:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个有趣的`AndroidCommunity()`，并使用`ConstraintLayout`创建`title`、`aboutCommunity`和`AndroidImage`引用：
- en: '[PRE43]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`createRefs()`, which means *create references*, simply creates a reference
    for each composable in our `ConstrainLayout`.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createRefs()`，即*创建引用*，为我们的`ConstrainLayout`中的每个可组合组件创建一个引用。'
- en: 'Now, let us go ahead and create our title text, `aboutCommunity`, and `AndroidImage`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们的标题文本`aboutCommunity`和`AndroidImage`：
- en: '[PRE50]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our title text has a modifier that has constraints defined, and if you have
    used XML before, you may notice that this works exactly how XML works. We provide
    constraints using the `constrainAs()` modifier, which, in our case, takes the
    references as a parameter and lets us specify its constraints in the body lambda.
    Hereafter, our constraints are specified using `linkTo(...)` or other methods,
    but in this case, we will use `linkTo(parent.top)`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的主题文本有一个具有约束定义的修饰符，如果您之前使用过XML，您可能会注意到这正好与XML的工作方式相同。我们使用`constrainAs()`修饰符提供约束，在我们的情况下，它将引用作为参数，并允许我们在lambda体中指定其约束。此后，我们将使用`linkTo(...)`或其他方法指定约束，但在此情况下，我们将使用`linkTo(parent.top)`。
- en: 'We can now connect the parts together using a similar style, in addition, ensure
    you check the *Technical requirements* section for the entire code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用类似的方式将各个部分连接起来，此外，请确保您检查整个代码的*技术要求*部分：
- en: '[PRE64]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we build the image:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们构建图像：
- en: '[PRE65]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, to run this part of the code, you can run the `@``Preview` section:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，要运行这段代码，您可以运行`@Preview`部分：
- en: '[PRE77]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When you run the application, it should render and adapt well to the screen
    sizes. For instance, if the state is full (which means not folded), data should
    be displayed on the entire screen (see *Figure 9**.7*).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，它应该能够很好地渲染和适应屏幕尺寸。例如，如果状态是全屏（这意味着未折叠），数据应显示在整个屏幕上（参见*图9.7*）。
- en: '![Figure 9.7 – The full screen of the not folded state](img/Figure_9.7_B18827.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 未折叠状态的全屏](img/Figure_9.7_B18827.jpg)'
- en: Figure 9.7 – The full screen of the not folded state
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 未折叠状态的全屏
- en: In *Figure 9**.8*, you can see a version of the data when the screen is folded
    and how it adapts to the specified dimensions.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*图9.8*中，您可以看到当屏幕折叠时数据的版本以及它如何适应指定的尺寸。
- en: '![Figure 9.8 – The folded state](img/Figure_9.8_B18827.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 折叠状态](img/Figure_9.8_B18827.jpg)'
- en: Figure 9.8 – The folded state
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 折叠状态
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We use modifiers to adjust the spacing between components and use dimension
    resources to define the margin between an image and `aboutCommunity`. Our layout
    will adjust based on the screen size to look good on both small and large screens.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用修饰符来调整组件之间的间距，并使用维度资源来定义图像和`aboutCommunity`之间的边距。我们的布局将根据屏幕尺寸调整，以在小屏幕和大屏幕上都看起来很好。
- en: We also use `ConstraintLayout`, which is a layout manager that allows us to
    create complex layouts with a flat view hierarchy. It also has built-in support
    for responsive layouts to create different layouts for different screen sizes
    and orientations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`ConstraintLayout`，这是一个允许我们使用扁平视图层次结构创建复杂布局的布局管理器。它还内置了对响应式布局的支持，以创建不同屏幕尺寸和方向的布局。
- en: 'The best use cases for `ConstraintLayout` include the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout`的最佳用例包括以下内容：'
- en: When you want to avoid nesting multiple columns and rows; this can include when
    you want to position your elements on screen for easier code readability
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想避免嵌套多个列和行时；这可以包括当您想将元素定位在屏幕上以方便代码可读性时
- en: Utilizing it when you need to use guidelines, chains, or barriers in your positioning
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要在使用定位时使用指南、链或障碍时利用它
- en: We mentioned modifiers in previous chapters, which are like attributes in XML
    layouts. They allow us to apply different styles and behaviors to the components
    in our layout. You can use modifiers to change your component’s size, position,
    and other properties, based on the screen size.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中提到了修饰符，它们类似于XML布局中的属性。它们允许我们根据屏幕尺寸将不同的样式和行为应用到布局中的组件。您可以使用修饰符根据屏幕尺寸更改组件的大小、位置和其他属性。
- en: In our example, we use dynamic padding and margins, and you can use them to
    adjust the spacing between components based on the screen size. For example, you
    can use a modifier to add more padding to a component on larger screens.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用动态填充和边距，您可以使用它们根据屏幕尺寸调整组件之间的间距。例如，您可以使用修饰符在较大屏幕上为组件添加更多填充。
- en: This allows you to create responsive layouts that adjust based on the screen
    size.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您创建响应式布局，根据屏幕尺寸进行调整。
- en: Handling large-screen configuration changes and continuity
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大屏幕配置更改和连续性
- en: 'Android devices undergo various configuration changes during their operation.
    Some of the most notable, or standard, ones include the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备在其运行过程中会经历各种配置更改。其中一些最显著或标准的包括以下内容：
- en: '**Screen orientation change**: This occurs when a user rotates a device’s screen,
    triggering a configuration change. This is when the device switches from portrait
    to landscape mode or vice versa.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕方向更改**：这发生在用户旋转设备的屏幕时，触发配置更改。这是设备从纵向模式切换到横向模式或反之亦然的时候。'
- en: '**Screen size change**: This is when a user changes the screen size of a device
    – for example, by plugging or unplugging an external display, triggering a configuration
    change.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕尺寸更改**：这是当用户更改设备的屏幕尺寸时——例如，通过连接或断开外部显示，触发配置更改。'
- en: '**Language or locale change**: This is when a user changes the language or
    locale of a device, triggering a configuration change. This can affect the formatting
    of text and dates, among other things.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言或区域设置更改**：这是当用户更改设备的语言或区域设置时，触发配置更改。这可能会影响文本和日期的格式化，以及其他方面。'
- en: '**Theme change**: This is when a user changes a device’s theme, triggering
    a configuration change. This can affect the appearance of the UI.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题更改**：这是当用户更改设备的主题时，触发配置更改。这可能会影响UI的外观。'
- en: '**Keyboard availability change**: This is when a user attaches or detaches
    a keyboard from a device, triggering a configuration change. This can affect the
    layout of the UI, and so on.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键盘可用性更改**：这是当用户将键盘连接或断开连接到设备时，触发配置更改。这可能会影响UI的布局，等等。'
- en: In this recipe, we will look at leveraging this knowledge to better handle screen
    size changes when dealing with foldable devices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何利用这些知识来更好地处理处理可折叠设备时的屏幕尺寸变化。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the first recipe, *Building adaptive layouts in Modern Android Development*,
    we discussed different state configurations and how to handle them better. In
    this recipe, we will learn how to use the already provided `rememberFoldableState`
    function in Jetpack Compose to handle screen changes in foldable devices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个菜谱中，*在现代安卓开发中构建自适应布局*，我们讨论了不同的状态配置以及如何更好地处理它们。在这个菜谱中，我们将学习如何使用Jetpack Compose中已经提供的`rememberFoldableState`函数来处理可折叠设备上的屏幕变化。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s use the already created `Traveller` project for this example; you will
    not need to create a new project:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用已经创建的`Traveller`项目来进行这个示例；您不需要创建一个新的项目：
- en: 'To be able to use `rememberFoldableState`, we will need to import it into our
    project:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`rememberFoldableState`，我们需要将其导入到我们的项目中：
- en: '[PRE84]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we will create a new `val/ property foldableState` and initialize it
    with our `rememberFoldableState`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的`val/属性 foldableState`并将其初始化为我们的`rememberFoldableState`：
- en: '[PRE85]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Using the `foldState` object, we can get information about foldable devices,
    make our application respond to the correct state, and display data as needed.
    The three states available are `STATE_FLAT`, `STATE_HALF_OPENED`, and `STATE_CLOSED`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`foldState`对象，我们可以获取有关可折叠设备的信息，使我们的应用程序能够响应正确的状态，并根据需要显示数据。可用的三种状态是`STATE_FLAT`、`STATE_HALF_OPENED`和`STATE_CLOSED`：
- en: '[PRE86]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can then use this information to adjust our UI accordingly, such as showing
    or hiding certain elements based on the foldable state or specified position.
    Also, we can create two different layouts for when the device is folded and when
    it is unfolded:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这些信息相应地调整我们的UI，例如根据可折叠状态或指定位置显示或隐藏某些元素。此外，我们可以为设备折叠和展开时创建两个不同的布局：
- en: '[PRE97]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: And that’s it; this will help solve the foldable state if you have a complex
    UI system that needs better handling.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；如果您有一个需要更好处理的复杂UI系统，这将有助于解决可折叠状态问题。
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Handling significant screen configuration changes, especially with foldable
    devices, can be challenging in Android Jetpack Compose. Here are some tips that
    can help you use the Configuration API. It allows you to get information about
    a device’s screen configuration, such as screen size, orientation, and foldable
    state. You can use this information to adjust your UI accordingly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Jetpack Compose中处理重要的屏幕配置更改，尤其是在可折叠设备上，可能会很具挑战性。以下是一些可以帮助您使用配置API的技巧。它允许您获取有关设备屏幕配置的信息，例如屏幕大小、方向和可折叠状态。您可以使用这些信息相应地调整您的UI。
- en: Compose’s layout system makes it easy to create responsive UIs that can adapt
    to different screen sizes and aspect ratios. Use flexible layouts such as columns
    and rows to create a UI that can scale up or down as needed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Compose的布局系统使得创建能够适应不同屏幕尺寸和宽高比的响应式UI变得容易。使用灵活的布局，如列和行，创建一个可以根据需要放大或缩小的UI。
- en: The `rememberFoldableState` function lets you get information about a device’s
    foldable state and adjust your UI accordingly. For example, you can use this function
    to create two different layouts, one for when the device is folded and one for
    when it is unfolded.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`rememberFoldableState`函数允许您获取有关设备可折叠状态的信息，并相应地调整您的UI。例如，您可以使用此函数创建两个不同的布局，一个用于设备折叠时，一个用于设备展开时。'
- en: Testing your app with different screen configurations is also essential to ensure
    that it works properly. You can use the Android emulator or physical devices to
    test your app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的屏幕配置测试您的应用也是确保其正常工作的关键。您可以使用Android模拟器或物理设备来测试您的应用。
- en: Understanding activity embedding
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解活动嵌入
- en: In Jetpack Compose, activity embedding refers to the process of including a
    composable function within the context of an activity. This allows you to create
    custom views that can integrate seamlessly with existing Android activities.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中，活动嵌入指的是在活动上下文中包含一个可组合函数的过程。这允许您创建可以无缝集成到现有Android活动中的自定义视图。
- en: To embed a composable function within an activity, you can use the `setContent`
    method of the activity. This method accepts a composable function as a parameter,
    which can be used to define the activity’s layout.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要在活动中嵌入一个可组合函数，您可以使用活动的`setContent`方法。此方法接受一个可组合函数作为参数，该参数可用于定义活动的布局。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have completed the previous recipes to follow along.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成之前的食谱才能继续学习。
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s look at an example of embedding a composable function in an activity:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在活动中嵌入一个可组合函数的示例：
- en: '[PRE104]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In this example, the `setContent` method embeds the `MyCustomView` composable
    function within `MainActivity`. When the activity is created, the `MyCustomView`
    function will be called to generate the activity’s layout.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`setContent`方法将`MyCustomView`可组合函数嵌入到`MainActivity`中。当活动创建时，`MyCustomView`函数将被调用以生成活动的布局。
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MyCustomView` function is defined as a composable function using the `@Composable`
    annotation. This allows the function to be called multiple times without causing
    any side effects. In this case, the function simply displays a `Text` composable
    with the text `Hello,` `Android Community!`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyCustomView`函数被定义为使用`@Composable`注解的可组合函数。这允许函数被多次调用而不会产生任何副作用。在这种情况下，该函数仅显示一个带有文本`Hello,
    Android Community!`的`Text`可组合组件。'
- en: By embedding composable functions within activities, you can create custom views
    that can be easily integrated into your Android app. This can be especially useful
    to create reusable components or customize the layout of existing activities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在活动中嵌入可组合函数，您可以创建可以轻松集成到您的Android应用中的自定义视图。这特别有用于创建可重用组件或自定义现有活动的布局。
- en: Material Theming in Compose
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Compose中的材料主题
- en: '**Material Theming** in Compose is a design system introduced by Google that
    provides guidelines and principles to design user interfaces. Material Theming
    helps designers create interfaces that are consistent, easy to use, and visually
    appealing. Some key features of Material Theming in Jetpack Compose include the
    following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Compose中的**材料主题**是由Google引入的设计系统，它提供了设计用户界面的指南和原则。材料主题帮助设计师创建一致、易于使用且视觉上吸引人的界面。Jetpack
    Compose中材料主题的一些关键特性包括以下内容：
- en: '`MaterialTheme` composable that allows you to apply a color palette to your
    entire app.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaterialTheme` 可组合组件，允许你将调色板应用于整个应用程序。'
- en: '`Typography` composable that allows you to apply a typography style to your
    text.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typography` 可组合组件，允许你将字体样式应用于你的文本。'
- en: '`Shape` composable that allows you to apply a shape to your components.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape` 可组合组件，允许你将形状应用于你的组件。'
- en: '`Icon` composable that allows you to use Material icons in your app.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Icon` 可组合组件，允许你在应用程序中使用 Material 图标。'
- en: By using Material Theming in Jetpack Compose, you can create interfaces that
    are consistent, easy to use, and visually appealing. Material Theming in Jetpack
    Compose helps you focus on designing your app’s functionality, while the design
    system takes care of the visual details.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Jetpack Compose 中使用 Material 主题，你可以创建一致、易于使用且视觉上吸引人的界面。Jetpack Compose 中的
    Material 主题可以帮助你专注于设计应用程序的功能，而设计系统则负责视觉细节。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To be able to follow along, you need to have worked on previous recipes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟上，你需要完成之前的食谱。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Many applications still do not use `Material 3`, but if you build a new application
    from scratch, it is highly recommended you go with `Material 3`. One thing to
    note is when you create a project, `Material 3` does not come pre-installed; this
    means you need to go ahead and update the Material libraries yourself to `Material
    3`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序仍然没有使用 `Material 3`，但如果你从头开始构建一个新应用程序，强烈建议你选择 `Material 3`。需要注意的是，当你创建一个项目时，`Material
    3` 并不是预先安装的；这意味着你需要自行更新 Material 库到 `Material 3`。
- en: 'Let’s see an example of implementing `Material 3` theming in Jetpack Compose
    for your Android applications:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Android 应用程序中使用 Jetpack Compose 实现 `Material 3` 主题的一个例子：
- en: 'You will need to add the required `Material 3` dependencies to your app’s `build.gradle`
    file:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在你的应用程序的 `build.gradle` 文件中添加所需的 `Material 3` 依赖项：
- en: '[PRE105]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then, you will need to declare your app theme:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要声明你的应用程序主题：
- en: '[PRE106]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, you can use your theme in the entire application:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在整个应用程序中使用你的主题：
- en: '[PRE115]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In this example, we’ve used `Material 3` colors, typography, and shapes to create
    a consistent and visually appealing interface. We’ve also used `Material 3` icons
    to enhance the user experience. Finally, we’ve wrapped our app’s content in the
    `MyAppMaterialTheme` composable to apply the `Material` `3` theme.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `Material 3` 的颜色、字体和形状来创建一个一致且视觉上吸引人的界面。我们还使用了 `Material 3` 的图标来增强用户体验。最后，我们将应用程序的内容包裹在
    `MyAppMaterialTheme` 可组合组件中，以应用 `Material` `3` 主题。
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Here’s how `Material 3` works in Jetpack Compose. `Material 3` introduces new
    and updated components, such as `AppBar`, `BottomNavigation`, and `TabBar`, which
    can be used in Jetpack Compose using the `Androidx.compose.material3` package.
    These components have updated design and functionality, and they follow the `Material`
    `3` guidelines.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Material 3` 在 Jetpack Compose 中的工作方式。`Material 3` 引入了新的和更新的组件，如 `AppBar`、`BottomNavigation`
    和 `TabBar`，这些组件可以使用 `Androidx.compose.material3` 包在 Jetpack Compose 中使用。这些组件具有更新的设计和功能，并遵循
    `Material` `3` 指南。
- en: Material 3 also introduces a new theming system that allows for more customization
    and flexibility – that is, in Jetpack Compose, `Material 3` theming can be applied
    using the `MaterialTheme3` composable. This composable allows you to customize
    the color scheme, typography, and shapes of your app, and it also provides new
    options to customize the elevation and shadows of your components.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Material 3` 还引入了一个新的主题系统，允许更多的自定义和灵活性——也就是说，在 Jetpack Compose 中，`Material
    3` 主题可以通过 `MaterialTheme3` 可组合组件应用。这个可组合组件允许你自定义应用程序的颜色方案、字体和形状，并且它还提供了新的选项来自定义组件的凸起和阴影。'
- en: The icons are now modern and easily accessible, which is a big plus for us developers.
    Finally, Material 3 introduces a new typography system that provides updated styles
    and guidelines for typography in your app. In Jetpack Compose, `Material 3` typography
    can be applied using the `Material3Typography` object, which provides several
    predefined styles for your text.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图标现在更加现代且易于访问，这对我们开发者来说是一个很大的加分项。最后，`Material 3` 引入了一个新的字体系统，为应用程序中的字体提供了更新的样式和指南。在
    Jetpack Compose 中，`Material 3` 字体可以通过 `Material3Typography` 对象应用，该对象为你的文本提供了几个预定义的样式。
- en: By using `Material 3` in Jetpack Compose, you can create modern and visually
    appealing interfaces that follow the latest design guidelines. Also note that
    `Material 3` components, theming, icons, and typography can all be used together
    to create a cohesive and consistent design system for your app.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Jetpack Compose 中使用 `Material 3`，你可以创建遵循最新设计指南的现代且视觉上吸引人的界面。同时请注意，`Material
    3` 组件、主题、图标和字体类型都可以一起使用，为你的应用创建一个统一和一致的设计系统。
- en: See also…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容…
- en: 'There is much to cover in Material Design, and trying to cover all components
    in a single recipe will not do it justice. To learn more about the components
    and how to ensure your application follows the Material Design guideline, read
    more here: [https://material.io/components](https://material.io/components).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计有很多内容需要介绍，试图在单一菜谱中涵盖所有组件并不能真正公正地对待它们。要了解更多关于组件以及如何确保你的应用遵循材料设计指南，请在此处阅读更多：[https://material.io/components](https://material.io/components)。
- en: Testing your applications on a foldable device
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可折叠设备上测试你的应用
- en: Testing your apps on foldable devices is essential to ensure they work correctly
    and provide an excellent user experience. In this recipe, we will look at some
    tips to test your apps on foldable devices in Jetpack Compose.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在可折叠设备上测试你的应用对于确保它们正确运行并提供了卓越的用户体验至关重要。在这个菜谱中，我们将探讨一些在 Jetpack Compose 中测试你的应用的提示。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have done the previous recipes. You can access the entire code
    in the *Technical* *requirements* section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完成之前的菜谱。你可以在 *技术* *要求* 部分访问整个代码。
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Here are some tips to test your applications on foldable devices:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在可折叠设备上测试你的应用的提示：
- en: '**Use an emulator**: You can use the Android emulator to test your app on foldable
    devices without buying a physical device. The emulator provides a range of foldable
    device configurations that you can use to test your app.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用模拟器**：你可以使用 Android 模拟器来测试你的应用，而无需购买物理设备。模拟器提供了一系列可折叠设备配置，你可以使用它们来测试你的应用。'
- en: '**Use real devices**: Testing your app on an actual foldable device can provide
    a more accurate representation of how your app will work on these devices. If
    you have access to a foldable device, it’s highly recommended to test your app
    on it.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用真实设备**：在真实的可折叠设备上测试你的应用可以更准确地反映你的应用在这些设备上的工作情况。如果你可以访问到可折叠设备，强烈建议你在其上测试你的应用。'
- en: '**Test different screen modes**: Foldable devices come in different screen
    modes, such as single-screen, dual-screen, and extended screens. It’s essential
    to test your app on different screen modes to ensure it works correctly in all
    modes.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试不同的屏幕模式**：可折叠设备有不同的屏幕模式，如单屏、双屏和扩展屏幕。测试你的应用在不同屏幕模式下以确保它在所有模式下都能正确运行至关重要。'
- en: '**Test with different screen sizes**: Foldable devices come in different sizes,
    so it’s crucial to test your app on different screen sizes to ensure it works
    well on all devices.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试不同屏幕尺寸**：可折叠设备有不同的尺寸，因此测试你的应用在不同屏幕尺寸上以确保它在所有设备上都能良好运行至关重要。'
- en: '**Test app transition**: Testing your app’s transition between different screen
    modes can help you identify any issues with an app’s layout or behavior. Make
    sure to test all the transition modes, such as fold, unfold, and hinge.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应用过渡**：测试你的应用在不同屏幕模式之间的过渡可以帮助你识别应用布局或行为中可能存在的问题。确保测试所有过渡模式，如折叠、展开和铰链。'
- en: '**Use automated testing**: Automated testing can help you test your app on
    different screen sizes, modes, and orientations more efficiently. You can use
    tools such as Espresso or UI Automator to write automated tests for your app.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自动化测试**：自动化测试可以帮助你更高效地在不同的屏幕尺寸、模式和方向上测试你的应用。你可以使用如 Espresso 或 UI Automator
    等工具为你的应用编写自动化测试。'
- en: How it works…
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Overall, testing your app on foldable devices requires careful consideration
    of a device’s unique features and abilities. By following these tips, you can
    ensure that your app is optimized for foldable devices and provides an excellent
    user experience.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在可折叠设备上测试你的应用需要仔细考虑设备的独特特性和能力。通过遵循这些提示，你可以确保你的应用针对可折叠设备进行了优化，并提供了卓越的用户体验。
